# Avo

Lean teams use Avo to build exceptional internal tools while it handles the technical heavy lifting, so they can focus on what matters.

Avo offers a few big features to get that done:

- CRUD
- Dashboards
- Advanced filters
- Kanban boards
- Collaboration tools
- Audit logging

CRUD is probably the most important feature of Avo. It's how you create, read, update and delete records (manage records).

# Resources

The Avo CRUD functionality uses the concept of a resource. A resource belongs to a model and a model may have multiple resources.
The model is how Rails talks to the database and the resource is how Avo talks to Rails and knows how to fetch and manipulate the records.

Each resource is a ruby class in this configuration `Avo::Resources::RESOURCE_NAME` and inherits the `Avo::BaseResource` class which inherits `Avo::Resources::Base`. `Avo::BaseResource` is empty so the user can override anything they want on a global level in theyr own app.

A resource has a multitude of options which are usually declared using the `self.OPTION_NAME = ` format. They can take a simple value like a string, boolean, symbol, hash or array or they can take an `ExecutionContext` which will give the developer much more control over what they can return from it.



# Customization

Actions can be customized in several ways to enhance the user experience. You can modify the action's display name, confirmation message, button labels, and confirmation behavior between other things.

There are 2 types of customization, visual and behavioral.

## Visual customization

Visual customization is the process of modifying the action's appearance. This includes changing the action's name, message and button labels.

All visual customization options can be set as a string or a block.

The blocks are executed using [`Avo::ExecutionContext`](#execution-context). Within these blocks, you gain access to:

- All attributes of [`Avo::ExecutionContext`](#execution-context)
- `resource` - The current resource instance
- `record` - The current record
- `view` - The current view
- `arguments` - Any passed arguments
- `query` - The current query parameters

<Option name="`name`" headingSize=3>

The `name` option is used to change the action's display name.

```ruby{3,5-8}
# app/avo/actions/release_fish.rb
class Avo::Actions::ReleaseFish < Avo::BaseAction
  self.name = "Release fish"

  # Or as a block
  self.name = -> {
    record.present? ? "Release #{record.name}?" : "Release fish"
  }
end
```

</Option>

<Option name="`message`" headingSize=3>

The `message` option is used to change the action's confirmation message.

```ruby{3,5-12}
# app/avo/actions/release_fish.rb
class Avo::Actions::ReleaseFish < Avo::BaseAction
  self.message = "Are you sure you want to release the fish?"

  # Or as a block
  self.message = -> {
    if resource.record.present?
      "Are you sure you want to release the #{resource.record.name}?"
    else
      "Are you sure you want to release the fish?"
    end
  }
end
```

</Option>

<Option name="`confirm_button_label`" headingSize=3>

The `confirm_button_label` option is used to change the action's confirmation button label.

```ruby{3,5-12}
# app/avo/actions/release_fish.rb
class Avo::Actions::ReleaseFish < Avo::BaseAction
  self.confirm_button_label = "Release fish"

  # Or as a block
  self.confirm_button_label = -> {
    if resource.record.present?
      "Release #{resource.record.name}"
    else
      "Release fish"
    end
  }
end
```

</Option>

<Option name="`cancel_button_label`" headingSize=3>

The `cancel_button_label` option is used to change the action's cancel button label.

```ruby{3,5-12}
# app/avo/actions/release_fish.rb
class Avo::Actions::ReleaseFish < Avo::BaseAction
  self.cancel_button_label = "Cancel release"

  # Or as a block
  self.cancel_button_label = -> {
    if resource.record.present?
      "Cancel release on #{resource.record.name}"
    else
      "Cancel release"
    end
  }
end
```

</Option>


## Behavioral customization

Behavioral customization is the process of modifying the action's behavior. This includes changing the action's confirmation behavior and authorization.

<Option name="`no_confirmation`" headingSize=3>

By default, actions display a confirmation modal before execution. You can bypass this modal by setting `self.no_confirmation = true`, which will execute the action immediately upon triggering.

```ruby{3}
# app/avo/actions/release_fish.rb
class Avo::Actions::ReleaseFish < Avo::BaseAction
  self.no_confirmation = true
end
```

This is particularly useful for actions that:
- Are safe to execute without confirmation
- Need to provide immediate feedback
- Are part of a multi-step workflow where confirmation is handled elsewhere

</Option>

<Option name="`standalone`" headingSize=3>

Standalone actions allow you to execute operations that aren't tied to specific model records. These are useful for global operations like:

- Generating system-wide reports
- Running maintenance tasks
- Triggering background jobs

You can create a standalone action in two ways:

1. Using the generator with the `--standalone` flag:
```bash
bin/rails generate avo:action global_action --standalone
```

2. Adding `self.standalone = true` to an existing action:
```ruby{4}
# app/avo/actions/global_report.rb
class Avo::Actions::GlobalReport < Avo::BaseAction
  self.name = "Generate Global Report"
  self.standalone = true
end
```

Standalone actions will be active in the Actions dropdown even when no records are selected. They can be used alongside regular record-based actions in the same resource.

:::tip
Standalone actions work well with the [`fields`](#fields) feature to collect additional input needed for the operation.
:::

</Option>

<Option name="`visible`" headingSize=3>

You may want to hide specific actions on some views, like a standalone action on the `Show` and `Edit` views, and show it only on the `Index` view. You can do that using the `self.visible` attribute.

```ruby{5,8}
# app/avo/actions/global_report.rb
class Avo::Actions::GlobalReport < Avo::BaseAction
  self.name = "Generate Global Report"
  self.standalone = true
  self.visible = true

  # Or as a block
  self.visible = -> { view.index? }
end
```

The `visible` attribute accepts a boolean or a block.

The block will be executed within the [`Avo::ExecutionContext`](#execution-context) environment, giving you access to important contextual attributes like:
- `view` - The current view type (index, show, edit)
- `resource` - The current resource instance
- `parent_resource` - The parent resource (if applicable).
  - You can access the `parent_record` by `parent_resource.record`
- Plus all other [`Avo::ExecutionContext`](#execution-context) default attributes
</Option>

<Option name="`authorize`" headingSize=3>

The `authorize` attribute is used to restrict access to actions based on custom logic.

If an action is unauthorized, it will be hidden. If a bad actor attempts to proceed with the action, the controller will re-evaluate the authorization and block unauthorized requests.

```ruby{2,4-7}
class Avo::Actions::GlobalReport < Avo::BaseAction
  self.authorize = false

  # Or as a block
  self.authorize = -> {
    current_user.is_admin?
  }
end
```

The `authorize` attribute accepts a boolean or a proc.

The block will be executed within the [`Avo::ExecutionContext`](#execution-context) environment, giving you access to important contextual attributes like:
- `action` - The current action instance
- `resource` - The current resource instance
- `view` - The current view type (index, show, edit)
- All other [`Avo::ExecutionContext`](#execution-context) attributes

</Option>

<Option name="`close_modal_on_backdrop_click`" headingSize=3>

<VersionReq version="3.14.0" class="mt-4" />

By default, action modals use a dynamic backdrop.

Add `self.close_modal_on_backdrop_click = false` in case you want to prevent the user from closing the modal when clicking on the backdrop.

```ruby{3}
# app/avo/actions/toggle_inactive.rb
class Avo::Actions::ToggleInactive < Avo::BaseAction
  self.close_modal_on_backdrop_click = false
end
```

</Option>


<Option name="`turbo`" headingSize=3>

The `turbo` attribute is used to control the Turbo behavior of actions.

There are times when you don't want to perform the actions with Turbo. In such cases, turbo should be set to false.

```ruby{3}
# app/avo/actions/toggle_inactive.rb
class Avo::Actions::ToggleInactive < Avo::BaseAction
  self.turbo = false
end
```

The `turbo` attribute accepts a boolean.
</Option>




# Execution flow

When a user triggers an action in Avo, the following flow occurs:

1. Record selection phase:
   - This phase can be bypassed by setting `self.standalone = true`
   - For bulk actions on the index page, Avo collects all the records selected by the user
   - For actions on the show page [or row controls](#customizable-controls), Avo uses that record as the target of the action

2. The action is initiated by the user through the index page (bulk actions), show page (single record actions), [or resource controls (custom action buttons)](#customizable-controls)

3. Form display phase (optional):
    - This phase can be bypassed by setting `self.no_confirmation = true`
    - By default, a modal is displayed where the user can confirm or cancel the action
    - If the action has defined fields, they will be shown in the modal for the user to fill out
    - The user can then choose to run the action or cancel it
    - If the user cancels, the execution stops here

4. Action execution:
    - The `handle` method processes selected records, form values, current user, and resource details
    - Your custom business logic is executed within the `handle` method
    - User feedback is configured ([`succeed`](#succeed), [`warn`](#warn), [`inform`](#inform), [`error`](#error), or [`silent`](#silent))
    - Response type is configured ([`redirect_to`](#redirect_to), [`reload`](#reload), [`keep_modal_open`](#keep_modal_open), and [more](#response-types))


## The `handle` method

The `handle` method is where you define what happens when your action is executed. This is the core of your action's business logic and receives the following arguments:

- `query` Contains the selected record(s). Single records are automatically wrapped in an array for consistency
- `fields` Contains the values submitted through the action's form fields
- `current_user` The currently authenticated user
- `resource` The Avo resource instance that triggered the action

```ruby{10-23}
# app/avo/actions/toggle_inactive.rb
class Avo::Actions::ToggleInactive < Avo::BaseAction
  self.name = "Toggle Inactive"

  def fields
    field :notify_user, as: :boolean
    field :message, as: :textarea
  end

  def handle(query:, fields:, current_user:, resource:, **args)
    query.each do |record|
      # Toggle the inactive status
      record.update!(inactive: !record.inactive)

      # Send notification if requested
      if fields[:notify_user]
        # Assuming there's a notify method
        record.notify(fields[:message])
      end
    end

    succeed "Successfully toggled status for #{query.count}"
  end
end
```

## Feedback notifications

After an action runs, you can respond to the user with different types of notifications or no feedback at all. The default feedback is an `Action ran successfully` message of type `inform`.

<Option name="`succeed`" headingSize="3">

Displays a **green** success alert to indicate successful completion.
</Option>

<Option name="`warn`" headingSize="3">

Displays an **orange** warning alert for cautionary messages.
</Option>

<Option name="`inform`" headingSize="3">

Displays a **blue** info alert for general information.
</Option>

<Option name="`error`" headingSize="3">

Displays a **red** error alert to indicate failure or errors.
</Option>

<Option name="`silent`" headingSize="3">

You may want to run an action and show no notification when it's done. That is useful for redirect scenarios. You can use the `silent` response for that.

```ruby{5}
# app/avo/actions/toggle_inactive.rb
class Avo::Actions::ToggleInactive < Avo::BaseAction
  def handle(**args)
    redirect_to "/admin/some-tool"
    silent
  end
end
```
</Option>


:::info
You can show multiple notifications at once by calling multiple feedback methods (`succeed`, `warn`, `inform`, `error`) in your action's `handle` method. Each notification will be displayed in sequence.
:::

```ruby{4-7}
# app/avo/actions/toggle_inactive.rb
class Avo::Actions::ToggleInactive < Avo::BaseAction
  def handle(**args)
    succeed "Success response âœŒï¸"
    warn "Warning response âœŒï¸"
    inform "Info response âœŒï¸"
    error "Error response âœŒï¸"
  end
end
```

<Image src="/assets/img/actions/alert-responses.png" width="1074" height="558" alt="Avo notification types" />

## Response types

After an action completes, you can control how the UI responds through various response types. These powerful responses give you fine-grained control over the user experience by allowing you to:

- **Navigate**: Reload pages or redirect users to different parts of your application
- **Manipulate UI**: Control modals, update specific page elements, or refresh table rows
- **Handle Files**: Trigger file downloads and handle data exports
- **Show Feedback**: Combine with notification messages for clear user communication

You can use these responses individually or combine them to create sophisticated interaction flows. Here are all the available action responses:

<Option name="`reload`" headingSize=3>

The `reload` response triggers a full-page reload. This is the default behavior if no other response type is specified.

```ruby{9}
def handle(query:, **args)
  query.each do |project|
    project.update active: false
  end

  succeed 'Done!'
  reload # This is optional since reload is the default behavior
end
```
</Option>

<Option name="`redirect_to`" headingSize=3>

`redirect_to` will execute a redirect to a new path of your app. It accept `allow_other_host`, `status` and any other arguments.

Example:
`redirect_to path, allow_other_host: true, status: 303`

```ruby{9}
def handle(query:, **args)
  query.each do |project|
    project.update active: false
  end

  succeed 'Done!'
  redirect_to avo.resources_users_path
end
```
</Option>

<Option name="`download`" headingSize=3>

`download` will start a file download to your specified `path` and `filename`.

**You need to set `self.may_download_file` to true for the download response to work like below**. That's required because we can't respond with a file download (send_data) when making a Turbo request.

If you find another way, please let us know ðŸ˜….

:::code-group

```ruby{3,16} [app/avo/actions/download_file.rb]
class Avo::Actions::DownloadFile < Avo::BaseAction
  self.name = "Download file"
  self.may_download_file = true

def handle(query:, **args)
    filename = "projects.csv"
    report_data = []

    query.each do |project|
      report_data << project.generate_report_data
    end

    succeed 'Done!'

    if report_data.present? and filename.present?
      download report_data, filename
    end
  end
end
```

```ruby{8} [app/avo/resources/project.rb]
# app/avo/resources/project.rb
class Avo::Resources::Project < Avo::BaseResource
  def fields
    # fields here
  end

  def actions
    action Avo::Actions::DownloadFile
  end
end
```
:::
</Option>

<Option name="`keep_modal_open`" headingSize=3>

There might be situations where you want to run an action and if it fails, respond back to the user with some feedback but still keep it open with the inputs filled in.

`keep_modal_open` will tell Avo to keep the modal open.

```ruby
class Avo::Actions::KeepModalOpenAction < Avo::BaseAction
  self.name = "Keep Modal Open"
  self.standalone = true

  def fields
    field :name, as: :text
    field :birthday, as: :date
  end

  def handle(fields:, **args)
    User.create fields
    succeed "All good âœŒï¸"
  rescue => error
    error "Something happened: #{error.message}"
    keep_modal_open
  end
end
```
</Option>

<Option name="`close_modal`" headingSize=3>

<VersionReq version="3.3.0" class="mt-4" />

This type of response becomes useful when you are working with a form and need to execute an action without redirecting, ensuring that the form remains filled as it is.

`close_modal` will flash all the messages gathered by [action responses](#action-responses) and will close the modal using turbo streams keeping the page still.

```ruby{7,9}
class Avo::Actions::CloseModal < Avo::BaseAction
  self.name = "Close modal"

  def handle(**args)
    # do_something_here
    succeed "Modal closed!!"
    close_modal
    # or
    do_nothing
  end
end
```
</Option>

<Option name="`do_nothing`" headingSize=3>

`do_nothing` is an alias for `close_modal`.

```ruby{7}
class Avo::Actions::CloseModal < Avo::BaseAction
  self.name = "Close modal"

  def handle(**args)
    # do_something_here
    succeed "Modal closed!!"
    do_nothing
  end
end
```
</Option>

<Option name="`navigate_to_action`" headingSize=3>

<VersionReq version="3.4.2" class="mt-4" />

You may want to redirect to another action. Here's an example of how to create a multi-step process, passing arguments from one action to another.
In this example the initial action prompts the user to select the fields they wish to update, and in the subsequent action, the chosen fields will be accessible for updating.

:::code-group
```ruby[PreUpdate]
class Avo::Actions::City::PreUpdate < Avo::BaseAction
  self.name = "Update"

  def fields
    field :name, as: :boolean
    field :population, as: :boolean
  end

  def handle(query:, fields:, **args)
    navigate_to_action Avo::Actions::City::Update,
      arguments: {
        cities: query.map(&:id),
        render_name: fields[:name],
        render_population: fields[:population]
      }
  end
end
```

```ruby[Update]
class Avo::Actions::City::Update < Avo::BaseAction
  self.name = "Update"
  self.visible = -> { false }

  def fields
    field :name, as: :text if arguments[:render_name]
    field :population, as: :number if arguments[:render_population]
  end

  def handle(fields:, **args)
    City.find(arguments[:cities]).each do |city|
      city.update! fields
    end

    succeed "City updated!"
  end
end
```
:::

You can see this multi-step process in action by visiting the [avodemo](https://main.avodemo.com/avo/resources/cities). Select one of the records, click on the "Update" action, choose the fields to update, and then proceed to update the selected fields in the subsequent action.
</Option>

<Option name="`append_to_response`" headingSize=3>

<VersionReq version="3.10.3" class="mt-4" />

Avo action responses are in the `turbo_stream` format. You can use the `append_to_response` method to append additional turbo stream responses to the default response.

```ruby{5-7}
def handle(**args)
  succeed "Modal closed!!"
  close_modal

  append_to_response -> {
    turbo_stream.set_title("Cool title ;)")
  }
end
```

The `append_to_response` method accepts a Proc or lambda function. This function is executed within the context of the action's controller response.

The block should return either a single `turbo_stream` response or an array of multiple `turbo_stream` responses.

:::code-group
```ruby[Array]{2-5}
append_to_response -> {
  [
    turbo_stream.set_title("Cool title"),
    turbo_stream.set_title("Cool title 2")
  ]
}
```

```ruby[Single]{2}
append_to_response -> {
  turbo_stream.set_title("Cool title")
}
```
:::
</Option>

<Option name="`reload_records`" headingSize=3>

<VersionReq version="3.14.0" class="my-4" />

<div style="position: relative; padding-bottom: 56.25%; height: 0;"><iframe src="https://www.loom.com/embed/6b9ae6a3968c447f98ac4f9a161fe781?sid=17f08010-6a56-4e8c-8b80-692424327b55" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></iframe></div>

:::warning
This option **only** works on **Index** pages, **NOT** on **associations**.
:::

This option leverages Turbo Stream to refresh specific table rows in response to an action. For individual records, you can use the `reload_record` alias method.

```ruby{8}
def handle(query:, fields:, **args)
  query.each do |record|
    record.update! active: !record.active

    record.notify fields[:message] if fields[:notify_user]
  end

  reload_records(query)
end
```

The `reload_records` and `reload_record` methods are aliases, and they accept either an array of records or a single record.

:::code-group
```ruby[Array]{1}
reload_records([record_1, record_2])
```

```ruby[Single]{1}
reload_record(record)
```
:::
</Option>



# Action Generator

Avo provides a powerful Rails generator to create action files quickly and efficiently.

## Basic Generator Usage

Generate a new action file using the Rails generator:

```bash
bin/rails generate avo:action toggle_inactive
```

This command creates a new action file at `app/avo/actions/toggle_inactive.rb` with the following structure:

```ruby
# app/avo/actions/toggle_inactive.rb
class Avo::Actions::ToggleInactive < Avo::BaseAction
  self.name = "Toggle Inactive"
  # self.visible = -> do
  #   true
  # end

  # def fields
  #   # Add Action fields here
  # end

  def handle(query:, fields:, current_user:, resource:, **args)
    query.each do |record|
      # Do something with your records.
    end
  end
end
```

## Generator Options

### `--standalone`

By default, actions require at least one record to be selected before they can be triggered, unless specifically configured as standalone actions.

The `--standalone` option creates an action that doesn't require record selection. This is particularly useful for:
- Generating reports
- Exporting all records
- Running global operations

```bash
bin/rails generate avo:action export_users --standalone
```

You can also make an existing action standalone by manually setting `self.standalone = true` in the action class:

```ruby{5}
# app/avo/actions/export_users.rb

class Avo::Actions::ExportUsers < Avo::BaseAction
  self.name = "Export Users"
  self.standalone = true

  # ... rest of the action code
end
```

## Best Practices

When generating actions, consider the following:

1. Use descriptive names that reflect the action's purpose (e.g., `toggle_published`, `send_newsletter`, `archive_records`)
2. Follow Ruby naming conventions (snake_case for file names)
3. Group related actions in namespaces using subdirectories
4. Use the `--standalone` flag when the action doesn't operate on specific records

## Examples

```bash
# Generate a regular action
bin/rails generate avo:action mark_as_featured

# Generate a standalone action
bin/rails generate avo:action generate_monthly_report --standalone

# Generate an action in a namespace
bin/rails generate avo:action admin/approve_user
```



# Action Generator

Avo provides a powerful Rails generator to create action files quickly and efficiently.

## Basic Generator Usage

Generate a new action file using the Rails generator:

```bash
bin/rails generate avo:action toggle_inactive
```

This command creates a new action file at `app/avo/actions/toggle_inactive.rb` with the following structure:

```ruby
# app/avo/actions/toggle_inactive.rb
class Avo::Actions::ToggleInactive < Avo::BaseAction
  self.name = "Toggle Inactive"
  # self.visible = -> do
  #   true
  # end

  # def fields
  #   # Add Action fields here
  # end

  def handle(query:, fields:, current_user:, resource:, **args)
    query.each do |record|
      # Do something with your records.
    end
  end
end
```

## Generator Options

### `--standalone`

By default, actions require at least one record to be selected before they can be triggered, unless specifically configured as standalone actions.

The `--standalone` option creates an action that doesn't require record selection. This is particularly useful for:
- Generating reports
- Exporting all records
- Running global operations

```bash
bin/rails generate avo:action export_users --standalone
```

You can also make an existing action standalone by manually setting `self.standalone = true` in the action class:

```ruby{5}
# app/avo/actions/export_users.rb

class Avo::Actions::ExportUsers < Avo::BaseAction
  self.name = "Export Users"
  self.standalone = true

  # ... rest of the action code
end
```

## Best Practices

When generating actions, consider the following:

1. Use descriptive names that reflect the action's purpose (e.g., `toggle_published`, `send_newsletter`, `archive_records`)
2. Follow Ruby naming conventions (snake_case for file names)
3. Group related actions in namespaces using subdirectories
4. Use the `--standalone` flag when the action doesn't operate on specific records

## Examples

```bash
# Generate a regular action
bin/rails generate avo:action mark_as_featured

# Generate a standalone action
bin/rails generate avo:action generate_monthly_report --standalone

# Generate an action in a namespace
bin/rails generate avo:action admin/approve_user
```


# WIP
this section is under construction
## Helpers

### `link_arguments`

The `link_arguments` method is used to generate the arguments for an action link.

You may want to dynamically generate an action link. For that you need the action class and a resource instance (with or without record hydrated). Call the action's class method `link_arguments` with the resource instance as argument and it will return the `[path, data]` that are necessary to create a proper link to a resource.

Let's see an example use case:

```ruby{4-,16} [Current Version]
# app/avo/resources/city.rb
class Avo::Resources::City < Avo::BaseResource
  field :name, as: :text, name: "Name (click to edit)", only_on: :index do
    path, data = Avo::Actions::City::Update.link_arguments(
      resource: resource,
      arguments: {
        cities: Array[resource.record.id],
        render_name: true
      }
    )

    link_to resource.record.name, path, data: data
  end
end
```


<Image src="/assets/img/actions/action_link.gif" width="684" height="391" alt="actions link demo" />

:::tip
#### Generate an Action Link Without a Resource Instance
Sometimes, you may need to generate an action link without having access to an instantiated resource.

#### Scenario
Imagine you want to trigger an action from a custom partial card on a dashboard, but there is no resource instance available.

#### Solution
In this case, you can create a new resource instance (with or without record) and use it as follows:

```ruby
path, data = Avo::Actions::City::Update.link_arguments(
  resource: Avo::Resources::City.new(record: city)
)

link_to "Update city", path, data: data
```
:::

## Guides

### StimulusJS

Please follow our extended [StimulusJS guides](#stimulus-integration) for more information.

### Passing Params to the Action Show Page
When navigation to an action from a resource <Index /> or <Show /> views, it's sometimes useful to pass parameters to an action.

One particular example is when you'd like to populate a field in that action with some particular value based on that param.

```ruby
class Action
  def fields
    field :some_field, as: :hidden, default: -> { if previous_param == yes ? :yes : :no}
  end
end
```
Consider the following scenario:

1. Navigate to `https://main.avodemo.com/avo/resources/users`.
2. Add the parameter `hey=ya` to the URL: `https://main.avodemo.com/avo/resources/users?hey=ya`
3. Attempt to run the dummy action.
4. After triggering the action, verify that you can access the `hey` parameter.
5. Ensure that the retrieved value of the `hey` parameter is `ya`.

**Implementation**

To achieve this, we'll reference the `request.referer` object and extract parameters from the URL. Here is how to do it:

```ruby
class Action
  def fields
    # Accessing the parameters passed from the parent view
    field :some_field, as: :hidden, default: -> {
      # Parsing the request referer to extract parameters
      parent_params = URI.parse(request.referer).query.split("&").map { |param| param.split("=")}.to_h.with_indifferent_access
      # Checking if the `hei` parameter equals `ya`
      if parent_params[:hey] == 'ya'
        :yes
      else
        :no
      end
    }
  end
end
```
Parse the `request.referer` to extract parameters using `URI.parse`.
Split the query string into key-value pairs and convert it into a hash.
Check if the `hey` parameter equals `ya`, and set the default value of `some_field` accordingly.



# Actions Overview

<DemoVideo demo-video="https://youtu.be/BK47E7TMXn0?t=778" class="mt-4" />

Actions in Avo are powerful tools that transform the way you interact with your data. They enable you to perform operations on one or multiple records simultaneously, extending your interface with custom functionality that goes beyond basic CRUD operations.

## What Are Actions?

Think of Actions as custom operations you can trigger from your admin interface. They're like specialized commands that can:
- Process single records or work in batch mode
- Collect additional information through customizable forms
- Trigger background jobs
- Generate reports or export data
- Modify record states
- Send notifications
- And much more...

## Key Benefits

### 1. Streamlined Workflows
Instead of building custom interfaces for common operations, Actions provide a standardized way to perform complex tasks right from your admin panel.

### 2. Flexibility
Actions can be as simple or as complex as you need:
- Simple toggles for changing record states
- Multi-step processes with user input on each step
- Background job triggers for heavy operations
- API integrations with external services

### 3. Batch Operations
Save time by performing operations on multiple records at once. Whether you're updating statuses, sending notifications, or processing data, batch actions have you covered.

### 4. User Input Forms
When additional information is needed, Actions can present custom forms to collect data before execution. These forms are fully customizable and support various field types.

## Common Use Cases

- **User Management**: Activate/deactivate accounts, reset passwords, or send welcome emails
- **Content Moderation**: Approve/reject content, flag items for review
- **Data Processing**: Generate reports, export data, or trigger data transformations
- **Communication**: Send notifications, emails, or SMS messages
- **State Management**: Change status, toggle features, or update permissions
- **Batch Updates**: Modify multiple records with consistent changes
- **Integration Triggers**: Connect with external APIs or services

Common use cases include managing user states, sending notifications, and automating data processing. Their flexibility makes them essential for building robust interfaces, streamlining workflows, and managing data efficiently.



# Registration

Actions are registered within a resource by using the resource's `actions` method. This method defines which actions are available for that specific resource.

## `action`

The `action` method is used to register an action within the `actions` block. It accepts the action class as its first argument and optional configuration parameters like `arguments` and `icon`

```ruby{5}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  def actions
    # Basic registration
    action Avo::Actions::ToggleInactive
  end
end
```

:::warning
Using the Pundit policies, you can restrict access to actions using the `act_on?` method. If you think you should see an action on a resource and you don't, please check the policy method.

More info [here](#authorization)
:::

Once attached, the action will appear in the **Actions** dropdown menu. By default, actions are available on all views.

:::info
You may use the [customizable controls](#customizable-controls) feature to show the actions outside the dropdown.
:::

<Option name="`arguments`" headingSize="3">

The `arguments` option allows you to pass custom data to your action. These arguments are accessible throughout the entire action class including the `handle` and `fields` methods.

```ruby{5-7,11-15}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  def actions
    action Avo::Actions::ToggleInactive,
      arguments: {
        special_message: true
      }

    # Or as a proc to make it dynamic
    action Avo::Actions::ToggleInactive,
      arguments: -> do
        {
          special_message: resource.view.index? && current_user.is_admin?
        }
      end
  end
end
```

Now, the arguments can be accessed all over the action class like inside `handle` and `fields` methods.

```ruby{4-8}
# app/avo/actions/toggle_inactive.rb
class Avo::Actions::ToggleInactive < Avo::BaseAction
  def handle(**args)
    if arguments[:special_message]
      succeed "I love ðŸ¥‘"
    else
      succeed "Success response âœŒï¸"
    end
  end
end
```
</Option>

<Option name="`icon`" headingSize="3">

<VersionReq version="3.5.6" class="mt-4" />

The `icon` option lets you specify the icon to display next to the action in the dropdown menu. Avo supports [Heroicons](https://heroicons.com) by default.

Here's an example of how you can define actions with icons:

```ruby{4}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  def actions
    action Avo::Actions::ToggleInactive, icon: "heroicons/outline/globe"
  end
end
```

</Option>

---

## `divider`

<VersionReq version="3.5.6" class="mt-4" />

Action dividers allow you to organize and separate actions into logical groups, improving the overall layout and usability.
This will create a visual separator in the actions dropdown menu, helping you group related actions together.

```ruby{8}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  def actions
    # User status actions
    action Avo::Actions::ActivateUser
    action Avo::Actions::DeactivateUser

    divider

    # Communication actions
    action Avo::Actions::SendWelcomeEmail
    action Avo::Actions::SendPasswordReset
  end
end
```

<Option name="`label`" headingSize="3">

You can also add a label to the divider for better organization:

```ruby{5}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  def actions
    action Avo::Actions::ActivateUser
    divider label: "Communication"
    action Avo::Actions::SendWelcomeEmail
  end
end
```

</Option>



# Belongs to

```ruby
field :user, as: :belongs_to
```

You will see three field types when you add a `BelongsTo` association to a model.


## Options

<Option name="`searchable`">

<div class="space-x-2">
  <LicenseReq license="pro" />
  <DemoVideo demo-video="https://youtu.be/KLI_sVTPX-Q" />
</div>

Turns the attach field/modal from a `select` input to a searchable experience

```ruby{5}
class Avo::Resources::CourseLink < Avo::BaseResource
  def fields
    field :links,
      as: :has_many,
      searchable: true
  end
end
```

:::warning
  Avo uses the **search feature** behind the scenes, so **make sure the target resource has the [`search_query`](#search) option configured**.
:::

```ruby{3-7}
# app/avo/resources/course_link.rb
class Avo::Resources::CourseLink < Avo::BaseResource
  self.search = {
    query: -> {
      query.ransack(id_eq: params[:q], link_cont: params[:q], m: "or").result(distinct: false)
    }
  }
end
```

#### Default

`false`

#### Possible values

`true`, `false`
</Option>


<Option name="`allow_via_detaching`">

Keeps the field enabled when visiting from the parent record.

#### Default

`false`

#### Possible values

`true`, `false`
</Option>

<Option name="`attach_scope`">

Scope out the records the user sees on the Attach modal.

#### Default

`nil`

#### Possible values

```ruby{3}
field :user,
  as: :belongs_to,
  attach_scope: -> { query.non_admins }
```

Pass in a block where you attach scopes to the `query` object and `parent` object, which is the actual record where you want to assign the association. The block is executed in the [`ExecutionContext`](#execution-context).
</Option>

:::warning
The `attach_scope` will not filter the records in the listing from `has_many` or `has_and_belongs_to_many` associations.
Use [`scope`](#scope) or a [Pundit policy `Scope`](#authorization) for that.
:::

```ruby-vue{3}
field :members,
  as: :{{ $frontmatter.field_type }},
  attach_scope: -> { query.where.not(team_id: parent.id) }
  ```
In this example, in the `attach_scope`, we ensure that when attaching members to a team, only those who are not already members will appear in the list of options.


<Option name="`polymorphic_as`">

Sets the field as polymorphic with the key set on the model.

#### Default

`nil`

#### Possible values

A symbol, used on the `belongs_to` association with `polymorphic: true`.

:::warning
You must use this option with the `types` option.
:::

#### Example

```ruby
field :commentable, as: :belongs_to, polymorphic_as: :commentable, types: [::Post, ::Project]
```
</Option>

<Option name="`types`">

Sets the types the field can morph to.

#### Default

`[]`

#### Possible values

`[Post, Project, Team]`. Any array of model names.

:::warning
You must use this option with the `polymorphic_as` option.
:::

#### Example

```ruby
field :commentable, as: :belongs_to, polymorphic_as: :commentable, types: [::Post, ::Project]
```
</Option>

<Option name="`polymorphic_help`">

Sets the help text for the polymorphic type dropdown. Useful when you need to specify to the user why and what they need to choose as polymorphic.

#### Default

`nil`

#### Possible values

Any string.
</Option>

<Option name="`use_resource`">

Sets a different resource to be used when displaying (or redirecting to) the association table.

#### Default

`nil`. When nothing is selected, Avo infers the resource type from the reflected association.

#### Possible values

`Avo::Resources::Post`, `Avo::Resources::PhotoComment`, or any Avo resource class.

The value can be the actual class or a string representation of that class.

```ruby
# the class
Avo::Resources::Post

# the string representation of the class
"Avo::Resources::Post"
```
</Option>


<Option name="`can_create`">

Controls the creation link visibility on forms.

#### Default

`true`

#### Possible values

`true`, `false`
:::warning Since version <Version version="3.10.2" />, the target resource policy takes precedence over this option.
`field :user, as: :belongs_to, can_create: true`

In this example, even if the `can_create` option is set to `true`, if the `UserPolicy` responds with `false` to the `create?` method, the creation link will **NOT** be visible.
:::
</Option>

## Overview

On the `Index` and `Show` views, Avo will generate a link to the associated record containing the [`self.title`](#resources) value of the target resource.

<Image src="/assets/img/associations/belongs-to-index.jpg" width="188" height="115" alt="Belongs to index" />

<Image src="/assets/img/associations/belongs-to-show.jpg" width="531" height="81" alt="Belongs to show" />

On the `Edit` and `New` views, Avo will generate a dropdown element with the available records where the user can change the associated model.

<Image src="/assets/img/associations/belongs-to-edit.jpg" width="555" height="123" alt="Belongs to edit" />

## Polymorphic `belongs_to`

To use a polymorphic relation, you must add the `polymorphic_as` and `types` properties.

```ruby{13}
class Avo::Resources::Comment < Avo::BaseResource
  self.title = :id

  def fields
    field :id, as: :id
    field :body, as: :textarea
    field :excerpt, as: :text, show_on: :index do
      ActionView::Base.full_sanitizer.sanitize(record.body).truncate 60
    rescue
      ""
    end

    field :commentable, as: :belongs_to, polymorphic_as: :commentable, types: [::Post, ::Project]
  end
end
```

## Polymorphic help

When displaying a polymorphic association, you will see two dropdowns. One selects the polymorphic type (`Post` or `Project`), and one for choosing the actual record. You may want to give the user explicit information about those dropdowns using the `polymorphic_help` option for the first dropdown and `help` for the second.

```ruby{17-18}
class Avo::Resources::Comment < Avo::BaseResource
  self.title = :id

  def fields
    field :id, as: :id
    field :body, as: :textarea
    field :excerpt, as: :text, show_on: :index do
      ActionView::Base.full_sanitizer.sanitize(record.body).truncate 60
    rescue
      ""
    end

    field :reviewable,
      as: :belongs_to,
      polymorphic_as: :reviewable,
      types: [::Post, ::Project, ::Team],
      polymorphic_help: "Choose the type of record to review",
      help: "Choose the record you need."
  end
end
```

<Image src="/assets/img/associations/polymorphic_help.jpg" width="1616" height="370" alt="Belongs to ploymorphic help" />

## Searchable `belongs_to`

<DemoVideo demo-video="https://youtu.be/KLI_sVTPX-Q" />

There might be the case that you have a lot of records for the parent resource, and a simple dropdown won't cut it. This is where you can use the `searchable` option to get a better search experience for that resource.

```ruby{8}
class Avo::Resources::Comment < Avo::BaseResource
  self.title = :id

  def fields
    field :id, as: :id
    field :body, as: :textarea

    field :user, as: :belongs_to, searchable: true
  end
end
```

<Image src="/assets/img/associations/searchable-closed.jpg" width="1232" height="184" alt="Belongs to searchable" />
<Image src="/assets/img/associations/searchable-open.jpg" width="1556" height="1272" alt="Belongs to searchable" />

`searchable` works with `polymorphic` `belongs_to` associations too.

```ruby{8}
class Avo::Resources::Comment < Avo::BaseResource
  self.title = :id

  def fields
    field :id, as: :id
    field :body, as: :textarea

    field :commentable, as: :belongs_to, polymorphic_as: :commentable, types: [::Post, ::Project], searchable: true
  end
end
```

:::info
Avo uses the [search feature](#search) behind the scenes, so **make sure the target resource has the `query` option configured inside the `search` block**.
:::


```ruby
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  self.search = {
    query: -> {
      query.ransack(id_eq: params[:q], name_cont: params[:q], body_cont: params[:q], m: "or").result(distinct: false)
    }
  }
end

# app/avo/resources/project.rb
class Avo::Resources::Project < Avo::BaseResource
  self.search = {
    query: -> {
      query.ransack(id_eq: params[:q], name_cont: params[:q], country_cont: params[:q], m: "or").result(distinct: false)
    }
  }
end
```

## Belongs to attach scope

<DemoVideo demo-video="https://youtu.be/Eex8CiinQZ8?t=6" />

When you edit a record that has a `belongs_to` association, on the edit screen, you will have a list of records from which you can choose a record to associate with.

For example, a `Post` belongs to a `User`. So on the post edit screen, you will have a dropdown (or a search field if it's [searchable](#searchable-belongs-to)) with all the available users. But that's not ideal. For example, maybe you don't want to show all the users in your app but only those who are not admins.

You can use the `attach_scope` option to keep only the users you need in the `belongs_to` dropdown field.

You have access to the `query` that you can alter and return it and the `parent` object, which is the actual record where you want to assign the association (the true `Post` in the below example).

```ruby
# app/models/user.rb
class User < ApplicationRecord
  scope :non_admins, -> { where "(roles->>'admin')::boolean != true" }
end

# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  def fields
    field :user, as: :belongs_to, attach_scope: -> { query.non_admins }
  end
end
```

For scenarios where you need to add a record associated with that resource (you create a `Post` through a `Category`), the `parent` is unavailable (the `Post` is not persisted in the database). Therefore, Avo makes the `parent` an instantiated object with its parent populated (a `Post` with the `category_id` populated with the parent `Category` from which you started the creation process) so you can better scope out the data (you know from which `Category` it was initiated).

## Allow detaching via the association

When you visit a record through an association, that `belongs_to` field is disabled. There might be cases where you'd like that field not to be disabled and allow your users to change that association.

You can instruct Avo to keep that field enabled in this scenario using `allow_via_detaching`.

```ruby{12}
class Avo::Resources::Comment < Avo::BaseResource
  self.title = :id

  def fields
    field :id, as: :id
    field :body, as: :textarea

    field :commentable,
      as: :belongs_to,
      polymorphic_as: :commentable,
      types: [::Post, ::Project],
      allow_via_detaching: true
  end
end
```



# Has And Belongs To Many

The `HasAndBelongsToMany` association works similarly to [`HasMany`](#has-many).

```ruby
field :users, as: :has_and_belongs_to_many
```

## Options
<Option name="`searchable`">

<div class="space-x-2">
  <LicenseReq license="pro" />
  <DemoVideo demo-video="https://youtu.be/KLI_sVTPX-Q" />
</div>

Turns the attach field/modal from a `select` input to a searchable experience

```ruby{5}
class Avo::Resources::CourseLink < Avo::BaseResource
  def fields
    field :links,
      as: :has_many,
      searchable: true
  end
end
```

:::warning
  Avo uses the **search feature** behind the scenes, so **make sure the target resource has the [`search_query`](#search) option configured**.
:::

```ruby{3-7}
# app/avo/resources/course_link.rb
class Avo::Resources::CourseLink < Avo::BaseResource
  self.search = {
    query: -> {
      query.ransack(id_eq: params[:q], link_cont: params[:q], m: "or").result(distinct: false)
    }
  }
end
```

#### Default

`false`

#### Possible values

`true`, `false`
</Option>

<Option name="`attach_scope`">

Scope out the records the user sees on the Attach modal.

#### Default

`nil`

#### Possible values

```ruby{3}
field :user,
  as: :belongs_to,
  attach_scope: -> { query.non_admins }
```

Pass in a block where you attach scopes to the `query` object and `parent` object, which is the actual record where you want to assign the association. The block is executed in the [`ExecutionContext`](#execution-context).
</Option>

:::warning
The `attach_scope` will not filter the records in the listing from `has_many` or `has_and_belongs_to_many` associations.
Use [`scope`](#scope) or a [Pundit policy `Scope`](#authorization) for that.
:::

```ruby-vue{3}
field :members,
  as: :{{ $frontmatter.field_type }},
  attach_scope: -> { query.where.not(team_id: parent.id) }
  ```
In this example, in the `attach_scope`, we ensure that when attaching members to a team, only those who are not already members will appear in the list of options.

<Option name="`scope`">

Scope out the records displayed in the table.

#### Default

`nil`

#### Possible values

```ruby{3}
field :user,
  as: :belongs_to,
  scope: -> { query.approved }
```

Pass in a block where you attach scopes to the `query` object. The block gets executed in the [`ExecutionContext`](#execution-context).

With version 2.5.0, you'll also have access to the `parent` record so that you can use that to scope your associated models even better.

Starting with version 3.12, access to `resource` and `parent_resource` was additionally provided.
</Option>

<Option name="`name`">
Changes the text displayed as association name.

![](/assets/img/associations/name-option.jpg)

#### Default

Plural association name.

#### Possible values

Any string or any zero arity lambda function.

Within lambda, you have access to all attributes of [`Avo::ExecutionContext`](#execution-context).
</Option>

<Option name="`description`">

Changes the text displayed under the association name.

<Image src="/assets/img/associations/description-option.jpg" width="702" height="198" alt="" />

#### Default

`nil`

#### Possible values

Any string or any zero arity lambda function.

Within lambda, you have access to `query` and all attributes of [`Avo::ExecutionContext`](#execution-context).
</Option>

<Option name="`use_resource`">

Sets a different resource to be used when displaying (or redirecting to) the association table.

#### Default

`nil`. When nothing is selected, Avo infers the resource type from the reflected association.

#### Possible values

`Avo::Resources::Post`, `Avo::Resources::PhotoComment`, or any Avo resource class.

The value can be the actual class or a string representation of that class.

```ruby
# the class
Avo::Resources::Post

# the string representation of the class
"Avo::Resources::Post"
```
</Option>

<Option name="`discreet_pagination`">

Hides the pagination details when only there's only one page for that association.

#### Default

`false`

#### Possible values

`true`, `false`
</Option>

<Option name="`hide_search_input`">

Hides the search input displayed on the association table.

#### Default

`false`. When nothing is selected and the `search_query` of association's resource is configured, Avo displays the search input.

#### Possible values

`true`, `false`.
</Option>


## Search query scope

<VersionReq version="2.13" />

If the resource used for the `has_many` association has the `search` block configured with a `query`, Avo will use that to scope out the search query to that association.

For example, if you have a `Team` model that `has_many` `User`s, now you'll be able to search through that team's users instead of all of them.

You can target that search using `params[:via_association]`. When the value of `params[:via_association]` is `has_many`, the search has been mad inside a has_many association.

For example, if you want to show the records in a different order, you can do this:

```ruby
self.search = {
  query: -> {
    if params[:via_association] == 'has_many'
      query.ransack(id_eq: params[:q], m: "or").result(distinct: false).order(name: :asc)
    else
      query.ransack(id_eq: params[:q], m: "or").result(distinct: false)
    end
  }
}
```

## Show on edit screens

By default, the `{{ $frontmatter.field_type }}` field is only visible in the [show](#views) view. To make it available in the [edit](#views) view as well, include the `show_on: :edit` option. This ensures that the `{{ $frontmatter.field_type }}` [show](#views) view component is also rendered within the [edit](#views) view.

## Nested in Forms
<div class="space-x-2">
  <VersionReq version="3.19.0"/>
  <BetaStatus label="Public beta"/>
  <LicenseReq license="advanced"/>
</div>


You can use ["Show on edit screens"](#show-on-edit-screens) to make the `{{ $frontmatter.field_type }}` field available in the [edit](#views) view. However, this will render it using the [show](#views) view component.

To enable nested creation for the `{{ $frontmatter.field_type }}` field, allowing it to be created and / or edited alongside its parent record within the same form, use the `nested` option which is a hash with configurable option.


Keep in mind that this will display the fieldâ€™s resource as it appears in the edit view.

<Option name="nested">

Enables this field as a nested form in the specified views.

##### Default value

`{}`

#### Possible values

A hash with the following options:
- `on:` Views in which to enable nesting. Accepted values:
  - `:new` - Enables nesting in the [new](#views) view.
  - `:edit` - Enables nesting in the [edit](#views) view.
  - `:forms` - Enables nesting in the [new](#views) and [edit](#views) views.
- `limit:` *(Only for `has_many` and `has_and_belongs_to_many` fields)* Hides the "Add" button when the specified limit is reached.

:::tip
Setting `nested: true` is a shortcut for `nested: { on: :forms }`.
:::

#### Example

```ruby-vue{4,5,7,8,10,11,13-14,16-19}
# app/avo/resources/book.rb
class Avo::Resources::Book < Avo::BaseResource
  def fields
    # Shortcut for full nesting
    field :{{ $frontmatter.field_type === 'has_one' ? 'author' : 'authors' }}, as: :{{ $frontmatter.field_type }}, nested: true

    # Explicit nesting on new only
    field :{{ $frontmatter.field_type === 'has_one' ? 'author' : 'authors' }}, as: :{{ $frontmatter.field_type }}, nested: { on: :new }

    # Explicit nesting on edit only
    field :{{ $frontmatter.field_type === 'has_one' ? 'author' : 'authors' }}, as: :{{ $frontmatter.field_type }}, nested: { on: :edit }

    # Explicit nesting on both new and edit
    field :{{ $frontmatter.field_type === 'has_one' ? 'author' : 'authors' }}, as: :{{ $frontmatter.field_type }}, nested: { on: :forms }

    # Limit nested creation (for has_many or has_and_belongs_to_many only)
    field :authors,
      as: :{{ $frontmatter.field_type }},
      nested: { on: [:new, :edit], limit: 2 }
  end
end
```

</Option>


### Searchable `has_and_belongs_to_many`

<div class="flex gap-2 mt-2">
  <VersionReq version="1.25" />
  <LicenseReq license="pro" title="Searchable associations are available as a pro feature" />
</div>


Similar to [`belongs_to`](#belongs_to), the `has_many` associations support the `searchable` option.

## Add scopes to associations

<DemoVideo demo-video="https://youtu.be/3ee9iq2CnzA" />

When displaying `has_many` associations, you might want to scope out some associated records. For example, a user might have multiple comments, but on the user's `Show` page, you don't want to display all the comments, but only the approved ones.

```ruby{5,16,22}
# app/models/comment.rb
class Comment < ApplicationRecord
  belongs_to :user, optional: true

  scope :approved, -> { where(approved: true) }
end

# app/models/user.rb
class User < ApplicationRecord
  has_many :comments
end

# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  def fields
    field :comments, as: :has_many, scope: -> { query.approved }
  end
end
```

The `comments` query on the user `Index` page will have the `approved` scope attached.

<Image src="/assets/img/associations/scope.jpg" width="1660" height="830" alt="Association scope" />

With version 2.5.0, you'll also have access to the `parent` record so that you can use that to scope your associated models even better.

Starting with version 3.12, access to `resource` and `parent_resource` was additionally provided.

All the `has_many` associations have the [`attach_scope`](#belongs_to) option available too.

## Show/hide buttons

You will want to control the visibility of the attach/detach/create/destroy/actions buttons visible throughout your app. You can use the policy methods to do that.

Find out more on the [authorization](#authorization) page.

<Image src="/assets/img/associations/authorization.jpg" width="1662" height="800" alt="Associations authorization" />

<Option name="Reloadable">

<VersionReq version="3.3.6" />

The reloadable option adds a reload icon next to the association title so users can easily reload just that turbo-frame instead of doing a full page reload.

#### Usage
To enable the reloadable feature, you have two options:

1. Direct Boolean Value:

Provide a boolean value directly to the reloadable option. This sets a default behavior where the reloadable feature is either enabled or disabled based on this boolean value.

```ruby-vue
field :reviews, as: :{{ $frontmatter.field_type }}, reloadable: true
```

2. Dynamic Conditions with a Block:

For more dynamic behavior, you can provide a block to the reloadable option. Within this block, you can specify conditions under which the reloadable should be displayed.

```ruby-vue
field :reviews, as: :{{ $frontmatter.field_type }},
  reloadable: -> {
    current_user.is_admin?
  }
```

In the above example, the reloadable will be visible if the current_user is an admin.

#### ExecutionContext
The reloadable block executes within the [`ExecutionContext`](#execution-context), granting access to all default methods and attributes.

<Image src="/assets/img/reloadable.png" width="680" height="94" alt="Reloadable" />
</Option>

<Option name="`association`">

<VersionReq version="3.6.2" />

The `for_attribute` option allows to specify the association used for a certain field. This option make possible to define same association with different scopes and different name several times on the same resource.

#### Usage
```ruby-vue
field :reviews,
  as: :{{ $frontmatter.field_type }}

field :special_reviews,
  as: :{{ $frontmatter.field_type }},
  for_attribute: :reviews,
  scope: -> { query.special_reviews }
```
</Option>




# Has Many

By default, the `HasMany` field is visible only on the `Show` view. You will see a new panel with the model's associated records below the regular fields panel.

```ruby
field :projects, as: :has_many
```

## Options

<Option name="`searchable`">

<div class="space-x-2">
  <LicenseReq license="pro" />
  <DemoVideo demo-video="https://youtu.be/KLI_sVTPX-Q" />
</div>

Turns the attach field/modal from a `select` input to a searchable experience

```ruby{5}
class Avo::Resources::CourseLink < Avo::BaseResource
  def fields
    field :links,
      as: :has_many,
      searchable: true
  end
end
```

:::warning
  Avo uses the **search feature** behind the scenes, so **make sure the target resource has the [`search_query`](#search) option configured**.
:::

```ruby{3-7}
# app/avo/resources/course_link.rb
class Avo::Resources::CourseLink < Avo::BaseResource
  self.search = {
    query: -> {
      query.ransack(id_eq: params[:q], link_cont: params[:q], m: "or").result(distinct: false)
    }
  }
end
```

#### Default

`false`

#### Possible values

`true`, `false`
</Option>

<Option name="`attach_scope`">

Scope out the records the user sees on the Attach modal.

#### Default

`nil`

#### Possible values

```ruby{3}
field :user,
  as: :belongs_to,
  attach_scope: -> { query.non_admins }
```

Pass in a block where you attach scopes to the `query` object and `parent` object, which is the actual record where you want to assign the association. The block is executed in the [`ExecutionContext`](#execution-context).
</Option>

:::warning
The `attach_scope` will not filter the records in the listing from `has_many` or `has_and_belongs_to_many` associations.
Use [`scope`](#scope) or a [Pundit policy `Scope`](#authorization) for that.
:::

```ruby-vue{3}
field :members,
  as: :{{ $frontmatter.field_type }},
  attach_scope: -> { query.where.not(team_id: parent.id) }
  ```
In this example, in the `attach_scope`, we ensure that when attaching members to a team, only those who are not already members will appear in the list of options.

<Option name="`scope`">

Scope out the records displayed in the table.

#### Default

`nil`

#### Possible values

```ruby{3}
field :user,
  as: :belongs_to,
  scope: -> { query.approved }
```

Pass in a block where you attach scopes to the `query` object. The block gets executed in the [`ExecutionContext`](#execution-context).

With version 2.5.0, you'll also have access to the `parent` record so that you can use that to scope your associated models even better.

Starting with version 3.12, access to `resource` and `parent_resource` was additionally provided.
</Option>

<Option name="`name`">
Changes the text displayed as association name.

![](/assets/img/associations/name-option.jpg)

#### Default

Plural association name.

#### Possible values

Any string or any zero arity lambda function.

Within lambda, you have access to all attributes of [`Avo::ExecutionContext`](#execution-context).
</Option>

<Option name="`description`">

Changes the text displayed under the association name.

<Image src="/assets/img/associations/description-option.jpg" width="702" height="198" alt="" />

#### Default

`nil`

#### Possible values

Any string or any zero arity lambda function.

Within lambda, you have access to `query` and all attributes of [`Avo::ExecutionContext`](#execution-context).
</Option>

<Option name="`use_resource`">

Sets a different resource to be used when displaying (or redirecting to) the association table.

#### Default

`nil`. When nothing is selected, Avo infers the resource type from the reflected association.

#### Possible values

`Avo::Resources::Post`, `Avo::Resources::PhotoComment`, or any Avo resource class.

The value can be the actual class or a string representation of that class.

```ruby
# the class
Avo::Resources::Post

# the string representation of the class
"Avo::Resources::Post"
```
</Option>

<Option name="`discreet_pagination`">

Hides the pagination details when only there's only one page for that association.

#### Default

`false`

#### Possible values

`true`, `false`
</Option>

<Option name="`hide_search_input`">

Hides the search input displayed on the association table.

#### Default

`false`. When nothing is selected and the `search_query` of association's resource is configured, Avo displays the search input.

#### Possible values

`true`, `false`.
</Option>

<Option name="`link_to_child_resource`">

Sets which resource should be used in an STI scenario.

See more on this in the [STI section](#associations).

#### Default

`false`. When it's `false` it will use the same resource.

#### Possible values

`true`, `false`.
</Option>


## Search query scope

<VersionReq version="2.13" />

If the resource used for the `has_many` association has the `search` block configured with a `query`, Avo will use that to scope out the search query to that association.

For example, if you have a `Team` model that `has_many` `User`s, now you'll be able to search through that team's users instead of all of them.

You can target that search using `params[:via_association]`. When the value of `params[:via_association]` is `has_many`, the search has been mad inside a has_many association.

For example, if you want to show the records in a different order, you can do this:

```ruby
self.search = {
  query: -> {
    if params[:via_association] == 'has_many'
      query.ransack(id_eq: params[:q], m: "or").result(distinct: false).order(name: :asc)
    else
      query.ransack(id_eq: params[:q], m: "or").result(distinct: false)
    end
  }
}
```



<Option name="`linkable`">

You can add use this option to make the association title clickable. That link will open a new page with the same view.

This feature doesn't go deeper than this. It just helps you see the association table easier in a separate page.

<Image src="/assets/img/3_0/has_many/linkable.gif" width="1200" height="875" alt="" />
</Option>

## Has Many Through

The `HasMany` association also supports the `:through` option.

```ruby{3}
field :members,
  as: :has_many,
  through: :memberships
```
<Option name="`attach_fields`">

<VersionReq version="3.11" />

If you have extra fields defined in the through table and would like to display them when attaching use the `attach_fields` option.

```ruby{4,5,6}
field :patrons,
  as: :has_many,
  through: :patronships,
  attach_fields: -> {
    field :review, as: :text
  }
```

:::warning
If the through model uses **polymorphism**, the type must be included as a hidden field:

```ruby{6}
field :patrons,
  as: :has_many,
  through: :patronships,
  attach_fields: -> {
    field :review, as: :text
    field :patronship_type, as: :hidden, default: "TheType"
  }
```
:::

<Image src="/assets/img/3_0/has_many/attach-fields.gif" width="600" height="338" alt="" />
</Option>

## Show on edit screens

By default, the `{{ $frontmatter.field_type }}` field is only visible in the [show](#views) view. To make it available in the [edit](#views) view as well, include the `show_on: :edit` option. This ensures that the `{{ $frontmatter.field_type }}` [show](#views) view component is also rendered within the [edit](#views) view.

## Nested in Forms
<div class="space-x-2">
  <VersionReq version="3.19.0"/>
  <BetaStatus label="Public beta"/>
  <LicenseReq license="advanced"/>
</div>


You can use ["Show on edit screens"](#show-on-edit-screens) to make the `{{ $frontmatter.field_type }}` field available in the [edit](#views) view. However, this will render it using the [show](#views) view component.

To enable nested creation for the `{{ $frontmatter.field_type }}` field, allowing it to be created and / or edited alongside its parent record within the same form, use the `nested` option which is a hash with configurable option.


Keep in mind that this will display the fieldâ€™s resource as it appears in the edit view.

<Option name="nested">

Enables this field as a nested form in the specified views.

##### Default value

`{}`

#### Possible values

A hash with the following options:
- `on:` Views in which to enable nesting. Accepted values:
  - `:new` - Enables nesting in the [new](#views) view.
  - `:edit` - Enables nesting in the [edit](#views) view.
  - `:forms` - Enables nesting in the [new](#views) and [edit](#views) views.
- `limit:` *(Only for `has_many` and `has_and_belongs_to_many` fields)* Hides the "Add" button when the specified limit is reached.

:::tip
Setting `nested: true` is a shortcut for `nested: { on: :forms }`.
:::

#### Example

```ruby-vue{4,5,7,8,10,11,13-14,16-19}
# app/avo/resources/book.rb
class Avo::Resources::Book < Avo::BaseResource
  def fields
    # Shortcut for full nesting
    field :{{ $frontmatter.field_type === 'has_one' ? 'author' : 'authors' }}, as: :{{ $frontmatter.field_type }}, nested: true

    # Explicit nesting on new only
    field :{{ $frontmatter.field_type === 'has_one' ? 'author' : 'authors' }}, as: :{{ $frontmatter.field_type }}, nested: { on: :new }

    # Explicit nesting on edit only
    field :{{ $frontmatter.field_type === 'has_one' ? 'author' : 'authors' }}, as: :{{ $frontmatter.field_type }}, nested: { on: :edit }

    # Explicit nesting on both new and edit
    field :{{ $frontmatter.field_type === 'has_one' ? 'author' : 'authors' }}, as: :{{ $frontmatter.field_type }}, nested: { on: :forms }

    # Limit nested creation (for has_many or has_and_belongs_to_many only)
    field :authors,
      as: :{{ $frontmatter.field_type }},
      nested: { on: [:new, :edit], limit: 2 }
  end
end
```

</Option>

## Add scopes to associations

<DemoVideo demo-video="https://youtu.be/3ee9iq2CnzA" />

When displaying `has_many` associations, you might want to scope out some associated records. For example, a user might have multiple comments, but on the user's `Show` page, you don't want to display all the comments, but only the approved ones.

```ruby{5,16,22}
# app/models/comment.rb
class Comment < ApplicationRecord
  belongs_to :user, optional: true

  scope :approved, -> { where(approved: true) }
end

# app/models/user.rb
class User < ApplicationRecord
  has_many :comments
end

# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  def fields
    field :comments, as: :has_many, scope: -> { query.approved }
  end
end
```

The `comments` query on the user `Index` page will have the `approved` scope attached.

<Image src="/assets/img/associations/scope.jpg" width="1660" height="830" alt="Association scope" />

With version 2.5.0, you'll also have access to the `parent` record so that you can use that to scope your associated models even better.

Starting with version 3.12, access to `resource` and `parent_resource` was additionally provided.

All the `has_many` associations have the [`attach_scope`](#belongs_to) option available too.

## Show/hide buttons

You will want to control the visibility of the attach/detach/create/destroy/actions buttons visible throughout your app. You can use the policy methods to do that.

Find out more on the [authorization](#authorization) page.

<Image src="/assets/img/associations/authorization.jpg" width="1662" height="800" alt="Associations authorization" />

<Option name="Reloadable">

<VersionReq version="3.3.6" />

The reloadable option adds a reload icon next to the association title so users can easily reload just that turbo-frame instead of doing a full page reload.

#### Usage
To enable the reloadable feature, you have two options:

1. Direct Boolean Value:

Provide a boolean value directly to the reloadable option. This sets a default behavior where the reloadable feature is either enabled or disabled based on this boolean value.

```ruby-vue
field :reviews, as: :{{ $frontmatter.field_type }}, reloadable: true
```

2. Dynamic Conditions with a Block:

For more dynamic behavior, you can provide a block to the reloadable option. Within this block, you can specify conditions under which the reloadable should be displayed.

```ruby-vue
field :reviews, as: :{{ $frontmatter.field_type }},
  reloadable: -> {
    current_user.is_admin?
  }
```

In the above example, the reloadable will be visible if the current_user is an admin.

#### ExecutionContext
The reloadable block executes within the [`ExecutionContext`](#execution-context), granting access to all default methods and attributes.

<Image src="/assets/img/reloadable.png" width="680" height="94" alt="Reloadable" />
</Option>

<Option name="`association`">

<VersionReq version="3.6.2" />

The `for_attribute` option allows to specify the association used for a certain field. This option make possible to define same association with different scopes and different name several times on the same resource.

#### Usage
```ruby-vue
field :reviews,
  as: :{{ $frontmatter.field_type }}

field :special_reviews,
  as: :{{ $frontmatter.field_type }},
  for_attribute: :reviews,
  scope: -> { query.special_reviews }
```
</Option>




:::warning
It's important to set the `inverse_of` as often as possible to your model's association attribute.
:::

# Has One

The `HasOne` association shows the unfolded view of your `has_one` association. It's like peaking on the `Show` view of that associated record. The user can also access the `Attach` and `Detach` buttons.

```ruby
field :admin, as: :has_one
```

<Image src="/assets/img/associations/has-one.jpg" width="919" height="824" alt="Has one" />

## Options

<Option name="`searchable`">

<div class="space-x-2">
  <LicenseReq license="pro" />
  <DemoVideo demo-video="https://youtu.be/KLI_sVTPX-Q" />
</div>

Turns the attach field/modal from a `select` input to a searchable experience

```ruby{5}
class Avo::Resources::CourseLink < Avo::BaseResource
  def fields
    field :links,
      as: :has_many,
      searchable: true
  end
end
```

:::warning
  Avo uses the **search feature** behind the scenes, so **make sure the target resource has the [`search_query`](#search) option configured**.
:::

```ruby{3-7}
# app/avo/resources/course_link.rb
class Avo::Resources::CourseLink < Avo::BaseResource
  self.search = {
    query: -> {
      query.ransack(id_eq: params[:q], link_cont: params[:q], m: "or").result(distinct: false)
    }
  }
end
```

#### Default

`false`

#### Possible values

`true`, `false`
</Option>

<Option name="`attach_scope`">

Scope out the records the user sees on the Attach modal.

#### Default

`nil`

#### Possible values

```ruby{3}
field :user,
  as: :belongs_to,
  attach_scope: -> { query.non_admins }
```

Pass in a block where you attach scopes to the `query` object and `parent` object, which is the actual record where you want to assign the association. The block is executed in the [`ExecutionContext`](#execution-context).
</Option>

:::warning
The `attach_scope` will not filter the records in the listing from `has_many` or `has_and_belongs_to_many` associations.
Use [`scope`](#scope) or a [Pundit policy `Scope`](#authorization) for that.
:::

```ruby-vue{3}
field :members,
  as: :{{ $frontmatter.field_type }},
  attach_scope: -> { query.where.not(team_id: parent.id) }
  ```
In this example, in the `attach_scope`, we ensure that when attaching members to a team, only those who are not already members will appear in the list of options.


## Show on edit screens

By default, the `{{ $frontmatter.field_type }}` field is only visible in the [show](#views) view. To make it available in the [edit](#views) view as well, include the `show_on: :edit` option. This ensures that the `{{ $frontmatter.field_type }}` [show](#views) view component is also rendered within the [edit](#views) view.

## Nested in Forms
<div class="space-x-2">
  <VersionReq version="3.19.0"/>
  <BetaStatus label="Public beta"/>
  <LicenseReq license="advanced"/>
</div>


You can use ["Show on edit screens"](#show-on-edit-screens) to make the `{{ $frontmatter.field_type }}` field available in the [edit](#views) view. However, this will render it using the [show](#views) view component.

To enable nested creation for the `{{ $frontmatter.field_type }}` field, allowing it to be created and / or edited alongside its parent record within the same form, use the `nested` option which is a hash with configurable option.


Keep in mind that this will display the fieldâ€™s resource as it appears in the edit view.

<Option name="nested">

Enables this field as a nested form in the specified views.

##### Default value

`{}`

#### Possible values

A hash with the following options:
- `on:` Views in which to enable nesting. Accepted values:
  - `:new` - Enables nesting in the [new](#views) view.
  - `:edit` - Enables nesting in the [edit](#views) view.
  - `:forms` - Enables nesting in the [new](#views) and [edit](#views) views.
- `limit:` *(Only for `has_many` and `has_and_belongs_to_many` fields)* Hides the "Add" button when the specified limit is reached.

:::tip
Setting `nested: true` is a shortcut for `nested: { on: :forms }`.
:::

#### Example

```ruby-vue{4,5,7,8,10,11,13-14,16-19}
# app/avo/resources/book.rb
class Avo::Resources::Book < Avo::BaseResource
  def fields
    # Shortcut for full nesting
    field :{{ $frontmatter.field_type === 'has_one' ? 'author' : 'authors' }}, as: :{{ $frontmatter.field_type }}, nested: true

    # Explicit nesting on new only
    field :{{ $frontmatter.field_type === 'has_one' ? 'author' : 'authors' }}, as: :{{ $frontmatter.field_type }}, nested: { on: :new }

    # Explicit nesting on edit only
    field :{{ $frontmatter.field_type === 'has_one' ? 'author' : 'authors' }}, as: :{{ $frontmatter.field_type }}, nested: { on: :edit }

    # Explicit nesting on both new and edit
    field :{{ $frontmatter.field_type === 'has_one' ? 'author' : 'authors' }}, as: :{{ $frontmatter.field_type }}, nested: { on: :forms }

    # Limit nested creation (for has_many or has_and_belongs_to_many only)
    field :authors,
      as: :{{ $frontmatter.field_type }},
      nested: { on: [:new, :edit], limit: 2 }
  end
end
```

</Option>




# Audit Logging

Avo's Audit Logging feature provides a seamless way to track and visualize user activity and changes within your applications. It seamlessly integrates with [`paper_trail`](https://github.com/paper-trail-gem/paper_trail), offering flexible installation and customization options.

Captures user activities on Avo resources and actions, recording details such as the author and the performed event.

The installation process will automatically generate the necessary migrations, resources, and controllers that power activity tracking. Additionally [`paper_trail`](https://github.com/paper-trail-gem/paper_trail) will be installed if it is not already present in your project.

## Requirements

- `avo-advanced`

## Installation

:::info
When installing `avo-audit_logging` on an application, we strongly recommend following this documentation page step-by-step without skipping sections, as it was designed with that approach in mind.
:::

### 1. Install the gem

Start by adding the following to your `Gemfile`:

```bash
gem "avo-audit_logging", source: "https://packager.dev/avo-hq/"
```

Then
```bash
bundle install
```

### 2. Run the installer

```bash
bin/rails generate avo:audit_logging install
```

### 3. Migrate

At this stage, all migrations, resources, and controllers required for the audit logging feature are set up and ready, it's time to migrate:

```bash
bin/rails db:migrate
```

## Enable and configure audit logging

### Global enable

After installation, audit logging is disabled by default. To enable it, navigate to your `avo.rb` initializer file and update the configuration for the `Avo::AuditLogging` module.

Set `config.enabled` to `true` within this configuration.

```ruby
# config/initializers/avo.rb # [!code focus]

Avo.configure do |config|
  # ...
end

Avo::AuditLogging.configure do |config| # [!code focus]
  # config.enabled = false # [!code --] # [!code focus]
  config.enabled = true # [!code ++] # [!code focus]
  # config.author_model = "User"
end # [!code focus]
```

:::info
Setting this configuration to `false` will disable the audit logging feature entirely, overriding any other specific settings. We'll cover those specific settings in the next steps.
:::

:::warning
Setting this configuration to `false` will not prevent previously registered activity from being displayed.

To control the display behavior when this configuration is set to `false`,
you can wrap the relevant fields or tools within an `Avo::AuditLogging.configuration.enabled?` condition, like this:

```ruby{6-8}
class Avo::Resources::User < Avo::BaseResource
  def fields
    field :id, as: :id, link_to_record: true
    field :email, as: :text, link_to_record: true
    field :products, as: :has_many
    if Avo::AuditLogging.configuration.enabled?
      field :avo_authored, as: :has_many, name: "Activity"
    end
  end
end
```
:::

### Configure author models

:::info
If `User` is your only author model, you can skip this step as it will be automatically set by default.
:::

Avo must determine the potential author models to correctly establish associations in the background. This setup enables the retrieval of all activities associated with a specific author via the `avo_authored` association. To designate a model as an author, use `config.author_model`, for multiple models, utilize `config.author_models`.

```ruby
# config/initializers/avo.rb # [!code focus]

Avo.configure do |config|
  # ...
end

Avo::AuditLogging.configure do |config| # [!code focus]
  config.enabled = true

  # config.author_model = "User" # [!code --] # [!code focus]
  config.author_model = "Account" # [!code ++] # [!code focus]

  # Or for multiples models # [!code focus]
  config.author_models = ["User", "Account"] # [!code ++] # [!code focus]
end # [!code focus]
```

### Enable specific resources and actions

At this stage, the audit logging feature should be enabled, but activities are not yet being saved. By default, only resources and actions that are explicitly enabled for auditing will be tracked.

To enable audit logging for specific resources or actions, use the `self.audit_logging` class attribute.

:::code-group
```ruby [Resource]{2-4}
class Avo::Resources::Product < Avo::BaseResource # [!code focus]
  self.audit_logging = { # [!code ++] # [!code focus]
    activity: true # [!code ++] # [!code focus]
  } # [!code ++] # [!code focus]

  def fields
    field :id, as: :id, link_to_record: true
    field :name, as: :text, link_to_record: true
    field :price, as: :number, step: 1
    # ...
  end

  def actions
    action Avo::Actions::ChangePrice
  end
end # [!code focus]
```

```ruby [Action]{4-6}
class Avo::Actions::ChangePrice < Avo::BaseAction # [!code focus]
  self.name = "Change Price"

  self.audit_logging = { # [!code ++] # [!code focus]
    activity: true # [!code ++] # [!code focus]
  } # [!code ++] # [!code focus]

  def fields
    field :price, as: :number, default: -> { resource.record.price rescue nil }
  end

  def handle(query:, fields:, current_user:, resource:, **args)
    query.each do |record|
      record.update!(price: fields[:price])
    end
  end
end # [!code focus]
```
:::

All resources and actions with audit logging activity enabled are being tracked now.

But these activities aren't visible yet, right? Let's look at how to display them in the next step.

## Display logged activities

### Resource-Specific Activities

The `Avo::ResourceTools::Timeline` tool, provided by the `avo-audit_logging` gem, is designed for use in the sidebar. It offers a compact view of activities that have occurred on a specific resource, presenting them in a streamlined format:

<Image src="/assets/img/3_0/audit-logging/sidebar-activities.png" width="1915" height="719" alt="Avo compact activities on sidebar image" />

### Configuring the Sidebar for Activity Tracking

To enable this feature, configure the resource to include the resource tool in the main menu sidebar:

```ruby{7,12-15}
class Avo::Resources::Product < Avo::BaseResource # [!code focus]
  self.audit_logging = {
    activity: true
  }

  def fields # [!code focus]
    main_panel do # [!code ++] # [!code focus]
      field :id, as: :id, link_to_record: true
      field :name, as: :text, link_to_record: true
      field :price, as: :number, step: 1

      sidebar do # [!code ++] # [!code focus]
        tool Avo::ResourceTools::Timeline # [!code ++] # [!code focus]
      end # [!code ++] # [!code focus]
    end # [!code ++] # [!code focus]

    field :avo_activities, as: :has_many # [!code focus]
  end # [!code focus]

  def actions
    action Avo::Actions::ChangePrice
  end
end # [!code focus]
```

### Viewing and Navigating Activity Logs

Hovering over an entry reveals the precise timestamp in UTC. Clicking on an entry navigates to a detailed page displaying the full payload.

<Image src="/assets/img/3_0/audit-logging/hover-activities.png" width="657" height="284" alt="Hover on activity" />

### Enabling Change Logs and Reverting Changes

By default, update activities do not display a change log, and there is no way to revert changes. This is because PaperTrail has not yet been enabled on the model. To enable it, simply add `has_paper_trail` to the model:

```ruby
# app/models/product.rb # [!code focus]

class Product < ApplicationRecord # [!code focus]
  has_paper_trail # [!code ++] # [!code focus]

  belongs_to :user, optional: true

  validates_presence_of :price
end # [!code focus]
```

Once enabled, the changelog will be visible, along with an action to revert changes.

<Image src="/assets/img/3_0/audit-logging/activity-details.png" width="2010" height="1152" alt="Activity details page" />

### Troubleshooting: Missing `changeset` Field

:::warning
If the `changeset` field in the versions table consistently appears as `nil`, ensure you add the following configuration in your `application.rb` file:

```ruby
config.active_record.yaml_column_permitted_classes = [Symbol, Date, Time, ActiveSupport::TimeWithZone, ActiveSupport::TimeZone]
```
:::

### Display author logged activities

Weâ€™ve already covered how to view all activity on a specific record. Now, letâ€™s display a table within `Avo::Resources::User` to view all tracked activity for a particular user.

<Image src="/assets/img/3_0/audit-logging/authored.png" width="1921" height="754" alt="Authored table image" />

:::warning
If you're using a model other than `User`, make sure you have already [configured the author models](#configure-author-models).
:::

```ruby
class Avo::Resources::User < Avo::BaseResource # [!code focus]
  def fields # [!code focus]
    field :id, as: :id, link_to_record: true
    field :email, as: :text, link_to_record: true
    field :products, as: :has_many
    field :avo_authored, as: :has_many, name: "Activity" # [!code ++] # [!code focus]
  end # [!code focus]
end # [!code focus]
```

### Overview of all activities

We've covered how to view activities for specific records and how to view all actions made by a particular author. However, having an overview of all the activities in one place can also be useful. This can be achieved by configuring the menu to include a section with an entry for all activities.

```ruby
# config/initializers/avo.rb

Avo.configure do |config|
  config.main_menu = -> {
    section "AuditLogging", icon: "presentation-chart-bar" do # [!code ++]
      resource :avo_activity # [!code ++]
    end # [!code ++]
  }
end
```

## Disable specific actions logging

By default, when audit logging is enabled for a resource or action, all actions, such as `index` visits, `show` visits, `edit`, `update`, etc. are logged.

If you prefer not to log all of these actions, configure the `actions` key within the `self.audit_logging` class attribute.

Let's turn off `edit` and `show` logging for the `Avo::Resources::Product`:

```ruby
class Avo::Resources::Product < Avo::BaseResource # [!code focus]
  self.audit_logging = { # [!code focus]
    activity: true, # [!code focus]
    actions: { # [!code ++] # [!code focus]
      edit: false, # [!code ++] # [!code focus]
      show: false # [!code ++] # [!code focus]
    } # [!code ++] # [!code focus]
  } # [!code focus]

  def fields
    main_menu do
      field :id, as: :id, link_to_record: true
      field :name, as: :text, link_to_record: true
      field :price, as: :number, step: 1

      sidebar do
        tool Avo::ResourceTools::Timeline
      end
    end
    # ...
    field :avo_activities, as: :has_many
  end

  def actions
    action Avo::Actions::ChangePrice
  end
end # [!code focus]
```

The default value for `actions` is:

```ruby
{
  index: true,
  new: true,
  create: true,
  edit: true,
  update: true,
  show: true,
  destroy: true,
  attach: true,
  detach: true,
  handle: true
}
```

## Conclusion

With Avo's Audit Logging, you gain a powerful tool to track and visualize user actions and record changes seamlessly across your application. By carefully following the setup steps and configuring logging to fit your needs, you can establish a robust and transparent audit system, enhancing accountability and preserving data integrity.

Happy auditing!



# Array

The `Array` field in allows you to display and manage structured array data. This field supports flexibility in fetching and rendering data, making it suitable for various use cases.

:::tip Important
To use the `Array` field, you must create a resource specifically for it. Refer to the [Array Resource documentation](#array-resources) for detailed instructions.

For example, to use `field :attendees, as: :array`, you can generate an array resource by running the following command:

```bash
rails generate avo:resource Attendee --array
```

This step ensures the proper setup of your array field within the Avo framework.
:::

### Example 1: Array field with a block

You can define array data directly within a block. This is useful for static or pre-configured data:

```ruby{3-8}
class Avo::Resources::Course < Avo::BaseResource
  def fields
    field :attendees, as: :array do
      [
        { id: 1, name: "John Doe", role: "Software Developer", organization: "TechCorp" },
        { id: 2, name: "Jane Smith", role: "Data Scientist", organization: "DataPros" }
      ]
    end
  end
end
```

:::warning Authorization
The `array` field internally inherits many behaviors from `has_many`, including authorization. If you are using authorization and the array field is not rendering, it is most likely not authorized.

To explicitly authorize it, define the following method in the resource's policy:

```ruby{3}
# app/policies/course_policy.rb
class CoursePolicy < ApplicationPolicy
  def view_attendees? = true
end
```

For more details, refer to the [view_{association}?](#authorization) documentation.
:::

### Example 2: Array field fetching data from the model's method

If no block is defined, Avo will attempt to fetch data by calling the corresponding method on the model:

```ruby
class Course < ApplicationRecord
  def attendees
    User.all.first(6) # Example fetching first 6 users
  end
end
```

Here, the `attendees` field will use the `attendees` method from the `Course` model to render its data dynamically.

### Example 3: Fallback to the `records` method

If neither the block nor the model's method exists, Avo will fall back to the `records` method defined in the resource used to render the array field. This is useful for providing a default dataset.

When neither a block nor a model's method is defined, Avo will fall back to the `records` method in the resource used to render the field. This is a handy fallback for providing default datasets:

```ruby
class Avo::Resources::Attendee < Avo::Resources::ArrayResource
  def records
    [
      { id: 1, name: "Default Attendee", role: "Guest", organization: "DefaultOrg" }
    ]
  end
end
```

## Summary of Data Fetching Hierarchy

When using `has_many` with `array: true`, Avo will fetch data in the following order:
1. Use data returned by the **block** provided in the field.
2. Fetch data from the **associated model method** (e.g., `Course#attendees`).
3. Fall back to the **`records` method** defined in the resource.

This hierarchy provides maximum flexibility and ensures seamless integration with both dynamic and predefined datasets.




# Badge

The `Badge` field is used to display an easily recognizable status of a record.

<Image src="/assets/img/fields/badge.jpg" width="244" height="476" alt="Badge field" />

```ruby
field :stage,
  as: :badge,
  options: {
    info: [:discovery, :idea],
    success: :done,
    warning: 'on hold',
    danger: :cancelled,
    neutral: :drafting
  } # The mapping of custom values to badge values.
```

## Description

By default, the badge field supports five value types: `info` (blue), `success` (green), `danger` (red), `warning` (yellow) and `neutral` (gray). We can choose what database values are mapped to which type with the `options` parameter.

The `options` parameter is a `Hash` that has the state as the `key` and your configured values as `value`. The `value` param can be a symbol, string, or array of symbols or strings.

The `Badge` field is intended to be displayed only on **Index** and **Show** views. In order to update the value shown by badge field you need to use another field like [Text](#text) or [Select](#select), in combination with `hide_on: index` and `hide_on: show`.


## Options

<Option name="`options`">

The options should be a hash with the keys of one of the five available types (`info`, `success`, `warning`, `danger`, `neutral`) and the values matching your record's database values.

#### Default value

`{ info: :info, success: :success, danger: :danger, warning: :warning, neutral: :neutral }`

Below is an example of how you can use two fields in that combination.
</Option>

## Examples

```ruby
field :stage, as: :select, hide_on: [:show, :index], options: { 'Discovery': :discovery, 'Idea': :idea, 'Done': :done, 'On hold': 'on hold', 'Cancelled': :cancelled, 'Drafting': :drafting }, placeholder: 'Choose the stage.'
field :stage, as: :badge, options: { info: [:discovery, :idea], success: :done, warning: 'on hold', danger: :cancelled, neutral: :drafting }
```




# Boolean

The `Boolean` field renders a `input[type="checkbox"]` on **Form** views and a nice green `check` icon/red `X` icon on the **Show** and **Index** views.

<Image src="/assets/img/fields/boolean.jpg" width="790" height="356" alt="Boolean field" />

```ruby
field :is_published,
  as: :boolean,
  name: 'Published',
  true_value: 'yes',
  false_value: 'no'
```

## Options

<Option name="`true_value`">

What should count as true. You can use `1`, `yes`, or a different value.

#### Default value

`[true, "true", "1"]`

</Option>
<Option name="`false_value`">

What should count as false. You can use `0`, `no`, or a different value.

#### Default value

`[false, "false", "0"]`
</Option>



# Boolean Group

<Image src="/assets/img/fields/boolean-group.jpg" width="645" height="275" alt="Boolean group field" />

The `BooleanGroup` is used to update a `Hash` with `string` keys and `boolean` values in the database.

It's useful when you have something like a roles hash in your database.

### DB payload example
An example of a boolean group object stored in the database:

```ruby
{
  "admin": true,
  "manager": true,
  "writer": true,
}
```

### Field declaration example
Below is an example of declaring a `boolean_group` field for roles that matches the DB value from the example above:

```ruby
field :roles,
  as: :boolean_group,
  name: "User roles",
  options: {
    admin: "Administrator",
    manager: "Manager",
    writer: "Writer"
  }
```



<Option name="`options`">

The `options` attribute should be a `Hash` where the keys match the DB keys and the values are the visible labels.

#### Default value

Empty `Hash`.

```ruby
{}
```

#### Computed options

You may need to compute the options dynamically for your `BooleanGroup` field. You can use a lambda for this, which provides access to the `record`, `resource`, `view`, and `field` properties where you can pull data off.

```ruby{5-9}
# app/avo/resources/project.rb
class Avo::Resources::Project < Avo::BaseResource
  field :features,
    as: :boolean_group,
    options: -> do
      record.features.each_with_object({}) do |feature, hash|
        hash[feature.id] = feature.name.humanize
      end
    end
end
```

The output value must be a hash as described above.

</Option>


## Updates

Before version <Version version="3.7.0" /> Avo would override the whole attribute with only the payload sent from the client.

```json
// Before update.
{
  "feature_enabled": true,
  "another_feature_enabled": false,
  "something_else": "some_value" // this will disappear
}

// After update.
{
  "feature_enabled": true,
  "another_feature_enabled": false,
}
```

<VersionReq version="3.7.0" /> will only update the keys that you send from the client.

```json
// Before update.
{
  "feature_enabled": true,
  "another_feature_enabled": false,
  "something_else": "some_value" // this will be kept
}

// After update.
{
  "feature_enabled": true,
  "another_feature_enabled": false,
  "something_else": "some_value"
}
```



# Code

<Image src="/assets/img/fields/code.jpg" width="1552" height="716" alt="Code field" />

The `Code` field generates a code editor using [codemirror](https://codemirror.net/) package. This field is hidden on **Index** view.

```ruby
field :custom_css, as: :code, theme: 'dracula', language: 'css'
```

## Options

<Option name="`theme`">

Customize the color theme.

#### Default value

`material-darker`

#### Possible values

`material-darker`, `eclipse`, or `dracula`

Preview the themes here: [codemirror-themes](https://codemirror.net/demo/theme.html).
</Option>

<Option name="`language`">

Customize the syntax highlighting using the language method.

#### Default value

`javascript`

#### Possible values

`css`, `dockerfile`, `htmlmixed`, `javascript`, `markdown`, `nginx`, `php`, `ruby`, `sass`, `shell`, `sql`, `vue` or `xml`.
</Option>

<Option name="`height`">

Customize the height of the editor.

#### Default value

`auto`

#### Possible values

`auto`, or any value in pixels (eg `height: 250px`).
</Option>

<Option name="`tab_size`">

Customize the tab_size of the editor.

#### Default value

`2`

#### Possible values

Any integer value.
</Option>

<Option name="`indent_with_tabs`">

Customize the type of indentation.

#### Default value

`false`

#### Possible values

`true` or `false`
</Option>

<Option name="`line_wrapping`">

Customize whether the editor should apply line wrapping.

#### Default value

`true`

#### Possible values

`true` or `false`
</Option>



# Country

`Country` field generates a [Select](#select) field on **Edit** view that includes all [ISO 3166-1](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes) countries. The value stored in the database will be the country code, and the value displayed in Avo will be the name of the country.

:::warning
You must manually require the `countries` gem in your `Gemfile`.

```ruby
# All sorts of useful information about every country packaged as convenient little country objects.
gem "countries"
```
:::

```ruby
field :country, as: :country, display_code: true
```

## Options

<Option name="`display_code`">

You can easily choose to display the `code` of the country on **Index** and **Show** views by declaring `display_code` to `true`.

### Default value

`false`

### Possible values

`true`, `false`
</Option>



# Date

The `Date` field may be used to display date values.

```ruby
field :birthday,
  as: :date,
  first_day_of_week: 1,
  picker_format: "F J Y",
  format: "yyyy-LL-dd",
  placeholder: "Feb 24th 1955"
```

## Options

<Option name="`format`">

Format the date shown to the user on the `Index` and `Show` views.

#### Default

`yyyy-LL-dd`

#### Possible values

Use [`luxon`](https://moment.github.io/luxon/#/formatting?id=table-of-tokens) formatting tokens.
</Option>
<Option name="`picker_format`">

Format the date shown to the user on the `Edit` and `New` views.

#### Default

`Y-m-d`

#### Possible values

Use [`flatpickr`](https://flatpickr.js.org/formatting) formatting tokens.
</Option>

<Option name="`picker_options`;">

Passes the options here to [flatpickr](https://flatpickr.js.org/).

#### Default

`{}`

#### Possible values

Use [`flatpickr`](https://flatpickr.js.org/options) options.

:::warning
These options may override other options like `picker_options`.
:::

</Option>
<Option name="`first_day_of_week`">

Set which should be the first date of the week in the picker calendar. Flatpickr [documentation](https://flatpickr.js.org/localization/) on that. 1 is Monday, and 7 is Sunday.

#### Default value

`1`

#### Possible values

`1`, `2`, `3`, `4`, `5`, `6`, and `7`
</Option>

<Option name="`disable_mobile`">

By default, flatpickr is [disabled on mobile](https://flatpickr.js.org/mobile-support/) because the mobile date pickers tend to give a better experience, but you can override that using `disable_mobile: true` (misleading to set it to `true`, I know. We're just forwarding the option). So that will override that behavior and display flatpickr on mobile devices too.

#### Default value

`false`

#### Possible values

`true`, `false`
</Option>




# DateTime

<Image src="/assets/img/fields/date-time.jpg" width="712" height="416" alt="DateTime field" />

The `DateTime` field is similar to the Date field with two new attributes. `time_24hr` tells flatpickr to use 24 hours format and `timezone` to tell it in what timezone to display the time. By default, it uses your browser's timezone.

```ruby
field :joined_at,
  as: :date_time,
  name: "Joined at",
  picker_format: "Y-m-d H:i:S",
  format: "yyyy-LL-dd TT",
  time_24hr: true,
  timezone: "PST"
```

## Options

<Option name="`format`">

Format the date shown to the user on the `Index` and `Show` views.

#### Default

`yyyy-LL-dd TT`

#### Possible values

Use [`luxon`](https://moment.github.io/luxon/#/formatting?id=table-of-tokens) formatting tokens.
</Option>
<Option name="`picker_format`">

Format the date shown to the user on the `Edit` and `New` views.

#### Default

`Y-m-d H:i:S`

#### Possible values

Use [`flatpickr`](https://flatpickr.js.org/formatting) formatting tokens.
</Option>
<Option name="`time_24hr`">

Displays time picker in 24-hour mode or AM/PM selection.

#### Default

`false`

#### Possible values

`true`, `false`
</Option>
<Option name="`timezone`">

Select in which timezone the values should be cast.

#### Default

If nothing is selected, the browser's timezone will be used.

#### Possible values

[TZInfo identifiers](https://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html).

```ruby{1,3}
field :started_at, as: :date_time, timezone: "EET"
# Or
field :started_at, as: :date_time, timezone: -> { record.timezone }
```
</Option>

<Option name="`picker_options`">

Passes the options here to [flatpickr](https://flatpickr.js.org/).

#### Default

`{}`

#### Possible values

Use [`flatpickr`](https://flatpickr.js.org/options) options.
</Option>

:::warning
These options may override other options like `time_24hr`.
:::

<Option name="`first_day_of_week`">

Set which should be the first date of the week in the picker calendar. Flatpickr [documentation](https://flatpickr.js.org/localization/) on that. 1 is Monday, and 7 is Sunday.

#### Default value

`1`

#### Possible values

`1`, `2`, `3`, `4`, `5`, `6`, and `7`
</Option>

<Option name="`disable_mobile`">

By default, flatpickr is [disabled on mobile](https://flatpickr.js.org/mobile-support/) because the mobile date pickers tend to give a better experience, but you can override that using `disable_mobile: true` (misleading to set it to `true`, I know. We're just forwarding the option). So that will override that behavior and display flatpickr on mobile devices too.

#### Default value

`false`

#### Possible values

`true`, `false`
</Option>




# EasyMDE

:::info
Before Avo 3.17 this field was called `markdown`. It was renamed to `easy_mde` so we can add our own implementation with `markdown`.
:::

<Image src="/assets/img/fields/easy_mde.jpg" width="906" height="421" alt="Trix field" />

The `easy_mde` field renders a [EasyMDE Markdown Editor](https://github.com/Ionaru/easy-markdown-editor) and is associated with a text or textarea column in the database.
`easy_mde` field converts text within the editor into raw Markdown text and stores it back in the database.

```ruby
field :description, as: :easy_mde
```

:::info
The `easy_mde` field is hidden from the **Index** view.
:::

## Options

<Option name="`always_show`">

By default, the content of the `easy_mde` field is not visible on the `Show` view, instead, it's hidden under a `Show Content` link that, when clicked, displays the content. You can set `easy_mde` to always display the content by setting `always_show` to `true`.

#### Default

`false`

#### Possible values

`true`, `false`
</Option>

<Option name="`height`">

Sets the value of the editor

#### Default

`auto`

#### Possible values

`auto` or any number in pixels.
</Option>

<Option name="`spell_checker`">

Toggles the editor's spell checker option.

```ruby
field :description, as: :easy_mde, spell_checker: true
```

#### Default

`false`

#### Possible values

`true`, `false`
</Option>

<!-- ## Enable spell checker -->



# External image

You may have a field in the database that has the URL to an image, and you want to display that in Avo. That is where the `ExternalImage` field comes in to help.

It will take that value, insert it into an `image_tag`, and display it on the `Index` and `Show` views.

```ruby
field :logo, as: :external_image
```

## Options

<Option name="`width`">

#### Default value

`40`

#### Possible values

Use any number to size the image.
</Option>

<Option name="`height`">

#### Default value

`40`

#### Possible values

Use any number to size the image.
</Option>

<Option name="`radius`">

#### Default value

`0`

#### Possible values

Use any number to set the radius value.
</Option>

<Option name="`link_to_record`">

Wraps the content into an anchor that links to the resource.
</Option>


## Use computed values

Another common scenario is to use a value from your database and create a new URL using a computed value.

```ruby
field :logo, as: :external_image do
  "//logo.clearbit.com/#{URI.parse(record.url).host}?size=180"
rescue
  nil
end
```

## Use in the Grid `cover` position

Another common place you could use it is in the grid `:cover` position.

```ruby
cover :logo, as: :external_image, link_to_record: true do
  "//logo.clearbit.com/#{URI.parse(record.url).host}?size=180"
rescue
  nil
end
```



# File

:::warning
You must manually require `activestorage` and `image_processing` gems in your `Gemfile`.

```ruby
# Active Storage makes it simple to upload and reference files
gem "activestorage"

# High-level image processing wrapper for libvips and ImageMagick/GraphicsMagick
gem "image_processing"
```
:::


The `File` field is the fastest way to implement file uploads in a Ruby on Rails app using [Active Storage](https://edgeguides.rubyonrails.org/active_storage_overview.html).

Avo will use your application's Active Storage settings with any supported [disk services](https://edgeguides.rubyonrails.org/active_storage_overview.html#disk-service).

```ruby
field :avatar, as: :file, is_image: true
```

## Authorization

:::info
Please ensure you have the `upload_{FIELD_ID}?`, `delete_{FIELD_ID}?`, and `download_{FIELD_ID}?` methods set on your model's **Pundit** policy. Otherwise, the input and download/delete buttons will be hidden.
:::

**Related:**
 - [Attachment pundit policies](#authorization)

<!-- ## Deprecated options

The `is_image`, `is_audio`, and `is_video` options are deprecated in favor of letting Active Storage figure out the type of the attachment. If Active Storage detects a file as an image, Avo will display it as an image. Same for audio and video files. -->


## Variants

When using the `file` field to display an image, you can opt to show a processed variant of that image. This can be achieved using the [`format_using`](#field-options) option.

### Example:

```ruby{3-5}
field :photo,
  as: :file,
  format_using: -> {
    value.variant(resize_to_limit: [150, 150]).processed.image
  }
```

## Options

<Option name="`accept`">

Instructs the input to accept only a particular file type for that input using the `accept` option.

```ruby
field :cover_video, as: :file, accept: "image/*"
```

#### Default

`nil`

#### Possible values

`image/*`, `audio/*`, `doc/*`, or any other types from [the spec](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/accept).
</Option>

<Option name="`direct_upload`">

<LicenseReq license="pro" />

If you have large files and don't want to overload the server with uploads, you can use the `direct_upload` feature, which will upload the file directly to your cloud provider.

```ruby
field :cover_video, as: :file, direct_upload: true
```

#### Default

`false`

#### Possible values

`true`, `false`
</Option>

<Option name="`display_filename`">

Option that specify if the file should have the caption present or not.

```ruby
field :cover_video, as: :file, display_filename: false
```

#### Default

`true`

#### Possible values

`true`, `false`
</Option>

<Option name="`link_to_record`">

Wraps the content into an anchor that links to the resource.
</Option>




# Files

:::warning
You must manually require `activestorage` and `image_processing` gems in your `Gemfile`.

```ruby
# Active Storage makes it simple to upload and reference files
gem "activestorage"

# High-level image processing wrapper for libvips and ImageMagick/GraphicsMagick
gem "image_processing"
```
:::


The `Files` field is similar to [`File`](#file) and enables you to upload multiple files at once using the same easy-to-use [Active Storage](https://edgeguides.rubyonrails.org/active_storage_overview.html) implementation.

```ruby
field :documents, as: :files
```

## Options
<Option name="`accept`">

Instructs the input to accept only a particular file type for that input using the `accept` option.

```ruby
field :cover_video, as: :file, accept: "image/*"
```

#### Default

`nil`

#### Possible values

`image/*`, `audio/*`, `doc/*`, or any other types from [the spec](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/accept).
</Option>

<Option name="`direct_upload`">

<LicenseReq license="pro" />

If you have large files and don't want to overload the server with uploads, you can use the `direct_upload` feature, which will upload the file directly to your cloud provider.

```ruby
field :cover_video, as: :file, direct_upload: true
```

#### Default

`false`

#### Possible values

`true`, `false`
</Option>

<Option name="`display_filename`">

Option that specify if the file should have the caption present or not.

```ruby
field :cover_video, as: :file, display_filename: false
```

#### Default

`true`

#### Possible values

`true`, `false`
</Option>


## Authorization

:::info
Please ensure you have the `upload_{FIELD_ID}?`, `delete_{FIELD_ID}?`, and `download_{FIELD_ID}?` methods set on your model's **Pundit** policy. Otherwise, the input and download/delete buttons will be hidden.
:::

**Related:**
 - [Attachment pundit policies](#authorization)

<!-- ## Deprecated options

The `is_image`, `is_audio`, and `is_video` options are deprecated in favor of letting Active Storage figure out the type of the attachment. If Active Storage detects a file as an image, Avo will display it as an image. Same for audio and video files. -->


<Option name="`view_type`">

<Image src="/assets/img/files_view_types.gif" width="1734" height="431" alt="" />

Set the default `view_type`.

#### Default

`grid`

#### Possible values

`grid`, `list`
</Option>

<Option name="`hide_view_type_switcher`">

Option to hide the view type switcher component.

#### Default

`false`

#### Possible values

`true`, `false`
</Option>



# Gravatar

The `Gravatar` field turns an email field from the database into an avatar image if it's found in the [Gravatar](https://en.gravatar.com/site/implement/images/) database.

```ruby
field :email,
  as: :gravatar,
  rounded: false,
  size: 60,
  default_url: 'some image url'
```

## Options
<Option name="`rounded`">

Choose whether the rendered avatar should be rounded or not on the `Index` view.

On `Show`, the image is always a `square,` and the size is `responsive`.

#### Default

`true`

#### Possible values

`true`, `false`
</Option>

<Option name="`size`">

Set the size of the avatar.

#### Default

`32`

#### Possible values

Any number in pixels. Remember that the size will influence the `Index` table row height.
</Option>

<Option name="`default`">

Set the default image if the email address was not found in Gravatar's database.

#### Default

`32`

#### Possible values

Any number in pixels. Remember that the size will influence the `Index` table row height.
</Option>

<Option name="`link_to_record`">

Wraps the content into an anchor that links to the resource.
</Option>


## Using computed values

You may also pass in a computed value.

```ruby
field :email, as: :gravatar do
  "#{record.google_username}@gmail.com"
end
```



# Heading

:::code-group
```ruby [Field id]
field :user_information, as: :heading
```

```ruby [Label]
field :some_id, as: :heading, label: "user information"
```

```ruby [Computed]
field :some_id, as: :heading do
  "user information"
end
```
:::


<Image src="/assets/img/fields/heading.png" width="821" height="230" alt="Heading field" />

The `Heading` field displays a header that acts as a separation layer between different sections.

`Heading` is not assigned to any column in the database and is only visible on the `Show`, `Edit` and `Create` views.

:::warning Computed heading
The computed fields are not rendered on form views, same with heading field, if computed syntax is used it will not be rendered on the form views. Use `label` in order to render it on **all** views.
:::

## Options

<Option name="`as_html`">

The `as_html` option will render it as HTML.

```ruby
field :dev_heading, as: :heading, as_html: true do
  '<div class="underline uppercase font-bold">DEV</div>'
end
```

#### Default

`false`

#### Possible values

`true`, `false`
</Option>

<Option name="`label`">

The content of `label` is the content displayed on the heading space.

```ruby
field :some_id, as: :heading, label: "user information"
```
</Option>



# Hidden

There are scenarios where in order to be able to submit a form, an input should be present but inaccessible to the user. An example of this might be where you want to set a field by default without the option to change, or see it. `Hidden` will render a `<input type="hidden" />` element on the `Edit` and `New` page.

> Hidden will only render on the `Edit` and `New` views.

### Example usage:
```ruby
# Basic
field :group_id, as: :hidden

# With default
field :user_id, as: :hidden, default: -> { current_user.id }

# If the current_user is a admin
# 1. Allow them to see and select a user.
# 2. Remove the user_id field to prevent user_id it from overriding the user selection.
# Otherwise set the user_id to the current user and hide the field.
field :user, as: :belongs_to, visible: -> { context[:current_user].admin? }
field :user_id, as: :hidden, default: -> { current_user.id }, visible: -> { !context[:current_user].admin? }
```



# ID

The `id` field is used to show the record's id. By default, it's visible only on the `Index` and `Show` views. That is a good field to add the `link_to_record` option to make it a shortcut to the record `Show` page.

```ruby
field :id, as: :id
```

## Options

<Option name="`link_to_record`">

Wraps the content into an anchor that links to the resource.
</Option>





# KeyValue

<Image src="/assets/img/fields/key-value.jpg" width="1564" height="400" alt="KeyValue field" />

The `KeyValue` field makes it easy to edit flat key-value pairs stored in `JSON` format in the database.

```ruby
field :meta, as: :key_value
```

## Options

<Option name="`key_label`">

Customize the label for the key header.

#### Default

`I18n.translate("avo.key_value_field.key")`

#### Possible values

Any string value.
</Option>

<Option name="`value_label`">

Customize the label for the value header.

#### Default

`I18n.translate("avo.key_value_field.value")`

#### Possible values

Any string value.
</Option>

<Option name="`action_text`">

Customize the label for the add row button tooltip.

#### Default

`I18n.translate("avo.key_value_field.add_row")`

#### Possible values

Any string value.
</Option>

<Option name="`delete_text`">

Customize the label for the delete row button tooltip.

#### Default

`I18n.translate("avo.key_value_field.delete_row")`

#### Possible values

Any string value.
</Option>

<Option name="`reorder_text`">

<VersionReq version="3.14.0" />

Set a custom label for the tooltip on the reorder by drag-and-drop row button.

#### Default

`I18n.translate("avo.key_value_field.reorder_row")`

#### Possible values

Any string value.
</Option>

<Option name="`disabled`">

Toggle on/off the ability to disable editing keys, editing values, adding rows, and deleting rows for that field.

#### Default

`false`

#### Possible values

`true`, `false`
</Option>

<Option name="`disable_editing_keys`">

Toggle on/off the ability to edit the keys for that field. Turning this off will allow the user to customize only the value fields.

#### Default

`false`

#### Possible values

`true`, `false`
</Option>

<Option name="`disable_editing_values`">

Toggle on/off the ability to edit the values for that field. Turning this off will allow the user to customize only the key fields.

#### Default

`false`

#### Possible values

`true`, `false`
</Option>

<Option name="`disable_adding_rows`">

Toggle on/off the ability to add new rows.

#### Default

`false`

#### Possible values

`true`, `false`
</Option>

<Option name="`disable_deleting_rows`">

Toggle on/off the ability to delete rows from that field. Turning this on will prevent the user from deleting existing rows.

#### Default

`false`

#### Possible values

`true`, `false`
</Option>

## Customizing the labels

You can easily customize the labels displayed in the UI by mentioning custom values in `key_label`, `value_label`, `action_text`, and `delete_text` properties when defining the field.

```ruby
field :meta, # The database field ID
  as: :key_value, # The field type.
  key_label: "Meta key", # Custom value for key header. Defaults to 'Key'.
  value_label: "Meta value", # Custom value for value header. Defaults to 'Value'.
  action_text: "New item", # Custom value for button to add a row. Defaults to 'Add'.
  delete_text: "Remove item" # Custom value for button to delete a row. Defaults to 'Delete'.
```

## Enforce restrictions

You can enforce some restrictions by removing the ability to edit the field's key or value by setting `disable_editing_keys` or `disable_editing_values` to `true` respectively. If `disable_editing_keys` is set to `true`, be aware that this option will also disable adding rows as well. You can separately remove the ability to add a new row by setting `disable_adding_rows` to `true`. Deletion of rows can be enforced by setting `disable_deleting_rows` to `true`.

```ruby
field :meta, # The database field ID
  as: :key_value, # The field type.
  disable_editing_keys: false, # Option to disable the ability to edit keys. Implies disabling to add rows. Defaults to false.
  disable_editing_values: false, # Option to disable the ability to edit values. Defaults to false.
  disable_adding_rows: false, # Option to disable the ability to add rows. Defaults to false.
  disable_deleting_rows: false # Option to disable the ability to delete rows. Defaults to false.
```

Setting `disabled: true` enforces all restrictions by disabling editing keys, editing values, adding rows, and deleting rows collectively.
```ruby
field :meta, # The database field ID
  as: :key_value, # The field type.
  disabled: true, # Option to disable editing keys, editing values, adding rows, and deleting rows. Defaults to false.
```
`KeyValue` is hidden on the `Index` view.



# Location

The `Location` field is used to display a point on a map.

```ruby
field :coordinates, as: :location
```

<Image src="/assets/img/fields/location-field.png" width="2564" height="1730" alt="Location field" />

:::warning
You need to add the `mapkick-rb` (not `mapkick`) gem to your `Gemfile` and have the `MAPBOX_ACCESS_TOKEN` environment variable with a valid [Mapbox](https://account.mapbox.com/auth/signup/) key.
:::

## Description

By default, the location field is attached to one database column that has the coordinates in plain text with a comma `,` joining them (`latitude,longitude`).
Ex: `44.427946,26.102451`

Avo will take that value, split it by the comma and use the first element as the `latitude` and the second one as the `longitude`.

On the <Show /> view you'll get in interactive map and on the edit you'll get one field where you can edit the coordinates.

## Options

<Option name="`stored_as`">

It's customary to have the coordinates in two distinct database columns, one named `latitude` and another `longitude`.

You can instruct Avo to use those two with the `stored_as` option

#### Default value

`nil`

#### Possible values

`nil`, or `[:latitude, :longitude]`.

```ruby
field :coordinates, as: :location, stored_as: [:latitude, :longitude]
```

By using this notation, Avo will grab the `latitude` and `longitude` from those particular columns to compose the map.

This will also render the <Edit /> view with two separate fields to edit the coordinates.

<Image src="/assets/img/fields/location-edit.png" width="2564" height="532" alt="Location field" />
</Option>

<Option name="`mapkick_options`">

<VersionReq version="3.16.2" />

The `mapkick_options` option allows you to customize the appearance and behavior of the map.

Using this option, you can provide a hash of configuration settings supported by the Mapkick gem, such as specifying the map style, enabling or disabling controls, or adding additional customizations.

#### Default

- When `static` is `true`:

```ruby
{
  width: 300,
  height: 300
}
```

- When `static` is `false`:

```ruby
{
  id: "location-map",
  zoom: 15,
  controls: true
}
```

#### Possible values

Accepts the options as [specified in the Mapkick-gem](https://github.com/ankane/mapkick#options).

For example:

```ruby{4-7}
field :coordinates,
  as: :location,
  stored_as: [:latitude, :longitude],
  mapkick_options: {
    style: 'mapbox://styles/mapbox/satellite-v9',
    controls: true
  }
```

By using `mapkick_options`, you can tailor the map's look and functionality to suit your application's requirements.
</Option>

<Option name="`static`">

<VersionReq version="3.16.2" />

The `static` option enables the rendering of a static map leveraging the power of the [mapkick-static](https://github.com/ankane/mapkick-static) gem.

:::warning
You need to add the [mapkick-static](https://github.com/ankane/mapkick-static) gem to your `Gemfile` and have the `MAPBOX_ACCESS_TOKEN` environment variable with a valid [Mapbox](https://account.mapbox.com/auth/signup/) key.
:::


#### Default

`false`

#### Possible values

`true` or `false`

```ruby{4}
field :coordinates,
  as: :location,
  stored_as: [:latitude, :longitude],
  static: true,
  mapkick_options: {
    style: 'mapbox://styles/mapbox/satellite-v9'
  }
```
</Option>



# Markdown

<Image src="/assets/img/fields/markdown/markdown-field.gif" alt="Markdown field" size="800x427" />

:::info
In Avo 3.17 we renamed the `markdown` field `easy_mde` and introduced this custom one based on the [Marksmith editor](https://github.com/avo-hq/marksmith).

Please read the docs on the repo for more information on how it works.
:::

This field is inspired by the wonderful GitHub editor we all love and use.

It supports applying styles to the markup, dropping files in the editor, and using the [Media Library](#media-library).
The uploaded files will be taken over by Rails and persisted using Active Storage.

```ruby
field :body, as: :markdown
```

:::warning
Please ensure you have these gems in your `Gemfile`.

```ruby
gem "marksmith"
gem "commonmarker"
```
:::

<div class="aspect-video">
  <iframe width="100%" height="100%" src="https://www.youtube.com/embed/wnWvzQyyo6A?start=2128" title="Avo 3.17 - Media Library, new Markdown field &amp; the Array Adapter" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

## Supported features

- [x] ActiveStorage file attachments
- [x] [Media Library](#media-library) integration
- [x] Preview panel
- [x] [Ready-to-use renderer](https://github.com/avo-hq/marksmith#built-in-preview-renderer)
- [x] Text formatting
- [x] Lists
- [x] Links
- [x] Images
- [x] Tables
- [x] Code blocks
- [x] Headings

## Customize the renderer

There are two places where we parse the markdown into the HTML you see.

1. In the controller
2. In the <Show /> field component

You may customize the renderer by overriding the model.

```ruby
# app/models/marksmith/renderer.rb

module Marksmith
  class Renderer
    def initialize(body:)
      @body = body
    end

    def render
      if Marksmith.configuration.parser == "commonmarker"
        render_commonmarker
      elsif Marksmith.configuration.parser == "kramdown"
        render_kramdown
      else
        render_redcarpet
      end
    end

    def render_commonmarker
      # commonmarker expects an utf-8 encoded string
      body = @body.to_s.dup.force_encoding("utf-8")
      Commonmarker.to_html(body)
    end

    def render_redcarpet
      ::Redcarpet::Markdown.new(
        ::Redcarpet::Render::HTML,
        tables: true,
        lax_spacing: true,
        fenced_code_blocks: true,
        space_after_headers: true,
        hard_wrap: true,
        autolink: true,
        strikethrough: true,
        underline: true,
        highlight: true,
        quote: true,
        with_toc_data: true
      ).render(@body)
    end

    def render_kramdown
      body = @body.to_s.dup.force_encoding("utf-8")
      Kramdown::Document.new(body).to_html
    end
  end
end
```

<Option name="`media_library`">

Controls the visibility of the **"Attach from gallery"** option in the markdown editor.

##### Default value

`true`

#### Possible values

- `true`
- `false`

#### Code example

```ruby
field :body, as: :markdown, media_library: false
```
</Option>


<Option name="`file_uploads`">

Controls the visibility of the **"Upload files"** option in the markdown editor.

##### Default value

`true`

#### Possible values

- `true`
- `false`

#### Code example

```ruby
field :body, as: :markdown, file_uploads: false
```
</Option>

<Option name="`extra_preview_params`">

Sends additional parameters to the **preview renderer** of the markdown field.
Useful for injecting context-specific data during preview rendering.

##### Default value

`{}`

#### Possible values

- Any `Hash` of key-value pairs.

#### Code example

```ruby
field :body, as: :markdown, extra_preview_params: { foo: :bar }
```
</Option>



# Money

The `Money` field is used to display a monetary value.

```ruby
field :price, as: :money, currencies: %w[EUR USD RON PEN]
```
## Money Field Example

You can explore the implementation of the money field in [avodemo](https://main.avodemo.com/avo/resources/products/new) and it's corresponding code on GitHub [here](https://github.com/avo-hq/main.avodemo.com/blob/main/app/avo/resources/product.rb)

### Example on new

<Image src="/assets/img/money-field.png" width="1005" height="59" alt="" />

<Image src="/assets/img/money-field2.png" width="1005" height="123" alt="" />

### Example on show with currencies USD

<Image src="/assets/img/money-field-show.png" width="689" height="54" alt="" />

### Example on show with currencies RON

<Image src="/assets/img/money-field-show-lei.png" width="689" height="55" alt="" />

### Example on index

<Image src="/assets/img/money-field-index.png" width="208" height="299" alt="" />

## Installation

This field is a standalone gem.
You have to add it to your `Gemfile` alongside the `money-rails` gem.

:::info Add this field to the `Gemfile`
```ruby
# Gemfile

gem "avo-money_field"
gem "money-rails", "~> 1.12"
```
:::

:::warning Important: Monetization Requirement
In order to fully utilize the money field's features, you must monetize the associated attribute at the model level using the `monetize` method from the `money-rails` gem. ([Usage example](https://github.com/RubyMoney/money-rails?tab=readme-ov-file#usage-example))

For example:

```ruby
monetize :price_cents
```

Without this step, the money field may not behave as expected, and the field might not render.
:::

## Options

<Option name="`currencies`">

The `currencies` option controls which currencies will be visible on the dropdown.


```ruby
field :price, as: :money, currencies: %w[EUR USD RON PEN]
```

#### Default

By default it's going to be an empty array.

`[]`

#### Possible values

Add an array of currencies by the ISO code.

`%w[EUR USD RON PEN]`
</Option>



# Number

The `number` field renders a `input[type="number"]` element.

```ruby
field :age, as: :number
```

## Options

<Option name="`min`">

Set the `min` attribute.

#### Default

`nil`

#### Possible values

Any number.
</Option>

<Option name="`max`">

Set the `max` attribute.

#### Default

`nil`

#### Possible values

Any number.
</Option>

<Option name="`step`">

Set the `step` attribute.

#### Default

`nil`

#### Possible values

Any number.
</Option>

## Examples

```ruby
field :age, as: :number, min: 0, max: 120, step: 5
```



# Password

The `Password` field renders a `input[type="password"]` element for that field. By default, it's visible only on the `Edit` and `New` views.

```ruby
field :password, as: :password
```

#### Revealable

<VersionReq version="3.13.7" class="mt-2" />

You can set the `revealable` to true to show an "eye" icon that toggles the password between hidden or visible.

**Related:**
- [Devise password optional](#resources)




# Preview

The `Preview` field adds a tiny icon to each row on the <Index /> view that, when hovered, it will display a preview popup with more information regarding that record.

<Image src="/assets/img/fields/preview/preview.gif" width="1200" height="750" alt="" />

```ruby
field :preview, as: :preview
```

## Define the fields

The fields shown in the preview popup are configured similarly to how you [configure the visibility in the different views](#resources).

When you want to display a field in the preview popup simply call the `show_on :preview` option on the field.

```ruby
  field :name, as: :text, show_on :preview
```

## Authorization

Since version <Version version="3.18.0" /> the preview request authorization is controller with the [`preview?` policy method](#authorization).



# Progress bar

The `ProgressBar` field renders a `progress` element on `Index` and `Show` views and and a `input[type=range]` element on `Edit` and `New` views.

```ruby
field :progress, as: :progress_bar
```
<Image src="/assets/img/custom-fields/progress-index.jpg" width="764" height="212" alt="Progress bar custom field on index" />

## Options

<Option name="`max`">

Sets the maximum value of the progress bar.

#### Default

`100`

#### Possible values

Any number.
</Option>

<Option name="`step`">

Sets the step in which the user can move the slider on the `Edit` and `New` views.

#### Default

`1`

#### Possible values

Any number.
</Option>

<Option name="`display_value`">

Choose if the value is displayed on the `Edit` and `New` views above the slider.

#### Default

`true`

#### Possible values

`true`, `false`
</Option>

<Option name="`value_suffix`">

Set a string value to be displayed after the value above the progress bar.

#### Default

`nil`

#### Possible values

`%` or any other string.
</Option>

## Examples

```ruby
field :progress,
  as: :progress_bar,
  max: 150,
  step: 10,
  display_value: true,
  value_suffix: "%"
```

<Image src="/assets/img/custom-fields/progress-edit.jpg" width="1144" height="182" alt="Progress bar custom field edit" />



# Radio

<Image src="/assets/img/fields/radio.png" width="425" height="87" alt="Radio field" />

The `Radio` field is used to render radio buttons. It's useful when only one value can be selected in a given options group.

### Field declaration example
Below is an example of declaring a `radio` field for a role:

```ruby
field :role,
  as: :radio,
  name: "User role",
  options: {
    admin: "Administrator",
    manager: "Manager",
    writer: "Writer"
  }
```

<Option name="`options`">

The `options` attribute accepts either a `Hash` or a proc, allowing the incorporation of custom logic. Within this block, you gain access to all attributes of [`Avo::ExecutionContext`](#execution-context) along with the `record`, `resource`, `view` and `field`.

This attribute represents the options that should be displayed in the radio buttons.

#### Default value

Empty `Hash`.

```ruby
{}
```

#### Possible values

Any `Hash`. The keys represent the value that will be persisted and the values are the visible labels. Example:

```ruby
options: {
  admin: "Administrator",
  manager: "Manager",
  writer: "Writer"
}
```

Or a `Proc`:

```ruby
options: -> do
  record.roles.each_with_object({}) do |role, hash|
    hash[role.id] = role.name.humanize
  end
end
```

</Option>



# Record link

Sometimes you just need to link to a field. That's it!

This is what this field does. You give it a record and it will link to it.
That record can come off an association a method or any kind of property on the record instance.

:::info Add this field to the `Gemfile`
```ruby
# Gemfile
gem "avo-record_link_field"
```
:::

:::warning
That record you're pointing to should have [a resource configured](#resources).
:::

```ruby{14,19}
class Comment < ApplicationRecord
  # Your model must return an instance of a record
  has_one :post
  # or
  belongs_to :post
  # or
  def post
    # trivially find a post
    Post.find 42
  end
end

# Calling the method like so will give us an instance of a Post
Comment.first.post => #<post:0x00000001685bb558 ...>

class Avo::Resources::Comment < Avo::BaseResource
  def fields
    # This will run `record.post` and try to display whatever is returned.
    field :post, as: :record_link
  end
end
```

<Image src="/assets/img/fields/record_link/record-link.png" width="876" height="160" alt="Record link field" />

## Options

Besides some of the [default options](#field-options), there are a few custom ones.

<Option name="`target`">

In case you want to set the target to `_blank`.

#### Default value

`nil`

#### Possible values

`:self`, `:blank`

#### Example

```ruby
field :post, as: :record_link, target: :blank
```
</Option>

<Option name="`use_resource`">

Because you only give it an instance of a record, Avo will try to guess which resource it should use to display the title of the record and how to compute it's link.
With more advanced configurations (when you have [multiple resources for the same model](#resources)) that resource might not be the one that you wish for.

Using the `use_resource` configuration value you can tell Avo which resource it should use.

#### Default value

`nil`

#### Possible values

`big_post`, `AdminUser`, `Avo::Resources::TinyPhoto`

#### Example

```ruby
field :post, as: :record_link, use_resource: "big_post"

field :admin, as: :record_link, use_resource: "AdminUser"

field :thumbnail, as: :record_link, use_resource: "Avo::Resources::TinyPhoto"
```
</Option>

<Option name="`add_via_params`">

In other places where Avo generates a link to a record like in the [`belongs_to` field](#belongs_to), Avo adds `via` params to the URL so it knows how to generate the back button link.
That URL can also be passed on to other team mates and everyone can have the same navigation experience.

In the `record_link` field Avo adds these params automatically, but that might not be what you want. You can remove those `via` params by setting the `add_via_params` option to `false`.

#### Default value

`true`

#### Possible values

`true`, `false`

#### Example

```ruby
# This will generate a link similar to this
# https://example.com/avo/resources/projects/40?via_record_id=40&via_resource_class=Avo%3A%3AResources%3A%3AProject
field :post, as: :record_link, add_via_params: true

# This will generate a link similar to this
# https://example.com/avo/resources/projects/40
field :post, as: :record_link, add_via_params: false
```
</Option>

## Using computed values

Of course you can take full control of this field and use your computed values too.

In order to do that, open a block and run some ruby query to return an instance of a record.

#### Example

```ruby
field :post, as: :record_link do
  # This will generate a link similar to this
  # https://example.com/avo/resources/posts/42
  Post.find 42
end

# or

field :creator, as: :record_link, add_via_params: false do
  user_id = SomeService.new(comment: record).fetch_user_id # returns 31

  # This will generate a link similar to this
  # https://example.com/avo/resources/users/31
  User.find user_id
end

# or

field :creator, as: :record_link, use_resource: "AdminUser", add_via_params: false do
  user_id = SomeService.new(comment: record).fetch_user_id # returns 31

  # This will generate a link similar to this
  # https://example.com/avo/resources/admin_users/31
  User.find user_id
end
```
</post:0x00000001685bb558>



# Rhino

<Image src="/assets/img/fields/rhino/rhino-field.gif" alt="Rhino field" size="800x413" />

The wonderful [Rhino Editor](https://rhino-editor.vercel.app/) built by [Konnor Rogers](https://www.konnorrogers.com/) is available and fully integrated with Avo.

```ruby
field :body, as: :rhino
```

Rhino is based on [TipTap](https://tiptap.dev/) which is a powerful and flexible WYSIWYG editor.

It supports [ActiveStorage](https://guides.rubyonrails.org/active_storage_overview.html) file attachments, [ActionText](https://guides.rubyonrails.org/action_text_overview.html), and seamlessly integrates with the [Media Library](#media-library).

## Options

<Option name="`always_show`">

By default, the content of the field is not visible on the `Show` view; instead, it's hidden under a `Show Content` link that, when clicked, displays the content. You can set it to display the content by setting `always_show` to `true`.

#### Default

`false`

#### Possible values

`true`, `false`
</Option>




# Select

The `Select` field renders a `select` field.

```ruby
field :type, as: :select, options: { 'Large container': :large, 'Medium container': :medium, 'Tiny container': :tiny }, display_with_value: true, placeholder: 'Choose the type of the container.'
```

<Option name="`options`">

A `Hash` representing the options that should be displayed in the select. The keys represent the labels, and the values represent the value stored in the database.

The options get cast as `ActiveSupport::HashWithIndifferentAccess` objects if they are a `Hash`.

#### Default

`nil`

#### Possible values

- `{ 'Large container': :large, 'Medium container': :medium, 'Tiny container': :tiny }` or any other `Hash`.
- A lambda function that returns a `Hash` (computed options)

### Computed options

You may want to compute the values on the fly for your `Select` field. You can use a lambda for that where you have access to the `record`, `resource`, `view`, and `field` properties where you can pull data off.

```ruby{5-7}
# app/avo/resources/project.rb
class Avo::Resources::Project < Avo::BaseResource
  field :type,
    as: :select,
    options: -> do
      record.get_types_from_the_database.map { |type| [type.name, type.id] }
    end,
    placeholder: 'Choose the type of the container.'
end
```

The output value must be a supported [`options_for_select`](https://apidock.com/rails/ActionView/Helpers/FormOptionsHelper/options_for_select) value.
</Option>

<Option name="`enum`">

Set the select options as an Active Record [enum](https://edgeapi.rubyonrails.org/classes/ActiveRecord/Enum.html). You may use `options` or `enum`, not both.

```ruby{3,10}
# app/models/project.rb
class Project < ApplicationRecord
  enum type: { 'Large container': 'large', 'Medium container': 'medium', 'Tiny container': 'small' }
end

# app/avo/resources/project.rb
class Avo::Resources::Project < Avo::BaseResource
  field :type,
    as: :select,
    enum: ::Project.types,
    display_with_value: true,
    placeholder: 'Choose the type of the container.'
end
```

#### Default

`nil`

#### Possible values

`Post::statuses` or any other `enum` stored on a model.
</Option>

<Option name="`display_value`">

You may want to display the values from the database and not the labels of the options. You may configure this behaviour by setting `display_value` to `true`. Note that this setting has no effect if an array of options is provided.

```ruby{5}
# app/avo/resources/project.rb
class Avo::Resources::Project < Avo::BaseResource
  field :type,
    as: :select,
    display_value: true
end
```

#### Default

`false`

#### Possible values

`true`, `false`
</Option>

<Option name="`include_blank`">

The `Select` field also has the `include_blank` option. That can have three values.

If it's set to `false` (default), it will not show any blank option but only the options you configured.

If it's set to `true` and you have a `placeholder` value assigned, it will use that placeholder string as the first option.

If it's a string `include_blank: "No country"`, the `No country` string will appear as the first option in the `<select>` and will set the value empty or `nil` depending on your settings.

```ruby{5}
# app/avo/resources/project.rb
class Avo::Resources::Project < Avo::BaseResource
  field :type,
    as: :select,
    include_blank: 'No type'
end
```

#### Default

`nil`

#### Possible values

`nil`, `true`, `false`, or a string to be used as the first option.
</Option>

<Option name="`multiple`">

<VersionReq version="3.17.3" />

If it's set to `false` (default), it will only allow selecting a single option from the list.

If it's set to `true`, it will enable multiple selections, allowing users to choose more than one option at a time.

```ruby{5}
# app/avo/resources/project.rb
class Avo::Resources::Project < Avo::BaseResource
  field :categories,
    as: :select,
    multiple: true
end
```

#### Default

`false`

#### Possible values

`true` or `false`

</Option>



# Status

Displays the status of a record in three ways; `loading`, `failed`, `success`, or `neutral`.

You may select the `loading`, `failed`, and `success` state values, and everything else will fall back to `neutral`.

```ruby
field :progress,
  as: :status,
  failed_when: [:closed, :rejected, :failed],
  loading_when: [:loading, :running, :waiting, "in progress"],
  success_when: [:done],
```

<Image src="/assets/img/fields/status.png" width="276" height="452" alt="Status field" />

## Options

<Option name="`failed_when`">

Set the values for when the status is `failed`.

#### Default value

`[]`

#### Possible values

`[:closed, :rejected, :failed]` or an array with strings or symbols that indicate the `failed` state.
</Option>

<Option name="`loading_when`">

Set the values for when the status is `loading`.

#### Default value

`[]`

#### Possible values

`[:loading, :running, :waiting, "in progress"]` or an array with strings or symbols that indicate the `loading` state.
</Option>

<Option name="`success_when`">

Set the values for when the status is `success`.

#### Default value

`[]`

#### Possible values

`[:done, :success, :deployed, "ok"]` or an array with strings or symbols that indicate the `success` state.
</Option>

<Option name="`neutral_when`">

Set the values for when the status is `neutral`.

#### Default value

`[]`

#### Possible values

`[:holding, "waiting"]` or an array with strings or symbols that indicate a `neutral` state.
</Option>





# Tags field

Adding a list of things to a record is something we need to do pretty frequently; that's why having the `tags` field is helpful.

```ruby
field :skills, as: :tags
```

<Image src="/assets/img/fields/tags-field/basic.gif" width="786" height="436" alt="Avo tags field" />

## Options

<Option name="`suggestions`">

:::warning
**This warning no longer applies** <VersionReq version="3.11.8" />

If you're using this field as `filterable`, dynamic filters are not yet picking these suggestions.

Please use the custom dynamic filters [suggestions](#dynamic-filters) option to specify filter suggestions.
:::

You can give suggestions to your users to pick from which will be displayed to the user as a dropdown under the field.

```ruby{4,10-12}
# app/avo/resources/course.rb
class Avo::Resources::Course < Avo::BaseResource
  def fields
    field :skills, as: :tags, suggestions: -> { record.skill_suggestions }
  end
end

# app/models/course.rb
class Course < ApplicationRecord
  def skill_suggestions
    ['example suggestion', 'example tag', self.name]
  end
end
```

<Image src="/assets/img/fields/tags-field/suggestions.gif" width="786" height="436" alt="Avo tags field" />

#### Default

`[]`

#### Possible values

The `suggestions` option can be an array of strings, an object with the keys `value`, `label`, and (optionally) `avatar`, or a lambda that returns an array of that type of object.

The lambda is run inside a [`ExecutionContext`](#execution-context), so it has access to the `record`, `resource`, `request`, `params`, `view`, and `view_context` along with other things.

```ruby{5-21}
# app/models/post.rb
class Post < ApplicationRecord
  def self.tags_suggestions
    # Example of an array of more advanced objects
    [
      {
        value: 1,
        label: 'one',
        avatar: 'https://images.unsplash.com/photo-1560363199-a1264d4ea5fc?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&w=256&h=256&fit=crop',
      },
      {
        value: 2,
        label: 'two',
        avatar: 'https://images.unsplash.com/photo-1567254790685-6b6d6abe4689?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&w=256&h=256&fit=crop',
      },
      {
        value: 3,
        label: 'three',
        avatar: 'https://images.unsplash.com/photo-1560765447-da05a55e72f8?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&w=256&h=256&fit=crop',
      },
    ]
  end
end
```

</Option>

<Option name="`disallowed`">

The `disallowed` param works similarly to `suggestions`. Use it to prevent the user from adding specific values.

```ruby{3}
field :skills,
  as: :tags,
  disallowed: ["not", "that"]
```

<Image src="/assets/img/fields/tags-field/disallowed.gif" width="786" height="436" alt="Avo tags field" />

#### Default

`[]`

#### Possible values

An array of strings representing the value that can't be stored in the database.

</Option>

<Option name="`enforce_suggestions`">

Set whether the field should accept other values outside the suggested ones. If set to `true` the user won't be able to add anything else than what you posted in the `suggestions` option.

```ruby{4}
field :skills,
  as: :tags,
  suggestions: %w(one two three),
  enforce_suggestions: true
```

<Image src="/assets/img/fields/tags-field/enforce_suggestions.gif" width="786" height="436" alt="Avo tags field" />

#### Default

`false`

#### Possible values

`true`, `false`

</Option>

<Option name="`suggestions_max_items`">

Set of suggestions that can be displayed at once. The excessive items will be hidden and the user will have to narrow down the query to see them.

```ruby{4}
field :skills,
  as: :tags,
  suggestions: %w(one two three),
  suggestions_max_items: 2
```

<Image src="/assets/img/fields/tags-field/suggestions_max_items.gif" width="600" height="302" alt="Avo tags field - suggestions max items option" />

#### Default

`20`

#### Possible values

Integers
</Option>

<Option name="`close_on_select`">

Set whether the `suggestions` dropdown should close after the user makes a selection.

```ruby{4}
field :items,
  as: :tags,
  suggestions: -> { Post.tags_suggestions },
  close_on_select: true
```

<Image src="/assets/img/fields/tags-field/close_on_select.gif" width="786" height="436" alt="Avo tags field" />

#### Default

`false`

#### Possible values

`true`, `false`
</Option>

<Option name="`acts_as_taggable_on`">

Set the field the `acts_as_taggable_on` is set.

#### Default

`nil`

#### Possible values

Any string or symbol you have configured on your corresponding model.
</Option>

<Option name="`delimiters`">

Set the characters that will cut off the content into tags when the user inputs the tags.

```ruby{3}
field :skills,
  as: :tags,
  delimiters: [",", " "]
```

<Image src="/assets/img/fields/tags-field/delimiters.gif" width="786" height="436" alt="Avo tags field" />

#### Default

`[","]`

#### Possible values

`[",", " "]`

Valid values are comma `,` and space ` `.

</Option>


<Option name="`mode`">

By default, the tags field produces an array of items (ex: categories for posts), but in some scenarios you might want it to produce a single value (ex: dynamically search for users and select just one). Use `mode: :select` to make the field produce a single value as opposed to an array of values.

```ruby{3}
field :skills,
  as: :tags,
  mode: :select
```

#### Default

`nil`

#### Possible values

Valid values are `nil` for array values and `select` for a single value.

<Image src="/assets/img/fields/tags-field/mode-select.gif" width="800" height="666" alt="" />

</Option>

<Option name="`fetch_values_from`">

There might be cases where you want to dynamically fetch the values from an API. The `fetch_values_from` option enables you to pass a URL from where the field should suggest values.

This options works wonderful when used in [Actions](#actions-overview).

```ruby{3}
field :skills,
  as: :tags,
  fetch_values_from: "/avo/resources/skills/skills_for_user"
```

When the user searches for a record, the field will perform a request to the server to fetch the records that match that query.

<Image src="/assets/img/fields/tags-field/mode-select.gif" width="800" height="666" alt="" />

<br>

#### Default

`nil`

#### Possible values

Valid values are `nil`, a string, or a block that evaluates to a string. The string should resolve to an endpoint that returns an array of objects with the keys `value` and `label`.

The endpoint will receive the user input as `q` in the params. It is accessible by using `params["q"]`.
::: code-group

```ruby{2-10} [app/controllers/avo/skills_controller.rb]
class Avo::SkillsController < Avo::ResourcesController
  def skills_for_user
    # You can access the user input by using params["q"]
    skills = Skill.all.map do |skill|
      {
        value: skill.id,
        label: skill.name
      }
    end
    render json: skills
  end
end
```

```ruby{13} [config/routes.rb]
Rails.application.routes.draw do
  # your routes

  authenticate :user, ->(user) { user.is_admin? } do
    mount_avo
  end
end

if defined? ::Avo
  Avo::Engine.routes.draw do
    scope :resources do
      # Add route for the skills_for_user action
      get "skills/skills_for_user", to: "skills#skills_for_user"
    end
  end
end
```
:::

:::info
When using the `fetch_labels_from` pattern, on the <Show /> and <Index /> views you will see the `id` of those options instead of the label.
That is expected, because you are storing the `id`s in the database and the field can't know what labels those `id`s have.

To mitigate that use the `fetch_labels` option.
:::

</Option>

<Option name="`fetch_labels`">

:::warning
Deprecated since <Version version="3.10" /> in favor of [`format_using`](#tags)
:::

The `fetch_labels` option allows you to pass an array of custom strings to be displayed on the tags field. This option is useful when Avo is displaying a bunch of IDs and you want to show some custom label from that ID's record.

```ruby{4-6}
field :skills,
  as: :tags,
  fetch_values_from: "/avo/resources/skills/skills_for_user",
  fetch_labels: -> {
    Skill.where(id: record.skills).pluck(:name)
  }
```

In the above example, `fetch_labels` is a lambda that retrieves the names of the skills stored in the record's `skills` property.

When you use `fetch_labels`, Avo passes the current `resource` and `record` as arguments to the lambda function. This gives you access to the hydrated resource and the current record.

#### Default

Avo's default behavior on tags

#### Possible values

- Array of strings
</Option>

<Option name="`format_using`" since="3.10">

:::info
Since <Version version="3.10" />
:::

The `format_using` option allows you to pass an array of custom strings or hashes to be displayed on the tags field. This option is useful when Avo is displaying a bunch of IDs and you want to show some custom label from that ID's record.

```ruby{4-11}
field :skills,
  as: :tags,
  fetch_values_from: "/avo/resources/skills/skills_for_user",
  format_using: -> {
    Skill.find(value).map do |skill|
      {
        value: skill.id,
        label: skill.name
      }
    end
  }
```

In the above example, `format_using` is a lambda that retrieves the names and the ids of the skills stored in the record's `skills` property.

When you use `format_using`, Avo passes the `value`, current `resource` and `record` as arguments to the lambda function. This gives you access to the hydrated resource and the current record.

#### Default

Avo's default behavior on tags

#### Possible values

- Array of strings, notice that this will replace the DB values
- Array of hashes with `value` and `label` keys. WIll show the `label` and store the `value`
</Option>

## PostgreSQL array fields

You can use the tags field with the PostgreSQL array field.

```ruby{11}
# app/avo/resources/course.rb
class Avo::Resources::Course < Avo::BaseResource
  def fields
    field :skills, as: :tags
  end
end

# db/migrate/add_skills_to_courses.rb
class AddSkillsToCourses < ActiveRecord::Migration[6.0]
  def change
    add_column :courses, :skills, :text, array: true, default: []
  end
end
```

## Acts as taggable on

One popular gem used for tagging is [`acts-as-taggable-on`](https://github.com/mbleigh/acts-as-taggable-on). The tags field integrates very well with it.

You need to add `gem 'acts-as-taggable-on', '~> 9.0'` in your `Gemfile`, add it to your model `acts_as_taggable_on :tags`, and use `acts_as_taggable_on` on the field.

```ruby{6}
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  def fields
    field :tags,
      as: :tags,
      acts_as_taggable_on: :tags,
      close_on_select: false,
      placeholder: 'add some tags',
      suggestions: -> { Post.tags_suggestions },
      enforce_suggestions: true,
      help: 'The only allowed values here are `one`, `two`, and `three`'
  end
end

# app/models/post.rb
class Post < ApplicationRecord
  acts_as_taggable_on :tags
end
```

That will let Avo know which attribute should be used to fill with the user's tags.

:::info Related
You can set up the tags as a resource using [this guide](#act-as-taggable-on-integration).
:::

## Array fields

We haven't tested all the scenarios, but the tags field should play nicely with any array fields provided by Rails.

```ruby{10-12,14-16}
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  def fields
    field :items, as: :tags
  end
end

# app/models/post.rb
class Post < ApplicationRecord
  def items=(items)
    puts ["items->", items].inspect
  end

  def items
    %w(1 2 3 4)
  end
end
```



# Text

The `Text` field renders a regular `<input type="text" />` element.

```ruby
field :title, as: :text
```
## Options

<Option name="`as_html`">

Displays the value as HTML on the `Index` and `Show` views. Useful when you need to link to another record.

```ruby
field :title, as: :text, as_html: true do
  '<a href="https://avohq.io">Avo</a>'
end
```

#### Default

`false`

#### Possible values

`true`, `false`
</Option>


<Option name="`protocol`">

Render the value with a protocol prefix on the `Index` and `Show` views. So, for example, you can make a text field a `mailto` link very quickly.

```ruby{3}
field :email,
  as: :text,
  protocol: :mailto
```

<DemoVideo demo-video="https://www.youtube.com/watch?v=MfryUtcXqvU&t=662s" />

#### Default

`nil`

#### Possible values

`mailto`, `tel`, or any other string value you need to pass to it.
</Option>

<Option name="`link_to_record`">

Wraps the content into an anchor that links to the resource.
</Option>


## Customization

You may customize the `Text` field with as many options as you need.

```ruby
field :title, # The database field ID
  as: :text, # The field type
  name: 'Post title', # The label you want displayed
  required: true, # Display it as required
  readonly: true, # Display it disabled
  as_html: true # Should the output be parsed as html
  placeholder: 'My shiny new post', # Update the placeholder text
  format_using: -> { value.truncate 3 } # Format the output
```



# Textarea

The `textarea` field renders a `<textarea />` element.

```ruby
field :body, as: :textarea
```

## Options


<Option name="`rows`">

Set the number of rows visible in the `Edit` and `New` views.

```ruby
field :body, as: :textarea, rows: 5
```

#### Default

`5`

#### Possible values

Any integer.
</Option>



# Time

<!-- Replace this image with one of the Time field -->
<Image src="/assets/img/fields/time.png" width="1674" height="402" alt="" />

The `Time` field is similar to the [DateTime](#datetime) field and uses the time picker of flatpickr (without the calendar). You can use the `time_24hr` option for flatpickr to use the 24-hour format. Add the option `relative: false` if you want the time to stay absolute and not change based on the browser's timezone.

```ruby
field :starting_at,
  as: :time,
  picker_format: 'H:i',
  format: "HH:mm",
  relative: true,
  picker_options: {
    time_24hr: true
  }
```


<Option name="`format`">

Format the date shown to the user on the `Index` and `Show` views.

#### Default

`TT`

#### Possible values

Use [`luxon`](https://moment.github.io/luxon/#/formatting?id=table-of-tokens) formatting tokens.
</Option>

<Option name="`picker_format`">

Format the date shown to the user on the `Edit` and `New` views.

#### Default

`H:i:S`

#### Possible values

Use [`flatpickr`](https://flatpickr.js.org/formatting) formatting tokens.
</Option>

<Option name="`picker_options`;">

Passes the options here to [flatpickr](https://flatpickr.js.org/).

#### Default

`{}`

#### Possible values

Use [`flatpickr`](https://flatpickr.js.org/options) options.

:::warning
These options may override other options like `picker_options`.
:::

</Option>



# Tip Tap

The `TipTap` field is deprecated in favor of the [Rhino](#rhino) field.

The Rhino field is a fork of the TipTap editor with some additional features and improvements.

The Rhino field is fully integrated with Avo and provides a seamless experience for managing rich text content using the [ActiveStorage](https://guides.rubyonrails.org/active_storage_overview.html) integration and the [Media Library](#media-library).



# Trix

```ruby
field :body, as: :trix
```

The `Trix` field renders a [WYSIWYG Editor](https://trix-editor.org/) and can be associated with a `string` or `text` column in the database. The value stored in the database will be the editor's resulting `HTML` content.

It supports [ActiveStorage](https://guides.rubyonrails.org/active_storage_overview.html) file attachments, [ActionText](https://guides.rubyonrails.org/action_text_overview.html), and seamlessly integrates with the [Media Library](#media-library).

<Image src="/assets/img/fields/trix.jpg" width="877" height="193" alt="Trix field" />

Trix field is hidden from the `Index` view.

## Options

<Option name="`always_show`">

By default, the content of the field is not visible on the `Show` view; instead, it's hidden under a `Show Content` link that, when clicked, displays the content. You can set it to display the content by setting `always_show` to `true`.

#### Default

`false`

#### Possible values

`true`, `false`
</Option>


<Option name="`attachments_disabled`">

Hides the attachments button from the Trix toolbar.

#### Default

`false`

#### Possible values

`true`, `false`
</Option>

<Option name="`hide_attachment_filename`">

Hides the attachment's name from the upload output in the field value.

#### Default

`false`

#### Possible values

`true`, `false`
</Option>

<Option name="`hide_attachment_filesize`">

Hides the attachment size from the upload output in the field value.

#### Default

`false`

#### Possible values

`true`, `false`
</Option>

<Option name="`hide_attachment_url`">

Hides the attachment URL from the upload output in the field value.

#### Default

`false`

#### Possible values

`true`, `false`
</Option>

<Option name="`attachment_key`">

Enables file attachments.

#### Default

`nil`

#### Possible values

`nil`, or a symbol representing the `has_many_attachments` key on the model.
</Option>

## File attachments

:::warning
You must manually require `activestorage` and `image_processing` gems in your `Gemfile`.

```ruby
# Active Storage makes it simple to upload and reference files
gem "activestorage"

# High-level image processing wrapper for libvips and ImageMagick/GraphicsMagick
gem "image_processing"
```
:::


Trix supports drag-and-drop file attachments. To enable **Active Storage** integration, you must add the `attachment_key` option to your Trix field.

```ruby
field :body, as: :trix, attachment_key: :trix_attachments
```

That `attachment_key` has to have the same name as the model.

```ruby{2}
class Post < ApplicationRecord
  has_many_attached :trix_attachments
end
```

Now, when you upload a file in the Trix field, Avo will create an Active Record attachment.

## Disable attachments

You may want to use Trix only as a text editor and disable the attachments feature. Adding the `attachments_disabled` option will hide the attachments button (paperclip icon).

```ruby
field :body, as: :trix, attachments_disabled: true
```

## Remove attachment attributes

By default, Trix will add some meta-data in the editor (filename, filesize, and URL) when adding an attachment. You might not need those to be present in the document. You can hide them using `hide_attachment_filename`, `hide_attachment_filesize`, and `hide_attachment_url`.

## Active Storage

Trix integrates seamlessly with Active Storage. When you use it with a plain database column on a record table (not with Action Text) you have to set the `attachment_key` option (documented above).

## Action Text

Trix integrates seamlessly with Action Text. It will automatically work with Action Text as well and it won't require you to add an `attachment_key`.

## Demo app

We prepared a [demo](https://trix.avodemo.com/) to showcase Trix's abilities to work with Action Text and Active Storage.

## Javascript Alert Messages

<VersionReq version="3.13.8" />

You can customize the javascript alert messages for various actions in the Trix editor. Below are the default messages that can be translated or modified:

```yml
avo:
  this_field_has_attachments_disabled: This field has attachments disabled.
  you_cant_upload_new_resource: You can't upload files into the Trix editor until you save the resource.
  you_havent_set_attachment_key: You haven't set an `attachment_key` to this Trix field.
```

Refer to the [default](https://github.com/avo-hq/avo/blob/main/lib/generators/avo/templates/locales/avo.en.yml) for more details.


# Act as taggable on integration

A popular way to implement the tags pattern is to use the [`acts-as-taggable-on`](https://github.com/mbleigh/acts-as-taggable-on) gem.
Avo already supports it in the [`tags`](#tags-field) field, but you might also want to browse the tags as resources.

[This template](https://railsbytes.com/templates/VRZskb) will add the necessarry resource and controller files to your app.

Run `rails app:template LOCATION='https://railsbytes.com/script/VRZskb'`

If you're using the menu editor don't forget to add the resources to your menus.

```ruby
resource :taggings
resource :tags
```

<Image src="/assets/img/3_0/guides/act-as-taggable-on-integration/act-as-taggable-on-integration.gif" width="1200" height="750" alt="" />


# Acts As Tenant Integration

Recipe [contributed](https://github.com/avo-hq/docs.avohq.io/pull/218) by [SahSantoshh](https://github.com/sahsantoshh).

:::warning
The guide expressed here shows how you we can add subdomain-level multitenancy (sah.example.org, adrian.example.org, etc).

This makes for more than one URL per application which in turn requires a special license.
To get more information please [reach out](mailto:avo@avohq.io?subject=Multi-URL%20tenancy%20with%20Avo&body=Hi%2C%0D%0A%0D%0AI%20would%20like%20to%20develop%20a%20multi-URL%20application%20using%20Avo.%0D%0A%0D%0A...) to us.
:::

There are different ways to achieve multi-tenancy in an application.
We already have a doc which describes about [Multitenancy](#multitenancy) with Avo.
Here we will deep dive in integrating [Acts As Tenant](https://github.com/ErwinM/acts_as_tenant) which supports row-level multitenancy with Avo.
In this implementation we will be setting tenant to subdomain.

:::info
Check out the [acts_as_tenant](https://github.com/ErwinM/acts_as_tenant) documentation for reference.
:::

## Installation

To use it, add it to your Gemfile:

```ruby
gem 'acts_as_tenant'
```

## Tenant

Let's create model for tenant. We are using `Account` as our tenant.

**Account Migration and Model class**

:::code-group
```ruby [db/migrate/random_number_create_accounts.rb]{3}
# Migration
class CreateAccounts < ActiveRecord::Migration[7.1]
  def change
    create_table :accounts do |t|
      t.string :name
      t.string :subdomain

      t.timestamps
    end

    add_index :accounts, :subdomain, unique: true
    add_index :accounts, :created_at
  end
end
```
```ruby [app/models/account.rb]{3}
# Account model handles Tenant management
class Account < ApplicationRecord
  MAX_SUBDOMAIN_LENGTH = 20

  validates :name, :subdomain, presence: true
  validates_uniqueness_of :name, :subdomain, case_sensitive: false
  validates_length_of :subdomain, :name, maximum: MAX_SUBDOMAIN_LENGTH

end
```
:::

## Scope models
___

Now let's add users to `Account`. Here I am assuming to have an existing user model which is used for `Authentication`.
Similarly we can scope other models.

:::code-group
```ruby [db/migrate/random_number_add_account_to_users.rb]{3}
class AddAccountToUsers < ActiveRecord::Migration
  def up
    add_column :users, :account_id, :integer # if we have existing user set null to true then update the data using seed
    add_index  :users, :account_id
  end
end
```
```ruby [app/models/account.rb]{3}
# Authentication
class User < ActiveRecord::Base
  acts_as_tenant(:account)
end
```
:::

## Setting the current tenant

There are three ways to set the current tenant but we be using the subdomain to lookup the current tenant.
Since Avo has it's own `Application Controller` so there is no point in setting the tenant in Rails default `Application Controller` but we will set it there as well just to be safe site and also we might have some other pages other than Admin Dashboard supported by Avo.

:::code-group
```ruby [app/controllers/concerns/multitenancy.rb]{3}
# Multitenancy, to set the current account/tenant.
module Multitenancy
  extend ActiveSupport::Concern

  included do
    prepend_before_action :set_current_account
  end

  def set_current_account
    hosts = request.host.split('.')

    # just to make sure we are using subdomain path
    subdomain = (hosts[0] if hosts.length > 2)

    # We only allow users to login from their account specific subdomain not outside of it.
    sign_out(current_user) if subdomain.blank?

    current_account = Account.find_by(subdomain:)
    sign_out(current_user) if current_account.blank?

    # set tenant for Avo and ActAsTenant
    ActsAsTenant.current_tenant = current_account
    Avo::Current.tenant = current_account
    Avo::Current.tenant_id = current_account.id
  end
end
```

```ruby [config/initializers/avo.rb]{3}
Avo.configure do |config|
  # configuration values
end

Rails.configuration.to_prepare do
  Avo::ApplicationController.include Multitenancy
end
```
:::

Now, whenever we navigate to https://sahsantoshh.example.com/ the tenant & the tenant_id will be set to **sahsantoshh**.

## Move existing data to model

We might have to many users and other records which needs to be associated with `Account`.
For example, we will only move users record to the account

:::code-group
```ruby [db/seeds.rb]{3}
# Create default/first account where we want to associate exiting data
account = Account.find_or_create_by!(name: 'Nepal', subdomain: 'sahsantoshh')

User.unscoped.in_batches do |relation|
  relation.update_all(account_id: account.id)
  sleep(0.01) # throttle
end
```
:::

Now run the seed command to update existing records


# Add nested fields to CRUD forms

Please follow [this](#resource-tools) guide to learn how to implement nested fields on Avo forms.


# Use Avo in an `api_only` Rails app

**After Avo version 2.9 ðŸ‘‡**

The `api_mode` might not be supported. The reason for that is that Rails does not generate some paths for the [`resource` route helper](https://guides.rubyonrails.org/routing.html#resource-routing-the-rails-default). Most important being the `new` and `edit` paths. That's because APIs don't have the `new` path (they have the `create` path).

But you're probably safer using Rails with `api_only` disabled (`config.api_only = false`).

**Pre Avo version 2.9 ðŸ‘‡**

You might have an api-only Rails app where you'd like to use Avo. In my early explorations I found that it needs the `::ActionDispatch::Flash` middleware for it to properly work.

So, add it in your `application.rb` file.

```ruby{18}
require_relative "boot"

require "rails/all"

# Require the gems listed in Gemfile, including any gems
# you've limited to :test, :development, or :production.
Bundler.require(*Rails.groups)

module RailApi
  class Application < Rails::Application
    # Initialize configuration defaults for originally generated Rails version.
    config.load_defaults 7.0

    # Only loads a smaller set of middleware suitable for API only apps.
    # Middleware like session, flash, cookies can be added back manually.
    # Skip views, helpers and assets when generating a new resource.
    config.api_only = true
    config.middleware.use ::ActionDispatch::Flash
  end
end
```


# Attachment Policy Extension for Pundit

When using Pundit, it's common to define permissions for each attachment action (e.g., upload, delete, download) individually. This can lead to repetitive code like:

```ruby
def upload_logo?
  update?
end

def delete_logo?
  update?
end

def download_logo?
  update?
end
```

To streamline this process, you can extend your `ApplicationPolicy` with a helper method that dynamically handles attachment permissions.

## Step 1: Add the `method_missing` Helper to `ApplicationPolicy`

This method intercepts calls to undefined policy methods that follow a specific pattern and delegates them to a predefined permission mapping:

```ruby
def method_missing(method_name, *args)
  if method_name.to_s =~ /^(upload|delete|download)_(.+)\?$/
    action = Regexp.last_match(1).to_sym
    attachment = Regexp.last_match(2).to_sym

    return attachment_concerns[attachment][action] if attachment_concerns.key?(attachment) &&
                                                      attachment_concerns[attachment].key?(action)
  end

  super
end
```

## Step 2: Define `attachment_concerns` in Your Policy

In each model-specific policy, define the permitted actions for each attachment:

```ruby
def attachment_concerns
  {
    logo: {
      upload: update?,
      delete: update?,
      download: update?
    }
  }
end
```

With this setup, calls to `upload_logo?`, `delete_logo?`, or `download_logo?` will be automatically resolved based on the configuration in `attachment_concerns`, reducing boilerplate and improving maintainability.


# Add Avo behind Basic Authentication

Because in Rails we commonly do that using a static function on the controller we need to [safely extend the controller](https://avohq.io/blog/safely-extend-a-ruby-on-rails-controller) to contain that function.

<Image src="/assets/img/guides/basic-auth/basic-auth.gif" width="800" height="753" alt="Add Avo behind Basic Authentication" />

In actuality we will end up with something that behaves like this:

```ruby{2}
class Avo::ApplicationController < ::ActionController::Base
  http_basic_authenticate_with name: "adrian", password: "password"

  # More methods here
end
```

## Safely add it to Avo

We described the process in depth in [this article](https://avohq.io/blog/safely-extend-a-ruby-on-rails-controller) so let's get down to business.

1. Add the `BasicAuth` concern
1. The concern will prepend the basic auth method
1. `include` that concern to Avo's `ApplicationController`

:::warning
Ensure you restart the server after you extend the controller in this way.
:::

```ruby{8,20}
# app/controllers/concerns/basic_auth.rb
module BasicAuth
  extend ActiveSupport::Concern

  # Authentication strategy came from this article:
  # https://dev.to/kevinluo201/setup-a-basic-authentication-in-rails-with-http-authentication-388e
  included do
    http_basic_authenticate_with name: "adrian", password: "password"
  end
end

# config/initializers/avo.rb
Avo.configure do |config|
  # Avo configuration
end

# Add this to include it in Avo's ApplicationController
Rails.configuration.to_prepare do
  # Add basic authentication to Avo
  Avo::ApplicationController.include BasicAuth
end
```


# Conditionally render styled rows

<Image src="/assets/img/guides/conditionally-render-styled-rows/conditionally-render-styled-rows.png" width="2588" height="1068" alt="" />

We've had [a request](https://discord.com/channels/740892036978442260/1197693313520771113) come in from a customer to style their soft-deleted records differently than the regular ones.

Their first idea was to add a new option to Avo to enable that. They even tried to monkey-patch our code to achieve that.
It's a "fair" strategy; we're not judging.

Our impression was to add a new option, too, but in the end, we found a better solution. Something that doesn't involve monkey-patching or us adding new code to the framework.
New code that we should maintain in the future and bring on more and more requests.

## Solution

The solution came to me a little while after the request came over, and it's so simple!

**Use the `has` CSS selector.**

#### 1. Attach a CSS class to the `id` field of the records you want to mark

```ruby
def fields
  field :id, as: :id, html: -> {
    index do
      wrapper do
        classes do
          # We'll mark every record that has an even `id`
          if record.id % 2 == 0
            "soft-deleted"
          end
        end
      end
    end
  }
end
```

#### 2. Target the row that has that child element and style it as you need it

```css
tr[data-component-name="avo/index/table_row_component"]:has(.soft-deleted){
  background: #fef2f2;
}

/* you may even target a specific resource by it's name */
tr[data-component-name="avo/index/table_row_component"][data-resource-name="course_links"]:has(.soft-deleted){
  background: #fef2f2;
}
```

Of course, I chose a trivial rule like the records with an even `id` column, but you can tweak that rule as needed.

I think there's a lesson or two to be learned from this, which I wrote about in [this article](https://avohq.io/blog/state-the-problem-not-the-solution).


# How to Use Custom IDs with Avo
Avo seamlessly integrates custom IDs, including popular solutions like FriendlyID, prefixed IDs, or Hashids. Below, you'll find examples illustrating each approach for effortless customization within your application.

## Example with FriendlyID

FriendlyID is a gem that allows you to generate pretty URLs and unique IDs. To integrate FriendlyID with Avo, follow these steps:

**Install [friendly_id](https://github.com/norman/friendly_id) gem by adding this line to your application's Gemfile:**

```ruby
gem "friendly_id", "~> 5.5.0"
```

And then execute:

```bash
bundle install
```

**Generate and run the migration to add a slug column to your model:**

```bash
rails generate friendly_id
rails db:migrate
```

**Add `friendly_id` to your model:**

```ruby{3,6}
# app/models/post.rb
class Post < ApplicationRecord
  extend FriendlyId

  # This post model have a name column
  friendly_id :name, use: :finders
end

```

With this setup, you can use `Post.find("bar")` to find records by their custom IDs.

:::info
For a version of [friendly_id](https://github.com/norman/friendly_id) smaller then 5.0 you can use [custom query scopes](#customization)
:::
View [friendly_id](https://github.com/norman/friendly_id) setup in action: [View Demo](https://main.avodemo.com/avo/resources/users)

Check out the code: [Code on GitHub](https://github.com/avo-hq/main.avodemo.com/blob/main/app/models/user.rb)

## Example with Prefixed IDs

Prefixed IDs involve adding a custom prefix to your IDs.

**Install [prefixed_ids](https://github.com/excid3/prefixed_ids) gem by adding this line to your application's Gemfile:**

```ruby
gem "prefixed_ids"
```

And then execute:

```bash
bundle install
```

**Basic Usage**

Add `has_prefix_id :my_prefix` to your models to autogenerate prefixed IDs:
```ruby{3}
# app/models/post.rb
class Post < ApplicationRecord
  has_prefix_id :post
end
```

View [prefixed_ids](https://github.com/excid3/prefixed_ids) setup in action: [View Demo](https://main.avodemo.com/avo/resources/teams)

Check out the code: [Code on GitHub](https://github.com/avo-hq/main.avodemo.com/blob/main/app/models/team.rb)

## Example with Hashids

Hashid Rials is a gem that generates short, unique, and cryptographically secure IDs.

**Install [hashid-rails](https://github.com/jcypret/hashid-rails) gem by adding this line to your application's Gemfile:**

```ruby
gem "hashid-rails", "~> 1.0"
```

And then execute:

```bash
bundle install
```

**Include Hashid Rails in the ActiveRecord model you'd like to enable hashids:**

```ruby{3}
# app/models/post.rb
class Post < ApplicationRecord
  include Hashid::Rails
end
```

View [hashid-rails](https://github.com/jcypret/hashid-rails) setup in action: [View Demo](https://main.avodemo.com/avo/resources/spouses)

Check out the code: [Code on GitHub](https://github.com/avo-hq/main.avodemo.com/blob/main/app/models/spouse.rb)


# Custom link field

When you want to add a custom link as a field on your resource that points to a related resource (and you don't want to use one of the available [association fields](#getting-started)) you can use the [`Text`](#text) field like so.

```ruby
# with the format_using option
field :partner_home, as: :text, format_using: -> { link_to(value, value, target: "_blank") } do
  avo.resources_partner_url record.partner.id
end

# with the as_html option
field :partner_home, as: :text, as_html: true do
  if record.partner.present?
    link_to record.partner.first_name, avo.resources_partner_url(record.partner.id)
  end
end
```


# Display and Edit Join Table Fields in `has_many :through` Associations

A common scenario in Rails is using a [`has_many :through`](#has_many) association to connect two models via a join model that contains extra fields. In Avo, you might want to display and edit attributes from the join table directly in your resource views (index, show, edit). This guide demonstrates how to achieve that.

## Example Models

```ruby
class Store < ApplicationRecord
  has_one :location

  has_many :patronships, class_name: :StorePatron
  has_many :patrons, through: :patronships, class_name: :User, source: :user
end

class User < ApplicationRecord
  has_many :patronships, class_name: :StorePatron
  has_many :stores, through: :patronships

  # Needed to make the field editable in Avo
  attr_accessor :review
end

# Join Table
class StorePatron < ApplicationRecord
  belongs_to :store
  belongs_to :user

  validates :review, presence: true
end
```

## Displaying Join Table Fields

You can display a join table attribute (like `review`) on the index or show view of the related resource by adding the field in your resource file and using `format_using` to fetch the correct value from the join table.

```ruby
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  def fields
    field :review,
      format_using: -> {
        # Fetch the review from the StorePatron join table
        record.patronships.find_by(store_id: params[:via_record_id])&.review
      }
  end
end
```

This will show the `review` field from the join table when viewing users from the context of a store.

## Editing Join Table Fields

To allow editing, you need to:

1. Add a writer for the field to the model (e.g., `attr_accessor :review` or a custom setter).
2. Use the `update_using` option to update the join record.

```ruby
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  def fields
    if params[:resource_name] == 'stores' || params[:via_resource_class] == 'Avo::Resources::Store'
      field :review,
        update_using: -> {
          # Update the review in the StorePatron join table
          patronship = record.patronships.find_by(user_id: record.id.to_i)
          patronship.update(review: value)
        },
        format_using: -> {
          record.patronships.find_by(user_id: record.id.to_i)&.review
        }
    end
  end
end
```

**Note:**
- The field will only render on the form if the model has a writer for it.
- You may need to adjust the logic for finding the join record depending on your association direction.

## Conditional Display Based on Parent Resource

You can use the `params` to control when the field is shown or editable. For example:

```ruby
# We use different params to detect the navigation context:
# - `resource_name` identifies when users access through the index table
# - `via_resource_class` identifies when users click to view or edit the resource
if params[:resource_name] == 'stores' || params[:via_resource_class] == 'Avo::Resources::Store'
  # field
end
```

In this example, the `review` field is only visible/editable on User when the resource is accessed from the `Store` resource.

```ruby
# app/avo/resources/store.rb
class Avo::Resources::Store < Avo::BaseResource
  def fields
    field :patrons,
      as: :has_many,
      through: :patronships,
      translation_key: "patrons",
      attach_fields: -> {
        # Add the review field to the attach form
        field :review, as: :text
      }
  end
end


# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  def fields
    # Only show when accessed from the Store resource
    if params[:resource_name] == 'stores' || params[:via_resource_class] == 'Avo::Resources::Store'
      field :review,
        format_using: -> {
          # Fetch the review from the StorePatron join table
          record.patronships.find_by(user_id: record.id.to_i)&.review
        }
    end
  end
end
```

## Gotchas & Tips

- Computed fields (using a block) do not render on forms. Use `format_using` and provide a writer on the model.
- Avo checks for a writer method to decide if a field is editable.
- If the form fails to save, your join field may revert to its original value â€” consider validations and persistence carefully.


# Display scope record count

The `name` and `description` scope options can be callable values and receive the `resource`, `scope` and `query` objects.

The `query` object is the actual Active Record query (unscoped) that is made to fetch the records.

There is also possible to access the `scoped_query` method that will return the `query` after applying the `scope`.
You may use that to display a counter of how many records are there in that scope. Notice that it can impact page loading time when applying on large data tables.

### Example

<Image src="/assets/img/3_0/guides/display-scope-record-count/scopes.png" width="421" height="83" alt="" />

```ruby{2-9}
class Avo::Scopes::Scheduled < Avo::Advanced::Scopes::BaseScope
  self.name = -> {
    sanitize(
      "Scheduled " \
      "<span class='bg-gray-500 px-1 text-white text-xs rounded font-semibold'>" \
        "#{scoped_query.count}" \
      "</span>"
    )
  }
  self.description = -> { "All the scheduled jobs." }
  self.scope = -> { query.finished.invert_where }
  self.visible = -> { true }
end
```

In this example we made the `name` option a callable block and are returning the name of the scope and a `span` with the count of the records.

We are also using the `sanitize` method to return it as HTML.

In order to make the counter stand out, we're using some Tailwind CSS classes that we have available in Avo. If you're trying different classes and they are not applying, you should consider adding the [Tailwind CSS integration](#tailwindcss-integration).

:::warning
This approach will have some performance implications as it will run the `count` query on every page load.
:::


# Export to CSV action

Even if we don't have a dedicated export to CSV feature, you may create an action that will take all the selected records and export a CSV file for you.

Below you have an example which you can take and customize to your liking. It even give you the ability to use custom user-selected attributes.

```ruby
# app/avo/actions/export_csv.rb
class Avo::Actions::ExportCsv < Avo::BaseAction
  self.name = "Export CSV"
  self.no_confirmation = false
  self.standalone = true

  def fields
    # Add more fields here for custom user-selected columns
    field :id, as: :boolean
    field :created_at, as: :boolean
  end

  def handle(records:, fields:, resource:, **args)
    # uncomment if you want to download all the records if none was selected
    # records = resource.model_class.all if records.blank?

    return error "No record selected" if records.blank?

    # uncomment to get all the models' attributes.
    # attributes = get_attributes_from_record records.first

    # uncomment to get some attributes
    # attributes = get_some_attributes

    attributes = get_attributes_from_fields fields

    # uncomment to get all the models' attributes if none were selected
    # attributes = get_attributes_from_record records.first if attributes.blank?

    file = CSV.generate(headers: true) do |csv|
      csv << attributes

      records.each do |record|
        csv << attributes.map do |attr|
          record.send(attr)
        end
      end
    end

    download file, "#{resource.plural_name}.csv"
  end

  def get_attributes_from_record(record)
    record.class.columns_hash.keys
  end

  def get_attributes_from_fields(fields)
    fields.select { |key, value| value }.keys
  end

  def get_some_attributes
    ["id", "created_at"]
  end
end
```

<Image src="/assets/img/3_0/guides/export-to-csv/export-to-csv.gif" width="1024" height="640" alt="" />



# Pretty JSON objects to the code field

It's common to have JSON objects stored in your database. So you might want to display them nicely on your resource page.

```ruby
field :meta, as: :code, language: 'javascript'
```

<Image src="/assets/img/3_0/guides/format-ruby-object-to-json/before.png" width="806" height="584" alt="Avo Admin for Rails" />

But that will be hard to read on one line like that. So we need to format it.

Luckily we can use `JSON.pretty_generate` for that and a computed field.

```ruby{3}
field :meta, as: :code, language: 'javascript' do
  if record.meta.present?
    JSON.pretty_generate(record.meta.as_json)
  end
end
```

<Image src="/assets/img/3_0/guides/format-ruby-object-to-json/after.png" width="806" height="616" alt="Avo Admin for Rails" />

That's better! You'll notice that the field is missing on the `Edit` view. That's normal for a computed field to be hidden on `Edit`.
To fix that, we should add another one just for editing.

```ruby{1}
field :meta, as: :code, language: 'javascript', only_on: :edit
field :meta, as: :code, language: 'javascript' do
  if record.meta.present?
    JSON.pretty_generate(record.meta.as_json)
  end
end
```

Now you have a beautifully formatted JSON object in a code editor.

## When you have more JSON fields

We can use a DRY solution that will help us to make our code cleaner and readable.

### 1. Concern

We will create a new concern in `app/models/concerns/avo_json_fields.rb` to be used in our models.

```ruby
module AvoJsonFields
  extend ActiveSupport::Concern

  class_methods do
    def avo_json_fields(*fields)
      fields.each do |field|
        define_method "#{field}_json" do
          JSON.pretty_generate(send(field).as_json)
        end

        define_method "#{field}_json=" do |value|
          begin
            send("#{field}=", JSON.parse(value))
          rescue JSON::ParserError => e
            # handle or ignore it
          end
        end
      end
    end
  end
end
```

The `AvoJsonFields` prepares two methods for each field we provide. The first is for displaying, and the second is for storing the JSON object.

We can use it only on the models we need or include it in the `ApplicationRecord` for all.

```ruby{4}
class ApplicationRecord < ActiveRecord::Base
  primary_abstract_class

  include AvoJsonFields
end
```

### 2. Usage in models

When we have the concern in place, we can use it. For the example above, it could look like this:

```ruby{2}
class Page < ApplicationRecord
  avo_json_fields :meta
end
```

That will create two methods for the `meta` field: `meta_json` and `meta_json=(value)`.

### 3. Usage in Avo resources

Now, we can use the `meta_json` field in our Avo resources. With the `name` option, we set the original name back.

```ruby
field :meta_json, as: :code, name: :meta, only_on: %i[show new edit], language: "javascript"
```


# Hide field labels

One common use case for the [`file`](#file), [`files`](#files), and [`external_image`](#external-image) fields is to display the logo for a record. You might want to do that but in a more "un-fieldy" way, so it doesn't look like a field with a label on top.

You can hide that label using CSS in your [custom asset pipeline](#custom-asset-pipeline), or in a [`_footer` partial](#eject-views).

Avo is littered with great `data` selectors so you can pick and choose any element you'd like. If it doesn't have it, we'll add it.

Here's an example on how to remove the label on an `external_image` field for the `Team` resource (try it [here](https://main.avodemo.com/avo/resources/teams/4)).

```css
[data-resource-name="TeamResource"] [data-field-type="external_image"][data-field-id="logo"] [data-slot="label"]{
  display: none;
}
```


# Manage information-heavy resources

This has been sent in by our friends at [Wyndy.com](https://wyndy.com). I'm just going to paste David's message because it says it all.

David ðŸ‘‡

Hey y'all - we've got a very information heavy app where there are pretty distinct differences between the data we display on index, show, & form views as well as how it's ordered.

We created a concern for our resources to make organizing this a bit easier, would love y'all's thoughts/feedback as to whether this could be a valuable feature! Example gist: [https://gist.github.com/davidlormor/d1d7e32a3568f6a9b3540669e7f601dc](https://gist.github.com/davidlormor/d1d7e32a3568f6a9b3540669e7f601dc)

We went with a concern because I ran into inheritance issues trying to create a `BaseResource` class (issues with Avo's `model_class` expectations) and monkey-patching `Avo::BaseResource` seemed to cause issues with Rails' autoloading/zeitwork?

```ruby
class ExampleResource < Avo::BaseResource
  include ResourceExtensions

  field :id, as: :id
  field :name, as: :text

  index do
    field :some_field, as: :text
    field :some_index_field, as: :text, sortable: true
  end

  show do
    field :some_show_field, as: :markdown
    field :some_field, as: :text
  end

  create do
    field :some_create_field, as: :number
  end

  edit do
    field :some_create_field, as: :number, readonly: true
    field :some_field
    field :some_editable_field, as: :text
  end
end
```

```ruby
require "active_support/concern"

module ResourceExtensions
  extend ActiveSupport::Concern

  class_methods do
    def index(&block)
      with_options only_on: :index, &block
    end

    def show(&block)
      with_options only_on: :show, &block
    end

    def create(&block)
      with_options only_on: :new, &block
    end

    def edit(&block)
      with_options only_on: :edit, &block
    end
  end
end
```



# Multi-language URLs

Implementing multi-language URLs is a common use-case. Using a route scope block in Avo allows you to seamlessly adapt your application to support multiple languages, enhancing the user experience. This recipe will guide you through the steps to configure a locale scope, ensuring your application dynamically sets and respects the user's preferred language. Let's dive in!

## 1. Mount Avo within a `:locale` scope

Using a locale scope is an effective way to set the locale for your users.

```ruby{3-5}
# config/routes.rb
Rails.application.routes.draw do
  scope ":locale" do
    mount_avo
  end
end
```

## 2. Apply the `locale` Scope

To properly handle localization within Avo, you'll need to ensure the `locale` parameter is respected throughout the request which we'll do by overriding the `set_avo_locale` method in your `Avo::ApplicationController` as follows:

:::info
If you don't have the `app/controllers/avo/application_controller.rb` file present in your app, you can eject it using this command:

```bash
rails generate avo:eject --controller application_controller
```
:::


```ruby{4-6}
# app/controllers/avo/application_controller.rb
module Avo
  class ApplicationController < BaseApplicationController
    def set_avo_locale(&action)
      I18n.with_locale(params[:locale], &action)
    end
  end
end
```

This implementation uses `I18n.with_locale` to set the desired locale for the duration of the request, ensuring consistent localization behavior across Avo's interface and that it won't impact the other non-Avo parts of your app.



# Multilingual content

This is not an official feature yet, but until we add it with all the bells and whistles, you can use this guide to monkey-patch it into your app.

We pushed some code to take in the `set_locale` param and set the `I18n.locale` and `I18n.default_locale` so all subsequent requests will use that locale. **That will change the locale for your whole app. Even to the front office**.

If you don't want to change the locale for the whole app, you can use `force_locale`, which will change the locale for that request only. It will also append `force_locale` to all your links going forward.

```ruby
def set_default_locale
  I18n.locale = params[:set_locale] || I18n.default_locale

  I18n.default_locale = I18n.locale
end

# Temporary set the locale
def set_force_locale
  if params[:force_locale].present?
    initial_locale = I18n.locale.to_s.dup
    I18n.locale = params[:force_locale]
    yield
    I18n.locale = initial_locale
  else
    yield
  end
end
```

## Install the mobility gem

Follow the install instructions [here](https://github.com/shioyama/mobility#installation). A brief introduction below (but follow their guide for best results)

 - add the gem to your `Gemfile` `gem 'mobility', '~> 1.2.5'`
 - `bundle install`
 - install mobility `rails generate mobility:install`
 - update the backend (like in the guide) `backend :key_value, type: :string`
 - add mobility to your model `extend Mobility`
 - add translatable field `translates :name`
 - ðŸ™Œ that's it. The content should be translatable now.

## Add the language switcher

**Before v 2.3.0**

First, you need to eject the `_profile_dropdown` partial using this command `bin/rails generate avo:eject :profile_dropdown`. In that partial, add the languages you need to support like so:

```erb
<!-- Before -->
<% destroy_user_session_path = "destroy_#{Avo.configuration.current_user_resource_name}_session_path".to_sym %>

<div <% if main_app.respond_to?(destroy_user_session_path) %> data-controller="toggle-panel" <% end %>>
  <a href="javascript:void(0);" class="flex items-center cursor-pointer font-semibold text-gray-700" data-action="click->toggle-panel#togglePanel">
    <% if _current_user.respond_to?(:avatar) &&  _current_user.avatar.present? %>
      <%= image_tag _current_user.avatar, class: "h-12 rounded-full border-4 border-white mr-1" %>
    <% end %>
    <% if _current_user.respond_to?(:name) && _current_user.name.present? %>
      <%= _current_user.name %>
    <% elsif _current_user.respond_to?(:email) && _current_user.email.present? %>
      <%= _current_user.email %>
    <% else %>
      Avo user
    <% end %>
    <% if main_app.respond_to?(destroy_user_session_path) %>
      <%= svg 'chevron-down', class: "ml-1 h-4" %>
    <% end %>
  </a>

  <% if main_app.respond_to?(destroy_user_session_path) %>
    <div class="hidden absolute inset-auto right-0 mr-6 mt-0 py-4 bg-white rounded-xl min-w-[200px] shadow-context" data-toggle-panel-target="panel">
      <%= button_to t('avo.sign_out'), main_app.send(:destroy_user_session_path), method: :delete, form: { "data-turbo" => "false" }, class: "appearance-none bg-white text-left cursor-pointer text-green-600 font-semibold hover:text-white hover:bg-green-500 block px-4 py-1 w-full" %>
    </div>
  <% end %>
</div>
```

```erb
<!-- After -->
<% destroy_user_session_path = "destroy_#{Avo.configuration.current_user_resource_name}_session_path".to_sym %>

<div <% if main_app.respond_to?(destroy_user_session_path) %> data-controller="toggle-panel" <% end %>>
  <a href="javascript:void(0);" class="flex items-center cursor-pointer font-semibold text-gray-700" data-action="click->toggle-panel#togglePanel">
    <% if _current_user.respond_to?(:avatar) &&  _current_user.avatar.present? %>
      <%= image_tag _current_user.avatar, class: "h-12 rounded-full border-4 border-white mr-1" %>
    <% end %>
    <% if _current_user.respond_to?(:name) && _current_user.name.present? %>
      <%= _current_user.name %>
    <% elsif _current_user.respond_to?(:email) && _current_user.email.present? %>
      <%= _current_user.email %>
    <% else %>
      Avo user
    <% end %>
    <% if main_app.respond_to?(destroy_user_session_path) %>
      <%= svg 'chevron-down', class: "ml-1 h-4" %>
    <% end %>
  </a>

  <% if main_app.respond_to?(destroy_user_session_path) %>
    <div class="hidden absolute inset-auto right-0 mr-6 mt-0 py-4 bg-white rounded-xl min-w-[200px] shadow-context" data-toggle-panel-target="panel">
      <!-- Add this ðŸ‘‡ -->
      <% classes = "appearance-none bg-white text-left cursor-pointer text-green-600 font-semibold hover:text-white hover:bg-green-500 block px-4 py-1 w-full" %>

      <% if I18n.locale == :en %>
        <%= link_to "Switch to Portuguese", { set_locale: 'pt-BR' }, class: classes %>
      <% else %>
        <%= link_to "Switch to English", { set_locale: 'en' }, class: classes %>
      <% end %>
      <!-- Add this ðŸ‘† -->

      <%= button_to t('avo.sign_out'), main_app.send(:destroy_user_session_path), method: :delete, form: { "data-turbo" => "false" }, class: classes %>
    </div>
  <% end %>
</div>
```

Feel free to customize the dropdown as much as you need it to and add as many locales as you need.

**After v2.3.0**

Use the `profile_menu` to add the language-switching links.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.profile_menu = -> {
    link "Switch to Portuguese", path: "?set_locale=pt-BR"
    link "Switch to English", path: "?set_locale=en"
  }
end
```

**After v2.10**

The `set_locale` param will change the locale for the entire website (for you and your customers). If you need to change it just for the current visit, use `force_locale`. That will switch the locale for that request only, not for your customers. It will also add the `force_locale` param to each link as we advance, making it easy to update all your multilingual content.

**After v2.11**

A change was pushed to consider the `locale` from the initializer. That will change the locale for Avo requests.

```ruby{2}
Avo.configure do |config|
  config.locale = :en # default is nil
end
```

## Workflow

You will now be able to edit the attributes you marked as translatable (eg: `name`) in the locale you are in (default is `en`). Next, you can go to the navbar on the top and switch to a new locale. The switch will then allow you to edit the record in that locale and so on.

## Support

This is the first iteration of multilingual content. It's obvious that this could be done in a better way, and we'll add that better way in the future, but until then, you can use this method to edit your multilingual content.

Thanks!


# Use route-level multitenancy

:::tip
We published a new [multitenancy guide](#multitenancy).
:::

Multitenancy is not a far-fetched concept, and you might need it when you reach a certain level with your app. Avo is ready to handle that.

This guide will show you **one way** of achieving that, but if can be changed if you have different needs.

## Prepare the Current model

We will use Rails' [`Current`](https://api.rubyonrails.org/classes/ActiveSupport/CurrentAttributes.html) model to hold the account.

```ruby{3}
# app/models/current.rb
class Current < ActiveSupport::CurrentAttributes
  attribute :account
end
```

## Add middleware to catch the account param

We're trying to fetch the account number from the `params` and see if we have an account with that ID in this middleware. If so, store it in the `Current.account` model, where we can use it throughout the app.

```ruby{18,21,23,25}
## Multitenant Account Middleware
#
# Included in the Rails engine if enabled.
#
# Used for setting the Account by the first ID in the URL like Basecamp 3.
# This means we don't have to include the Account ID in every URL helper.
# From JumpstartRails AccountMiddleware

class AccountMiddleware
  def initialize(app)
    @app = app
  end

  # http://example.com/12345/projects
  def call(env)
    request = ActionDispatch::Request.new env
    # Fetch the account id from the path
    _, account_id, request_path = request.path.split("/", 3)

    # Check if the id is a number
    if /\d+/.match?(account_id)
      # See if that account is present in the database.
      if (account = Account.find_by(id: account_id))
        # If the account is present, set the Current.account to that
        Current.account = account
      else
        # If not, redirect to the root path
        return [302, {"Location" => "/"}, []]
      end

      request.script_name = "/#{account_id}"
      request.path_info = "/#{request_path}"
    end

    @app.call(request.env)
  end
end
```

## Update the custom tools routes

By default, when generating [custom tools](#custom-tools), we're adding them to the parent app's routes. Because we're declaring them there, the link helpers don't hold the account id in the params.

```ruby{2-4}
Rails.application.routes.draw do
  scope :avo do
    get "custom_page", to: "avo/tools#custom_page"
  end

  devise_for :users

  # Your routes

  authenticate :user, -> user { user.admin? } do
    mount_avo
  end
end
```

To fix that, we need to move them as if they were added to Avo's routes.

```ruby{13-18}
# config/routes.rb
Rails.application.routes.draw do
  devise_for :users

  # Your routes

  authenticate :user, -> user { user.admin? } do
    mount_avo
  end
end

# Move Avo custom tools routes to Avo engine
if defined? ::Avo
  Avo::Engine.routes.draw do
    # make sure you don't add the `avo/` prefix to the controller below
    get 'custom_page', to: "tools#custom_page"
  end
end
```

```ruby
# app/controllers/avo/tools_controller.rb
class Avo::ToolsController < Avo::ApplicationController
  def custom_page
    @page_title = "Your custom page"

    add_breadcrumb "Your custom page"
  end
end
```

## Retrieve and use the account

Throughout your app you can use `Current.account` or if you add it to Avo's [`context`](#customization) object and use it from there.

```ruby{8}
# config/initializers/avo.rb
Avo.configure do |config|
  config.set_context do
    {
      foo: 'bar',
      user: current_user,
      params: request.params,
      account: Current.account
    }
  end
end
```

Check out [this PR](https://github.com/avo-hq/avodemo/pull/4) for how to update an app to support multitenancy.



# Nested records when creating

<Image src="/assets/img/3_0/guides/nested-records-when-creating/nested-records-demo.gif" width="1024" height="640" alt="" />

A lot of you asked for the ability to create nested `has_many` records on the <New /> view. Although it's fairly "easy" to implement using `accepts_nested_attributes_for` for simple cases, it's a different story to extract it, make it available, and cover most edge cases for everyone.
That's why Avo and no other similar gems dont't offer this feature as a first-party feature.
But, that doesn't mean that it's impossible to implement it yourself. It's actually similar to how you'd implement it for your own app.

We prepared this scenario where a `Fish` model `has_many` `Review`s. I know, it's not the `Slider` `has_many` `Item`s example, but you'll get the point.

## Full set of changes

The full code is available in Avo's [dummy app](https://github.com/avo-hq/avo/tree/main/spec/dummy) and the changes in [this PR](https://github.com/avo-hq/avo/pull/1472).

## Guide to add it to your app

You can add this functionality using these steps.

### 1. Add `accepts_nested_attributes_for` on your parent model

```ruby{4}
class Fish < ApplicationRecord
  has_many :reviews, as: :reviewable

  accepts_nested_attributes_for :reviews
end
```

:::warning
Ensure you have the `has_many` association on the parent model.
:::

### 2. Add a JS helper package that dynamically adds more review forms

`yarn add stimulus-rails-nested-form`

In your JS file register the controller.

```js{3,6}
// Probably app/javascript/avo.custom.js
import { Application } from '@hotwired/stimulus'
import NestedForm from 'stimulus-rails-nested-form'

const application = Application.start()
application.register('nested-form', NestedForm)
```

:::info
Use [this guide](#custom-asset-pipeline) to add custom JavaScript to your Avo app.
:::

### 3. Generate a new resource tool

`bin/rails generate avo:resource_tool nested_fish_reviews`

This will generate two files. The `NestedFishReviews` ruby file you'll register on the `Avo::Resources::Fish` file and we'll edit the template to contain our fields.

### 4. Register the tool on the resource

We'll display it only on the <New /> view.

```ruby{7}
class Avo::Resources::Fish < Avo::BaseResource
  # other fields actions, filters and more

  def fields
    field :reviews, as: :has_many

    tool Avo::ResourceTools::NestedFishReviews, only_on: :new
  end
end
```

### 5. Create a partial for one new review

This partial will have the fields for one new review which we'll add more on the page.

```erb
<!-- app/views/avo/partials/_fish_review.html.erb -->
<%= render Avo::PanelComponent.new do |c| %>
  <% c.with_body do %>
    <div class="nested-form-wrapper divide-y" data-new-record="<%= f.object.new_record? %>">
      <%= avo_edit_field :body, as: :trix, form: f, help: "What should the review say", required: true %>
      <%= avo_edit_field :user, as: :belongs_to, form: f, help: "Who created the review", required: true %>
    </div>
  <% end %>
<% end %>
```

### 6. Update the resource tool partial

It's time to put it all together. In the resource tool partial we're wrapping the whole thing with the `nested-form` controller div, creating a new `form` helper to reference the nested fields with `form.fields_for` and wrapping the "new" template so we can use replicate it using the `nested-form` package.
In the footer we'll also add the button that will add new reviews on the page.

```erb
<!-- app/views/avo/resource_tools/_nested_fish_reviews.html.erb -->
<div class="flex flex-col">
  <%= content_tag :div,data: { controller: 'nested-form', nested_form_wrapper_selector_value: '.nested-form-wrapper' } do %>
    <%= render Avo::PanelComponent.new(name: "Reviews", description: "Create some reviews for this fish") do |c| %>
      <% c.with_bare_content do %>
        <% if form.present? %>
          <template data-nested-form-target="template">
            <%= form.fields_for :reviews, Review.new, multiple: true, child_index: 'NEW_RECORD' do |todo_fields| %>
              <%= render "avo/partials/fish_review", f: todo_fields %>
            <% end %>
          </template>
          <div class="space-y-4">
            <%= form.fields_for :reviews, Review.new, multiple: true do |todo_fields| %>
              <%= render "avo/partials/fish_review", f: todo_fields %>
            <% end %>
            <div data-nested-form-target="target"></div>
          </div>
        <% end %>
      <% end %>
      <% c.with_footer_tools do %>
        <div class="mt-4">
          <%= a_link 'javascript:void(0);', icon: 'plus', color: :primary, style: :outline, data: {action: "click->nested-form#add"} do %>
            Add another review
          <% end %>
        </div>
      <% end %>
    <% end %>
  <% end %>
</div>
```

### 7. Permit the new nested params

There's one more step we need to do and that's to whitelist the new `reviews_attributes` params to be passed to the model.

```ruby{2}
class Avo::Resources::Fish < Avo::BaseResource
  self.extra_params = [reviews_attributes: [:body, :user_id]]

  # other fields actions, filters and more
  def fields
    field :reviews, as: :has_many

    tool Avo::ResourceTools::NestedFishReviews, only_on: :new
  end
end
```

## Conclusion

There you have it!

Apart from the resource tool and the `extra_params` attribute, we wrote regular Rails code that we would have to write to get this functionality in our app.

<Image src="/assets/img/3_0/guides/nested-records-when-creating/nested-records-demo.gif" width="1024" height="640" alt="" />


# Authentication using Rails' scaffold

In essence, the [authentication scaffold](https://github.com/rails/rails/pull/52328) that Rails 8 comes with is custom authentication so we need to do a few things to ensure it's working properly with Avo.

## 1. Set the current user

The scaffold uses the `Current.user` thread-safe global to hold the current authenticated user so we need to tell Avo how to fetch them.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  # other pieces of configuration

  # tell Avo how to find the current authenticated user.
  config.current_user_method do
    Current.user
  end
end
```

## 2. Set the sign out link

The scaffold uses the `SessionsController` to sign out the user so the link should be `sessions_path`. We need to add that to Avo as well.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  # other pieces of configuration

  # tell Avo how to sign out the authenticated user.
  config.sign_out_path_name = :session_path
end
```

## 3. Ensure only authenticated users are allowed on Avo

Now, here comes the part which might seem unfamiliar but it's actually pretty standard.

The scaffold adds the `Authentication` concern to your `ApplicationController` which is great. We will add it to Avo's `ApplicationController` and also add the `before_action`, but instead of just appending it wil will prepend it so we can ensure it will be fired as soon as possible in the request lifecycle.

Since `require_authentication` runs in the Avo context, it's necessary to delegate the `new_session_path` to the `main_app` to ensure proper routing.

```ruby{4,5,8}
# app/controllers/avo/application_controller.rb
module Avo
  class ApplicationController < BaseApplicationController
    include Authentication
    delegate :new_session_path, to: :main_app

    # we are prepending the action to ensure it will be fired very early on in the request lifecycle
    prepend_before_action :require_authentication
  end
end
```

:::info
If you don't have the `app/controllers/avo/application_controller.rb` file present in your app, you can eject it using this command:

```bash
rails generate avo:eject --controller application_controller
```
:::



# REST API integration

Recipe [contributed](https://github.com/avo-hq/avo/issues/656) by [santhanakarthikeyan](https://github.com/santhanakarthikeyan).

I've built a page using AVO + REST API without using the ActiveRecord model. I was able to build an index page + associated has_many index page. It would be great if we could offer this as a feature, I guess, Avo would be the only admin framework that can offer this feature in case we take it forward :+1:

I've made it work along with Pagination, Filter and even search are easily doable.

`app/avo/filters/grace_period.rb`
```ruby
class GracePeriod < Avo::Filters::BooleanFilter
  self.name = 'Grace period'

  def apply(_request, query, value)
    query.where(value)
  end

  def options
    {
      grace_period: 'Within graceperiod'
    }
  end
end

```

`app/avo/resources/aging_order_resource.rb`
```ruby
class AgingOrderResource < Avo::BaseResource
  self.title = :id
  self.includes = []

  field :id, as: :text
  field :folio_number, as: :text
  field :order_submitted_at, as: :date_time, timezone: 'Chennai', format: '%B %d, %Y %H:%M %Z'
  field :amc_name, as: :text
  field :scheme, as: :text
  field :primary_investor_id, as: :text
  field :order_type, as: :text
  field :systematic, as: :boolean
  field :order_reference, as: :text
  field :amount, as: :text
  field :units, as: :text
  field :age, as: :text

  filter GracePeriod
end
```

`app/controllers/avo/aging_orders_controller.rb`
```ruby
module Avo
  class AgingOrdersController < Avo::ResourcesController
    def pagy_get_items(collection, _pagy)
      collection.all.items
    end

    def pagy_get_vars(collection, vars)
      collection.where(page: page, size: per_page)

      vars[:count] = collection.all.count
      vars[:page] = params[:page]
      vars
    end

    private

    def per_page
      params[:per_page] || Avo.configuration.per_page
    end

    def page
      params[:page]
    end
  end
end
```

`app/models/aging_order.rb`
```ruby
class AgingOrder
  include ActiveModel::Model
  include ActiveModel::Conversion
  include ActiveModel::Validations
  extend ActiveModel::Naming

  attr_accessor :id, :investment_date, :folio_number, :order_submitted_at,
                :amc_name, :scheme, :primary_investor_id, :order_type, :systematic,
                :order_reference, :amount, :units, :age

  class << self
    def column_names
      %i[id investment_date folio_number order_submitted_at amc_name
         scheme primary_investor_id order_type systematic
         order_reference amount units age]
    end

    def base_class
      AgingOrder
    end

    def root_key
      'data'
    end

    def count_key
      'total_elements'
    end

    def all(query)
      response = HTTParty.get(ENV['AGING_URL'], query: query)
      JSON.parse(response.body)
    end
  end

  def persisted?
    id.present?
  end
end
```

`app/models/lazy_loader.rb`
```ruby
class LazyLoader
  def initialize(klass)
    @offset, @limit = nil
    @params = {}
    @items = []
    @count = 0
    @klass = klass
  end

  def where(query)
    @params = @params.merge(query)
    self
  end

  def items
    all
    @items
  end

  def count(_attr = nil)
    all
    @count
  end

  def offset(value)
    @offset = value
    self
  end

  def limit(value)
    @limit = value
    items[@offset, @limit]
  end

  def all
    api_response
    self
  end

  def to_sql
    ""
  end

  private

  def api_response
    @api_response ||= begin
      json = @klass.all(@params)
      json.fetch(@klass.root_key, []).map do |obj|
        @items << @klass.new(obj)
      end
      @count = json.fetch(@klass.count_key, @items.size)
    end
  end
end
```

`app/policies/aging_order_policy.rb`
```ruby
class AgingOrderPolicy < ApplicationPolicy
  class Scope < Scope
    def resolve
      LazyLoader.new(scope)
    end
  end

  def index?
    user.admin?
  end

  def show?
    false
  end
end
```

`config/initializers/array.rb`
```ruby
class Array
  def limit(upto)
    take(upto)
  end
end
```



# Integration with rolify

_Recipe contributed by [Paul](https://github.com/FLX-0x00) after discussing it [here](https://github.com/avo-hq/avo/issues/1568)._

It is possible to implement the [`rolify`](https://github.com/RolifyCommunity/rolify) gem in conjunction with `pundit` in an Avo using basic functionality.
Following the next steps allows for easy management of roles within the admin panel, which can be used to control access to different parts of the application based on user roles. By assigning specific permissions to each user role, Avo users can ensure that their admin panels remain secure and accessible only to authorised users.

:::warning
You must manually require `rolify` in your `Gemfile`.
:::

```ruby
gem "rolify"
```

**If this is a new app you need to do some initial steps, create the role model and specify which models should be handled by rolify**

:::info
Check out the [rolify documentation](https://github.com/RolifyCommunity/rolify) for reference.
:::

We assume that your model for managing users is called `Account` (default when using `rodauth`) and your role model is called `Role` (default when using `rolify`).

```ruby
class Account < ApplicationRecord
  rolify

  # ...
end
```

A `Role` connects to an `Account` through `has_and_belongs_to_many` while an `Account` connects to `Role` through `has_many` (not directly used in the model because the `rolify` statement manage this). Although rolify has its own functions for adding and deleting roles, normal rails operations can also be used to manage the roles. To implement this in avo, the appropriate resources need to be created.

*Perhaps the creation of the account resource is not necessary, as it has already been done in previous steps or has been created automatically by the avo generator through a scaffold/model. So we assume this step is already done.*

```zsh
bin/rails generate avo:resource role
```

After this step the `roles` should now accessible via the avo interface. The final modification should be done in the corresponding `Account` resource file.

```ruby
class AccountResource < Avo::BaseResource
  # ...

  field :assigned_roles, as: :tags, hide_on: :forms do
    record.roles.map {|role|role.name}
  end

  # Only show roles that have not already been assigned to the object, because Avo does not use the add_role method, so it is possible to assign a role twice
  field :roles, as: :has_many, attach_scope: -> { query.where.not(id: parent.roles.pluck(:id)) }

  # ...
end
```

Example of RoleResource file:

```ruby
class RoleResource < Avo::BaseResource
  self.title = :name
  self.includes = []

  field :name, as: :text
  field :accounts, as: :has_and_belongs_to_many
end

```

The roles of an account can now be easily assigned and removed using avo. The currently assigned roles are displayed in the index and show view using the virtual `assigned_roles' field.


# Run Avo on the root path

You might want to run avo on the root path on your app.
We've seen plenty of users use this strategy.

This is as simple as changing the `root_path` from the `avo.rb` initializer to `/`.

```ruby{5}
Avo.configure do |config|
  # other pieces of configuration

  # Change the path to `/` to make it the root path
  config.root_path = '/'
end
```

I used these commands to create a new repo and change the path.

```bash
rails new avo-root-path
cd avo-root-path
bin/rails app:template LOCATION='https://avohq.io/app-template'
sed -i '' "s|config.root_path = '/avo'|config.root_path = '/'|" config/initializers/avo.rb
```


# Display counter indicator on tabs switcher

When a tab contains an association field you may want to show some counter indicator about how many records are on that particular tab. You can include that information inside tab's name.

<Image src="/assets/img/3_0/guides/tabs-counter-indicator/tabs_counter.png" width="292" height="87" alt="" />

```ruby{7,10,16-23}
class Avo::Resources::User < Avo::BaseResource
  def fields
    main_panel do
    end

    tabs do
      tab name_with_counter("Teams", record&.teams&.size) do
        field :teams, as: :has_and_belongs_to_many
      end
      tab name_with_counter("People", record&.people&.size) do
        field :people, as: :has_many
      end
    end
  end

  def name_with_counter(name, counter)
    view_context.sanitize(
      "#{name} " \
      "<span class='bg-gray-500 ml-1 px-1 text-white text-xs rounded font-semibold'>" \
        "#{counter}" \
      "</span>"
    )
  end
end
```

We are also using the `sanitize` method to return it as HTML.

In order to make the counter stand out, we're using some Tailwind CSS classes that we have available in Avo. If you're trying different classes and they are not applying, you should consider adding the [Tailwind CSS integration](#tailwindcss-integration).

:::warning
This approach will have some performance implications as it will run the `count` query on every page load.
:::


# Use markdown for help attributes

:::info User contribution
Recipe [contributed](https://github.com/avo-hq/avo/issues/1390#issuecomment-1302553590) by [dhnaranjo](https://github.com/dhnaranjo).
:::

Desmond needed a way to write markdown in the help field and built an HTML to Markdown compiler.

```ruby
module MarkdownHelpText
  class Renderer < Redcarpet::Render::HTML
    def header(text, level)
      case level
      when 1 then %(<h1 class="mb-4">#{text}</h1>)
      when 2 then %(<h2 class="mb-4">#{text}</h1>)
      else
        %(<h#{level} class="mb-2">#{text}</h#{level}>)
      end
    end

    def paragraph(text)
      %(<p class="mb-2">#{text}</p>)
    end

    def block_code(code, language)
      <<~HTML
        <pre class="mb-2 p-1 rounded bg-gray-500 text-white text-sm">
        <code class="#{language}">#{code.chomp}</code>
        </pre>
      HTML
    end

    def codespan(code)
      %(<code class="mb-2 p-1 rounded bg-gray-500 text-white text-sm">#{code}</code>)
    end

    def list(contents, list_type)
      list_style = case list_type
             when "ul" then "list-disc"
             when "ol" then "list-decimal"
             else "list-none"
             end
      %(<#{list_type} class="ml-8 mb-2 #{list_style}">#{contents}</#{list_type}>)
    end
  end

  def markdown_help(content, renderer: Renderer)
    markdown = Redcarpet::Markdown.new(
      renderer.new,
      filter_html: false,
      escape_html: false,
      autolink: true,
      fenced_code_blocks: true
    ).render(content)

    %(<section>#{markdown}</section>)
  end
end
```

```ruby
 field :description_copy, as: :markdown,
    help: markdown_help(<<~MARKDOWN
      # Dog
      ## Cat
      ### bird
      paragraph about hats **bold hat**

      ~~~
      class Ham
        def wow
          puts "wow"
        end
      end
      ~~~

      `code thinger`

      - one
      - two
      - three
    MARKDOWN
    )
```

<Image src="/assets/img/3_0/guides/use-markdown-in-help-attributes/result.png" width="1264" height="1790" alt="" />


# Use own helpers in Resource files

## TL;DR

Run `rails app:template LOCATION='https://railsbytes.com/script/V2Gsb9'`

## Details

A common pattern is to have some helpers defined in your app to manipulate your data. You might need those helpers in your `Resource` files.

#### Example:

Let's say you have a `Post` resource and you'd like to show a stripped-down version of your `body` field. So in your `posts_helper.rb` file you have the `extract_excerpt` method that sanitizes the body and truncates it to 120 characters.

```ruby
# app/helpers/posts_helper.rb
module PostsHelper
  def extract_excerpt(body)
    ActionView::Base.full_sanitizer.sanitize(body).truncate 120
  end
end
```

Now, you'd like to use that helper inside one of you computed fields.

```ruby
class Avo::Resources::Post < Avo::BaseResource
  def fields
    field :excerpt, as: :text do |model|
      extract_excerpt model.body
    end
  end
end
```

Initially you'll get an error similar to `undefined method 'extract_excerpt' for #<Avo::Fields::TextField>`. That's because the compute field executes that method in a scope that's different from your application controller, thus not having that method present.

## The solution

The fix is to include the helper module in the `BaseField` and we can do that using this snippet somewhere in the app (you can add it in `config/initializers/avo.rb`).

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  # Usual Avo config
end

module FieldExtensions
  # Include a specific helper
  include PostsHelper
end

Rails.configuration.to_prepare do
  Avo::Fields::BaseField.include FieldExtensions
end
```

Or you can go wild and include all helpers programatically.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  # Usual Avo config
end

module FieldExtensions
  # Include all helpers
  helper_names = ActionController::Base.all_helpers_from_path Rails.root.join("app", "helpers")
  helpers = ActionController::Base.modules_for_helpers helper_names
  helpers.each do |helper|
    send(:include, helper)
  end
end

Rails.configuration.to_prepare do
  Avo::Fields::BaseField.include FieldExtensions
end
```

Now you can reference all helpers in your `Resource` files.


# Avo::ButtonComponent

This component renders a button or a link with the styling


# `Avo::PanelComponent`

The panel component is one of the most used components in Avo.

```erb
<%= render Avo::PanelComponent.new(title: @product.name, description: @product.description) do |c| %>
  <% c.with_tools do %>
    <%= a_link(@product.link, icon: 'heroicons/solid/academic-cap', style: :primary, color: :primary) do %>
      View product
    <% end %>
  <% end %>

  <% c.with_body do %>
    <div class="flex flex-col p-4 min-h-24">
      <div class="space-y-4">
        <h3>Product information</h3>

        <p>Style: shiny</p>
      </div>
    </div>
  <% end %>
<% end %>
```

<Image src="/assets/img/native-components/avo-panel-component/index.jpg" width="773" height="276" alt="" />

## Options

All options are optional. You may render a panel without options.

```erb
<%= render Avo::PanelComponent.new do |c| %>
  <% c.with_body do %>
    Something here.
  <% end %>
<% end %>
```

<Option name="`name`">

The name of the panel. It's displayed on the top under the breadcrumbs.

#### Type
`String`

<Image src="/assets/img/native-components/avo-panel-component/name.jpg" width="773" height="411" alt="" />
</Option>

<Option name="`description`">

Small text under the name that speaks a bit about what the panel does.

#### Type
`String`

<Image src="/assets/img/native-components/avo-panel-component/description.jpg" width="773" height="533" alt="" />
</Option>

<Option name="`classes`">

A list of classes that should be applied to the panel container.

#### Type
`String`

<Image src="/assets/img/native-components/avo-panel-component/classes.jpg" width="773" height="533" alt="" />
</Option>

<Option name="`body_classes`">

A list of classes that should be applied to the body of panel.

#### Type
`String`

<Image src="/assets/img/native-components/avo-panel-component/body_classes.jpg" width="773" height="533" alt="" />
</Option>

<Option name="`data`">

A hash of data attributes to be forwarded to the panel container.

#### Type
`Hash`

<Image src="/assets/img/native-components/avo-panel-component/classes.jpg" width="773" height="533" alt="" />
</Option>

<Option name="`display_breadcrumbs`">

Toggles the breadcrumbs visibility. You can't customize the breadcrumbs yet.

#### Type
`Boolean`

<Image src="/assets/img/native-components/avo-panel-component/display_breadcrumbs.jpg" width="773" height="720" alt="" />
</Option>

## Slots

The component has a few slots where you customize the content in certain areas.

<Option name="`tools`">

We created this slot as a place to put resource controls like the back, edit, delete, and detach buttons.
This slot will collapse under the title and description when the screen resolution falls under `1024px`.

The section is automatically aligned to the right using `justify-end` class.

```erb
<%= render Avo::PanelComponent.new(name: "Dashboard") do |c| %>
  <% c.with_tools do %>
    <%= a_link('/admin', icon: 'heroicons/solid/academic-cap', style: :primary) do %>
      Admin
    <% end %>
  <% end %>
<% end %>
```

<Image src="/assets/img/native-components/avo-panel-component/tools-slot.jpg" width="1014" height="226" alt="" />
</Option>

<Option name="`body`">

This is one of the main slots of the component where the bulk of the content is displayed.

```erb{2-4}
<%= render Avo::PanelComponent.new do |c| %>
  <% c.with_body do %>
    Something here.
  <% end %>
<% end %>
```

<Image src="/assets/img/native-components/avo-panel-component/body-slot.jpg" width="773" height="720" alt="" />
</Option>

<Option name="`bare_content`">

Used when displaying the [Grid view](#grid-view), it displays the data flush in the container and with no background.

```erb{2-4}
<%= render Avo::PanelComponent.new do |c| %>
  <% c.with_bare_content do %>
    Something here.
  <% end %>
<% end %>
```

<Image src="/assets/img/native-components/avo-panel-component/grid-view.jpg" width="1312" height="1096" alt="" />
</Option>

<Option name="`footer_tools`">

This is pretty much the same slot as `tools` but rendered under the `body` or `bare_content` slots.

```erb{2-4}
<%= render Avo::PanelComponent.new do |c| %>
  <% c.with_footer_controls do %>
    Something here.
  <% end %>
<% end %>
```

<Image src="/assets/img/native-components/avo-panel-component/footer-controls.jpg" width="1013" height="295" alt="" />
</Option>

<Option name="`footer`">

The lowest available area at the end of the component.

```erb{2-4}
<%= render Avo::PanelComponent.new do |c| %>
  <% c.with_footer do %>
    Something here.
  <% end %>
<% end %>
```
</Option>

<Option name="`sidebar`">

The sidebar will conveniently show things in a smaller area on the right of the `body`.

```erb{2-4}
<%= render Avo::PanelComponent.new do |c| %>
  <% c.with_Sidebar do %>
    Something tiny here.
  <% end %>
<% end %>
```
<Image src="/assets/img/native-components/avo-panel-component/sidebar.png" width="2032" height="1294" alt="" />
</Option>


# <img src="/assets/img/editor/chatgpt.webp" alt="ChatGPT" class="no-border h-8 -mt-2 inline-block self-center"> ChatGPT

Setup ChatGPT to correctly generate Avo code based on your prompt.

## Quick use

In Chat window, enable the `ðŸŒ Search` feature, and add this before your prompt:

```bash
https://avohq.io/llms.txt
```

For example:

```bash
https://avohq.io/llms.txt create an Avo resource for a product model
```


# <img src="/assets/img/editor/claude.webp" alt="Claude" class="no-border h-8 -mt-2 inline-block self-center"> Claude

Setup Claude to correctly generate Avo code based on your prompt.

## Quick use

Copy and paste the file in the prompt and write your prompt.

```bash
https://avohq.io/llms.txt
```

## MCP server

MCP is a an API to communicate with AI models. You can add MCP servers and Claude will communicate with them to get more accurate results.

I suggest using [Context7](https://context7.com/) [MCP server](https://github.com/upstash/context7-mcp) which provides many libraries including Avo's docs.

1. Go to Settings > Developer

2. Click `Edit Config` button

3. Add this to the config file:

```json
// claude_desktop_config.json
{
  "mcpServers": {
   "Context7": {
     "type": "stdio",
     "command": "npx",
     "args": ["-y", "@upstash/context7-mcp@latest"]
   }
  }
}
```

Now you can ask AI anything about Avo, and write `use context7` at the end of your prompt.

For example:

```bash
create a new Avo resource for a product model. use context7
```


# <img src="/assets/img/editor/cursor.webp" alt="Cursor" class="no-border h-8 -mt-2 inline-block self-center"> Cursor

Setup Cursor to correctly generate Avo code based on your prompt.

## Quick use

  In chat window type this and Cursor will use Avo's llms.txt file to generate code.

```bash
@web https://avohq.io/llms.txt
```

## Permanent setup

1. Press âŒ˜ CMD+â‡§ Shift+P. Or if it's Windows, pressâŒƒ Ctrl+â‡§ Shift+P.
2. Type `Add new custom docs`
3. Add this: `https://avohq.io/llms.txt`
4. Now in chat window you can type `@docs` and choose `Avo` to provide Avo's docs to Cursor.

## Project-level permanent setup

You can setup Avo's llms.txt file to your repo so Cursor can use it by default. (Read more at Cursor docs)

Run this command to save the llms.txt file to `.cursor/rules/avohq.mdc`

```bash
curl -L https://avohq.io/llms.txt --create-dirs -o .cursor/rules/avo.mdc
```

## MCP server

MCP is a an API to communicate with AI models. You can add MCP servers and Cursor will communicate with them to get more accurate results.

I suggest using [Context7](https://context7.com/) [MCP server](https://github.com/upstash/context7-mcp) which provides many libraries including Avo's docs.

1. Go to Cursor settings âŒ˜ CMD+â‡§ Shift+J (or âŒƒ Ctrl+â‡§ Shift+J on Windows)

2. Click MCP from the left sidebar

3. Click Add new global MCP server

4. Add this:

```json
// .cursor/mcp.json
{
  "mcpServers": {
   "Context7": {
     "type": "stdio",
     "command": "npx",
     "args": ["-y", "@upstash/context7-mcp@latest"]
   }
  }
}
```

5. Now in Agent Mode you can ask AI anything about Avo, and write `use context7` at the end of your prompt.

For example:

```bash
create a new Avo resource for a product model. use context7
```



# <img src="/assets/img/editor/gemini.webp" alt="Gemini" class="no-border h-8 -mt-2 inline-block"> Gemini


Setup Gemini to correctly generate Avo code based on your prompt.

## Quick use

In Chat window, enable the `ðŸ” Deep research` feature, and add this before your prompt:

```bash
https://avohq.io/llms.txt
```

For example:

```bash
https://avohq.io/llms.txt create an Avo resource for a product model
```


# <img src="/assets/img/editor/grok.webp" alt="Grok" class="no-border h-8 -mt-2 inline-block self-center"> Grok

Setup Grok to correctly generate Avo code based on your prompt.

## Quick use

In Chat window, enable the `ê©œ Deep Search` feature, and add this before your prompt:

```bash
https://avohq.io/llms.txt
```

For example:

```bash
https://avohq.io/llms.txt create an Avo resource for a product model
```


# <img src="/assets/img/editor/vscode.webp" alt="VSCode" class="no-border h-8 -mt-2 inline-block self-center"> VSCode

Setup VSCode to correctly generate Avo code based on your prompt.

## Quick use

In chat window type this and VSCode will use Avo's llms.txt file to generate code.

```bash
#fetch https://avohq.io/llms.txt
```

## Project-level permanent setup

You can setup Avo's llms.txt file to your repo so Copilot can use it by default. (Read more at VSCode docs)

1. Run this command to save the llms.txt file to `.vscode/avo.md`

```bash
curl -L https://avohq.io/llms.txt --create-dirs -o .vscode/avo.md
```

2. Add this to `.vscode/settings.json`

```json
.vscode/settings.json
{
  "github.copilot.chat.codeGeneration.instructions": [
    {
      "file": "./.vscode/avo.md"
    }
  ]
}
```

## MCP server

MCP is a an API to communicate with AI models. You can add MCP servers and Copilot will communicate with them to get more accurate results.

I suggest using [Context7](https://context7.com/) [MCP server](https://github.com/upstash/context7-mcp) which provides many libraries including Avo's docs.

1. Go to MCP settings in VSCode: `vscode://settings/mcp`

2. Click Edit in settings.json`

3. Add this:

```json
// settings.json
{
  "mcp": {
    "servers": {
     "Context7": {
       "type": "stdio",
       "command": "npx",
       "args": ["-y", "@upstash/context7-mcp@latest"]
     }
    }
  }
}
```

5. Now in Agent Mode you can ask AI anything about Avo, and write `use context7` at the end of your prompt.

For example:

```bash
create a new Avo resource for a product model. use context7
```



# <img src="/assets/img/editor/windsurf.webp" alt="Windsurf" class="no-border h-8 -mt-2 inline-block"> Windsurf

Setup Windsurf to correctly generate Avo code based on your prompt.

## Quick use

In chat window type this and write your prompt.

```bash
@web https://avohq.io/llms.txt
```

## MCP server

MCP is a an API to communicate with AI models. You can add MCP servers and Windsurf will communicate with them to get more accurate results.

I suggest using [Context7](https://context7.com/) [MCP server](https://github.com/upstash/context7-mcp) which provides many libraries including Avo's docs.

1. PressâŒ˜ CMD+â‡§ Shift+P(orâŒƒ Ctrl+â‡§ Shift+Pon Windows)

2. Type `Windsurf: MCP Configuration Panel`

3. Click `Add custom server +`

4. Add this:

```json
// mcp_config.json
{
  "mcpServers": {
   "context7": {
     "command": "npx",
     "args": ["-y", "@upstash/context7-mcp@latest"]
   }
  }
}
```

Now you can ask AI anything about Avo, and write `use context7` at the end of your prompt.

For example:

```bash
create a new Avo resource for a product model. use context7
```


# <img src="/assets/img/editor/zed.webp" alt="Zed" class="no-border h-8 -mt-2 inline-block self-center"> Zed

Setup Zed to correctly generate Avo code based on your prompt.

## Quick use

In Thread chat type this before your prompt

```bash
@fetch https://avohq.io/llms.txt
```

Or in Text thread chat type this before your prompt

```bash
/fetch https://avohq.io/llms.txt
```

## MCP server

MCP is a an API to communicate with AI models. You can add MCP servers to your code editor and Cursor will communicate with them to get more accurate results.

I suggest using [Context7](https://context7.com/) [MCP server](https://github.com/upstash/context7-mcp) which provides many libraries including Avo's docs.

1. PressâŒ˜ CMD+â‡§ Shift+P(orâŒƒ Ctrl+â‡§ Shift+Pon Windows)

2. Type `agent: add context server`

3. Add this name and server:

```bash
# name
context7
```

```bash
# server
npx -y @upstash/context7-mcp@latest
```

Now in Agent Mode you can ask AI anything about Avo, and write `use context7` at the end of your prompt.

For example:

```bash
create a new Avo resource for a product model. use context7
```



# Tabs

Once your Avo resources reach a certain level of complexity, you might feel the need to better organize the fields, associations, and resource tools into groups. You can already use the [`heading`](#heading) to separate the fields inside a panel, but maybe you'd like to do more.

Tabs are a new layer of abstraction over panels. They enable you to group panels and tools together under a single pavilion and toggle between them.

```ruby
class Avo::Resources::User < Avo::BaseResource
  def fields
    field :id, as: :id, link_to_record: true
    field :email, as: :text, name: "User Email", required: true

    tabs do
      tab "User information", description: "Some information about this user" do
        panel do
          field :first_name, as: :text, required: true, placeholder: "John"
          field :last_name, as: :text, required: true, placeholder: "Doe"
          field :active, as: :boolean, name: "Is active", show_on: :show
        end
      end

      field :teams, as: :has_and_belongs_to_many
      field :people, as: :has_many
      field :spouses, as: :has_many
      field :projects, as: :has_and_belongs_to_many
    end
  end
end
```

<Image src="/assets/img/tabs-and-panels/tabs.png" width="1024" height="640" alt="Avo tabs" />

To use tabs, you need to open a `tabs` group block. Next, you add your `tab` block where you add fields and panels like you're used to on resource root. Most fields like `text`, `number`, `gravatar`, `date`, etc. need to be placed in a `panel`. However, the `has_one`, `has_many`, and `has_and_belongs_to_many` have their own panels, and they don't require a `panel` or a `tab`.

The tab `name` is mandatory is what will be displayed on the tab switcher. The tab `description` is what will be displayed in the tooltip on hover.

<Image src="/assets/img/tabs-and-panels/tab-name-description.png" width="640" height="211" alt="Avo tab name and description" />

## Tabs on Show view

Tabs have more than an aesthetic function. They have a performance function too. On the <Show /> page, if you have a lot of `has_many` type of fields or tools, they won't load right away, making it a bit more lightweight for your Rails app. Instead, they will lazy-load only when they are displayed.

## Tabs on Edit view

All visibility rules still apply on <Edit />, meaning that `has_*` fields will be hidden by default. However, you can enable them by adding `show_on: :edit`. All other fields will be loaded and hidden on page load. This way, when you submit a form, if you have validation rules in place requiring a field that's in a hidden tab, it will be present on the page on submit-time.

## Durable and "Bookmarkable"

Tabs remain durable within views, meaning that when switch between views, each tab group retains the selected tab. This ensures a consistent UX, allowing for seamless navigation without losing context.

Moreover, you have the ability to bookmark a link with a personalized tab selection.

This functionalities relies on the unique tab group ID. To take full advantage of this feature, it's important to assign a unique ID to each tab group defined in your application.

```ruby {1}
tabs id: :some_random_uniq_id do
  field :posts, as: :has_many, show_on: :edit
end
```
<!-- The panel has a few parts available -->


<!-- <img :src="('/assets/img/tabs-and-panels/panel-top.png')" alt="Avo Panels" class="border mb-4" /> -->
<!-- <img :src="('/assets/img/tabs-and-panels/panel-bottom.png')" alt="Avo Panels" class="border mb-4" /> -->


## Display counter indicator on tabs switcher

Check [this recipe](#tabs-counter-indicator) on how to enhance your tabs switcher with a counter for each association tab.

## Visibility control

<VersionReq version="3.10.10" />

Both `tabs` and individual `tab` components support a `visible` option that allows you to dynamically control their visibility based on certain conditions. For example, you might want to hide a tab if the user doesn't have the necessary permissions to view its content.

<Option name="`visible`">

The `visible` option allows you to control the visibility of either a group of tabs or an individual tab. It can be a `boolean` or a lambda.

#### Example

```ruby
tabs visible: -> { resource.record.enabled? } do
  tab name: "General Information" do
    panel do
      field :name, as: :text
      field :email, as: :text
    end
  end
  tab "Admin Information", visible: -> { current_user.is_admin? } do
    panel do
      field :role, as: :text
      field :permissions, as: :text
    end
  end
end
```

In this example:
- The entire group of tabs is only visible if the record is enabled (`resource.record.enabled?`).
- Within this group, the "General Information" tab is always visible when the tabs are shown.
- The "Admin Information" tab is only visible for admin records (`resource.record.admin?`).

</Option>

<Option name="`title`">

<VersionReq version="3.15.0" />

The `title` option enables you to specify a label for the entire group of tabs. This title serves as an overarching descriptor for the collection, providing context regarding the purpose or content of the tabs.

You can define the title of a tabs group by passing it as an argument to the `tabs` block. The value should be a string that succinctly encapsulates the theme or purpose of the tabs.

```ruby
tabs title: "Tabs group title" do
  # ...
end
```

</Option>

<Option name="`description`">

<VersionReq version="3.15.0" />

The `description` option allows you to provide an auxiliary explanation or detailed note for the entire group of tabs. This can be used to elaborate on the purpose of the tabs or provide additional guidance.

You can define a description for a tabs group by passing it as an argument to the `tabs` block. The value should be a string that offers further clarity about the content or functionality of the tabs.

```ruby
tabs description: "Tabs group description" do
  # ...
end
```

</Option>

<Option name="`lazy_load`">

<VersionReq version="3.17.0" />

The `lazy_load` option enables deferred loading of tab content, improving performance by fetching data only when the tab is clicked. By default, `lazy_load` is set to `false`, ensuring that all tabs load immediately. However, in form views, this option is automatically disabled to prevent data loss during form submission.

```ruby{2}
tabs do
  tab "Address", lazy_load: true do
    # ...
  end
end
```

</Option>


# TailwindCSS integration

We use TailwindCSS 3.0 with the JIT engine to style Avo, so on release we only pack the used Tailwind classes in our final css file. That's why, when you want to style your custom content (tools, resource tools, fields, or ejected partials), you won't have access to all of Tailwind's utility classes. It's a feature, not a bug. It's a performance optimization.

But there's an easy way to overcome that. You can add your own TailwindCSS process to watch for your the utility classes you use.

In versions prior to Avo 3, we maintained separate pre-compiled assets and provided a way to inject your Tailwind CSS assets into Avo's application. This often led to stylesheet conflicts. Now, we've improved integration by compiling a single stylesheet during the build process. If you want to add Tailwind configurations to Avo, your application will compile Avo's assets alongside your own in one build.

```bash
bin/rails generate avo:tailwindcss:install
```

That command will:

- install `tailwindcss-rails` gem if you haven't installed it yet;
- generate Avo's tailwind config.js `config/avo/tailwind.config.js`
- generate tailwind `base`, `components` and `utilities` under `app/assets/stylesheets/avo/tailwind` directory (workaround to import avo's base css after tailwind's base)
- create a custom `app/assets/stylesheets/avo/tailwind.css` file where you can further customize your Avo space;
- generate or enhance your `Procfile.dev` with the required compile `yarn avo:tailwindcss --watch` command, as per default `tailwindcss-rails` practices;
- add the build script to your `package.json`. **Ensure a `package.json` file is present;`yarn init` will generate one if your project doesn't have one**.
- add the following code to your `Rakefile`:
```ruby
# When running `rake assets:precompile` this is the order of events:
# 1 - Task `avo:yarn_install`
# 2 - Task `avo:sym_link`
# 3 - Cmd  `yarn avo:tailwindcss`
# 4 - Task `assets:precompile`
Rake::Task["assets:precompile"].enhance(["avo:sym_link"])
Rake::Task["avo:sym_link"].enhance(["avo:yarn_install"])
Rake::Task["avo:sym_link"].enhance do
  `yarn avo:tailwindcss`
end
```

Now, instead of running `bin/rails server`, you can run that Procfile with `bin/dev`.

:::info
You mileage may vary when running these tasks depending with your setup. The gist is that you need to run `yarn avo:tailwindcss` on deploy0time to compile the css file and `yarn avo:tailwindcss --watch` to watch for changes in development.
:::

Inside `app/assets/stylesheets/avo` you'll have a new `tailwind.css` file that's waiting for you to customize. The default `config/avo/tailwind.config.js` file should have the proper paths set up for purging and should be ready to go. Notice that it utilizes an preset that we manage, that preset is essential to build all avo's styles.

```css
@import 'tailwindcss/base';
/* Have all of Avo's custom and plugins styles available. */
@import '../../../../tmp/avo/avo.base.css';
@import 'tailwindcss/components';
@import 'tailwindcss/utilities';

/*

@layer components {
  .btn-primary {
    @apply py-2 px-4 bg-blue-200;
  }
}

*/
```

:::warning Avo Task Dependencies
You must ensure that the `avo:sym_link` and `avo:yarn_install` tasks are executed before building the Avo assets.

These tasks are responsible for creating various symbolic links within the `tmp/avo` directory and installing necessary Node modules within Avo's path. These modules are essential for utilizing the Avo Tailwind preset. And the symbolic links are essentials for purging all Avo's tailwind classes.
:::


# Avo 3.0 release notes

We brought up a few new things:

 - `panel`s can not receive `show_on: :index`. That will take all the fields inside that panel and display them on the index screen
 - you have access to the `main_panel`. This will hold the resource name, description, buttons and more.
 - `panel`s can now hold `tool`s.
 - `tool`s can be added inside `body` statements inside `panel` statements
 - `tool`s can come before fields using `main_panel`
 - `body`s can have the type of `:clear` to not wrap everything in a white container (aliased to `clear_body`)
 - `sidebar`s can have multiple panels by declaring multiple `sidebar` statements


# Views performance

## Log ViewComponent loading times and allocations

Sometimes, you may want to track the loading times and memory allocations of ViewComponents, similar to how you do with partials. Follow these two steps to enable this functionality.

#### 1. Enable ViewComponent Instrumentation

First, you need to enable instrumentation for ViewComponents. Add the following configuration to your `application.rb` or `development.rb` file:

```ruby
# application.rb or development.rb
config.view_component.instrumentation_enabled = true
```

#### 2. Add Logging

Next, set up logging to capture the performance data. Create or update the `config/initializers/view_component.rb` file with the following code:

```ruby
# config/initializers/view_component.rb
module ViewComponent
  class LogSubscriber < ActiveSupport::LogSubscriber
    define_method :'!render' do |event|
      info do
        message = +"  Rendered #{event.payload[:name]}"
        message << " (Duration: #{event.duration.round(1)}ms"
        message << " | Allocations: #{event.allocations})"
      end
    end
  end
end

ViewComponent::LogSubscriber.attach_to :view_component
```

<Image src="/assets/img/3_0/performance/views-performance/view-component-logs.png" size="2236xâ€Š462" alt="View Component logging" />

:::warning
Enabling this logging can negatively impact your applicationâ€™s performance. We recommend using it in the development environment or disabling it in production once you have completed debugging.
:::



# Native field components

One of the most important features of Avo is the ability to extend it pass the DSL. It's very important to us to enable you to add the features you need and create the best experience for your users.

That's why you can so easily create [custom fields](#custom-fields), [resource tools](#resource-tools), and [custom tools](#custom-pages-custom-tools) altogether. When you need to augment the UI even more you can use your [custom CSS and JS assets](#custom-asset-pipeline) too.

When you start adding those custom views you might want to add your own fields, and you'd like to make them look like the rest of the app.
That's why Avo provides a way to use those fields beyond the DSL, in your own custom Rails partials.

## Declaring fields

When you generate a new [resource tool](#resource-tools) you get access to the resource partial.

:::details Sample resource tool
```erb
<div class="flex flex-col">
  <%= render Avo::PanelComponent.new title: "Post info" do |c| %>
    <% c.with_tools do %>
      <%= a_link('/avo', icon: 'heroicons/solid/academic-cap', style: :primary) do %>
        Dummy link
      <% end %>
    <% end %>
    <% c.with_body do %>
      <div class="flex flex-col p-4 min-h-24">
        <div class="space-y-4">
          <h3>ðŸª§ This partial is waiting to be updated</h3>
          <p>
            You can edit this file here <code class='p-1 rounded bg-gray-500 text-white text-sm'>app/views/avo/resource_tools/post_info.html.erb</code>.
          </p>
          <p>
            The resource tool configuration file should be here <code class='p-1 rounded bg-gray-500 text-white text-sm'>app/avo/resource_tools/post_info.rb</code>.
          </p>
          <%
            # In this partial, you have access to the following variables:
            # tool
            # @resource
            # @resource.model
            # form (on create & edit pages. please check for presence first)
            # params
            # Avo::Current.context
            # current_user
          %>
        </div>
      </div>
    <% end %>
  <% end %>
</div>
```
:::

You may add new fields using the `avo_show_field`, or `avo_edit_field` methods and use [the arguments you are used to from resources](#field-options).

```ruby
# In your resource file
field :name, as: :text
```

```erb
<!-- In your partial file -->
<%= avo_edit_field :name, as: :text %>
```

## The `form` option

If this is an <Edit /> or a <New /> view, you should pass it the `form` object that an Avo resource tool provides for you.

```erb
<%= avo_edit_field :name, as: :text, form: form %>
```

## The `value` option

When you are building a show field and you want to give it a value to show, use the `value` options

```erb
<%= avo_show_field(:photo, as: :external_image, value: record.cdn_image) %>
```

## Other field options

The fields take all the [field options](#field-options) you are used to like, `help`, `required`, `readonly`, `placeholder`, and more.

```erb
<%= avo_edit_field :name, as: :text, form: form, help: "The user's name", readonly: -> { !current_user.is_admin? }, placeholder: "John Doe", nullable: true %>
```

## Component options

The field taks a new `component_options` argument that will be passed to the view component for that field. Please check out the [field wrapper documentation](#field-wrappers) for more details on that.

## `avo_field` helper

You may use the `avo_field` helper to conditionally switch from `avo_show_field` and `avo_edit_field`.

```erb
<%= avo_field :name, as: :text, view: :show %>
<%= avo_field :name, as: :text, view: :edit %>
<%= avo_field :name, as: :text, view: ExampleHelper.view_conditional %>
```


# Routing

We stick to Rails defaults in terms of routing just to make working with Avo as straightforward as possible.

Avo's functionality is distributed across multiple gems, each encapsulating its own engine. By default, these engines are mounted under Avo's scope within your Rails application.

Each engine registers itself with Avo.

### Default Mounting Behavior

When the `mount_avo` method is invoked, Avo and all the associated engines are mounted at a common entry point. By default, this mounting point corresponds to `Avo.configuration.root_path`, but you can customize it using the `at` argument:

```ruby{4,7}
# config/routes.rb
Rails.application.routes.draw do
  # Mounts Avo at Avo.configuration.root_path
  mount_avo

  # Mounts Avo at `/custom_path` instead of the default
  mount_avo at: "custom_path"
end
```

If no custom path is specified, Avo is mounted at the default configuration root path.

## Mount Avo under a scope

In this example, we'll demonstrate how to add a `:locale` scope to your routes.

The `:locale` scope is just an example. If your objective is to implement a route scope for localization within Avo, there's a detailed recipe available. Check out [this guide](#multi-language-urls) for comprehensive instructions.

```ruby{4-6}
# config/routes.rb

Rails.application.routes.draw do
  scope ":locale" do
    mount_avo
  end
end
```


:::info
To guarantee that the `locale` scope is included in the `default_url_options`, you must explicitly add it to the Avo configuration.

Check [this documentation section](#customization) for details on how to configure `default_url_options` setting.
:::

## Add your own routes

You may want to add your own routes inside Avo so you can access different custom actions that you might have set in the Avo resource controllers.

You can do that in your app's `routes.rb` file by opening up the Avo routes block and append your own.

```ruby
# routes.rb
Rails.application.routes.draw do
  mount_avo

  # your other app routes
end

if defined? ::Avo
  Avo::Engine.routes.draw do
    # new route in new controller
    put "switch_accounts/:id", to: "switch_accounts#update", as: :switch_account

    scope :resources do
      # append a route to a resource controller
      get "courses/cities", to: "courses#cities"
    end
  end
end

# app/controllers/avo/switch_accounts_controller.rb
class Avo::SwitchAccountsController < Avo::ApplicationController
  def update
    session[:tenant_id] = params[:id]

    redirect_back fallback_location: root_path
  end
end
```


# Select All

The "Select All" feature is designed to enable users to select all queried records and perform actions on the entire selection. This feature is particularly useful when dealing with large datasets, allowing users to trigger actions on all queried records, not just the ones visible on the current page.

## How does it work?

<Image src="/assets/img/3_0/select_all.gif" width="687" height="289" alt="Select all demonstration" />

When a user toggles the "Select all" checkbox, Avo will first check to see if there are more records than just those displayed on that page, and if there are, it will ask if the user if they want to select all the records or not.

This is being done through serializing the query to be unserialized back in the action.

## Serializing the query

The query might include various filters, sorting parameters, and other custom elements. Reconstructing this query at the time of the action request can be complex. Therefore, the system serializes the entire query object into a secure format before sending it with the action request.

- **Security**: To ensure that sensitive data is protected, the serialized query is encrypted before it is transmitted.
- **Efficiency**: This approach allows the system to accurately and efficiently reconstruct the original query when the action is executed, ensuring that all relevant records are included.

:::warning
<VersionReq version="3.12.0" />
If an error occurs during the serialization process, the "Select All" feature is automatically disabled. This safeguard ensures that the page will not crash because of a coding error.
We listed a few reasons on why it might crash below.
:::

## Serialization known issues

In this section, we outline common serialization problems and provide guidance on how to resolve them effectively.

##### `normalize`

If your model includes any `normalize` proc, such as:

```ruby
normalizes :status, with: ->(status) { status }
```

Serialization may fail when a filter is applied to the normalized attribute (e.g., `status` in this example). This can result in the error `TypeError: no _dump_data is defined for class Proc`, which causes the "Select All" feature to be automatically disabled.

For applications created before Rails `7.1`, configuring the `marshalling_format_version` to `7.1` or higher will resolve the issue:

```ruby
# config/application.rb

config.active_record.marshalling_format_version = 7.1
```

More details on [`normalizes` documentation](https://api.rubyonrails.org/classes/ActiveRecord/Normalization/ClassMethods.html#method-i-normalizes).



# Stimulus JS & HTML attributes

:::warning
This feature is in the **beta** phase. The API might change while seeing how the community uses it to build their apps.
This is not the **dependable fields** feature but a placeholder so we can observe and see what we need to ship to make it helpful to you.
:::

_What we'll be able to do at the end of reading these docs_

<Image src="/assets/img/stimulus/country-city-select.gif" width="800" height="344" alt="Debug on input stimulus method" />

:::info
**Please note** that in order to have the JS code from your controllers loaded in Avo you'll need to add your asset pipeline using [these instructions](#custom-asset-pipeline). It's really easier than it sounds. It's like you'd add a new JS file to your regular Rails app.
:::

<hr>

One of the most requested features is the ability to make the forms more dynamic. We want to bring the first iteration of this feature through Stimulus JS integration.
This light layer will allow you to hook into the views and inject your functionality with Stimulus JS.

You'll be able to add your Stimulus controllers to the resource views (`Index`, `Show`, `Edit`, and `New`), attach `classes`, `style`, and `data` attributes to the fields and inputs in different views.

## Assign Stimulus controllers to resource views

To enable a stimulus controller to resource view, you can use the `stimulus_controllers` option on the resource file.

```ruby
class Avo::Resources::Course < Avo::BaseResource
  self.stimulus_controllers = "course-resource"
end
```

You can add more and separate them by a space character.

```ruby
class Avo::Resources::Course < Avo::BaseResource
  self.stimulus_controllers = "course-resource select-field association-fields"
end
```

Avo will add a `resource-[VIEW]` (`resource-edit`, `resource-show`, or `resource-index`) controller for each view.

### Field wrappers as targets

By default, Avo will add stimulus target data attributes to all field wrappers. The notation scheme uses the name and field type `[FIELD_NAME][FIELD_TYPE]WrapperTarget`.

```ruby
# Wrappers get the `data-[CONTROLLER]-target="nameTextWrapper"` attribute and can be targeted using nameTextWrapperTarget
field :name, as: :text

# Wrappers get the `data-[CONTROLLER]-target="createdAtDateTimeWrapper"` attribute and can be targeted using createdAtDateTimeWrapperTarget
field :created_at, as: :date_time

# Wrappers get the `data-[CONTROLLER]-target="hasSkillsTagsWrapper"` attribute and can be targeted using hasSkillsTagsWrapperTarget
field :has_skills, as: :tags
```

For example for the following stimulus controllers `self.stimulus_controllers = "course-resource select-field association-fields"` Avo will generate the following markup for the `has_skills` field above on the `edit` view.

```html{4-7}
<div class="relative flex flex-col md:flex-row md:items-center pb-2 md:pb-0 leading-tight min-h-14" data-field-id="has_skills" data-field-type="boolean" data-resource-edit-target="hasSkillsBooleanWrapper" data-course-resource-target="hasSkillsBooleanWrapper" data-select-field-target="hasSkillsBooleanWrapper" data-association-fields-target="hasSkillsBooleanWrapper">
  <!-- Rest of the field content -->
</div>
```

You can add those targets to your controllers and use them in your JS code.

### Field inputs as targets

Similar to the wrapper element, inputs in the `Edit` and `New` views get the `[FIELD_NAME][FIELD_TYPE]InputTarget`. On more complex fields like the searchable, polymorphic `belongs_to` field, where there is more than one input, the target attributes are attached to all `input`, `select`, and `button` elements.

```ruby
# Inputs get the `data-[CONTROLLER]-target="nameTextInput"` attribute and can be targeted using nameTextInputTarget
field :name, as: :text

# Inputs get the `data-[CONTROLLER]-target="createdAtDateTimeInput"` attribute and can be targeted using createdAtDateTimeInputTarget
field :created_at, as: :date_time

# Inputs get the `data-[CONTROLLER]-target="hasSkillsTagsInput"` attribute and can be targeted using hasSkillsTagsInputTarget
field :has_skills, as: :tags
```

### All controllers receive the `view` value

All stimulus controllers receive the `view` attribute in the DOM.

```html{4-5}
<div class="space-y-12" data-model-id="280" data-controller="resource-edit course-resource" data-resource-edit-view-value="edit" data-course-resource-view-value="edit">
  <!-- The fields and panels -->
</div>
```

Now you can use that inside your Stimulus JS controller like so:

```js{5,9}
import { Controller } from '@hotwired/stimulus'

export default class extends Controller {
  static values = {
    view: String,
  }

  async connect() {
    console.log('view ->', this.viewValue)
  }
}
```

The possible values are `index`, `show`, `edit`, or `new`

## Assign Stimulus controllers to actions

Similarly as to resource, you can assign stimulus controller to an action. To do that you can use the `stimulus_controllers` option on the action file.

```ruby
class Avo::Actions::ShowCurrentTime < Avo::BaseAction
  self.stimulus_controllers = "city-in-country"
end
```

You can add more and separate them by a space character.

```ruby
class Avo::Actions::ShowCurrentTime < Avo::BaseAction
  self.stimulus_controllers = "course-resource select-field association-fields"
end
```

The same way as for the resources, Avo will add stimulus target data attributes to [all field wrappers](#field-wrappers-as-targets) and [all input fields](#field-inputs-as-targets).

Unlike with the resource, Avo will not add a specific default controller for each type of the view (`index`, `show`, `edit`).
Same way, the controllers will not receive the `view` attribute in the DOM, [as in case of resources](#all-controllers-receive-the-view-value).

## Attach HTML attributes

[This section has moved.](#field-options)

## Composing the attributes together

You can use the attributes together to make your fields more dynamic.

```ruby{3-9}
  field :has_skills, as: :boolean, html: {
    edit: {
      input: {
        data: {
          # On click run the toggleSkills method on the toggle-fields controller
          action: "input->toggle-fields#toggleSkills",
        }
      }
    }
  }
  field :skills, as: :tags, html: {
    edit: {
      wrapper: {
        # hide this field by default
        classes: "hidden"
      }
    }
  }
```

```js
// toggle_fields_controller.js
import { Controller } from "@hotwired/stimulus";

export default class extends Controller {
  static targets = ["skillsTagsWrapper"]; // use the target Avo prepared for you

  toggleSkills() {
    this.skillsTagsWrapperTarget.classList.toggle("hidden");
  }
}
```

## Pre-made stimulus methods

Avo ships with a few JS methods you may use on your resources.

### `resource-edit#toggle`

On your `Edit` views, you can use the `resource-edit#toggle` method to toggle the field visibility from another field.

```ruby{5-7}
field :has_country, as: :boolean, html: {
  edit: {
    input: {
      data: {
        action: "input->resource-edit#toggle", # use the pre-made stimulus method on input
        resource_edit_toggle_target_param: "countrySelectWrapper", # target to be toggled
        # resource_edit_toggle_targets_param: ["countrySelectWrapper"] # add more than one target
      }
    }
  }
}
field :country, as: :select, options: Course.countries.map { |country| [country, country] }.to_h
```

<Image src="/assets/img/stimulus/toggle-method.gif" width="800" height="421" alt="Toggle method" />

### `resource-edit#disable`

Disable works similarly to toggle, with the difference that it disables the field instead of hiding it.

```ruby{5-7,16}
field :has_skills, as: :boolean, html: {
  edit: {
    input: {
      data: {
        action: "input->resource-edit#disable", # use the pre-made stimulus method on input
        resource_edit_disable_target_param: "countrySelectInput", # target to be disabled
        # resource_edit_disable_targets_param: ["countrySelectWrapper"] # add more than one target to disable
      }
    }
  }
}
field :country, as: :select, options: Course.countries.map { |country| [country, country] }.to_h
```

<Image src="/assets/img/stimulus/disable-method.gif" width="800" height="421" alt="Disable method" />

You may also target the `wrapper` element for that field if the target field has more than one input like the searchable polymorphic `belongs_to` field.

```ruby{6}
field :has_skills, as: :boolean, html: {
  edit: {
    input: {
      data: {
        action: "input->resource-edit#disable", # use the pre-made stimulus method on input
        resource_edit_disable_target_param: "countrySelectWrapper", # target the wrapper so all inputs are disabled
        # resource_edit_disable_targets_param: ["countrySelectWrapper"] # add more than one target to disable
      }
    }
  }
}
field :country, as: :select, options: Course.countries.map { |country| [country, country] }.to_h
```

### `resource-edit#debugOnInput`

For debugging purposes only, the `resource_edit` Stimulus JS controller provides the `debugOnInput` method that outputs the event and value for an action to the console. Use this just to make sure you targeted your fields correctly. It doesn't have any real use.

<Image src="/assets/img/stimulus/debug-on-input.gif" width="800" height="261" alt="Debug on input stimulus method" />

## Custom Stimulus controllers

<DemoVideo demo-video="https://youtu.be/ZMOz22FaAUg?t=1127" />

:::info Check the source code
If you visit our demo website on the [course edit page](https://main.avodemo.com/avo/resources/courses/1/edit) you can see this in action.

- Demo of the feature in action <br>
https://main.avodemo.com/avo/resources/courses/1/edit
- JS controller that does that change <br>
https://github.com/avo-hq/main.avodemo.com/blob/main/app/javascript/controllers/course_controller.js
- Rails controller that returns the results <br>
https://github.com/avo-hq/main.avodemo.com/blob/main/app/controllers/avo/courses_controller.rb#L3
- Stimulus action that triggers the update <br>
https://github.com/avo-hq/main.avodemo.com/blob/main/app/avo/resources/course.rb#L68
:::

The bigger purpose of this feature is to create your own Stimulus JS controllers to bring the functionality you need to the CRUD interface.

Below is an example of how you could implement a city & country select feature where the city select will have its options changed when the user selects a country:

1. Add an action to the country select to trigger a change.
1. The stimulus method `onCountryChange` will be triggered when the user changes the country.
1. That will trigger a fetch from the server where Rails will return an array of cities for the provided country.
1. The city field will have a `loading` state while we fetch the results.
1. The cities will be added to the `city` select field
1. If the initial value is present in the returned results, it will be selected.
1. All of this will happen only on the `New` and `Edit` views because of the condition we added to the `connect` method.

::: code-group

```ruby [app/avo/resources/course.rb]
# app/avo/resources/course.rb
class Avo::Resources::Course < Avo::BaseResource
  self.stimulus_controllers = "course-resource"

  def fields
    field :id, as: :id
    field :name, as: :text
    field :country, as: :select, options: Course.countries.map { |country| [country, country] }.to_h, html: {
      edit: {
        input: {
          data: {
            course_resource_target: "countryFieldInput", # Make the input a target
            action: "input->course-resource#onCountryChange" # Add an action on change
          }
        }
      }
    }
    field :city, as: :select, options: Course.cities.values.flatten.map { |city| [city, city] }.to_h, html: {
      edit: {
        input: {
          data: {
            course_resource_target: "cityFieldInput" # Make the input a target
          }
        }
      }
    }
  end
end
```

```ruby{4-6} [config/routes.rb]
Rails.application.routes.draw do
  if defined? ::Avo
    Avo::Engine.routes.draw do
      scope :resources do
        get "courses/cities", to: "courses#cities"
      end
    end
  end
end
```

```ruby{3} [app/controllers/avo/courses_controller.rb]
class Avo::CoursesController < Avo::ResourcesController
  def cities
    render json: get_cities(params[:country]) # return an array of cities based on the country we received
  end

  private

  def get_cities(country)
    return [] unless Course.countries.include?(country)

    Course.cities[country.to_sym]
  end
end
```

```ruby [app/models/course.rb]
class Course < ApplicationRecord
  def self.countries
    ["USA", "Japan", "Spain", "Thailand"]
  end

  def self.cities
    {
      USA: ["New York", "Los Angeles", "San Francisco", "Boston", "Philadelphia"],
      Japan: ["Tokyo", "Osaka", "Kyoto", "Hiroshima", "Yokohama", "Nagoya", "Kobe"],
      Spain: ["Madrid", "Valencia", "Barcelona"],
      Thailand: ["Chiang Mai", "Bangkok", "Phuket"]
    }
  end
end
```

```js [course_resource_controller.js]
import { Controller } from "@hotwired/stimulus";

const LOADER_CLASSES = "absolute bg-gray-100 opacity-10 w-full h-full";

export default class extends Controller {
  static targets = ["countryFieldInput", "cityFieldInput", "citySelectWrapper"];

  static values = {
    view: String,
  };

  // Te fields initial value
  static initialValue;

  get placeholder() {
    return this.cityFieldInputTarget.ariaPlaceholder;
  }

  set loading(isLoading) {
    if (isLoading) {
      // create a loader overlay
      const loadingDiv = document.createElement("div");
      loadingDiv.className = LOADER_CLASSES;
      loadingDiv.dataset.target = "city-loader";

      // add the loader overlay
      this.citySelectWrapperTarget.prepend(loadingDiv);
      this.citySelectWrapperTarget.classList.add("opacity-50");
    } else {
      // remove the loader overlay
      this.citySelectWrapperTarget
        .querySelector('[data-target="city-loader"]')
        .remove();
      this.citySelectWrapperTarget.classList.remove("opacity-50");
    }
  }

  async connect() {
    // Add the controller functionality only on forms
    if (["edit", "new"].includes(this.viewValue)) {
      this.captureTheInitialValue();

      // Trigger the change on load
      await this.onCountryChange();
    }
  }

  // Read the country select.
  // If there's any value selected show the cities and prefill them.
  async onCountryChange() {
    if (this.hasCountryFieldInputTarget && this.countryFieldInputTarget) {
      // Get the country
      const country = this.countryFieldInputTarget.value;
      // Dynamically fetch the cities for this country
      const cities = await this.fetchCitiesForCountry(country);

      // Clear the select of options
      Object.keys(this.cityFieldInputTarget.options).forEach(() => {
        this.cityFieldInputTarget.options.remove(0);
      });

      // Add blank option
      this.cityFieldInputTarget.add(new Option(this.placeholder));

      // Add the new cities
      cities.forEach((city) => {
        this.cityFieldInputTarget.add(new Option(city, city));
      });

      // Check if the initial value is present in the cities array and select it.
      // If not, select the first item
      const currentOptions = Array.from(this.cityFieldInputTarget.options).map(
        (item) => item.value
      );
      if (currentOptions.includes(this.initialValue)) {
        this.cityFieldInputTarget.value = this.initialValue;
      } else {
        // Select the first item
        this.cityFieldInputTarget.value =
          this.cityFieldInputTarget.options[0].value;
      }
    }
  }

  // Private

  captureTheInitialValue() {
    this.initialValue = this.cityFieldInputTarget.value;
  }

  async fetchCitiesForCountry(country) {
    if (!country) {
      return [];
    }

    this.loading = true;

    const response = await fetch(
      `${window.Avo.configuration.root_path}/resources/courses/cities?country=${country}`
    );
    const data = await response.json();

    this.loading = false;

    return data;
  }
}
```

:::

This is how the fields behave with this Stimulus JS controller.

<Image src="/assets/img/stimulus/country-city-select.gif" width="800" height="344" alt="Debug on input stimulus method" />

## Use Stimulus JS in a tool

There are a few steps you need to take in order to register the Stimulus JS controller in the current app context.

First, you need to have a JS entrypoint (ex: `avo.custom.js`) and have that loaded in the `_head` partial. For instructions on that please follow [these steps](#custom-asset-pipeline) to add it to your app (`importmaps` or `esbuild`).

### Set up a controller

```js
// app/javascript/controllers/sample_controller.js
import { Controller } from "@hotwired/stimulus";

export default class extends Controller {
  connect() {
    console.log("Hey from sample controller ðŸ‘‹");
  }
}
```

### Register that controller with the current Stimulus app

```js
// app/javascript/avo.custom.js
import SampleController from "controllers/sample_controller";

// Hook into the stimulus instance provided by Avo
const application = window.Stimulus;
application.register("course-resource", SampleController);

// eslint-disable-next-line no-console
console.log("Hi from Avo custom JS ðŸ‘‹");
```

### Use the controller in the Avo tool

```erb
<!-- app/views/avo/_sample_tool.html.erb -->
<div data-controller="sample">
  <!-- content here -->
</div>
```

Done ðŸ™Œ Now you have a controller connecting to a custom [Resource tool](#resource-tools) or [Avo tool](#custom-pages-custom-tools) (or Avo views).

## StimulusJS in actions

Currently, Avo doesn't support the use of StimulusJS in the same manner in action modals. Please follow [this](https://github.com/avo-hq/avo/issues/2811) issue to get updates on when it will be available.

This is not very prio on our near roadmap, but we will take a contribution in the form of a PR or a sponsorship in order to prioritize it on our end.


# Licensing

Avo runs on the [Open-Core model](https://en.wikipedia.org/wiki/Open-core_model). The **Community** edition is free to use and works best for personal, hobby, and small commercial projects.
There are a couple of paid tiers (**Pro**, **Advanced**, and **Enterprise**) that give you more features, more customization, a higher level of control, and more support.

## Community vs. Paid

<Option name="Community">

The **Community** version has powerful features that you can use today like [Resource management](#resources), most [feature-rich](#field-options) [fields](#fields), out-of-the box [sorting](#field-options), [filtering](#filters) and [actions](#overview), all the [associations](#associations) you need, and about 70% of all the features Avo has to offer.

</Option>

<Option name="Pro">

The **Pro** tier comes with [Advanced Authorization](#authorization) using Pundit, [Advanced File Uploads](#files), [Records Re-Ordering](#records-reordering), [Menu Editor](#menu-editor), and [Dashboards](#dashboards).

</Option>

<Option name="Advanced">

The **Advanced** tier is a pick-and-choose plan which has a few features and add-ons to offer like [Customizable Controls](#customizable-controls), [Resource Scopes](#scopes), [Dynamic Filters](#dynamic-filters), [Kanban Boards](#kanban-boards), Dynamic Fields, Collaboration, or White Labeling.
In order to get a quote on the **Advanced** features, please [get in touch](https://savvycal.com/avo-hq/discovery-call-advanced) with us.

</Option>

The features are separated by their level of complexity and maintenance needs. Selling the Avo Pro edition as a paid upgrade and enables us to fund this business and work on it full-time. That way, Avo improves over time, helping developers with more features and customization options.

## One license per site

Each license can be used to run one application in one `production` environment on one URL. So when an app is in the `production` environment (`Rails.env.production?` is `true`), we only need to check that the license key and URL match the purchased license you're using for that app.

:::info
More info [here](https://avohq.io/faq/one-production-environment.html).
:::

### More installations/environments per site

You might have the same site running in multiple environments (`development`, `staging`, `test`, `QA`, etc.) for non-production purposes. You don't need extra licenses for those environments as long as they are not production environments (`Rails.env.production?` returns `false`).

:::info
More info [here](https://avohq.io/faq/one-license-per-url.html).
:::

### Sites

You can see your licenses and projects on your [dashboard](https://avohq.io/dashboard).

## Add the license key

After you purchase an Avo license, add it to your `config/initializers/avo.rb` file under `license_key`.

```ruby{3}
# config/initializers/avo.rb
Avo.configure do |config|
  config.license_key = '************************' # or use ENV['AVO_LICENSE_KEY']
end
```

## Configure the display of license request timeout error

If you want to hide the badge displaying the license request timeout error, you can do it by setting the `display_license_request_timeout_error` configuration to `false`. It defaults to `true`.

```ruby{3}
# config/initializers/avo.rb
Avo.configure do |config|
  config.display_license_request_timeout_error = false
end
```

## Purchase a license

You can purchase a license from the [pricing](https://avohq.io/pricing) page.

## License validation

### "Phone home" mechanism

Avo pings the [HQ](https://avohq.io) (the license validation service) with some information about the current Avo installation. You can find the full payload below.

```ruby
# HQ ping payload
{
  license: Avo.configuration.license,
  license_key: Avo.configuration.license_key,
  avo_version: Avo::VERSION,
  rails_version: Rails::VERSION::STRING,
  ruby_version: RUBY_VERSION,
  environment: Rails.env,
  ip: current_request.ip,
  host: current_request.host,
  port: current_request.port,
  app_name: Rails.application.class.to_s.split("::").first,
  avo_metadata: avo_metadata
}
```

That information helps us to identify your license and return a license valid/invalid response to Avo.
The requests are made at boot time and every hour when you use Avo on any license type.

If you need a special build without the license validation mechanism please [get in touch](mailto:adrian@avohq.io).


## Upgrade your 1.0 license to 2.0, to 3.0

We are grateful to our `1.0` customers for believing in us. So we offer a free and easy upgrade path and **a year of free updates** for version `2.0`.

If you have a 1.0 license and want to upgrade to 2.0, you need to log in to [avohq.io](https://avohq.io), and go to the [licenses page](https://avohq.io/subscriptions), and hit the `Upgrade` button next to your license. You'll be redirected to the new subscription screen where you can start the subscription for 2.0.
After you add your billing details, you won't get charged immediately, but on the next billing cycle next year.

If you choose not to renew the subscription after one year, that's fine; you can cancel at any time, no biggie. You won't get charged and will keep the last version available at the end of that subscription.

Same treatment was applied with the 2.0 -> 3.0 customers.



# Menu editor

One common task you need to do is organize your sidebar resources into menus. You can easily do that using the menu editor in the initializer.

When you start with Avo, you'll get an auto-generated sidebar by default. That sidebar will contain all your resources, dashboards, and custom tools. To customize that menu, you have to add the `main_menu` key to your initializer.

```ruby{3-22}
# config/initializers/avo.rb
Avo.configure do |config|
  config.main_menu = -> {
    section "Resources", icon: "heroicons/outline/academic-cap" do
      group "Academia" do
        resource :course
        resource :course_link
      end

      group "Blog", collapsable: true, collapsed: true do
        dashboard :dashy

        resource :post
        resource :comment
      end
    end

    section I18n.t('avo.other'), icon: "heroicons/outline/finger-print", collapsable: true, collapsed: true do
      link_to 'Avo HQ', path: 'https://avohq.io', target: :_blank
      link_to 'Jumpstart Rails', path: 'https://jumpstartrails.com/', target: :_blank
    end
  }
end
```

<Image src="/assets/img/menu-editor/main.jpg" width="250" height="448" alt="Avo main menu" />

For now, Avo supports editing only two menus, `main_menu` and `profile_menu`. However, that might change in the future by allowing you to write custom menus for other parts of your app.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.main_menu = -> {
    section I18n.t("avo.dashboards"), icon: "dashboards" do
      dashboard :dashy, visible: -> { true }
      dashboard :sales, visible: -> { true }

      group "All dashboards", visible: false do
        all_dashboards
      end
    end

    section "Resources", icon: "heroicons/outline/academic-cap" do
      group "Academia" do
        resource :course
        resource :course_link
      end

      group "Blog" do
        resource :posts
        resource :comments
      end

      group "Other" do
        resource :fish
      end
    end

    section "Tools", icon: "heroicons/outline/finger-print" do
      all_tools
    end

    group do
      link_to "Avo", path: "https://avohq.io"
      link_to "Google", path: "https://google.com", target: :_blank
    end
  }
  config.profile_menu = -> {
    link_to "Profile", path: "/profile", icon: "user-circle"
  }
end
```

## Menu item types

A few menu item types are supported `link_to`, `section`, `group`, `resource`, and `dashboard`. There are a few helpers too, like `all_resources`, `all_dashboards`, and `all_tools`.

<Option name="`link_to`">

`link_to` is the menu item that the user will probably interact with the most. It will generate a link on your menu. You can specify the `name`, `path` , and `target`.

```ruby
link_to "Google", path: "https://google.com", target: :_blank
```

<Image src="/assets/img/menu-editor/external-link.jpg" width="254" height="155" alt="Avo menu editor" />

When you add the `target: :_blank` option, a tiny external link icon will be displayed.

#### `link_to` options

#### `path`

This is the path of the item.
It may be ommited to make the API look like Rail's

```ruby
config.main_menu = -> {
  # These two are equivalent
  link_to "Home", path: main_app.root_path
  link_to "Home", main_app.root_path
}
```

##### `data`

You may add arbitraty `data` attributes to your link.

You can make a link execute a `put`, `post`, or `delete` request similar to how you use the `data-turbo-method` attribute.

```ruby
config.main_menu = -> {
  link_to "Sign out!", main_app.destroy_user_session_path, data: { turbo_method: :delete }
}
```

</Option>

<Option name="`render`">

The `render` method will render renderable objects like partials or View Components.

You can even pass `locals` to partials.
The partials follow the same pattern as the regular `render` method.

```ruby
render "avo/sidebar/items/custom_tool"
render "avo/sidebar/items/custom_tool", locals: { something: :here }
render Super::Dooper::Component.new(something: :here)
```

</Option>

<Option name="`resource`">

To make it a bit easier, you can use `resource` to quickly generate a link to one of your resources. For example, you can pass a short symbol name `:user` or the full name `Avo::Resources::User`.

```ruby
resource :posts
resource "Avo::Resources::Comments"
```

<Image src="/assets/img/menu-editor/resource.jpg" width="252" height="177" alt="Avo menu editor" />

You can also change the label for the `resource` items to something else.

```ruby
resource :posts, label: "News posts"
```

Additionally, you can pass the `params` option to the `resource` items to add query params to the link.

```ruby
resource :posts, params: { status: "published" }
resource :users, params: -> do
  decoded_filter = {"Avo::Filters::IsAdmin"=>["non_admins"]}

  { encoded_filters: Avo::Filters::BaseFilter.encode_filters(decoded_filter)}
end
```

</Option>

<Option name="`dashboard`">

Similar to `resource`, this is a helper to make it easier to reference a dashboard. You pass in the `id` or the `name` of the dashboard.

```ruby
dashboard :dashy
dashboard "Sales"
```

<Image src="/assets/img/menu-editor/dashboard.jpg" width="256" height="212" alt="Avo menu editor" />

You can also change the label for the `dashboard` items to something else.

```ruby
dashboard :dashy, label: "Dashy Dashboard"
```

</Option>

<Option name="`section`">

Sections are the big categories in which you can group your menu items. They take `name` and `icon` options.

```ruby
section "Resources", icon: "heroicons/outline/academic-cap" do
  resource :course
  resource :course_link
end
```

<Image src="/assets/img/menu-editor/section.jpg" width="255" height="207" alt="Avo menu editor" />

</Option>

<Option name="`group`">

Groups are smaller categories where you can bring together your items.

```ruby
group "Blog" do
  resource :posts
  resource :categories
  resource :comments
end
```

<Image src="/assets/img/menu-editor/group.jpg" width="252" height="205" alt="Avo menu editor" />

</Option>

<Option name="`all_resources`">

Renders all resources, except those explicitly excluded.

#### Arguments:
- `exclude`: *(Array, optional)* â€“ A list of resource names to be excluded.

#### Example:

```ruby
section "App", icon: "heroicons/outline/beaker" do
  group "Resources", icon: "resources" do
    all_resources exclude: [:users, :orders]
  end
end
```

In the example above, all resources will be rendered except `Avo::Resources::Users` and `Avo::Resources::Orders`.

</Option>

<Option name="`all_dashboards`">

Renders all dashboards, except those explicitly excluded.

#### Arguments:
- `exclude`: *(Array, optional)* â€“ A list of dashboard names to be excluded.

#### Example:

```ruby
section "App", icon: "heroicons/outline/beaker" do
  group "Dashboards", icon: "dashboards" do
    all_dashboards exclude: [:sales, :analytics]
  end
end
```

In this example, all dashboards will be rendered except `Avo::Resources::Sales` and `Avo::Resources::Analytics`.

</Option>

<Option name="`all_tools`">

Renders all tools.

```ruby
section "App", icon: "heroicons/outline/beaker" do
  group "All tools", icon: "tools" do
    all_tools
  end
end
```

</Option>

### `all_` helpers

```ruby
section "App", icon: "heroicons/outline/beaker" do
  group "Dashboards", icon: "dashboards" do
    all_dashboards
  end

  group "Resources", icon: "resources" do
    all_resources
  end

  group "All tools", icon: "tools" do
    all_tools
  end
end
```

:::warning
The `all_resources` helper is taking into account your [authorization](#authorization) rules, so make sure you have `def index?` enabled in your resource policy.
:::

<Image src="/assets/img/menu-editor/all-helpers.jpg" width="254" height="732" alt="Avo menu editor" />

## Item visibility

The `visible` option is available on all menu items. It can be a boolean or a block that has access to a few things:

- the `current_user`. Given that you [set a way](#authentication) for Avo to know who the current user is, that will be available in that block call
- the [`context`](#customization) object.
- the `params` object of that current request
- the [`view_context`](https://apidock.com/rails/AbstractController/Rendering/view_context) object. The `view_context` object lets you use the route helpers. eg: `view_context.main_app.posts_path`.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.main_menu = -> {
    resource :user, visible: -> do
      context[:something] == :something_else
    end
  }
end
```

## Add `data` attributes to items

<VersionReq version="2.16" />

You may want to add special data attributes to some items and you can do that using the `data` option. For example you may add `data: {turbo: false}` to make a regular request for a link.

```ruby{4}
# config/initializers/avo.rb
Avo.configure do |config|
  config.main_menu = -> {
    resource :user, data: {turbo: false}
  }
end
```

## Using authorization rules

When you switch from a generated menu to a custom one, you might want to keep using the same authorization rules as before. To quickly do that, use the `authorize` method in the `visible` option.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.main_menu = -> {
    resource :team, visible: -> do
      # authorize current_user, MODEL_THAT_NEEDS_TO_BE_AUTHORIZED, METHOD_THAT_NEEDS_TO_BE_AUTHORIZED
      authorize current_user, Team, "index?", raise_exception: false
    end
  }
end
```

## Icons

For [`Section`](#section)s, you can use icons to make them look better. You can use some local ones that we used throughout the app and all [heroicons](https://heroicons.com/) designed by [Steve Schoger](https://twitter.com/steveschoger). In addition, you can use the `solid` or `outline` versions. We used the `outline` version throughout the app.

```ruby
section "Resources", icon: "heroicons/outline/academic-cap" do
  resource :course
end

section "Resources", icon: "heroicons/solid/finger-print" do
  resource :course
end

section "Resources", icon: "heroicons/outline/adjustments" do
  resource :course
end
```

<Image src="/assets/img/menu-editor/icons.jpg" width="253" height="328" alt="Avo menu editor" />

### Icons on resource, dashboard, and link_to items

You can add icons to other menu items like `resource`, `dashboard`, and `link_to`.

```ruby
link_to "Avo", "https://avohq.io", icon: "globe"
```

## Collapsable sections and groups

When you have a lot of items they can take up a lot of vertical space. You can choose to make those sidebar sections collapsable by you or your users.

```ruby
section "Resources", icon: "resources", collapsable: true do
  resource :course
end
```

<Image src="/assets/img/menu-editor/collapsable.jpg" width="250" height="182" alt="Avo menu editor" />

That will add the arrow icon next to the section to indicate it's collapsable. So when your users collapse and expand it, their choice will be stored in Local Storage and remembered in that browser.

### Default collapsed state

You can however, set a default collapsed state using the `collapsed` option.

```ruby
section "Resources", icon: "resources", collapsable: true, collapsed: true do
  resource :course
end
```

<Image src="/assets/img/menu-editor/collapsed.jpg" width="250" height="182" alt="Avo menu editor" />

You might want to allow your users to hide certain items from view.

## Authorization

<DemoVideo demo-video="https://youtu.be/Eex8CiinQZ8?t=373" />

If you use the [authorization feature](#authorization), you will need an easy way to authorize your items in the menu builder.
For that scenario, we added the `authorize` helper.

```ruby{3}
Avo.configure do |config|
  config.main_menu = -> {
    resource :team, visible: -> {
      # authorize current_user, THE_RESOURCE_MODEL, THE_POLICY_METHOD, raise_exception: false
      authorize current_user, Team, "index?", raise_exception: false
    }
  }
end
```

Use it in the `visible` block by giving it the `current_user` (which is available in that block), the class of the resource, the method that you'd like to authorize for (default is `index?`), and tell it not to throw an exception.

Now, the item visibility will use the `index?` method from the `TeamPolicy` class.

## Profile menu

The profile menu allows you to add items to the menu displayed in the profile component. **The sign-out link is automatically added for you.**

You may add the `icon` option to the `profile_menu` links.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.profile_menu = -> {
    link_to "Profile", path: "/profile", icon: "user-circle"
  }
end
```

<Image src="/assets/img/menu-editor/profile-menu.png" width="276" height="192" alt="Avo profile menu" />

## Forms in profile menu

It's common to have forms that `POST` to a path to do sign ut a user. For this scenario we added the `method` and `params` option to the profile item `link_to`, so if you have a custom sign out path you can do things like this.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.profile_menu = -> {
    link_to "Sign out", path: main_app.destroy_user_session_path, icon: "user-circle", method: :post, params: {custom_param: :here}
  }
end
```

## Custom content in the profile menu

You might, however, want to add a very custom form or more items to the profile menu. For that we prepared the `_profile_menu_extra.html.erb` partial for you.

```bash
bin/rails generate avo:eject --partial :profile_menu_extra
```

This will eject the partial and you can add whatever custom content you might need.

```erb
<%# Example link below %>
<%#= render Avo::ProfileItemComponent.new label: 'Profile', path: '/profile', icon: 'user-circle' %>
```



# Record previews

:::warning
This section is a work in progress.
:::

To use record previews add the `preview` field on your resource and add `show_on: :preview` to the fields you'd like to have visible on the preview popover.


```ruby{3,7,11,14}
class Avo::Resources::Team < Avo::BaseResource
  def fields
    field :preview, as: :preview
    field :name,
     as: :text,
     sortable: true,
     show_on: :preview
    field :color,
      as: Avo::Fields::ColorPickerField,
      hide_on: :index,
      show_on: :preview
    field :description,
      as: :textarea,
      show_on: :preview
  end
end
```
<Image src="/assets/img/3_0/record-previews/preview-field.png" width="1328" height="1000" alt="" />



# Resource tools

Similar to adding custom fields to a resource, you can add custom tools. A custom tool is a partial added to your resource's `Show` and `Edit` views.

## Generate a resource tool

Run `bin/rails generate avo:resource_tool post_info`. That will create two files. The configuration file `app/avo/resource_tools/post_info.rb` and the partial file `app/views/avo/resource_tools/_post_info.html.erb`.

The configuration file holds the tool's name and the partial path if you want to override it.

```ruby
class Avo::ResourceTools::PostInfo < Avo::BaseResourceTool
  self.name = "Post info"
  # self.partial = "avo/resource_tools/post_info"
end
```

The partial is ready for you to customize further.

```erb
<div class="flex flex-col">
  <%= render Avo::PanelComponent.new title: "Post info" do |c| %>
    <% c.with_tools do %>
      <%= a_link('/avo', icon: 'heroicons/solid/academic-cap', style: :primary) do %>
        Dummy link
      <% end %>
    <% end %>

    <% c.with_body do %>
      <div class="flex flex-col p-4 min-h-24">
        <div class="space-y-4">
          <h3>ðŸª§ This partial is waiting to be updated</h3>

          <p>
            You can edit this file here <code class="p-1 rounded bg-gray-500 text-white text-sm">app/views/avo/resource_tools/post_info.html.erb</code>.
          </p>

          <p>
            The resource tool configuration file should be here <code class="p-1 rounded bg-gray-500 text-white text-sm">app/avo/resource_tools/post_info.rb</code>.
          </p>

          <%
            # In this partial, you have access to the following variables:
            # tool
            # @resource
            # @resource.model
            # form (on create & edit pages. please check for presence first)
            # params
            # Avo::Current.context
            # current_user
          %>
        </div>
      </div>
    <% end %>
  <% end %>
</div>
```

<Image src="/assets/img/resource-tools/resource-tool-partial.png" width="2034" height="470" alt="Avo resource tool partial" />

## Partial context

You might need access to a few things in the partial.

You have access to the `tool`, which is an instance of your tool `PostInfo`, and the `@resource`, which holds all the information about that particular resource (`view`, `model`, `params`, and others), the `params` of the request, the `Avo::Current.context` and the `current_user`.
That should give you all the necessary data to scope out the partial content.

## Tool visibility

The resource tool is default visible on the `Show` view of a resource. You can change that using the [visibility options](#field-options) (`show_on`, `only_on`).

```ruby
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  def fields
    tool Avo::ResourceTools::PostInfo, show_on: :edit
  end
end
```

### Using path helpers

Because you're in a Rails engine, you will have to prepend the engine object to the path.

#### For Avo paths

Instead of writing `resources_posts_path(1)` you have to write `avo.resources_posts_path(1)`.

#### For the main app paths

When you want to reference paths from your main app, instead of writing `posts_path(1)`, you have to write `main_app.posts_path`.

## Add custom fields on forms

**From Avo 2.12**

You might want to add a few more fields or pieces of functionality besides the CRUD-generated fields on your forms. Of course, you can already create new [custom fields](#custom-fields) to do it in a more structured way, but you can also use a resource tool to achieve more custom behavior.

You have access to the `form` object that is available on the new/edit pages on which you can attach inputs of your choosing. You can even achieve nested form functionality.

You have to follow three steps to enable this functionality:

1. Add the inputs in a resource tool and enable the tool on the form pages
2. Tell Avo which `params` it should permit to write to the model
3. Make sure the model is equipped to receive the params

In the example below, we'll use the `Avo::Resources::Fish`, add a few input fields (they will be a bit unstyled because this is not the scope of the exercise), and do some actions with some of them.

We first need to generate the tool with `bin/rails g avo:resource_tool fish_information` and add the tool to the resource file.

```ruby{3}
class Avo::ResourcesFish < Avo::BaseResource
  def fields
    tool Avo::ResourceTools::FishInformation, show_on: :forms
  end
end
```

In the `_fish_information.html.erb` partial, we'll add a few input fields. Some are directly on the `form`, and some are nested with `form.fields_for`.

The fields are:

- `fish_type` as a text input
- `properties` as a multiple text input which will produce an array in the back-end
- `information` as nested inputs which will produce a `Hash` in the back-end

```erb{13-36}
<!-- _fish_information.html.erb -->
<div class="flex flex-col">
  <%= render Avo::PanelComponent.new(title: @resource.model.name) do |c| %>
    <% c.with_tools do %>
      <%= a_link('/admin', icon: 'heroicons/solid/academic-cap', style: :primary) do %>
        Primary
      <% end %>
    <% end %>

    <% c.with_body do %>
      <div class="flex flex-col p-4 min-h-24">
        <div class="space-y-4">
          <% if form.present? %>
            <%= form.label :fish_type %>
            <%= form.text_field :fish_type, value: 'default type of fish', class: input_classes %>
            <br>

            <%= form.label :properties %>
            <%= form.text_field :properties, multiple: true, value: 'property 1', class: input_classes %>
            <%= form.text_field :properties, multiple: true, value: 'property 2', class: input_classes %>
            <br>

            <% form.fields_for :information do |information_form| %>
              <%= form.label :information_name %>
              <%= information_form.text_field :name, value: 'information name', class: input_classes %>
              <div class="text-gray-600 mt-2 text-sm">This is going to be passed to the model</div>
              <br>
              <%= form.label :information_history %>
              <%= information_form.text_field :history, value: 'information history', class: input_classes %>
              <div class="text-gray-600 mt-2 text-sm">This is going to be passed to the model</div>
              <br>
              <%= form.label :information_age %>
              <%= information_form.text_field :age, value: 'information age', class: input_classes %>
              <div class="text-gray-600 mt-2 text-sm">This is NOT going to be passed to the model</div>
            <% end %>
          <% end %>
        </div>
      </div>
    <% end %>
  <% end %>
</div>
```

Next, we need to tell Avo and Rails which params are welcomed in the `create`/`update` request. We do that using the `extra_params` option on the `Avo::Resources::Fish`. Avo's internal implementation is to assign the attributes you specify here to the underlying model (`model.assign_attributes params.permit(extra_params)`).

```ruby{2}
class Avo::Resources::Fish < Avo::BaseResource
  self.extra_params = [:fish_type, :something_else, properties: [], information: [:name, :history]]

  def fields
    tool Avo::ResourceTools::FishInformation, show_on: :forms
  end
end
```

The third step is optional. You must ensure your model responds to the params you're sending. Our example should have the `fish_type`, `properties`, and `information` attributes or setter methods on the model class. We chose to add setters to demonstrate the params are called to the model.

```ruby
class Fish < ApplicationRecord
  self.inheritance_column = nil # required in order to use the type DB attribute

  def fish_type=(value)
    self.type = value
  end

  def properties=(value)
    # properties should be an array
    puts ["properties in the Fish model->", value].inspect
  end

  def information=(value)
    # properties should be a hash
    puts ["information in the Fish model->", value].inspect
  end
end
```

If you run this code, you'll notice that the `information.information_age` param will not reach the `information=` method because we haven't allowed it in the `extra_params` option.

## Where to add logic

It's a good practice not to keep login in view files (partials).
You can hide that logic inside the tool using instance variables and methods, and access it in the partial using the `tool` variable.

[Here's an example](https://github.com/avo-hq/main.avodemo.com/commit/c8ecb9b53a770103a993df4c2b3acec0a1faf737) on how you could do that.

```ruby{8,10}
class Avo::ResourceTools::PostInfo < Avo::BaseResourceTool
  self.name = "Post info"
  # self.partial = "avo/resource_tools/post_info"

  attr_reader :foo

  def initialize(**kwargs)
    super **kwargs # It's important to call super with the same keyword arguments

    # You'll have access to the following objects:
    # resource - when attached to a resource
    # parent - which is the object it's attached to (resource if attached to a resource)
    # view

    @foo = :bar # Add your variables
  end

  def custom_method_call
    :called
  end
end
```

```erb{7,12}
<div class="flex flex-col">
  <%= render Avo::PanelComponent.new title: "Post info" do |c| %>

    <% c.with_body do %>
      <p>
        This variable was declared in the initializer:
        <%= tool.foo %>
      </p>

      <p>
        This is a method called on the tool:
        <%= tool.custom_method_call %>
      </p>
    <% end %>
  <% end %>
</div>
```



# Scopes

<Image src="/assets/img/scopes.png" width="862" height="636" alt="" />

:::warning
This section is a work in progress.
:::

Sometimes you might need to segment your data beyond just a few filters. You might have an `User` resource but you frequently need to see all the **Active users** or **Admin users**. You can use a filter for that or add a scope.

## Generating scopes

```bash
bin/rails generate avo:scope admins
```

```ruby
# app/avo/scopes/admins.rb
class Avo::Scopes::Admins < Avo::Advanced::Scopes::BaseScope
  self.name = "Admins" # Name displayed on the scopes bar
  self.description = "Admins only" # This is the tooltip value
  self.scope = :admins # valid scope on the model you're using it
  self.visible = -> { true } # control the visibility
end

# app/models/user.rb
class User < ApplicationRecord
  scope :admins, -> { where role: :admin } # This is used in the scope file above
end
```

## Registering scopes

Because scopes are re-utilizable, you must manually add that scope to a resource using the `scope` method inside the `scopes` method.


```ruby
class Avo::Resources::User < Avo::BaseResource
  def scopes
    scope Avo::Scopes::Admins
  end
end
```

## Remove `All` scope

If you don't want to have the `All` default scope you can remove it by executing the `remove_scope_all` method inside `scopes` method.

```ruby
class Avo::Resources::User < Avo::BaseResource
  def scopes
    remove_scope_all
    scope Avo::Scopes::Admins
  end
end
```

## Options

The scope classes take a few options.

<Option name="`name`">

This value is going to be displayed on the scopes bar as the name of the scope.

This can be a callable value and it receives the `resource` and `query` objects.

The `query` object can be used to compute and display the record count.

Please see [the recipe](#display-scope-record-count) on how to enable it.
</Option>

<Option name="`description`">

This value is going to be displayed when the user hovers over the scope.

This can be a callable value and it receives the `resource` and `query` objects.
</Option>

<Option name="`scope`">

The scope you return here is going to be applied to the query of records on that page.

You can use a symbol which will indicate the scope on that model or a block which will have the `query` available so you can apply any modifications you need.

```ruby
class Avo::Scopes::EvenId < Avo::Advanced::Scopes::BaseScope
  self.name = "Even"
  self.description = "Only records that have an even ID."
  self.scope = -> { query.where("#{resource.model_key}.id % 2 = ?", "0") }
  self.visible = -> { true }
end
```
</Option>

<Option name="`visible`">

From this block you can show, hide, and authorize the scope on the resource.
</Option>

<Option name="`default`">

<VersionReq version="3.11" />

The `default` option lets you select a default scope that is applied when you
navigate to the resources page.

```ruby{4}
def scopes
  scope Avo::Scopes::OddId
  # EvenId scope is applied as default
  scope Avo::Scopes::EvenId, default: true
end
```

You can also use it as a block, the `default` block executes within the [`ExecutionContext`](#execution-context), granting access to all default methods and attributes.:

```ruby{3}
def scopes
  scope Avo::Scopes::OddId
  scope Avo::Scopes::EvenId, default: -> { current_user.admin? }
end
```
</Option>


# Table View

The table view is the default way to display resources in Avo. It provides a powerful, tabular layout that supports searching, sorting, filtering, and pagination out of the box.

<Image src="/assets/img/table-view.png" width="1919" height="1122" alt="Table view" />

## Row controls configuration
:::info
The configuration options for row controls depend on the version of Avo you are using.

**If you are using a version earlier than <Version version="3.16.3" />**, refer to the following pages for guidance:

- [How to adjust resource controls globally for all resources](#customization)
- [Customize the placement of controls for individual resources](#resources)
:::

By default, resource controls are positioned on the right side of record rows. However, if the table contains many columns, these controls may become obscured. In such cases, you may prefer to move the controls to the left side for better visibility.

<VersionReq version="3.16.3" /> Avo provides configuration options that allow you to customize row controls placement, floating behavior, and visibility on hover either globally or individually for each resource.


## Global configuration

`resource_row_controls_config` defines the default settings for row controls across all resources. These global configurations will apply to each resource unless explicitly overridden.

This option can be configured on `config/initializers/avo.rb` and defaults to the following:

```ruby{3-7}
# config/initializers/avo.rb
Avo.configure do |config|
  config.resource_row_controls_config = {
    placement: :right,
    float: false,
    show_on_hover: false
  }
end
```

## Resource configuration

`row_controls_config` allows you to customize the row controls for a specific resource, overriding the global configuration.

This option can be configured individually for each resource and defaults to the global configuration value defined in `resource_row_controls_config`.


```ruby{3-7}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  self.row_controls_config = {
    placement: :right,
    float: false,
    show_on_hover: false,
  }
end
```

<Option name="`placement`">

Defines the position of the row controls.

##### Optional

`true`

##### Default value

`:right`

#### Possible values

- `:left` - Places the controls on the **left side** of the resource row.
- `:right` - Places the controls on the **right side** of the resource row.
- `:both` - Displays controls on **both sides** of the resource row.


:::warning
The `float` and `show_on_hover` options are designed to function optimally when `placement` is set to `:right`. While Avo does not restrict its usage with `:left` or `:both`, the applied styles are specifically intended for use with `:right`, and unexpected behavior may occur with other placements.
:::
</Option>

<Option name="`float`">

Determines whether the row controls should float over the row.

<DemoVideo demo-video="https://youtu.be/wnWvzQyyo6A?t=698" class="mb-4" />

##### Optional

`true`

##### Default value

`false`

#### Possible values

- `true` - Enables floating behavior.
- `false` - Disables floating behavior (default).
</Option>

<Option name="`show_on_hover`">

Controls whether the row controls should be displayed only on hover.

##### Optional

`true`

##### Default value

`false`

#### Possible values

- `true` - Displays the controls on hover only.
- `false` - Always shows the controls (default).
</Option>



# TailwindCSS 4 Migration Guide

## Overview
Avo will fully transition to TailwindCSS 4. To facilitate a smooth migration process, Avo `3.18.x` (which uses TailwindCSS 3) will continue to be maintained alongside a parallel version, `3.18.x.tw4`, which incorporates TailwindCSS 4.

**We strongly encourage you to utilize the `3.18.x.tw4` version as a testing ground for the migration. By doing so, you can identify potential issues, provide feedback, and ensure a seamless transition before the official release of Avo with TailwindCSS4.**

This guide outlines the necessary steps to migrate to TailwindCSS 4, addressing two distinct scenarios:

1. **Projects without a TailwindCSS pipeline**
    - These setups do not have an existing TailwindCSS configuration
    - This is the case for most projects
    - There isn't much action to take
2. **Projects with an existing TailwindCSS pipeline**
    - These projects already utilize TailwindCSS.
    - Will need to adjust their configurations accordingly.

Each of these cases will be discussed in detail in their respective sections.

:::warning
Additionally, a dedicated section highlights [breaking changes](#tailwindcss-4-breaking-changes) that apply universally, regardless of your current TailwindCSS setup. Understanding these changes is crucial to ensure compatibility and avoid disruptions.
:::

Proceed to the following sections to determine the appropriate migration path for your project.

## Use the `3.18.x.tw4` version

:::info
`x` is the patch version, it can be `0`, `1`, `2`, etc., depending on the number of patch releases in the `3.18` minor version.

Each patch release will have both the TailwindCSS 3 and the TailwindCSS 4 versions of the gem.

Example:

```bash
# 3.18.0
# TailwindCSS 3 version
gem "avo", "3.18.0"
# TailwindCSS 4 version
gem "avo", "3.18.0.tw4"

# 3.18.1
# TailwindCSS 3 version
gem "avo", "3.18.1"
# TailwindCSS 4 version
gem "avo", "3.18.1.tw4"
```
:::

To test TailwindCSS 4, ensure you are using the following versions:

```bash
gem "avo", "3.18.x.tw4"
```

If you're utilizing `avo-rhino_field`, you must lock its version to `0.0.12.tw4`.

```ruby
gem "avo-rhino_field", "0.0.12.tw4"
```

Add the appropriate entry to your `Gemfile`, depending on your tier:
```ruby
# Avo Community
gem "avo", "3.18.x.tw4"

# Avo Pro
gem "avo", "3.18.x.tw4"
gem "avo-pro", "3.18.x", source: "https://packager.dev/avo-hq/"

# Avo Advanced
gem "avo", "3.18.x.tw4"
gem "avo-advanced", "3.18.x", source: "https://packager.dev/avo-hq/"
```

To report any issue please leave a comment [here](https://github.com/avo-hq/avo/pull/3632).

## Projects without a TailwindCSS pipeline

If you don't have a TailwindCSS pipeline, which should be the case for most cases, there isn't much to do besides following the steps in the [Use the `3.18.x.tw4` version](#use-the-3-18-x-tw4-version) section and address the [TailwindCSS 4 breaking changes](#tailwindcss-4-breaking-changes) below.

After, you can use the `3.18.x.tw4` version of the gem and it will work just fine and ready for the Avo with TailwindCSS 4 release.


## You do have a TailwindCSS pipeline

If you have a TailwindCSS pipeline, the first required step is to update the TailwindCSS version to 4.x.

After that, navigate to `config/avo/tailwind.config.js` and remove the `content` entry:

```ruby
# config/avo/tailwind.config.js
const avoPreset = require('../../tmp/avo/tailwind.preset.js')

module.exports = {
  presets: [avoPreset],
  content: [ # [!code --]
    ...avoPreset.content, # [!code --]
    './app/views/**/*.html.erb', # [!code --]
    './app/helpers/**/*.rb', # [!code --]
    './app/javascript/**/*.js', # [!code --]
    './app/components/avo/**/*.html.erb', # [!code --]
  ], # [!code --]
}
```

Then, update `app/assets/stylesheets/avo/avo.tailwind.css` with the following changes:

```css
/* app/assets/stylesheets/avo/avo.tailwind.css */
@import 'tailwindcss/base'; /* [!code --] */
@import 'tailwindcss'; /* [!code ++] */
/* Have all of Avo's custom and plugins styles available. */
@import '../../../../tmp/avo/avo.base.css';
@import 'tailwindcss/components'; /* [!code --] */
@import 'tailwindcss/utilities'; /* [!code --] */

/*

@layer components {
  .btn-primary {
    @apply py-2 px-4 bg-blue-200;
  }
}

*/
```

Additionally, remove the following files:

- `app/assets/stylesheets/avo/tailwindcss/base.css`
- `app/assets/stylesheets/avo/tailwindcss/components.cs`
- `app/assets/stylesheets/avo/tailwindcss/utilities.css`

Finally, relocate `app/assets/stylesheets/application.tailwind.css` to `app/assets/tailwind/application.css`.

You can accomplish this by executing the following command:

```bash
git mv app/assets/stylesheets/application.tailwind.css app/assets/tailwind/application.css
```

Once these steps are completed, your TailwindCSS pipeline should be fully migrated and ready for Avo `3.19.0`.

Review the complete set of changes we made to upgrade our demo app, which includes a custom TailwindCSS pipeline:

- [Pull Request #3](https://github.com/avo-hq/ticketing.avodemo.com/pull/3)
- [Commit 539c643](https://github.com/avo-hq/ticketing.avodemo.com/commit/539c64322f53fa2070a641303f5d289b7cb2e6a3)

## TailwindCSS 4 breaking changes

TailwindCSS 4 introduces several breaking changes that might affect your application. While we highlight some common changes below, we strongly recommend reviewing the [official TailwindCSS 4 upgrade guide](https://tailwindcss.com/docs/upgrade-guide) for a comprehensive list of changes.

You need to apply this changes on all the Avo related custom components that you have in your application. That includes:

- Custom fields
- Resource tools
- Custom tools
- Custom cards
- Ejected components

### Renamed Utilities

TailwindCSS 4 has renamed several utilities to make them more consistent and predictable.

We'll highlight the most common use-case encountered in the Avo codebase, please refer to the whole [Renamed Utilities list](https://tailwindcss.com/docs/upgrade-guide#renamed-utilities) for more details.

| TailwindCSS 3 Utility | TailwindCSS 4 Utility |
|------------|------------|
| rounded-sm | rounded-xs |
| rounded | rounded-sm |
| ... | ... |

For example, update your code from:

```html
<div class="rounded-sm"> <!-- TailwindCSS 3 -->  // [!code --]
<div class="rounded-xs"> <!-- TailwindCSS 4 --> // [!code ++]
  Content
</div>

<div class="rounded"> <!-- TailwindCSS 3 -->  // [!code --]
<div class="rounded-sm"> <!-- TailwindCSS 4 --> // [!code ++]
  Content
</div>
```

:::tip
If you're applying global search and bulk replace do the `rounded-sm` to `rounded-xs` transition first, then do the `rounded` to `rounded-sm` transition.
:::

### Default Border Color

In TailwindCSS 4, the default border color has changed from `gray-200` to `currentColor`. This affects both `border-*` and `divide-*` utilities. You'll need to explicitly specify border colors where you previously relied on the default.

For example, update your code from:

```html
<div class="border p-4"> <!-- TailwindCSS 3 -->  // [!code --]
<div class="border border-gray-200 p-4"> <!-- TailwindCSS 4 --> // [!code ++]
  Content with default gray border
</div>
```

:::tip
Do a global search for `border` and `divide` and verify where they have any implicit color borders. Add the `border-gray-200` and `divide-gray-200` classes to the elements that don't have an explicit color.
:::





# HTML attributes

Using the `html` option you can attach `style`, `classes`, and `data` attributes. The `style` attribute adds the `style` tag to your element, `classes` adds the `class` tag, and the `data` attribute the `data` tag to the element you choose.

Pass the `style` and `classes` attributes as strings, and the `data` attribute a Hash.

```ruby{4-11}
field :name, as: :text, html: {
  edit: {
    wrapper: {
      style: "background: red; text: white;" # string
      classes: "absolute h-[41px] w-full" # string
      data: {
        action: "input->resource-edit#toggle",
        resource_edit_toggle_target_param: "skills_tags_wrapper",
      } # Hash
    }
  }
}
```


## Declare the fields from the outside in

When you add these attributes, you need to think from the outside in. So first the `view` (`index`, `show`, or `edit`), next the element to which you add the attribute (`wrapper`, `label`, `content` or `input`), and then the attribute `style`, `classes`, or `data`.

**The `edit` value will be used for both the `Edit` and `New` views.**

There are two notations through which you can attach the attributes; `object` or `block` notation.

## The `object` notation

This is the simplest way of attaching the attribute. You usually use this when you want to add _static_ content and params.

```ruby{3-9}
field :has_skills,
  as: :boolean,
  html: {
    edit: {
      wrapper: {
        classes: "hidden"
      }
    }
  }
```

In this example, we're adding the `hidden` class to the field wrapper on the `Edit` and `New` views.

## The `block` notation

You can use the' block' notation if you need to do a more complex transformation to add your attributes. You'll have access to the `params`, `current_user`, `record`, and `resource` variables. It's handy in multi-tenancy scenarios and when you need to scope out the information across accounts.

```ruby{3-18}
field :has_skills,
  as: :boolean,
  html: -> do
    edit do
      wrapper do
        classes do
          "hidden"
        end
        data do
          if current_user.admin?
            {
              action: "click->admin#do_something_admin"
            }
          else
            {
              record: record,
              resource: resource,
            }
          end
        end
      end
    end
  end
```

For the `data`, `style`, and `classes` options, you may use the `method` notation alongside the block notation for simplicity.

```ruby{6,7}
field :has_skills,
  as: :boolean,
  html: -> do
    edit do
      wrapper do
        classes("hidden")
        data({action: "click->admin#do_something_admin"})
      end
    end
  end
```

## Where are the attributes added?

You can add attributes to the wrapper element for the `index`, `show`, or `edit` blocks.

<Option name="Index field wrapper">

```ruby
field :name, as: :text, html: {
  index: {
    wrapper: {}
  }
}
```

<Image src="/assets/img/stimulus/index-field-wrapper.jpg" width="1642" height="864" alt="Index field wrapper" />

</Option>

<Option name="Show field wrapper">

```ruby
field :name, as: :text, html: {
  show: {
    wrapper: {}
  }
}
```

<Image src="/assets/img/stimulus/show-field-wrapper.jpg" width="763" height="331" alt="Show field wrapper" />

</Option>
<Option name="Show label target">

```ruby
field :name, as: :text, html: {
  show: {
    label: {}
  }
}
```

<Image src="/assets/img/stimulus/show-label-target.jpg" width="763" height="331" alt="Show label target" />

</Option>
<Option name="Show content target">

```ruby
field :name, as: :text, html: {
  show: {
    content: {}
  }
}
```

<Image src="/assets/img/stimulus/show-content-target.jpg" width="763" height="331" alt="Show content target" />

</Option>
<Option name="Edit field wrapper">

```ruby
field :name, as: :text, html: {
  edit: {
    wrapper: {}
  }
}
```

<Image src="/assets/img/stimulus/edit-field-wrapper.jpg" width="1634" height="766" alt="Edit field wrapper" />

</Option>
<Option name="Edit label target">

```ruby
field :name, as: :text, html: {
  edit: {
    label: {}
  }
}
```

<Image src="/assets/img/stimulus/edit-label-target.jpg" width="763" height="331" alt="Edit label target" />

</Option>
<Option name="Edit content target">

```ruby
field :name, as: :text, html: {
  edit: {
    content: {}
  }
}
```

<Image src="/assets/img/stimulus/edit-content-target.jpg" width="763" height="331" alt="Edit content target" />

</Option>
<Option name="Edit input target">

```ruby
field :name, as: :text, html: {
  edit: {
    input: {}
  }
}
```

<Image src="/assets/img/stimulus/edit-input-target.jpg" width="1646" height="784" alt="Index field wrapper" />


</Option>


# Getting Started

Avo is a tool that helps developers and teams build apps 10x faster. It takes the things we always build for every app and abstracts them in familiar configuration files.

It has three main parts:

1. [The CRUD UI](#_1-the-crud-ui)
2. [Dashboards](#_2-dashboards)
3. [The custom content](#_3-the-custom-content)

## 1. The CRUD UI

If before, we built apps by creating layouts, adding controller methods to extract _data_ from the database, display it on the screen, worrying how we present it to the user, capture the users input as best we can and writing logic to send that data back to the database, Avo takes a different approach.

It only needs to know what kind of data you need to expose and what type it is. After that, it takes care of the rest.
You **tell it** you need to manage Users, Projects, Products, or any other types of data and what properties they have; `first_name` as `text`, `birthday` as `date`, `cover_photo` as `file` and so on.

There are the basic fields like [text](#text), [textarea](#textarea), [select](#select) and [boolean](#boolean), and the more complex ones like [trix](#trix), [markdown](#markdown), [gravatar](#gravatar), and [boolean_group](#boolean-group). There's even an amazing [file](#file) field that's tightly integrated with `Active Storage`. **You've never added files integration as easy as this before.**

## 2. Dashboards

Most apps need a way of displaying the stats in an aggregated form. Using the same configuration-based approach, Avo makes it so easy to display data in metric cards, charts, and even lets you take over using partial cards.

## 3. Custom content
Avo is a shell in which you develop your app. It offers a familiar DSL to configure the app you're building, but sometimes you might have custom needs. That's where the custom content comes in.

You can extend Avo in different layers. For example, in the CRUD UI, you may add [Custom fields](#custom-fields) that slot in perfectly in the current panels and in each view. You can also add [Resource tools](#resource-tools) to control the experience using standard Rails partials completely.

You can even create [Custom tools](#custom-pages-custom-tools) where you can add all the content you need using Rails partials or View Components.

Most of the places where records are listed like [Has many associations](#has-many), [attach modals](#belongs_to), [search](#search), and more are scopable to meet your multi-tenancy scenarios.

Most of the views you see are exportable using the [`eject` command](#eject).

StimulusJS is deeply baked into the CRUD UI and helps you extend the UI and make a complete experience for your users.

## Seamless upgrades

Avo comes packaged as a [gem](https://rubygems.org/gems/avo). Therefore, it does not pollute your app with its internal files. Instead, everything is tucked away neatly in the package.

That makes for a beautiful upgrade experience. You hit `bundle update avo` and get the newest and best of Avo without any file conflicts.

## Next up

Please take your time and read the documentation pages to see how Avo interacts with your app and how one should use it.

<!-- 1. [Rails and Hotwire](#avo-rails-hotwire)
1. [Installation](#installation)
1. [Authentication](#authentication)
1. [Authorization](#authorization) -->
1. [Install Avo in your app](#installation)
1. [Set up the current user](#authentication)
1. [Create a Resource](#resources)
1. [Set up authorization](#authorization)
1. [Set up licensing](#licensing)
1. [Explore the live demo app](https://main.avodemo.com/)
1. Explore these docs
1. Enjoy building your app without ever worrying about the admin layer ever again
1. Explore the [FAQ](#faq) pages for guides on how to set up your Avo instance.

## Walkthrough videos

### Build a blog admin panel

<br/>

<div class="aspect-video">
  <iframe width="100%" height="100%" src="https://www.youtube.com/embed/WgNK-oINFww" title="Build a production-ready blog admin panel" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

### Build a booking app

<br/>

<div class="aspect-video">
  <iframe width="100%" height="100%" src="https://www.youtube.com/embed/BK47E7TMXn0" title="Build a booking app in less than an hour" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>


# Reserved model names and routes

When defining models in an Avo-powered application, certain names should be avoided as they are used by Avoâ€™s internal controllers. Using these names may lead to conflicts, routing issues, or unexpected behavior.

## Model names to avoid

Avo uses the following names for its internal controllers:

- `action`
- `application`
- `association`
- `attachment`
- `base_application`
- `base`
- `chart`
- `debug`
- `home`
- `private`
- `resource`
- `search`

Using these names for models may override built-in functionality, cause routing mismatches, or introduce other conflicts.

## Why these names are reserved

Avo relies on these names for its controller and routing system. For example:
- `resource` is essential for managing Avo resources.
- `chart` is used for analytics and visualizations.
- `search` handles search functionality.

Since Avo dynamically maps models and controllers, using these names may interfere with how Avo processes requests and displays resources.

## Alternative approaches

If your application requires one of these names, consider the following alternatives:
- **Use a prefix or suffix**
  - `user_resource` instead of `resource`
  - `advanced_search` instead of `search`
- **Choose a synonym**
  - `graph` instead of `chart`

### Using Avo with existing models

If your application already has models with these names, you can generate an Avo resource with a different name while keeping the same model class.

For example for `Resource` run the following command:

```sh
bin/rails generate avo:resource user_resource --model-class resource
```

This will generate:

- `Avo::Resources::UserResource`
- `Avo::UserResourcesController`

However, it will still use the existing `Resource` model, ensuring no conflicts arise.

## Route Conflicts with `resources :resources`

If your application has a route definition like:

```ruby
resources :resources
```

This will create path helpers such as `resources_path`, which **conflicts with [Avoâ€™s internal routing helpers](https://github.com/avo-hq/avo/blob/main/app/helpers/avo/url_helpers.rb#L3)**. Avo uses `resources_path` internally, and having this route in your application **will override Avoâ€™s default helpers**, potentially breaking parts of the admin panel.

### How to Fix It

To prevent conflicts, rename the route helpers to something more specific:

```ruby
resources :resources, as: 'articles'
```

This allows you to maintain the desired URL structure (`/resources`) without interfering with Avoâ€™s internals.


# Internals

This section documents on how we think about the internals of Avo and hwo much you could/should hook into them to extend it.

### Public Methods and Internal Usage

Not all public methods within the Avo codebase are meant for direct user consumption. Some methods are publicly accessible but primarily intended for internal use by various components of the Avo framework itself. This distinction arises due to the complex nature of building a framework or an ecosystem of gems, where numerous moving parts require public interfaces for framework developers rather than for end users.



# Plugins

:::warning
This feature is in beta and we might change the API as we develop it.

These docs are in beta too, so please [ask for more information](https://github.com/avo-hq/avo/discussions) when you need it.
:::

## Overview

Plugins are a way to extend the functionality of Avo.

### Light layer

We are in the early days of the plugin system and we're still figuring out the best way to do it. This is why we have a light layer that you can use to extend the functionality of Avo.

This means we provide two hooks that you can use to extend the functionality of the Rails app, and a few Avo APIs to add scrips and stylesheets.

## Register the plugin

The way we do it is through an initializer. We mostly use the `engine.rb` file to register the plugin.

```ruby{8-15}
# lib/avo/feed_view/engine.rb
module Avo
  module FeedView
    class Engine < ::Rails::Engine
      isolate_namespace Avo::FeedView

      initializer "avo-feed-view.init" do
        # Avo will run this hook on boot time
        ActiveSupport.on_load(:avo_boot) do
          # Register the plugin
          Avo.plugin_manager.register :feed_view

          # Register the mounting point
          Avo.plugin_manager.mount_engine Avo::FeedView::Engine, at: "/feed_view"
        end
      end
    end
  end
end
```

This will add the plugin to a list of plugins which Avo will run the hooks on.

## Hook into Avo

```ruby
module Avo
  module FeedView
    class Engine < ::Rails::Engine
      isolate_namespace Avo::FeedView

      initializer "avo-feed-view.init" do
        ActiveSupport.on_load(:avo_boot) do
          Avo.plugin_manager.register :feed_view

          # Add some concerns
          Avo::Resources::Base.include Avo::FeedView::Concerns::FeedViewConcern

          # Remove some concerns
          Avo::Resources::Base.included_modules.delete(Avo::Concerns::SOME_CONCERN)

          # Add asset files to be loaded by Avo
          # These assets will be added to Avo's `application.html.erb` layout file
          Avo.asset_manager.add_javascript "/avo-advanced-assets/avo_advanced"
          Avo.asset_manager.add_stylesheet "/avo-kanban-assets/avo_kanban"
        end

        ActiveSupport.on_load(:avo_init) do
          # Run some code on each request
          Avo::FeedView::Current.something = VALUE
        end
      end
    end
  end
end
```

## Hooks

<Option name="`avo_boot`">

The `avo_boot` hook is called when the parent Rails application boots up. This is where you can register your scripts and stylesheets and also add your functionality to Avo.

We use it heavily to add our own concerns to the `Avo::BaseResource` and `Avo::BaseController` classes and even extend the `Avo::ApplicationController` class.

</Option>

<Option name="`avo_init`">

The `avo_init` hook is called on every request done inside Avo. You can use this hook to attach some code to the `Avo::App.context` object or do other things.

:::info
We don't use it as much in our plugins as we do in the `avo_boot` hook.
:::

</Option>

## Avo `AssetManager`

We use the `AssetManager` to add our own asset files (JavaScript and CSS) to be loaded by Avo. They will be added in the `<head>` section of Avo's layout file.

It has two methods:

<Option name="`add_javascript`">

```ruby
Avo.asset_manager.add_javascript "/avo-kanban-assets/avo_kanban"
```

This snippet will add the `/avo-kanban-assets/avo_kanban.js` file to the `<head>` section of Avo's layout file.

</Option>

<Option name="`add_stylesheet`">

```ruby
Avo.asset_manager.add_stylesheet "/avo-kanban-assets/avo_kanban"
```

This snippet will add the `/avo-kanban-assets/avo_kanban.css` file to the `<head>` section of Avo's layout file.

</Option>

## Using a middleware to surface asset files

One tricky thing to do with Rails Engines is to expose some asset files to the parent Rails app.
The way we do it is by using a middleware that will serve the files from the Engine's `app/assets/builds` directory.

So `app/assets/builds/feed_view.js` from the `feed_view` engine will be served by the parent Rails app at `/feed-view-assets/feed_view.js` with the following middleware added to your `engine.rb` file.

```ruby
module Avo
  module FeedView
    class Engine < ::Rails::Engine
      isolate_namespace Avo::FeedView

      initializer "avo-feed-view.init" do
        ActiveSupport.on_load(:avo_boot) do
          Avo.plugin_manager.register :feed_view
        end
      end

      config.app_middleware.use(
        Rack::Static,
        urls: ["/feed-view-assets"], # ðŸ‘ˆ This is the path where the files will be served
        root: root.join("app", "assets", "builds") # ðŸ‘ˆ This is the path where the files are located
      )
    end
  end
end
```

:::info
Avo doesn't compile the assets in any way, but just adds them to the layout file. This means that the assets should be compiled and ready for the browser to use them.

We use [`jsbundling-rails`](https://github.com/rails/jsbundling-rails)  with `esbuild` to compile the assets before packaging them in the `gem` file.

Please check out [the scripts](https://github.com/avo-hq/avo/blob/main/package.json) we use.
:::

## Create your own plugin

We don't yet have a generator for that but what we do is to create a new Rails Engine and add the plugin to it.

1. Run `rails plugin new feed-view`
1. Add the plugin to the `engine.rb` file
1. Register the plugin to the `lib/avo/feed_view/engine.rb` file
1. Optionally add assets
1. Add the plugin to your app's `Gemfile` using the `path` option to test it out



# Records ordering

A typical scenario is when you need to set your records into a specific order. Like re-ordering `Slide`s inside a `Carousel` or `MenuItem`s inside a `Menu`.

The `ordering` class attribute is your friend for this. You can set four actions `higher`, `lower`, `to_top` or `to_bottom`, and the `display_inline` and `visible_on` options.
The actions are simple lambda functions but coupled with your logic or an ordering gem, and they can be pretty powerful.

## Configuration

I'll demonstrate the ordering feature using the `acts_as_list` gem.

Install and configure the gem as instructed in the [tutorials](https://github.com/brendon/acts_as_list#example). Please ensure you [give all records position attribute values](https://github.com/brendon/acts_as_list#adding-acts_as_list-to-an-existing-model), so the gem works fine.

Next, add the order actions like below.

```ruby
class Avo::Resources::CourseLink < Avo::BaseResource
  self.ordering = {
    visible_on: :index,
    actions: {
      higher: -> { record.move_higher },
      lower: -> { record.move_lower },
      to_top: -> { record.move_to_top },
      to_bottom: -> { record.move_to_bottom },
    }
  }
end
```

The `record` is the actual instantiated model. The `move_higher`, `move_lower`, `move_to_top`, and `move_to_bottom` methods are provided by `acts_as_list`. If you're not using that gem, you can add your logic inside to change the position of the record.

The actions have access to `record`, `resource`, `options` (the `ordering` class attribute) and `params` (the `request` params).

That configuration will generate a button with a popover containing the ordering buttons.

<Image src="/assets/img/resources/ordering_hover.jpg" width="1058" height="550" alt="Avo ordering" />

## Always show the order buttons

If the resource you're trying to update requires re-ordering often, you can have the buttons visible at all times using the `display_inline: true` option.

```ruby
class Avo::Resources::CourseLink < Avo::BaseResource
  self.ordering = {
    display_inline: true,
    visible_on: :index,
    actions: {
      higher: -> { record.move_higher },
      lower: -> { record.move_lower },
      to_top: -> { record.move_to_top },
      to_bottom: -> { record.move_to_bottom },
    }
  }
end
```

<Image src="/assets/img/resources/ordering_visible.jpg" width="1055" height="546" alt="Avo ordering" />

## Display the buttons in the `Index` view or association view

A typical scenario is to have the order buttons on the <Index /> view or a resource. That's the default value for the `visible_on` option.

```ruby{3}
class Avo::Resources::CourseLink < Avo::BaseResource
  self.ordering = {
    visible_on: :index,
  }
end
```

## Display the button on a `has_many` association

Another scenario is to order the records only in the scope of a parent record, like order the `MenuItems` for a `Menu`, or `Slides` for a `Slider`. So you wouldn't need to have the order buttons on the <Index /> view but only in the association section (in a has many association).

To control that, you can use the `visible_on` option and set it to `:association`.

```ruby{3}
class Avo::Resources::CourseLink < Avo::BaseResource
  self.ordering = {
    visible_on: :association,
  }
end
```

### Possible values

The possible values for the `visible_on` option are `:index`, `:association` or `[:index, :association]` for both views.

## Change the scope on the `Index` view

Naturally, you'll want to apply the `order(position: :asc)` condition to your query. You may do that in two ways.

1. Add a `default_scope` to your model. If you're using this ordering scheme only in Avo, then, this is not the recommended way, because it will add that scope to all queries for that model and you probably don't want that.

2. Use the [`index_query`](https://docs.avohq.io/3.0/customization.html#custom-query-scopes) to alter the query in Avo.

```ruby{2-4}
class Avo::Resources::CourseLink < Avo::BaseResource
  self.index_query = -> {
    query.order(position: :asc)
  }

  self.ordering = {
    display_inline: true,
    visible_on: :index, # :index or :association
    actions: {
      higher: -> { record.move_higher }, # has access to record, resource, options, params
      lower: -> { record.move_lower },
      to_top: -> { record.move_to_top },
      to_bottom: -> { record.move_to_bottom }
    }
  }
end
```

## Reorder using drag and drop

<BetaStatus label="Beta"></BetaStatus>

Sometimes just picking up a record and dropping it in the position that you'd like it to be. That's exactly what this feature does.

It's disabled by default but you can enable it by adding `drag_and_drop: true` and `insert_at` options to the `self.ordering` hash.

```ruby{5,11}
self.ordering = {
  display_inline: true,
  visible_on: %i[index association], # :index or :association or both
  # position: -> { record.position },
  drag_and_drop: true,
  actions: {
    higher: -> { record.move_higher }, # has access to record, resource, options, params
    lower: -> { record.move_lower },
    to_top: -> { record.move_to_top },
    to_bottom: -> { record.move_to_bottom },
    insert_at: -> { record.insert_at position }
  }
}
```

### Custom `position` attribute

Using the `position` option you can specify the record's `position` attribute. The default is `record.position`.

```ruby{4}
self.ordering = {
  display_inline: true,
  visible_on: %i[index association], # :index or :association or both
  position: -> { record.position_in_list },
  drag_and_drop: true,
  actions: {
    higher: -> { record.move_higher }, # has access to record, resource, options, params
    lower: -> { record.move_lower },
    to_top: -> { record.move_to_top },
    to_bottom: -> { record.move_to_bottom },
    insert_at: -> { record.insert_at position }
  }
}
```

## Authorization

If you're using the [authorization](#authorization) feature please ensure you give the proper permissions using the [`reorder?`](#authorization) method.

```ruby
class CourseLinkPolicy < ApplicationPolicy
  def reorder? = edit?

  # or a custom permission

  def reorder?
    user.can_reorder_items?
  end

  # other policy methods
end
```


# Resource options

Avo effortlessly empowers you to build an entire customer-facing interface for your Ruby on Rails application. One of the most powerful features is how easy you can administer your database records using the CRUD UI.

## Overview

Similar to how you configure your database layer using the Rails models and their DSL, Avo's CRUD UI is configured using `Resource` files.

Each `Resource` maps out one of your models. There can be multiple `Resource`s associated to the same model if you need that.

All resources are located in the `app/avo/resources` directory.

## Resources from model generation

```bash
bin/rails generate model car make:string mileage:integer
```

Running this command will generate the standard Rails files (model, controller, etc.) and `Avo::Resources::Car` & `Avo::CarsController` for Avo.

The auto-generated resource file will look like this:

```ruby
# app/avo/resources/car.rb
class Avo::Resources::Car < Avo::BaseResource
  self.includes = []
  # self.search = {
  #   query: -> { query.ransack(id_eq: params[:q], m: "or").result(distinct: false) }
  # }

  def fields
    field :id, as: :id
    field :make, as: :text
    field :mileage, as: :number
  end
end
```

This behavior can be omitted by using the argument `--skip-avo-resource`. For example if we want to generate a `Car` model but no Avo counterpart we should use the following command:

```bash
bin/rails generate model car make:string kms:integer --skip-avo-resource
```

## Manually defining resources

```bash
bin/rails generate avo:resource post
```

This command will generate the `Post` resource file in `app/avo/resources/post.rb` with the following code:

```ruby
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  self.includes = []
  # self.search = {
  #   query: -> { query.ransack(id_eq: params[:q], m: "or").result(distinct: false) }
  # }

  def fields
    field :id, as: :id
  end
end
```

From this config, Avo will infer a few things like the resource's model will be the `Post` model and the name of the resource is `Post`. But all of those inferred things are actually overridable.

Now, let's say we already have a model `Post` well defined with attributes and associations. In that case, the Avo resource will be generated with the fields attributes and associations.

::: code-group

```ruby [app/models/post.rb]
# == Schema Information
#
# Table name: posts
#
#  id           :bigint           not null, primary key
#  name         :string
#  body         :text
#  is_featured  :boolean
#  published_at :datetime
#  user_id      :bigint
#  created_at   :datetime         not null
#  updated_at   :datetime         not null
#  status       :integer          default("draft")
#
class Post < ApplicationRecord
 enum status: [:draft, :published, :archived]

 validates :name, presence: true

 has_one_attached :cover_photo
 has_one_attached :audio
 has_many_attached :attachments

 belongs_to :user, optional: true
 has_many :comments, as: :commentable
 has_many :reviews, as: :reviewable

 acts_as_taggable_on :tags
end
```

```ruby [app/avo/resources/post.rb]
class Avo::Resources::Post < Avo::BaseResource
  self.includes = []
  # self.search = {
  #   query: -> { query.ransack(id_eq: params[:q], m: "or").result(distinct: false) }
  # }

  def fields
    field :id, as: :id
    field :name, as: :text
    field :body, as: :textarea
    field :is_featured, as: :boolean
    field :published_at, as: :datetime
    field :user_id, as: :number
    field :status, as: :select, enum: ::Post.statuses
    field :cover_photo, as: :file
    field :audio, as: :file
    field :attachments, as: :files
    field :user, as: :belongs_to
    field :comments, as: :has_many
    field :reviews, as: :has_many
    field :tags, as: :tags
  end
end
```

:::

It's also possible to specify the resource model class. For example, if we want to create a new resource named `MiniPost` resource using the `Post` model we can do that using the following command:

```bash
bin/rails generate avo:resource mini-post --model-class post
```

That command will create a new resource with the same attributes as the post resource above with specifying the `model_class`:

```ruby
class Avo::Resources::MiniPost < Avo::BaseResource
  self.model_class = "Post"
end
```

:::info
You can see the result in the admin panel using this URL `/avo`. The `Post` resource will be visible on the left sidebar.
:::

## Fields

`Resource` files tell Avo what records should be displayed in the UI, but not what kinds of data they hold. You do that using the `fields` method.

Read more about the fields [here](#fields).

```ruby{5-17}
class Avo::Resources::Post < Avo::BaseResource
  self.title = :id
  self.includes = []

  def fields
    field :id, as: :id
    field :name, as: :text, required: true
    field :body, as: :trix, placeholder: "Add the post body here", always_show: false
    field :cover_photo, as: :file, is_image: true, link_to_record: true
    field :is_featured, as: :boolean

    field :is_published, as: :boolean do
      record.published_at.present?
    end

    field :user, as: :belongs_to, placeholder: "â€”"
  end
end
```

## Routing

Avo will automatically generate routes based on the resource name when generating a resource.

```
Avo::Resources::Post         -> /avo/resources/posts
Avo::Resources::PhotoComment -> /avo/resources/photo_comments
```

If you change the resource name, you should change the generated controller name too.

## Use multiple resources for the same model

Usually, an Avo Resource maps to one Rails model. So there will be a one-to-one relationship between them. But there will be scenarios where you'd like to create another resource for the same model.

Let's take as an example the `User` model. You'll have an `User` resource associated with it.

```ruby
# app/models/user.rb
class User < ApplicationRecord
end

# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  self.title = :name

  def fields
    field :id, as: :id, link_to_record: true
    field :email, as: :gravatar, link_to_record: true, as_avatar: :circle
    field :first_name, as: :text, required: true, placeholder: "John"
    field :last_name, as: :text, required: true, placeholder: "Doe"
  end
end
```

<Image src="/assets/img/resources/model-resource-mapping-1.jpg" width="2048" height="1280" alt="" />

So when you click on the Users sidebar menu item, you get to the `Index` page where all the users will be displayed. The information displayed will be the gravatar image, the first and the last name.

Let's say we have a `Team` model with many `User`s. You'll have a `Team` resource like so:

```ruby{12}
# app/models/team.rb
class Team < ApplicationRecord
end

# app/avo/resources/team.rb
class Avo::Resources::Team < Avo::BaseResource
  self.title = :name

  def fields
    field :id, as: :id, link_to_record: true
    field :name, as: :text
    field :users, as: :has_many
  end
end
```

From that configuration, Avo will figure out that the `users` field points to the `User` resource and will use that one to display the users.

But, let's imagine that we don't want to display the gravatar on the `has_many` association, and we want to show the name on one column and the number of projects the user has on another column.
We can create a different resource named `TeamUser` resource and add those fields.

```ruby
# app/avo/resources/team_user.rb
class Avo::Resources::TeamUser < Avo::BaseResource
  self.title = :name

  def fields
    field :id, as: :id, link_to_record: true
    field :name, as: :text
    field :projects_count, as: :number
  end
end
```

We also need to update the `Team` resource to use the new `TeamUser` resource for reference.

```ruby
# app/avo/resources/team.rb
class Avo::Resources::Team < Avo::BaseResource
  self.title = :name

  def fields
    field :id, as: :id, link_to_record: true
    field :name, as: :text
    field :users, as: :has_many, use_resource: Avo::Resources::TeamUser
  end
end
```

<Image src="/assets/img/resources/model-resource-mapping-2.jpg" width="1524" height="714" alt="" />

But now, if we visit the `Users` page, we will see the fields for the `TeamUser` resource instead of `User` resource, and that's because Avo fetches the resources in an alphabetical order, and `TeamUser` resource is before `User` resource. That's definitely not what we want.
The same might happen if you reference the `User` in other associations throughout your resource files.

To mitigate that, we are going to use the `model_resource_mapping` option to set the "default" resource for a model.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.model_resource_mapping = {
    'User': 'Avo::Resources::User'
  }
end
```

That will "shortcircuit" the regular alphabetical search and use the `User` resource every time we don't specify otherwise.

We can still tell Avo which resource to use in other `has_many` or `has_and_belongs_to_many` associations with the [`use_resource`](#has_many) option.

## Namespaced resources

`Resource`s can't be namespaced yet, so they all need to be in the root level of that directory. If you have a model `Super::Dooper::Trooper::Model` you can use `Avo::Resources::SuperDooperTrooperModel` with the `model_class` option.

```ruby
class Avo::Resources::SuperDooperTrooperModel < Avo::BaseResource
  self.model_class = "Super::Dooper::Trooper::Model"
end
```

## Views

Please read the detailed [views](#views) page.


## Extending `Avo::ResourcesController`

You may need to execute additional actions on the `ResourcesController` before loading the Avo pages. You can create an `Avo::BaseResourcesController` and extend your resource controller from it.

```ruby
# app/controllers/avo/base_resources_controller.rb
class Avo::BaseResourcesController < Avo::ResourcesController
  include AuthenticationController::Authentication

  before_action :is_logged_in?
end

# app/controllers/avo/posts_controller.rb
class Avo::PostsController < Avo::BaseResourcesController
end
```

:::warning
You can't use `Avo::BaseController` and `Avo::ResourcesController` as **your base controller**. They are defined inside Avo.
:::

When you generate a new resource or controller in Avo, it won't automatically inherit from the `Avo::BaseResourcesController`. However, you have two approaches to ensure that the new generated controllers inherit from a custom controller:

### `--parent-controller` option on the generators
Both the `avo:controller` and `avo:resource` generators accept the `--parent-controller` option, which allows you to specify the controller from which the new controller should inherit. Here are examples of how to use it:

```bash
rails g avo:controller city --parent-controller Avo::BaseResourcesController
rails g avo:resource city --parent-controller Avo::BaseResourcesController
```

### `resource_parent_controller` configuration option
You can configure the `resource_parent_controller` option in the `avo.rb` initializer. This option will be used to establish the inherited controller if the `--parent-controller` argument is not passed on the generators. Here's how you can do it:

```ruby
Avo.configure do |config|
  # ...
  config.resource_parent_controller = "Avo::BaseResourcesController" # "Avo::ResourcesController" is default value
  # ...
end
```

### Attach concerns to `Avo::BaseController`

Alternatively you can use [this guide](https://avohq.io/blog/safely-extend-a-ruby-on-rails-controller) to attach methods, actions, and hooks to the main `Avo::BaseController` or `Avo::ApplicationController`.


## Manually registering resources

In order to have a more straightforward experience when getting started with Avo, we are eager-loading the `app/avo/resources` directory.
That makes all those resources available to your app without you doing anything else.

If you want to manually load them use the `config.resources` option.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.resources = [
    "Avo::Resources::User",
    "Avo::Resources::Fish",
  ]
end
```

This tells Avo which resources you use and stops the eager-loading process on boot-time.
This means that other resources that are not declared in this array will not show up in your app.

## Extending `Avo::BaseResource`

<VersionReq version="3.10.7" /> we have restructured the `Avo::BaseResource` to enhance user customization capabilities. The existing functionality has been moved to a new base class `Avo::Resources::Base`, and `Avo::BaseResource` is now left empty for user overrides. This allows users to easily add custom methods that all of their resources will inherit, without having to modify the internal base class.

### How to Customize `Avo::BaseResource`

You can customize `Avo::BaseResource` by creating your own version in your application. This custom resource can include methods and logic that you want all your resources to inherit. Here's an example to illustrate how you can do this:

```ruby
# app/avo/base_resource.rb
module Avo
  class BaseResource < Avo::Resources::Base
    # Example custom method: make all number fields cast their values to float
    def field(id, **args, &block)
      if args[:as] == :number
        args[:format_using] = -> { value.to_f }
      end

      super(id, **args, &block)
    end
  end
end
```


All your resources will now inherit from your custom `Avo::BaseResource`, allowing you to add common functionality across your admin interface. For instance, the above example ensures that all number fields in your resources will have their values cast to floats. You can add any other shared methods or customizations here, making it easier to maintain consistent behavior across all resources.

### Your resource files

Your resource file will still look the same as it did before.

```ruby
# app/avo/resources/post_resource.rb
module Avo::Resources::Post < Avo::BaseResource
  # Your existing configuration for the Post resource
end
```

## Resource Options

Resources have a few options available for customization.

<Option name="`self.title`">

Each Avo resource will try to figure out what the title of a record is. It will try the following attributes in order `name`, `title`, `label`, and fallback to the `id`.

You can change it to something more specific, like the model's `first_name` or `slug` attributes.

```ruby
class Avo::Resources::Post < Avo::BaseResource
  self.title = :slug # it will now reference @post.slug to show the title
end
```

### Using a computed title

If you don't have a `title`, `name`, or `label` attribute in the database, you can add a getter method to your model where you compose the name.

```ruby{3,8-10}
# app/avo/resources/comment.rb
class Avo::Resources::Comment < Avo::BaseResource
  self.title = :tiny_name
end

# app/models/comment.rb
class Comment < ApplicationRecord
  def tiny_name
    ActionView::Base.full_sanitizer.sanitize(body).truncate 30
  end
end
```

### `title` as a block

If you prefer not to use any record methods and instead compute the resource's title directly within the resource itself, you can accomplish this by assigning a lambda function to the `title` class attribute. You'll have access to `resource` and `record`.

```ruby{3-5}
# app/avo/resources/comment.rb
class Avo::Resources::Comment < Avo::BaseResource
  self.title = -> {
    ActionView::Base.full_sanitizer.sanitize(record.body).truncate 30
  }
end
```
</Option>

<Option name="`self.description`">

You might want to display information about the current resource to your users. Then, using the `description` class attribute, you can add some text to the `Index`, `Show`, `Edit`, and `New` views.

<Image src="/assets/img/resources/description.png" width="1272" height="216" alt="Avo message" />

There are two ways of setting the description. The quick way as a `string` and the more customizable way as a `block`.

### Set the description as a string

```ruby{3}
class Avo::Resources::User < Avo::BaseResource
  self.title = :name
  self.description = "These are the users of the app."
end
```

This is the quick way to set the label, and it will be displayed **on all pages**. If you want to restrict the message to custom views, use a lambda function.

### Set the description as a block

This is the more customizable method where you can access the `record`, `resource`, `view`, `current_user`, and `params` objects.

```ruby{3-13}
class Avo::Resources::User < Avo::BaseResource
  self.title = :name
  self.description = -> do
    if view == :index
    "These are the users of the app"
    else
      if current_user.is_admin?
        "You can update all properties for this user: #{record.id}"
      else
        "You can update some properties for this user: #{record.id}"
      end
    end
  end
end
```
</Option>

<Option name="`self.includes`">

If you regularly need access to a resource's associations, you can tell Avo to eager load those associations on the `Index` view using `includes`.

That will help you avoid those nasty `n+1` performance issues.

```ruby
class Avo::Resources::Post < Avo::BaseResource
  self.includes = [:user, :tags]

  # or a very nested scenario
  self.includes = [files_attachments: :blob, users: [:comments, :teams, post: [comments: :user]]]
end
```

We know, the array notation looks weird, but it works.

</Option>

<Option name="`self.single_includes`">

`single_includes` works the same as `includes` but it's going to eager load the associations on the <Show /> and <Edit /> views only.
</Option>

<Option name="`self.attachments`">

Similar to how `includes` works, you can use `attachments` to eager load attachments on the `Index` view.

:::code-group
```ruby{2-4} [app/models/post.rb]
class Post < ApplicationRecord
  has_one_attached :cover_photo
  has_one_attached :audio
  has_many_attached :attachments
end
```

```ruby{5-7} [app/avo/resources/post.rb]
class Avo::Resources::Post < Avo::BaseResource
  self.attachments = [:cover_photo, :audio, :attachments]
end
```
:::

</Option>

<Option name="`self.single_attachments`">

`single_attachments` works the same as `attachments` but it's going to eager load the attachments on the <Show /> and <Edit /> views only.

</Option>

<Option name="`self.confirm_on_save`">

<VersionReq version="3.10.10" />
If you would like to ask for confirmation when saving a resource you can do so by setting `confirm_on_save` to `true`.

That will help add friction to the saving process, avoiding human error.

```ruby
class Avo::Resources::Post < Avo::BaseResource
  self.confirm_on_save = true
end
```

This option defaults to false

<Image src="/assets/img/customization/confirm-on-save.png" width="2494" height="845" alt="Confirm on save" />

</Option>

<Option name="`default_view_type`">

On <Index />, the most common view type is `:table`, but you might have some data that you want to display in a `:grid` or `:map`. You can change that by setting `default_view_type` to `:grid` and by adding the `grid` block.

<Image src="/assets/img/grid-view.jpg" width="1312" height="1096" alt="Avo grid view" />

```ruby{2}
class Avo::Resources::Post < Avo::BaseResource
  self.default_view_type = :grid
end
```

Find out more on the [grid view documentation page](#grid-view).

<VersionReq version="3.5.6" /> `default_view_type` become callable. Within this block, you gain access to all attributes of [`Avo::ExecutionContext`](#execution-context) along with the `resource` and `view`. Example:

```ruby
class Avo::Resources::Post < Avo::BaseResource
  self.default_view_type = -> {
    mobile_user = request.user_agent =~ /Mobile/

    mobile_user ? :table : :grid
  }
end
```

</Option>

<Option name="`self.model_class`">

For some resources you might have a model that is namespaced, or you might have a secondary resource for a model. For that scenario, you can use the `self.model_class` option to tell Avo which model to reference in that resource.

```ruby{2}
class Avo::Resources::DelayedJob < Avo::BaseResource
  self.model_class = "Delayed::Job"

  def fields
    field :id, as: :id
  end
end
```

</Option>

<Option name="`self.devise_password_optional`">

If you use `devise` and update your user models (usually `User`) without passing a password, you will get a validation error. You can use `devise_password_optional` to stop receiving that error. It will [strip out](https://stackoverflow.com/questions/5113248/devise-update-user-without-password/11676957#11676957) the `password` key from `params`.

```ruby
class Avo::Resources::User < Avo::BaseResource
  self.devise_password_optional = true
end
```

### Related

- [Password field](#password)

</Option>

<Option name="`self.visible_on_sidebar`">

When you get started, the sidebar will be auto-generated for you with all the [dashboards](#dashboards), resources, and [custom tools](#custom-pages-custom-tools).
However, you may have resources that should not appear on the sidebar, which you can hide using the `visible_on_sidebar` option.

```ruby{2}
class Avo::Resources::TeamMembership < Avo::BaseResource
  self.visible_on_sidebar = false
end
```

:::warning
This option is used in the **auto-generated menu**, not in the [menu editor](#menu-editor).

You'll have to use your own logic in the [`visible`](#menu-editor) block for that.
:::
</Option>

<Option name="`config.buttons_on_form_footers`">

If you have a lot of fields on a resource, that form might get pretty tall. So it would be useful to have the `Save` button in the footer of that form.

You can do that by setting the `buttons_on_form_footers` option to `true` in your initializer. That will add the `Back` and `Save` buttons on the footer of that form for the `New` and `Edit` screens.

```ruby{3}
# config/initializers/avo.rb
Avo.configure do |config|
  config.buttons_on_form_footers = true
end
```

<Image src="/assets/img/resources/buttons_on_footer.png" width="1276" height="594" alt="Buttons on footer" />

</Option>

<Option name="`after_create_path`/`after_update_path`">

For some resources, it might make sense to redirect to something other than the `Show` view. With `after_create_path` and `after_update_path` you can control that.

The valid options are `:show` (default), `:edit`, or `:index`.

```ruby{2-3}
class Avo::Resources::Comment < Avo::BaseResource
  self.after_create_path = :index
  self.after_update_path = :edit
end
```

### Related

You can go more granular and customize these paths or response more using controller methods.

 - [`after_create_path`](#controllers)
 - [`after_update_path`](#controllers)
 - [`after_destroy_path`](#controllers)
</Option>


<Option name="`self.record_selector`">

You might have resources that will never be selected, and you do not need that checkbox to waste your horizontal space.

You can hide it using the `record_selector` class_attribute.

```ruby{2}
class Avo::Resources::Comment < Avo::BaseResource
  self.record_selector = false
end
```

<Image src="/assets/img/resources/record_selector.png" width="688" height="361" alt="Hide the record selector." />
</Option>

<Option name="`self.link_to_child_resource`">

Let's take an example. We have a `Person` model and `Sibling` and `Spouse` models that inherit from it using Single Table Inheritance (STI).

When you declare this option on the parent resource `Person` it has the following effect. When a user is on the <Index /> view of your the `Person` resource and clicks to visit a `Person` record they will be redirected to a `Child` or `Spouse` record instead of a `Person` record.

```ruby
class Avo::Resources::Person < Avo::BaseResource
  self.link_to_child_resource = true
end
```
</Option>

<Option name="`self.keep_filters_panel_open`">

<DemoVideo demo-video="https://youtu.be/M2RsNPPFOio?t=374" />

There are scenarios where you wouldn't want to close the filters panel when you change the values. For that, you can use the `keep_filters_panel_open` resource option.

```ruby{2}
class Avo::Resources::Course < Avo::BaseResource
  self.keep_filters_panel_open = true

  def fields
    field :id, as: :id
    field :name, as: :text
  end

  def filters
    filter Avo::Filters::CourseCountryFilter
    filter Avo::Filters::CourseCityFilter
  end
end
```

<Image src="/assets/img/filters/keep-filters-panel-open.gif" width="449" height="800" alt="Avo filters" />
</Option>

<Option name="`self.components`">

By default, for each view we render an component:

[Index](#views) -> `Avo::Views::ResourceIndexComponent`<br>
[Show](#views) -> `Avo::Views::ResourceShowComponent`<br>
[New](#views), [Edit](#views) -> `Avo::Views::ResourceEditComponent`

It's possible to change this behavior by using the `self.components` resource option.

```ruby
self.components = {
  resource_index_component: Avo::Views::Users::ResourceIndexComponent,
  resource_show_component: "Avo::Views::Users::ResourceShowComponent",
  resource_edit_component: "Avo::Views::Users::ResourceEditComponent",
  resource_new_component: Avo::Views::Users::ResourceEditComponent
}
```

<VersionReq version="3.11.8" /> more components can be replaced. From this version, keys must be strings that match the original component with the exception of those from the snippet above.

Here is a list of all the supported customizable components:

```ruby
self.components = {
  "Avo::Views::ResourceIndexComponent": Avo::Custom::ResourceIndexComponent,
  "Avo::Views::ResourceShowComponent": "Avo::Custom::ResourceShowComponent",
  "Avo::Views::ResourceEditComponent": "Avo::Custom::ResourceEditComponent",
  "Avo::Index::GridItemComponent": "Avo::Custom::GridItemComponent",
  "Avo::Index::ResourceMapComponent": "Avo::Custom::ResourceMapComponent",
  "Avo::Index::ResourceTableComponent": "Avo::Custom::ResourceTableComponent",
  "Avo::Index::TableRowComponent": "Avo::Custom::TableRowComponent"
}
```


A resource configured with the example above will start using the declared components instead the default ones.

:::warning
The custom view components must ensure that their initializers are configured to receive all the arguments passed during the rendering of a component. You can verify this in our codebase through the following files:

[Index](#views) -> `app/views/avo/base/index.html.erb`<br>
[Show](#views) -> `app/views/avo/base/show.html.erb`<br>
[New](#views) -> `app/views/avo/base/new.html.erb`<br>
[Edit](#views) -> `app/views/avo/base/edit.html.erb`
:::
Creating a customized component for a view is most easily achieved by ejecting one of our pre-existing components using the `--scope` parameter. You can find step-by-step instructions in the documentation [here](#customization).

Alternatively, there is another method which requires two additional manual steps. This involves crafting a personalized component by extracting an existing one and adjusting its namespace. Although changing the namespace is not mandatory, we strongly recommend it unless you intend for all resources to adopt the extracted component.

Example:
1. Execute the command `bin/rails generate avo:eject --component Avo::Views::ResourceIndexComponent` to eject the specified component.<br><br>
2. Access the newly ejected file and adjust the namespace. You can create a fresh directory like `my_dir` and transfer the component to that directory.<br><br>
2. You have the flexibility to establish multiple directories, just ensure that the class name corresponds to the path of the directories.<br><br>
3. Update the class namespace in the file from `Avo::Views::ResourceIndexComponent` to `Avo::MyDir::Views::ResourceIndexComponent`.<br><br>
4. You can now utilize the customized component in a resource.

```ruby
self.components = {
  resource_index_component: Avo::MyDir::Views::ResourceIndexComponent
}
```

This way you can choose the whatever namespace structure you want and you assure that the initializer is accepting the right arguments.
</Option>

<Option name="`self.index_query`">

### Unscoped queries on `Index`

You might have a `default_scope` on your model that you don't want to be applied when you render the `Index` view.
```ruby{2}
class Project < ApplicationRecord
  default_scope { order(name: :asc) }
end
```

You can unscope the query using the `index_query` method on that resource.

```ruby{3}
class Avo::Resources::Project < Avo::BaseResource
  self.title = :name
  self.index_query = -> { query.unscoped }
end
```
</Option>

<Option name="`self.default_sort_column`">

<VersionReq version="3.10.7" />

By default, Avo sorts records on the <Index /> view by the `created_at` attribute. However, you can customize this behavior using the `default_sort_column` option in your resource file.

#### Default

`:created_at`

#### Possible values

Any symbol representing a sortable column in your model. If the specified column doesn't exist in the model, Avo will fall back to the default sort column (`created_at`).

```ruby
class Avo::Resources::User < Avo::BaseResource
  self.default_sort_column = :last_name

  def fields
    field :id, as: :id
    field :last_name, as: :text
  end

  # other resource configurations...
end
```

:::info
When changing the default sort column, it's recommended to add an index to that column in your database for better query performance.

```ruby
# Example migration
class AddIndexOnUsersCreatedAt < ActiveRecord::Migration[7.1]
  def change
    add_index :users, :last_name
  end
end
```
:::

**Related:**
  - [Add an index on the `created_at` column](#best-practices)
</Option>

<Option name="`self.default_sort_direction`">

<VersionReq version="3.11.5" />

By default, Avo sorts records in descending order of the [default sort column](#resources). However, you can customize this using the `self.default_sort_direction` option in your resource file.

#### Default

`:desc`

#### Possible values

Either `:desc` (descending) or `:asc` (ascending).

```ruby
class Avo::Resources::Task < Avo::BaseResource
  self.default_sort_column = :position
  self.default_sort_direction = :asc

  # ...
end
```

</Option>

<Option name="`self.controls_placement`">

<VersionReq version="3.13.7" />

:::warning
<VersionReq version="3.16.3" /> `controls_placement` option is **obsolete**.

Check [row controls configuration on table view](#table-view) instead
:::

By default, Avo renders action controls according to the `controls_placement` configuration, which is set to `right` by default. This value can be customized for each individual resource.

#### Possible values

Either `:left`, `:right` or `:both`

```ruby{3}
# app/avo/resources/task.rb
class Avo::Resources::Task < Avo::BaseResource
  self.controls_placement = :both
end
```

</Option>

<Option name="`self.pagination`">

This feature is designed for managing pagination. For example on large tables of data sometimes count is inefficient and unnecessary.

By setting `self.pagination[:type]` to `:countless`, you can disable the pagination count on the index page.

This is especially beneficial for large datasets, where displaying the total number of items and pages may have some performance impact.

```ruby
# As block:
self.pagination = -> do
  {
    type: :default,
    size: [1, 2, 2, 1],
  }
end

# Or as hash:
self.pagination = {
  type: :default,
  size: [1, 2, 2, 1],
}
```

The exposed pagination setting above have the default value for each key.

### `type`<br><br>
  #### Possible values
  `:default`, `:countless`
  #### Default
  `:default`


### `size`<br><br>
  #### Possible values
  [Pagy docs - Control the page links](https://ddnexus.github.io/pagy/docs/how-to/#control-the-page-links)
  #### Default
  `[1, 2, 2, 1]` - before <Version version="3.11.5" />

  `9` - <VersionReq version="3.11.5" />

### Examples
#### Default
```ruby
self.pagination = -> do
  {
    type: :default,
    size: [1, 2, 2, 1],
  }
end
```

<Image src="/assets/img/resources/pagination/default.png" width="1025" height="65" alt="Default pagination" />
<br><br>

#### Countless

```ruby
self.pagination = -> do
  {
    type: :countless
  }
end
```

<Image src="/assets/img/resources/pagination/countless.png" width="1030" height="67" alt="Countless pagination" />
<br><br>

#### Countless and "pageless"
```ruby
self.pagination = -> do
  {
    type: :countless,
    size: []
  }
end
```
<Image src="/assets/img/resources/pagination/countless_empty_size.png" width="1029" height="62" alt="Countless pagination size empty" />
</Option>

<Option name="`cache_hash`">

The `cache_hash` method is used to compute the cache key for each row. The method looks something like this:

```ruby
def cache_hash(parent_record)
  result = [record, file_hash]

  if parent_record.present?
    result << parent_record
  end

  result
end

def file_hash
  content_to_be_hashed = ""

  file_name = self.class.underscore_name.tr(" ", "_")
  resource_path = Rails.root.join("app", "avo", "resources", "#{file_name}.rb").to_s
  if File.file? resource_path
    content_to_be_hashed += File.read(resource_path)
  end

  # policy file hash
  policy_path = Rails.root.join("app", "policies", "#{file_name.gsub("_resource", "")}_policy.rb").to_s
  if File.file? policy_path
    content_to_be_hashed += File.read(policy_path)
  end

  Digest::MD5.hexdigest(content_to_be_hashed)
end
```

It's an md5 of the resource file name, the policy file (so the cache gets busted when the rules change). We also add the `parent_record` when it's displayed in as an association, so there's a separate cache record for each association.

This is the default, but if you have special requirements you can add it to your resource file and it will be used to cache your records accordingly.

```ruby
class Avo::Resources::User < Avo::BaseResource
  def cache_hash(parent_record)
    result = [record, file_hash, "SOMETHING_NEW"]

    if parent_record.present?
      result << parent_record
    end

    result
  end

  # fields, cards and more
end
```
</Option>

<Option name="`self.external_link`">

<VersionReq version="3.15.6" />

<br>
<br>

<Image src="/assets/img/resources/external-link.png" width="1293" height="426" alt="External link demonstration" />


It's often desirable to provide users with a link to the public path of a record outside of the Avo interface. The `external_link` option allows you to achieve this.

### Usage

To define an external link for a resource, set the `self.external_link` option with a lambda function. Within this lambda function, you gain access to all attributes of [`Avo::ExecutionContext`](#execution-context) along with the `record`.

```ruby{2-4}
class Avo::Resources::Post < Avo::BaseResource
  self.external_link = -> { # [!code focus]
    main_app.post_path(record) # [!code focus]
  } # [!code focus]
end
```

The `self.external_link` lambda should return a string representing the URL of the record.

You can use path helpers from your application (e.g., `main_app.post_path`) or any external URL generator.

When this option is configured, Avo will display an external link button for the resource. Clicking it will take the user to the specified URL.

</Option>

<Option name="`self.discreet_information`">

<VersionReq version="3.17" />

Oftern we want to show some information about records without adding another field. `discreet_information` does exactly that ðŸ™Œ

More information on [`discreet_information`](#discreet-information)

</Option>


## Cards

Use the `def cards` method to add some cards to your resource.

Check [cards documentation](#cards) for more details.

```ruby{9-19}
class Avo::Resources::User < Avo::BaseResource
  def fields
    field :id, as: :id
    field :name, as: :text
    field :email, as: :text
    field :roles, as: :boolean_group, options: {admin: "Administrator", manager: "Manager", writer: "Writer"}
  end

  def cards
    card Avo::Cards::ExampleAreaChart, cols: 3
    card Avo::Cards::ExampleMetric, cols: 2
    card Avo::Cards::ExampleMetric,
      label: "Active users metric",
      description: "Count of the active users.",
      arguments: { active_users: true },
      visible: -> { !resource.view.form? }
  end
end
```

<Image src="/assets/img/cards_on_resource.png" width="2520" height="1258" alt="Cards on resources - Avo for Rails" />



# Search

Finding what you're looking for fast is essential. That's why Avo leverages [ransack's](https://github.com/activerecord-hackery/ransack) powerful query language.

:::info
While we show you examples using `ransack`, you can use other search engines, so `ransack` is not mandatory.
:::

First, you need to add `ransack` as a dependency to your app (breaking change from Avo v1.10).

```ruby
# Gemfile
gem 'ransack'
```

## Enable search for a resource

To enable search for a resource, you need to configure the `search` class attribute to the resource file.

```ruby{2-4}
class Avo::Resources::User < Avo::BaseResource
  self.search = {
    query: -> { query.ransack(name_eq: params[:q]).result(distinct: false) }
  }
end
```

The `query` block passes over the `params` object that holds the `q` param, the actual query string. It also provides the `query` variable on which you run the query. That ensures that the [authorization scopes](#authorization) have been appropriately applied.

In this block, you may configure the search however strict or loose you need it. Check out [ransack's search matchers](https://github.com/activerecord-hackery/ransack#search-matchers) to compose the query better.

:::warning
If you're using ransack version 4 and up you must add `ransackable_attributes` and maybe more to your model in order for it to work. Read more about it [here](https://activerecord-hackery.github.io/ransack/going-further/other-notes/#authorization-allowlistingdenylisting).
:::

### Custom search provider

<VersionReq version="3.10.8" />

You can use custom search providers like Elasticsearch.
In such cases, or when you want to have full control over the search results, the `query` block should return an array of hashes. Each hash should follow the structure below:

```ruby
{
  _id: 1,
  _label: "The label",
  _url: "The URL",
  _description: "Some description about the record", # only with Avo Pro and above
  _avatar: "URL to an image that represents the record", # only with Avo Pro and above
  _avatar_type: :rounded # or :circle or :square; only with Avo Pro and above
}
```

Example:

```ruby{2-10}
class Avo::Resources::Project < Avo::BaseResource
  self.search = {
    query: -> do
      [
        { _id: 1, _label: "Record One", _url: "https://example.com/1" },
        { _id: 2, _label: "Record Two", _url: "https://example.com/2" },
        { _id: 3, _label: "Record Three", _url: "https://example.com/3" }
      ]
    end
  }
end
```

:::warning
Results count will not be available with custom search providers.
:::

## Authorize search

Search is authorized in policy files using the [`search?`](#authorization) method.

```ruby
class UserPolicy < ApplicationPolicy
  def search?
    true
  end
end
```

If the `search?` method returns false, the search operation for that resource is not going to show up in the global search and the search box on index is not going to be displayed.

If you're using `search?` already in your policy file, you can alias it to some other method in you initializer using the `config.authorization_methods` config. More about that on [the authorization page](#authorization).

```ruby
Avo.configure do |config|
  config.authorization_methods = {
    search: 'avo_search?',
  }
  end
```

## Configure the search result

<Option name="`title`">

By default, the search results will be displayed as text. By default search title will be the [resource title](#resources).

<Image src="/assets/img/search/search_blank.jpg" width="1412" height="686" alt="Blank search" />

You may configure that to be something more complex using the `item -> title` option. That will display it as the title of the search result.

```ruby{6}
class Avo::Resources::Post < Avo::BaseResource
  self.search = {
    query: -> { query.ransack(name_cont: params[:q], m: "or").result(distinct: false) },
    item: -> do
      {
        title: "[#{record.id}]#{record.name}",
      }
    end
  }
end
```

<Image src="/assets/img/search/search_label.jpg" width="1406" height="674" alt="Search label" />
</Option>

<Option name="`description`">

<LicenseReq license="pro" />

You might want to show more than just the title in the search result. Avo provides the `item -> description` option to add some more information.

```ruby{7}
class Avo::Resources::Post < Avo::BaseResource
  self.search = {
    query: -> { query.ransack(name_cont: params[:q], m: "or").result(distinct: false) },
    item:  -> do
      {
        title: "[#{record.id}]#{record.name}",
        description: record.truncated_body
      }
    end
  }
end
```

<Image src="/assets/img/search/search_description.jpg" width="1396" height="754" alt="Search description" />
</Option>

<Option name="`image_url`">

<LicenseReq license="pro" />

You may improve the results listing by adding an image to each search result. You do that by using the `item -> image_url` attribute that is an url to a image.

```ruby{8}
class Avo::Resources::Post < Avo::BaseResource
  self.search = {
    query: -> { query.ransack(name_cont: params[:q], m: "or").result(distinct: false) },
    item: -> do
      {
        title: "[#{record.id}]#{record.name}",
        description: ActionView::Base.full_sanitizer.sanitize(record.body).truncate(130),
        image_url: main_app.url_for(record.cover_photo),
      }
    end
  }
end
```

</Option>

<Option name="`image_format`">

<LicenseReq license="pro" />

The image you add to a search result can have a different format based on what you set on the `item -> image_format` attribute. You may choose between three options: `:square`, `:rounded` or `:circle`.

```ruby{9}
class Avo::Resources::Post < Avo::BaseResource
  self.search = {
    query: -> { query.ransack(name_cont: params[:q], m: "or").result(distinct: false) },
    item: -> do
      {
        title: "[#{record.id}]#{record.name}",
        description: ActionView::Base.full_sanitizer.sanitize(record.body).truncate(130),
        image_url: main_app.url_for(record.cover_photo),
        image_format: :rounded
      }
    end
  }
end
```

<Image src="/assets/img/search/search_avatar.jpg" width="1400" height="794" alt="Search avatar" />
</Option>

<Option name="`help`">

You may improve the results listing header by adding a piece of text highlighting the fields you are looking for or any other instruction for the user. You do that by using the `help` attribute. This attribute takes a string and appends it to the title of the resource.

<Image src="/assets/img/search/search_header_help.jpg" width="1620" height="538" alt="Search Header Help" />

```ruby{4}
class Avo::Resources::Post < Avo::BaseResource
  self.search = {
    query: -> { query.ransack(id_eq: params[:q], m: "or").result(distinct: false) },
    help: -> { "- search by id" }
  }
end
```
</Option>

<Option name="`result_path`">

By default, when a user clicks on a search result, they will be redirected to that record, but you can change that using the `result_path` option.

```ruby
class Avo::Resources::City < Avo::BaseResource
  self.search = {
    query: -> { query.ransack(name_eq: params[:q]).result(distinct: false) },
    result_path: -> { avo.resources_city_path record, custom: "yup" }
  }
end
```
</Option>

<Option name="`hide_on_global`">

You might have a resource that you'd like to be able to perform a search on when on its `Index` page but not have it present in the global search. You can hide it using `hide_on_global: true`.

```ruby{9}
class Avo::Resources::TeamMembership < Avo::BaseResource
  self.search = {
    query: -> { query.ransack(id_eq: params[:q], m: "or").result(distinct: false) },
    item: -> do
      {
        description: record.level,
      }
    end,
    hide_on_global: true
  }
end
```
</Option>

## Resource search

When a resource has the `search` attribute with a valid configuration, a new search input will be displayed on the `Index` view.

<Image src="/assets/img/search/resource_search.jpg" width="808" height="395" alt="" />

## Global search

<LicenseReq license="pro" />

Avo also has a global search feature. It will search through all the resources that have the `search` attribute with a valid configuration.

You open the global search input by clicking the trigger on the navbar or by using the <kbd>CMD</kbd> + <kbd>K</kbd> keyboard shortcut (<kbd>Ctrl</kbd> + <kbd>K</kbd> on Windows).

<Image src="/assets/img/search/global_search_trigger.jpg" width="960" height="76" alt="Global search trigger" />

### Hide the global search

If you, by any chance, want to hide the global search, you can do so using this setting ðŸ‘‡

```ruby{3}
# config/initializers/avo.rb
Avo.configure do |config|
  config.disabled_features = [:global_search]
end
```

Since version <Version version="3.13.5" /> `disabled_features` become callable. Within this block, you gain access to all attributes of [`Avo::ExecutionContext`](#execution-context)

```ruby{3}
# config/initializers/avo.rb
Avo.configure do |config|
  config.disabled_features = -> { current_user.is_admin? ? [] : [:global_search] }
end
```

### Scope out global or resource searches

You may want to perform different searches on the `global` search from the `resource` search. You may use the `params[:global]` flag to figure that out.


```ruby
class Avo::Resources::Order < Avo::BaseResource
  self.search = {
    query: -> {
      if params[:global]
        # Perform global search
        query.ransack(id_eq: params[:q], m: "or").result(distinct: false)
      else
        # Perform resource search
        query.ransack(id_eq: params[:q], details_cont: params[:q], m: "or").result(distinct: false)
      end
    }
  }
end
```

## Searching within associations

In some cases, you might need to search for records based on attributes of associated models. This can be achieved by adding a few things to the search query. Here's an example of how to do that:

Assuming you have two models, `Application` and `Client`, with the following associations:

```ruby{3,8}
# app/models/application.rb
class Application < ApplicationRecord
  belongs_to :client
end

# app/models/client.rb
class Client < ApplicationRecord
  has_many :applications
end
```

You can perform a search on `Application` records based on attributes of the associated `Client`. For example, searching by the client's email, name, or phone number:

```ruby{6,11-15}
# app/avo/resources/application.rb
class Avo::Resources::Application < Avo::BaseResource
  self.search = {
    query: -> {
      query
        .joins(:client)
        .ransack(
          id_eq: params[:q],
          name_cont: params[:q],
          workflow_name_cont: params[:q],
          client_id_eq: params[:q],
          client_first_name_cont: params[:q],
          client_last_name_cont: params[:q],
          client_email_cont: params[:q],
          client_phone_number_cont: params[:q],
          m: 'or'
        ).result(distinct: false)
    }
  }
end
```

In the above example, ransack is used to search for `Application` records based on various attributes of the associated `Client`, such as `client_email_cont` and `client_phone_number_cont`. The joins method is used to join the applications table with the clients table to perform the search efficiently.

This approach allows for flexible searching within associations, enabling you to find records based on related model attributes.

## Results count

<VersionReq version="3.11" />

By default, Avo displays 8 search results whenever you search. You can change the number of results displayed by configuring the `search_results_count` option:

```ruby
Avo.configure do |config|
  config.search_results_count = 16
end
```

You can also change the number of results displayed on individual resources:

```ruby{3}
class Avo::Resources::User < Avo::BaseResource
  self.search = {
    results_count: 5
    query: -> {},
  }
end
```

You can also assign a lambda to dynamically set the value.

```ruby{3}
class Avo::Resources::User < Avo::BaseResource
  self.search = {
    results_count: -> { user.admin? ? 30 : 10 }
  }
end
```

If you configure `results_count` by specifying it in the resource file then that number takes precedence over the global [`search_results_count`](#results-count) for that resource.


# Technical support

Avo is designed to be a self-serve product with [comprehensive documentation](https://docs.avohq.io) and [demo apps](#demo-apps) to be used as references.

But, even the best of us get stuck at some point and you might need a nudge in the right direction. There are a few levels of how can get help.

1. [Open Source Software Support Policy](#open-source-software-support-policy)
1. [Self-help](#self-help)
1. [Help from the official team](#official-support)

<!-- 1. [Free support](#free-support)
1. [Free chat support Thursday](#free-chat-support-thursday)
2. [Demo apps](#demo-apps)
3. [Paid support](#paid-support) -->


## Open Source Software Support

Avo's Open Source Software (OSS) support primarily revolves around assisting users with issues related to the Avo and other Avo libraries. This involves troubleshooting and providing solutions for problems originating from Avo or its related subcomponents.

However, it is crucial to understand that the OSS support does not extend to application-specific issues that do not originate from Avo or its related parts.
This includes but is not limited to:

- Incorrect application configurations unrelated to Avo.
- Conflicts with other libraries or frameworks within your application.
- Deployment issues on specific infrastructure or platforms.
- Application-specific runtime errors.
- Problems caused by third-party plugins or extensions.
- Data issues within your application.
- Issues related to application performance optimization.
- Integration problems with other services or databases.
- Design and architecture questions about your specific application.
- Language-specific issues are unrelated to Avo or other Avo libraries.

We acknowledge that understanding your specific applications and their configuration is essential, but due to the time and resource demands, this goes beyond the scope of our OSS support.

:::tip Enhanced support
For users seeking assistance with application-specific issues, we offer a few paid technical support plans. These subscriptions provide comprehensive support, including help with application-specific problems.

1. Priority chat support
2. Advanced hands-on support

For more information about our support plans, please visit [this](https://avohq.io/support) page.

:::

## Self help

This is how you can help yourself.

<Option name="1. The docs">

We work hard to ensure these documentation pages express everything Avo can do and keep them up to date.

<div class="pl-6">

#### ðŸ‘ˆ Left Sidebar

From the sidebar you can check out the major sections where we grouped up similar pieces of information.

#### ðŸ”Ž Docs Search

We use Algolia DocSearch so you can quickly find what you're looking for.

#### ðŸ“š Guides and FAQ page

We compiled a list of helpful [guides](#guides) from ourselves and the community and a few [FAQ](#faq) items for you to check out.

</div>

</Option>

<Option name="2. GitHub Issues & Discussions">

<div class="pl-6">

Avo is [LGPL-licensed](https://opensource.org/license/lgpl-3-0) and available on GitHub. We love to use [GitHub Issues](https://github.com/avo-hq/avo/issues/) to report bugs and [GitHub Discussions](https://github.com/avo-hq/avo/discussions) to receive feedback and suggestions.

There is no guarantee [w.r.t.](https://preply.com/en/question/what-does-wrt-mean-41448) response time to the reports nor is there any guarantee that issues will be resolved (e.g., fixed) within any time frame.

#### ðŸ˜± I'm in trouble

So, when you run into troubles, please go on the [issues](https://github.com/avo-hq/avo/issues?q=) section and search to see if anyone else encountered your issue and found a way to fix it.

Try out different queries as each person expresses themselves differently. Even if you don't find the exact same problem, it might give yout starting point.

#### ðŸ› I found a bug

This is the perfect oportunity to open a [GitHub issue](https://avo.cool/new-issue). GitHub Issues is the perfect feature where one can ask questions, collaborate, reference other issues or PRs, or present screenshots and videos.

It would be great if you could go through all the information that the issue asks of you (versions and others) as it will help us understand the problem better and shorten the back and forth of us asking that same information.

The second great thing about GitHub Issues is that they are searchable and enables self-help for others.

#### ðŸ“£ I have some feedback

The next best way to send us your feedback and ideas si through GitHub Discussions. Think of GitHub Discussions like our forum where folks can share their thoughts.

:::info
We prefer GitHub Issues over any other form of communication.
:::

</div>

</Option>

<Option name="3. Demo apps">

These apps have been made to showcase the technical abilities of Avo. You can browse their source-code to uncover many examples of how you can use Avo in many environments and with advanced use-cases.

The [main demo app](https://main.avodemo.com/) is a catch-all all that mimics an internal tool. It has multiple examples about Avo's support to all the edge-cases you might encounter.

The [ticketing demo app](https://ticketing.avodemo.com/) is an example of how you could build a ticketing support app for your customers completely in Avo.
It also features websockets integration for live commenting on tickets alongside a custom tool that serves as a "Settings" page.

</Option>

## Help from the official team

You sometimes need help from the authors. There are a few ways to do that.

<Option name="1. Thursday is community day">

We know that sometimes you just need to ask a quick question and a chat is the best place for that.
From our experience, few quick questions are actually quick. Most of the times the answer is "it depends", and we need more information about the problem.

The Discord server has a few channels marked `#avo-2`, `#avo-3`, `#resources`, `#front-end`, `#fields`, and more to try to narrow down the issues. There's a bot that will open up a thread after each question so please use those threads to make it easier to track the conversation.

Due to the nature of how time-consuming it is, we can't offer free tech support.
We are lucky that other community members have experience and pitch in from time to time.

On Thursday we'll be present on the Discord server where we can answer your questions.

</Option>

<Option name="2. Paid support">

<!-- Due to the nature of how time-consuming support is, we can't treat each issue the same or allocate the same amount of time.
The policy is that if it's something simple that we can figure on the spot we will happily answer. If it's something we can reproduce really quick, we will do it and answer the inquiry. -->

<!-- But there are times when we can't reproduce it quickly and more information is needed. That's when we'll ask you to provide a reproduction repository where we can troubleshoot the issue on our local machines quickly by (preferably) just running the app and going through a few provided steps. -->

<!-- When none of the above can be run and the case requires pair programming sessions, we can offer those as a separate paid service. -->

The paid support chat comes in different flavours.

If you'd like to know more about that, see our standard plans [here](https://avohq.io/support) or reach out to us on [email](mailto:adrian@avohq.io?subject=I'd%20like%20to%20know%20more%20about%20your%20Tech%20Support%20plans&body=Hi%2C%0D%0A%0D%0AMy%20name%20is%20...%2C%20I%20represent%20...%2C%20and%20I'd%20like%20to%20know%20...).

</Option>

## Reproduction repository

The easiest way for us to troubleshoot and check on an issue is to send us a reproduction repository which we can install and run in our local environments.

```bash
# run this command to get a new Rails app with Avo installed
rails new -m https://avo.cool/new.rb APP_NAME

# run to install avo-pro
rails new -m https://avo.cool/new-pro.rb APP_NAME

# run to install avo-advanced
rails new -m https://avo.cool/new-advanced.rb APP_NAME
```

<iframe width="100%" height="344" src="https://www.youtube.com/embed/_zC5Ci7t7Lo" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>



# FAQ

## Show/hide buttons throughout the admin

You might want to hide some buttons and not show them to your users. That's pretty handy using the [`Authorization`](#authorization) feature. Then, you control the display of those buttons using the policy methods.

- Show button -> `show?` method
- Edit button -> `edit?` method
- Delete button -> `destroy?` method
- Upload attachments button -> `upload_{FIELD_ID}?` method
- Download attachments button -> `download_{FIELD_ID}?` method
- Delete attachments button -> `delete_{FIELD_ID}?` method
- Attach button -> `attach_#{RESOURCE_PLURL_NAME}?` (eg: `attach_posts?`) method
- Detach button -> `detach_#{RESOURCE_PLURL_NAME}?` (eg: `detach_posts?`) method

## Why don't regular URL helpers work as expected?

When writing rails code somewhere in the Avo domain you might want to use your regular URL helpers like the below:

```ruby{2}
field :partner_home, as: :text, as_html: true do
  link_to 'Partner', partner_home_url(record)
end
```

That will not work because Avo will execute that code inside itself, a Rails engine. So per the [Rails documentation](https://guides.rubyonrails.org/engines.html#routes) you have to prepend the helper with `main_app` for it to work. Rails needs to know which engine it should find a route for. So the query becomes this ðŸ‘‡

```ruby{2}
field :partner_home, as: :text, as_html: true do
  link_to 'Partner', main_app.partner_home_url(record)
end
```

## I want to give access to different kinds of users to various resources.

You can do that using Pundit scopes and the Authorization feature. You create a policy for that resource and set the condition on the `index?` method. More on that on the [authorization](#authorization) page and Pundit's [docs](https://github.com/varvet/pundit).

Authorization is a Pro feature for Avo. Please [reach out](https://avohq.io/subscriptions/new?plan=2&trial=1) if you need a trial key to test it out.

## How can I set a homepage for the admin section

You can do that using the [home_path](#customization) configuration. You just set `config.home_path = "/avo/resources/posts"` (or whatever path you'd like) in the Avo initializer, and you're all set up. The user will be redirected to that path when navigating to `/avo`.


```ruby{8}
# config/initializers/avo.rb

Avo.configure do |config|
  config.root_path = '/avo'
  config.license_key = ENV['AVO_LICENSE_KEY']
  config.id_links_to_resource = true
  config.home_path = '/avo/resources/posts'
  config.set_context do
    {
      foo: 'bar',
      user: current_user,
      params: request.params,
    }
  end
end
```

## I want to have two different resources mapped to the same model with different types

That depends on your setup:

1. If you have [Rails STI](https://guides.rubyonrails.org/association_basics.html#single-table-inheritance-sti), then it will work. Avo knows how to handle STI models. So you'll have two models and an Avo resource for each one. That will render two resources in your admin panel's sidebar.
2. You don't have Rails STI but something custom. Then the response is it depends. Because something custom is... custom, we offer a few mechanisms to get over that.

If you have one model, `User`, you'll have one Avo resource, `Avo::Resources::User`.
Then you can customize different things based on your requirements. Like if for instance, you want to show only some types of users on the `Index` view, you can use [custom query scopes](https://docs.avohq.io/1.0/customization.html#custom-query-scopes) to hide specific types (if that's what you want to do).
Same if you want to [show/hide fields](https://docs.avohq.io/1.0/field-options.html#field-visibility) based on the resource type or type of user.

All in all **we're confident you'll have the necessary instruments** you need to build your admin.

### STI example

For **STI** you can check out the models and resources in the [demo app](https://main.avodemo.com/).

 - [person.rb](https://github.com/avo-hq/avodemo/blob/main/app/models/person.rb)
 - [spouse.rb](https://github.com/avo-hq/avodemo/blob/main/app/models/spouse.rb)
 - [person_resource.rb](https://github.com/avo-hq/avodemo/blob/main/app/avo/resources/person_resource.rb)
 - [spouse_resource.rb](https://github.com/avo-hq/avodemo/blob/main/app/avo/resources/spouse_resource.rb)

One thing you should do is for the derived model (`Spouse` in this case) add the `model_class` to [the Avo resource](https://github.com/avo-hq/avodemo/blob/main/app/avo/resources/spouse_resource.rb#L5).

## Try a pre-release version

We push pre-release versions of the gem from time to time for you to try out before pushing it to the `main` branch. To test them out, specify the exact version in your `Gemfile`.

Let's say you want to try out `1.19.1.pre.1`. You need to specify it like below ðŸ‘‡

```ruby
# Gemfile

# ... other gems

gem 'avo', '1.19.1.pre.1'
```

## The authorization features are not working

If you're having trouble with the authorization feature, make sure you have the following enabled:

- you are on a [Pro](#licensing) license
- you have set the [`current_user_method`](#authentication)
- you have reset the rails server after the above settings
- you have the pundit policy on the appropriate model

## Add custom methods/get custom data

You might want to be able to send custom data to some of the blocks you use (`default` block, computed fields, field formatters, etc.). You can use the `context` block. The block is evaluated in the `ApplicationController` so it can access the `params` and other common controller methods. More on that [here](#customization).

## Get access to the `ActionView` helper methods

For convenience sake, we capture the `view_context` for you and set it to the `Avo::App.view_context` global object. You can use all the `ActionView` methods you'd regularly use in your helpers throughout your Avo configuration.

On the `Resource` and `Field` classes, it's already delegated for you, so you can just use `view_context`.

```ruby{7,10}
class Avo::Resources::Comment < Avo::BaseResource
  def fields
    field :id, as: :id
    field :body,
      as: :textarea,
      format_using: -> do
        view_context.content_tag(:div, style: 'white-space: pre-line') { value }
      end
    field :computed_field, as: :text do
      view_context.link_to("Login", main_app.new_user_session_path)
    end
  end
end
```

## Render new lines for textarea fields

**From version 2.8**

When adding content using the `textarea` field, you might see that the newlines are not displayed on the `Show` view.

```ruby{3}
class Avo::Resources::Comment < Avo::BaseResource
  def fields
    field :body, as: :textarea
  end
end
```

<Image src="/assets/img/faq/newline/edit.png" width="1560" height="1160" alt="Render new lines" />
<Image src="/assets/img/faq/newline/default.png" width="1560" height="1160" alt="Render new lines" />

You can change how you display the information by using the `format_using` option.

### Use `simple_format`

```ruby{6}
class Avo::Resources::Comment < Avo::BaseResource
  def fields
    field :body,
      as: :textarea,
      format_using: -> do
        simple_format value
      end
  end
end
```

<Image src="/assets/img/faq/newline/simple_format.png" width="1560" height="1160" alt="Render new lines" />

### Use the `white-space: pre-line` style rule

```ruby{6}
class Avo::Resources::Comment < Avo::BaseResource
  def fields
    field :body,
      as: :textarea,
      format_using: -> do
        content_tag(:div, style: 'white-space: pre-line') { value }
      end
    end
end
```

<Image src="/assets/img/faq/newline/whitespace.png" width="1560" height="1160" alt="Render new lines" />

### Use the `whitespace-pre-line` class

```ruby{6}
class Avo::Resources::Comment < Avo::BaseResource
  def fields
    field :body,
      as: :textarea,
      format_using: -> do
        content_tag(:div, class: 'whitespace-pre-line') { value }
      end
  end
end
```

<Image src="/assets/img/faq/newline/whitespace.png" width="1560" height="1160" alt="Render new lines" />



# Field Discovery

`discover_columns` and `discover_associations` automatically detect and configure fields for your Avo resources based on your model's database structure.

```rb{6-7}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  # ...

  def fields
    discover_columns
    discover_associations
  end
end
```

<div class="aspect-video">
  <iframe width="100%" height="100%" src="https://www.youtube.com/embed/wnWvzQyyo6A?start=1475" title="Avo 3.17 - Media Library, new Markdown field &amp; the Array Adapter" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

## Options

<Option name="`only`">

Specify which fields should be discovered, excluding all others.

```rb{6-7}
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  # ...

  def fields
    discover_columns only: [:title, :body, :published_at]
    discover_associations only: [:author, :comments]
  end
end
```

##### Default value

`nil`

#### Possible values

Array of symbols representing column or association names

</Option>

<Option name="`except`">

Specify which fields should be excluded from discovery.

```rb{6-7}
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  # ...

  def fields
    discover_columns except: [:metadata, :internal_notes]
    discover_associations except: [:audit_logs]
  end
end
```

##### Default value

`nil`

#### Possible values

Array of symbols representing column or association names

</Option>

<Option name="`column_names_mapping`">

Override how specific column names are mapped to field types globally.

```rb{5-8}
# config/initializers/avo.rb
Avo.configure do |config|
  # ...

  config.column_names_mapping = {
    published_at: { field: :date_time, timezone: 'UTC' },
    role: { field: :select, enum: -> { User.roles } }
  }
end
```

##### Default value

`{}`

#### Possible values

Hash mapping column names to field configurations

</Option>

<Option name="`column_types_mapping`">

Override how database column types are mapped to field types globally.

```rb{5-8}
# config/initializers/avo.rb
Avo.configure do |config|
  # ...

  config.column_types_mapping = {
    jsonb: { field: :code, language: 'json' },
    decimal: { field: :number, decimals: 2 }
  }
end
```

##### Default value

`{}`

#### Possible values

Hash mapping database column types to field configurations

</Option>

## Examples

### Basic Discovery

```rb{6-7}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  # ...

  def fields
    discover_columns
    discover_associations
  end
end
```

### Custom Field Options

This will add the provided options to every discovered field or association. This is particularly useful when having duplicative configurations across many fields.

```rb{6-7}
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  # ...

  def fields
    discover_columns help: "Automatically discovered fields"
    discover_associations searchable: false
  end
end
```

### Combining Manual and Discovered Fields

```rb{6,8-9,11}
# app/avo/resources/project.rb
class Avo::Resources::Project < Avo::BaseResource
  # ...

  def fields
    field :custom_field, as: :text

    discover_columns except: [:custom_field]
    discover_associations

    field :another_custom_field, as: :boolean
  end
end
```

## Automatic Type Mapping

Field discovery maps database column types to Avo field types automatically.
e.g.

- `string` â†’ `:text`
- `integer` â†’ `:number`
- `float` â†’ `:number`
- `datetime` â†’ `:datetime`
- `boolean` â†’ `:boolean`
- `json/jsonb` â†’ `:code`

The full, up-to-date list can be found [here](https://github.com/avo-hq/avo/blob/main/lib/avo/mappings.rb)

## Association Discovery

The following associations are automatically configured:

- `belongs_to` â†’ `:belongs_to`
- `has_one` â†’ `:has_one`
- `has_many` â†’ `:has_many`
- `has_one_attached` â†’ `:file`
- `has_many_attached` â†’ `:files`
- `has_rich_text` â†’ `:trix`
- `acts-as-taggable-on :tags` â†’ `:tags`

The full, up-to-date list can be found [here](https://github.com/avo-hq/avo/blob/main/lib/avo/mappings.rb)



# Field options

Avo fields are dynamic and can be configured using field options.

There are quite a few **common field options** described on this page that will work with most fields (but some might not support them), and some **custom field options** that only some fields respond to that are described on each field page.


### Common field option example

```ruby
# disabled will disable the field on the `Edit` view
field :name, as: :text, disabled: true
field :status, as: :select, disabled: true
```

### Custom field option example

```ruby
# options will set the dropdown options for a select field
field :status, as: :select, options: %w[first second third]
```

## Change field name

To customize the label, you can use the `name` property to pick a different label.

```ruby
field :is_available, as: :boolean, name: "Availability"
```

<Image src="/assets/img/fields-reference/naming-convention-override.png" width="938" height="158" alt="Field naming convention override" />

## Showing / Hiding fields on different views

There will be cases where you want to show fields on different views conditionally. For example, you may want to display a field in the <New /> and <Edit /> views and hide it on the <Index /> and <Show /> views.

For scenarios like that, you may use the visibility helpers `hide_on`, `show_on`, `only_on`, and `except_on` methods. Available options for these methods are: `:new`, `:edit`, `:index`, `:show`, `:forms` (both `:new` and `:edit`) and `:all` (only for `hide_on` and `show_on`).

Version 3 introduces the `:display` option that is the opposite of `:forms`, referring to both, `:index` and `:show`

Be aware that a few fields are designed to override those options (ex: the `id` field is hidden in <Edit /> and <New />).

```ruby
field :body, as: :text, hide_on: [:index, :show]
```

Please read the detailed [views](#views) page for more info.

## Field Visibility

You might want to restrict some fields to be accessible only if a specific condition applies. For example, hide fields if the user is not an admin.

You can use the `visible` block to do that. It can be a `boolean` or a lambda.
Inside the lambda, we have access to the [`context`](#customization) object and the current `resource`. The `resource` has the current `record` object, too (`resource.record`).

```ruby
field :is_featured, as: :boolean, visible: -> { context[:user].is_admin? }  # show field based on the context object
field :is_featured, as: :boolean, visible: -> { resource.name.include? 'user' } # show field based on the resource name
field :is_featured, as: :boolean, visible: -> { resource.record.published_at.present? } # show field based on a record attribute
```

:::warning
On form submissions, the `visible` block is evaluated in the `create` and `update` controller actions. That's why you have to check if the `resource.record` object is present before trying to use it.
:::


```ruby
# `resource.record` is nil when submitting the form on resource creation
field :name, as: :text, visible -> { resource.record.enabled? }

# Do this instead
field :name, as: :text, visible -> { resource.record&.enabled? }
```

## Computed Fields

You might need to show a field with a value you don't have in a database row. In that case, you may compute the value using a block that receives the `record` (the actual database record), the `resource` (the configured Avo resource), and the current `view`. With that information, you can compute what to show on the field in the <Index /> and <Show /> views.

```ruby
field 'Has posts', as: :boolean do
  record.posts.present?
rescue
  false
end
```

:::info
Computed fields are displayed only on the <Show /> and <Index /> views.
:::

This example will display a boolean field with the value computed from your custom block.

## Fields Formatter

Sometimes you will want to process the database value before showing it to the user. You may do that using `format_using` block.

Notice that this block will have effect on **all** views.

You have access to a bunch of variables inside this block, all the defaults that [`Avo::ExecutionContext`](#execution-context) provides plus `value`, `record`, `resource`, `view` and `field`.

```ruby
field :is_writer, as: :text, format_using: -> {
  if view.form?
    value
  else
    value.present? ? 'ðŸ‘' : 'ðŸ‘Ž'
  end
}
```

This example snippet will make the `:is_writer` field generate `ðŸ‘` or `ðŸ‘Ž` emojis instead of `1` or `0` values on display views and the values `1` or `0` on form views.

<Image src="/assets/img/fields-reference/fields-formatter.png" width="943" height="156" alt="Fields formatter" />

Another example:

```ruby
field :company_url,
  as: :text,
  format_using: -> {
    if view == :new || view == :edit
      value
    else
      link_to(value, value, target: "_blank")
    end
  } do
  main_app.companies_url(record)
end
```

Since <Version version="3.20" /> `decorate` option has been available. It affects only display views. This is how the above examples would look when applying `decorate`

```ruby
field :is_writer, as: :text, decorate: -> { value.present? ? 'ðŸ‘' : 'ðŸ‘Ž' }

field :company_url,
  as: :text,
  decorate: -> {
    link_to(value, value, target: "_blank")
  } do
  main_app.companies_url(record)
end
```

## Formatting with Rails helpers

You can also format using Rails helpers like `number_to_currency` (note that `view_context` is used to access the helper):

```ruby
field :price, as: :number, format_using: -> { view_context.number_to_currency(value) }
```

## Parse value before update
When it's necessary to parse information before storing it in the database, the `update_using` option proves to be useful. Inside the block you can access the raw `value` from the form, and the returned value will be saved in the database.

```ruby
field :metadata,
  as: :code,
  update_using: -> do
    ActiveSupport::JSON.decode(value)
  end
```

## Sortable fields

One of the most common operations with database records is sorting the records by one of your fields. For that, Avo makes it easy using the `sortable` option.

Add it to any field to make that column sortable in the <Index /> view.

```ruby
field :name, as: :text, sortable: true
```

<Image src="/assets/img/fields-reference/sortable-fields.png" width="406" height="363" alt="Sortable fields" />

**Related:**
  - [Add an index on the `created_at` column](#best-practices)

## Custom sortable block

When using computed fields or `belongs_to` associations, you can't set `sortable: true` to that field because Avo doesn't know what to sort by. However, you can use a block to specify how the records should be sorted in those scenarios.

```ruby{4-7}
class Avo::Resources::User < Avo::BaseResource
  field :is_writer,
    as: :text,
    sortable: -> {
      # Order by something else completely, just to make a test case that clearly and reliably does what we want.
      query.order(id: direction)
    },
    hide_on: :edit do
      record.posts.to_a.size > 0 ? "yes" : "no"
    end
end
```

The block receives the `query` and the `direction` in which the sorting should be made and must return back a `query`.

In the example of a `Post` that `has_many` `Comment`s, you might want to order the posts by which one received a comment the latest.

You can do that using this query.

::: code-group

```ruby{5} [app/avo/resources/post.rb]
class Avo::Resources::Post < Avo::BaseResource
  field :last_commented_at,
    as: :date,
    sortable: -> {
      query.includes(:comments).order("comments.created_at #{direction}")
    }
end
```

```ruby{4-6} [app/models/post.rb]
class Post < ApplicationRecord
  has_many :comments

  def last_commented_at
    comments.last&.created_at
  end
end
```

:::

## Placeholder

Some fields support the `placeholder` option, which will be passed to the inputs on <Edit /> and <New /> views when they are empty.

```ruby
field :name, as: :text, placeholder: 'John Doe'
```

<Image src="/assets/img/fields-reference/placeholder.png" width="946" height="160" alt="Placeholder option" />

## Required
To indicate that a field is mandatory, you can utilize the `required` option, which adds an asterisk to the field as a visual cue.

Avo automatically examines each field to determine if the associated attribute requires a mandatory presence. If it does, Avo appends the asterisk to signify its mandatory status. It's important to note that this option is purely cosmetic and does not incorporate any validation logic into your model. You will need to manually include the validation logic yourself, such as (`validates :name, presence: true`).


```ruby
field :name, as: :text, required: true
```

<Image src="/assets/img/fields-reference/required.png" width="949" height="156" alt="Required option" />

<DemoVideo demo-video="https://youtu.be/peKt90XhdOg?t=937" />

You may use a block as well. It will be executed in the `Avo::ExecutionContext` and you will have access to the `view`, `record`, `params`, `context`, `view_context`, and `current_user`.

```ruby
field :name, as: :text, required: -> { view == :new } # make the field required only on the new view and not on edit
```

## Disabled

When you need to prevent the user from editing a field, the `disabled` option will render it as `disabled` on <New /> and <Edit /> views and the value will not be passed to that record in the database. This prevents a bad actor to go into the DOM, enable that field, update it, and then submit it, updating the record.


```ruby
field :name, as: :text, disabled: true
```

<Image src="/assets/img/fields-reference/readonly.png" width="953" height="164" alt="Disabled option" />


### Disabled as a block

<VersionReq version="2.14" class="mt-2" />

You may use a block as well. It will be executed in the `Avo::ExecutionContext` and you will have access to the `view`, `record`, `params`, `context`, `view_context`, and `current_user`.

```ruby
field :id, as: :number, disabled: -> { view == :edit } # make the field disabled only on the new edit view
```

## Readonly

When you need to prevent the user from editing a field, the `readonly` option will render it as `disabled` on <New /> and <Edit /> views. This does not, however, prevent the user from enabling the field in the DOM and send an arbitrary value to the database.


```ruby
field :name, as: :text, readonly: true
```

<Image src="/assets/img/fields-reference/readonly.png" width="953" height="164" alt="Readonly option" />

## Default Value

When you need to give a default value to one of your fields on the <New /> view, you may use the `default` block, which takes either a fixed value or a block.

```ruby
# using a value
field :name, as: :text, default: 'John'

# using a callback function
field :level, as: :select, options: { 'Beginner': :beginner, 'Advanced': :advanced }, default: -> { Time.now.hour < 12 ? 'advanced' : 'beginner' }
```

## Help text

Sometimes you will need some extra text to explain better what the field is used for. You can achieve that by using the `help` method.
The value can be either text or HTML.

```ruby
# using the text value
field :custom_css, as: :code, theme: 'dracula', language: 'css', help: "This enables you to edit the user's custom styles."

# using HTML value
field :password, as: :password, help: 'You may verify the password strength <a href="http://www.passwordmeter.com/">here</a>.'
```

<Image src="/assets/img/fields-reference/help-text.png" width="954" height="271" alt="Help text" />

## Nullable

When a user uses the **Save** button, Avo stores the value for each field in the database. However, there are cases where you may prefer to explicitly instruct Avo to store a `NULL` value in the database row when the field is empty. You do that by using the `nullable` option, which converts `nil` and empty values to `NULL`.

You may also define which values should be interpreted as `NULL` using the `null_values` method.

```ruby
# using default options
field :updated_status, as: :status, failed_when: [:closed, :rejected, :failed], loading_when: [:loading, :running, :waiting], nullable: true

# using custom null values
field :body, as: :textarea, nullable: true, null_values: ['0', '', 'null', 'nil', nil]
```

## Link to record

Sometimes, on the <Index /> view, you may want a field in the table to be a link to that resource so that you don't have to scroll to the right to click on the <Show /> icon. You can use `link_to_record` to change a table cell to be a link to that record.

```ruby
# for id field
field :id, as: :id, link_to_record: true

# for text field
field :name, as: :text, link_to_record: true

# for gravatar field
field :email, as: :gravatar, link_to_record: true
```

<Image src="/assets/img/fields-reference/as-link-to-resource.jpg" width="694" height="166" alt="As link to resource" />

You can add this property on [`id`](#id), [`text`](#text), and [`gravatar`](#gravatar) fields.

Optionally you can enable the global config `id_links_to_resource`. More on that on the [id links to resource docs page](#customization).

**Related:**
 - [ID links to resource](#customization)
 - [Resource controls on the left side](#customization)

## Align text on Index view

It's customary on tables to align numbers to the right. You can do that using the `html` option.

```ruby{2}
class Avo::Resources::Project < Avo::BaseResource
  field :users_required, as: :number, html: {index: {wrapper: {classes: "text-right"}}}
end
```

<Image src="/assets/img/fields/index_text_align.jpg" width="632" height="476" alt="Index text align" />

## Stacked layout

For some fields, it might make more sense to use all of the horizontal area to display it. You can do that by changing the layout of the field wrapper using the `stacked` option.

```ruby
field :meta, as: :key_value, stacked: true
```

#### `inline` layout (default)

<Image src="/assets/img/fields/field_wrapper_layout_inline.jpg" width="808" height="117" alt="" />

#### `stacked` layout

<Image src="/assets/img/fields/field_wrapper_layout_stacked.jpg" width="815" height="179" alt="" />

## Global `stacked` layout

You may also set all the fields to follow the `stacked` layout by changing the `field_wrapper_layout` initializer option from `:inline` (default) to `:stacked`.

```ruby
Avo.configure do |config|
  config.field_wrapper_layout = :stacked
end
```

Now, all fields will have the stacked layout throughout your app.

## Field options

<Option name="`components`">

The field's `components` option allows you to customize the view components used for rendering the field in all, `index`, `show` and `edit` views. This provides you with a high degree of flexibility.

### Ejecting the field components
To start customizing the field components, you can eject one or multiple field components using the `avo:eject` command. Ejecting a field component generates the necessary files for customization. Here's how you can use the `avo:eject` command:

#### Ejecting All Components for a Field

`$ rails g avo:eject --field-components FIELD_TYPE --scope admin`

Replace `FIELD_TYPE` with the desired field type. For instance, to eject components for a Text field, use:

`$ rails g avo:eject --field-components text --scope admin`

This command will generate the files for all the index, edit and show components of the Text field, for each field type the amount of components may vary.

For more advanced usage check the [eject documentation](#eject-views).

:::warning Scope
If you don't pass a `--scope` when ejecting a field view component, the ejected component will override the default components all over the project.

Check [eject documentation](#eject-views) for more details.
:::

### Customizing field components using `components` option

Here's some examples of how to use the `components` option in a field definition:

::: code-group
```ruby [Hash]
field :description,
  as: :text,
  components: {
    index_component: Avo::Fields::Admin::TextField::IndexComponent,
    show_component: Avo::Fields::Admin::TextField::ShowComponent,
    edit_component: "Avo::Fields::Admin::TextField::EditComponent"
  }
```

```ruby [Block]
field :description,
  as: :text,
  components: -> do
    {
      show_component: Avo::Fields::Admin::TextField::ShowComponent,
      edit_component: "Avo::Fields::Admin::TextField::EditComponent"
    }
  end
```
:::

The components block it's executed using `Avo::ExecutionContent` and gives access to a bunch of variables as: `resource`, `record`, `view`, `params` and more.

`<view>_component` is the key used to render the field's `<view>`'s component, replace `<view>` with one of the views in order to customize a component per each view.

:::warning Initializer
It's important to keep the initializer on your custom components as the original field view component initializer.
:::

</Option>

<Option name="`html`">

### Attach HTML attributes

Using the `html` option you can attach `style`, `classes`, and `data` attributes. The `style` attribute adds the `style` tag to your element, `classes` adds the `class` tag, and the `data` attribute the `data` tag to the element you choose.

You may find more detailed information about the HTML attributes [here](#html).

</Option>

<Option name="`summarizable`">

<Image src="/assets/img/summarizable.png" width="554" height="347" alt="Field summarizable preview" />

The `summarizable` option allows you to generate a visual summary of a column's data distribution. This feature provides a quick and intuitive overview of your dataset by displaying a chart within the table header.

You can enable `summarizable` for a column like this:

```ruby
def fields
  field :status, as: :select, summarizable: true
  field :status, as: :badge, summarizable: true
end
```

### How It Works

When `summarizable` is enabled, a chart icon will appear in the table header for that column.
Clicking on the icon will display a summary chart based on the data in that column.
The chart provides a visual representation of data distribution, making it easier to analyze trends.

</Option>

<Option name="`for_attribute`">

Allows to specify the target attribute on the model for each field. By default the target attribute is the field's id.

<!-- <VersionReq version="3.6.2" /> -->

Usage example:

```ruby
field :status, as: :select, options: [:one, :two, :three], only_on: :forms

field :secondary_field_for_status,
  as: :badge,
  for_attribute: :status,
  options: {info: :one, :success: :two, warning: :three},
  except_on: :forms,
  help: "Secondary field for status using the for_attribute option"
```
</Option>

<Option name="`meta`">

This handy option enables you to send arbitrary information to the field. It's especially useful when you're building your own [custom fields](#custom-fields) or you are using [custom components](#components) for the built-in fields.

<!-- <VersionReq version="3.10" /> -->

Usage example:

```ruby{4,9-11}
# meta as a hash
field :status,
  as: :custom_status,
  meta: {foo: :bar}

# meta as a block
field :status,
  as: :badge,
  meta: -> do
    record.statuses.map(&:id)
  end
```

Within your field template you can now access the `@field.meta` attribute.

```erb{2}
<%= field_wrapper **field_wrapper_args do %>
  <% if @field.meta[:foo] %>
    <%= @resource.record.foo_value %>
  <% else %>
    <%= @field.value %>
  <% end %>
<% end %>
```
</Option>

<Option name="`copyable`">

<VersionReq version="3.15.6" class="mt-2" />

The `copyable` option enables users to copy the field's value to their clipboard. When set to `true`, a clipboard icon appears when hovering over the field value, allowing easy copying. This feature can be particularly useful for fields such as unique identifiers, URLs, or other text-based content that users may frequently need to copy.

```ruby
field :name, as: :text, copyable: true
```

The `copyable` option is available for text-based fields such as `:text`, `:textarea`, and others that render text values.

</Option>

<Option name="`react_on`">

<VersionReq version="4.0" class="mt-2" />

The `react_on` option enables dynamic reactivity for a field when changes occur elsewhere in the form. When a specified field changes, the current field is re-evaluated, and the `@record` object is refreshed with the latest form values.

:::tip
To retrieve the original value of a field before it was changed, use the [`*_was`](https://api.rubyonrails.org/classes/ActiveModel/Dirty.html#method-i-2A_was) methods.

```ruby
# Current from form
@record.country
"USA"

# Initial value
@record.country_was
"Spain"
```
:::

#### Possible values

You can configure the field to react to:

- A single field: `:field_one`
- Multiple fields: `[:field_one, :field_two]`
- All fields in the form: `:all`

#### Example

In the example below, the `city` field is set to react whenever the `country` select field is changed. This ensures that the available city options are always relevant to the selected country.

```ruby{11}
# app/avo/resources/course.rb
class Avo::Resources::Course < Avo::BaseResource
  def fields
    field :country,
      as: :select,
      options: Course.countries,
      include_blank: "No country"

    field :city,
      as: :select,
      react_on: :country,
      options: -> { Course.cities.dig(@record.country&.to_sym) || [""] }
  end
end
```

</Option>


# Gem server authentication

Avo comes in a few tiers. The Community tier which comes as a free gem available on rubygems.org and a few paid tiers which come in private gems hosted on our own private gems server (packager.dev).

In order to have access to the paid gems you must authenticate using the **Gem Server Token** found on your [license page](https://v3.avohq.io/licenses).

There are a few ways to do that, but we will focus on the most important and secure ones for [on the server and CI systems](#on-the-server-and-ci-systems) and [on your local development environment](#on-your-local-development-environment).

:::info
We'll use the `xxx` notiation instead of the actual gem server token.
:::

## On the server and CI systems

:::info Recommendation
This is the recommended way for most use cases.
:::

The best way to do it is to register this environment variable so bundler knows to use it when pulling packages from [`packager.dev`](https://packager.dev).

```bash
export BUNDLE_PACKAGER__DEV=xxx
# or
BUNDLE_PACKAGER__DEV=xxx bundle install
```

Each hosting service will have their own way to add environment variables. Check out how to do it on [Heroku](#Heroku), [Hatchbox](#Hatchbox), [Docker](#docker_and_docker_compose), [Kamal](#Kamal) or [GitHub Actions](#git_hub_actions).

:::warning Warning about using the `.env` file
You might be tempted to add the token to your `.env` file, as you might do with your Rails app.
That will not work because `bundler` will not automatically load those environment variables.

You should add the environment variable through the service dedicated page or by running the `export` command before `bundle install`.
:::

## On your local development environment

For your local development environment you should add the token to the default bundler configuration.
This way `bundler` is aware of it without having to specify it in the `Gemfile`.

```bash
bundle config set --global https://packager.dev/avo-hq/ xxx
```

## Add Avo to your `Gemfile`

Now you are ready to add Avo to your `Gemfile`.

```ruby
# Add one of the following in your Gemfile depending on the tier you are on.

# Avo Community
gem "avo", ">= 3.2.1"

# Avo Pro
gem "avo", ">= 3.2.1"
gem "avo-pro", ">= 3.2.0", source: "https://packager.dev/avo-hq/"

# Avo Advanced
gem "avo", ">= 3.2.1"
gem "avo-advanced", ">= 3.2.0", source: "https://packager.dev/avo-hq/"
```


Now you can run `bundle install` and `bundler` will pick it up and use it to authenticate on the server.

<Option name="Heroku">

If you're using heroku, you can set the environment variable using the following command. This way `bundler` will use it when authenticating to `packager.dev`.

```bash
heroku config:set BUNDLE_PACKAGER__DEV=xxx
```
</Option>

<Option name="Hatchbox">

If you're using Hatchbox, you can set the environment variable in your apps "Environment" tab. This way `bundler` will use it when authenticating to `packager.dev`.

```yaml
BUNDLE_PACKAGER__DEV: xxx
```
</Option>

<Option name="GitHub Actions">

You might need to install Avo's paid gems in you GitHub Actions pipeline. There are two steps you need to take in order to enable that.

#### 1. Add `BUNDLE_PACKAGER__DEV` to your repository's secrets

Go in your repo, under Settings -> Secrets and Variables -> Actions -> New repository secret and add your Gem server token there with the name `BUNDLE_PACKAGER__DEV` and the token as the value.

<Image src="/assets/img/3_0/gem-server-authentication/github-actions.png" width="2462" height="1816" alt="" />
<Image src="/assets/img/3_0/gem-server-authentication/new-secret.png" width="2462" height="1816" alt="" />

#### 2. Expose `BUNDLE_PACKAGER__DEV` as an environment variable

Then, in your `test.yml` (you might have it as a different name), expose that configuration item as an environment variable.

```yml{8-9}
name: Tests

on:
  pull_request:
    branches:
      - main

env:
  BUNDLE_PACKAGER__DEV: ${{secrets.BUNDLE_PACKAGER__DEV}}

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      # Testing and deployment steps
```
</Option>

<Option name="Docker and docker compose">

You can build with docker by passing a build argument from your environment.

```dockerfile{8,10}
FROM ruby:3.2.2
RUN apt-get update -qq && apt-get install -y nodejs postgresql-client
WORKDIR /app
COPY Gemfile /app/Gemfile
COPY Gemfile.lock /app/Gemfile.lock

# get the build argument
ARG BUNDLE_PACKAGER__DEV
# make it available in the docker image
ENV BUNDLE_PACKAGER__DEV=$BUNDLE_PACKAGER__DEV

RUN bundle install
COPY . /app
# do more stuff
```

```bash
# Pass the key to the build argument
docker build --build-arg BUNDLE_PACKAGER__DEV=xxx

# OR

# Set the key as an environment variable on your machine
# Somewhere in your `.bashrc` or `.bash_profile` file
export BUNDLE_PACKAGER__DEV=xxx
# Then pass it to the build argument from there
docker build --build-arg BUNDLE_PACKAGER__DEV=$BUNDLE_PACKAGER__DEV
```

```bash
docker compose build --build-arg BUNDLE_PACKAGER__DEV=xxx
```

</Option>

<Option name="Kamal">

Kamal setup is very similar to Docker: include `BUNDLE_PACKAGER__DEV` in your secrets and then use it in your `Dockerfile`.

In your `deploy.yml`:

```yaml
# Configure builder setup.

builder:
  arch: amd64
  secrets:
    - BUNDLE_PACKAGER__DEV
```

Then in `.kamal/secrets`:

```
# However you set your secrets in Kamal
BUNDLE_PACKAGER__DEV=xxx
```

Finally, in your `Dockerfile`:

```dockerfile
# Install application gems
COPY Gemfile Gemfile.lock ./

RUN --mount=type=secret,id=BUNDLE_PACKAGER__DEV BUNDLE_PACKAGER__DEV=$(cat /run/secrets/BUNDLE_PACKAGER__DEV) bundle install  && \
    rm -rf ~/.bundle/ "${BUNDLE_PATH}"/ruby/*/cache "${BUNDLE_PATH}"/ruby/*/bundler/gems/*/.git && \
    bundle exec bootsnap precompile --gemfile
```

</Option>

## Bundle without paid gems

If you need to distribute your Rails app without the paid gems you can move them to an optional group.

```bash
RAILS_GROUPS=avo BUNDLE_WITH=avo bundle install
```

```ruby
# Gemfile
gem 'avo',

group :avo, optional: true do
  source "https://packager.dev/avo-hq/" do
    gem "avo-advanced", "~> 3.17"
  end
end
```

## FAQ

Frequently asked questions:

<Option name="`Forbidden 403`">

If you're seeing this error `Retrying download gem from https://packager.dev/avo-hq/ due to error (1/4): Gem::RemoteFetcher::FetchError bad response Forbidden 403`, this probably means that bundler does not have access to the `BUNDLE_PACKAGER__DEV` environment variable.

Please read the guides above on how to set that on your development machine and in deployment scenarios.
</Option>


# Guides

These are various guides on how to build some things with Avo or how to integrate with different pieces of tech.
Some guides have been written by us, and some by our community members.

<RecipesList />

# Videos

We regularly publish videos on our [YouTube channel](https://www.youtube.com/@avo_hq).

SupeRails featured Avo in a few of [their videos](https://superails.com/playlists/avo).



# Localization (i18n)

Avo leverages Rails' powerful `I18n` translations module.

:::warning Multi-language URL Support
If you're serving Avo using multiple languages and you're using the locale in your routes (`/en/resources/users`, `/de/resources/users`), check out [this guide](#multi-language-urls).
:::

When you run `bin/rails avo:install`, Rails will not generate for you the `avo.en.yml` translation file. This file is already loaded will automatically be injected into the I18n translations module.

## Localizing resources

Let's say you want to localize a resource. All you need to do is add a `self.translation_key` class attribute in the `Resource` file. That will tell Avo to use that translation key to localize this resource. That will change the labels of that resource everywhere in Avo.

```ruby{4}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  self.title = :name
  self.translation_key = 'avo.resource_translations.user'
end
```

```yaml{6-10}
# avo.es.yml
es:
  avo:
    dashboard: 'Dashboard'
    # ... other translation keys
    resource_translations:
      user:
        zero: 'usuarios'
        one: 'usuario'
        other: 'usuarios'
```

## Localizing fields

Similarly, you can even localize fields. All you need to do is add a `translation_key:` option on the field declaration.


```ruby{8}
# app/avo/resources/project.rb
class Avo::Resources::Project < Avo::BaseResource
  self.title = :name

  def fields
    field :id, as: :id
    # ... other fields
    field :files, as: :files, translation_key: 'avo.field_translations.file'
  end
end
```

```yaml{6-10}
# avo.es.yml
es:
  avo:
    dashboard: 'Dashboard'
    # ... other translation keys
    field_translations:
      file:
        zero: 'archivos'
        one: 'archivo'
        other: 'archivos'
```

## Localizing buttons label

<BetaStatus label="Beta" />

The `avo.save` configuration applies to all save buttons. If you wish to customize the localization for a specific resource, such as `Avo::Resources::Product`, you can achieve this by:

```yml
---
en:
  avo:
    resource_translations:
      product:
        save: "Save the product!"
```

## Setting the locale

Setting the locale for Avo is pretty simple. Just use the `config.locale = :en` config attribute. Default is `nil` and will fall back to whatever you have configured in as `config.i18n.default_locale` in `application.rb`.

```ruby{2}
Avo.configure do |config|
  config.locale = :en # default is nil
end
```

That will change the locale only for Avo requests. The rest of your app will still use your locale set in `application.rb`. If you wish to change the locale for Avo, you can use the `set_locale=pt-BR` param. That will set the default locale for Avo until you restart your server.

Suppose you wish to change the locale only for one request using the `force_locale=pt-BR` param. That will set the locale for that request and keep the `force_locale` param in all links while you navigate Avo. Remove that param when you want to go back to your configured `default_locale`.


Related:
- Check out our guide for [multilingual records](#multilingual-content).

## Customize the locale

If there's anything in the locale files that you would like to change, run `bin/rails generate avo:locales` to generate the locale files.

These provide a guide for you for when you want to add more languages.

If you do translate Avo in a new language please consider contributing it to the [main repo](https://github.com/avo-hq/avo). Thank you

## FAQ

If you try to localize your resources and fields and it doesn't seem to work, please be aware of the following.

### The I18n.t method defaults to the name of that field/resource

Internally the localization works like so `I18n.t(translation_key, count: 1, default: default)` where the `default` is the computed field/resource name. So check the structure of your translation keys.

```yaml
# config/locales/avo.pt-BR.yml
pt-BR:
  avo:
    field_translations:
      file:
        zero: 'arquivos'
        one: 'arquivo'
        other: 'arquivos'
    resource_translations:
      user:
        zero: 'usuÃ¡rios'
        one: 'usuÃ¡rio'
        other: 'usuÃ¡rios'
```

### Using a Route Scope for Localization

To implement a route scope for localization within Avo, refer to [this guide](#multi-language-urls). It provides step-by-step instructions on configuring your routes to include a locale scope, enabling seamless localization handling across your application.




# Installation


## Requirements

- Ruby on Rails >= 6.1
- Ruby >= 3.1
- `api_only` set to `false`. More [here](#use-avo-in-an-api-only-rails-app).
- `propshaft` or `sprockets` gem
- Have the `secret_key_base` defined in  any of the following `ENV["SECRET_KEY_BASE"]`, `Rails.application.credentials.secret_key_base`, or `Rails.application.secrets.secret_key_base`

:::warning Zeitwerk autoloading is required.
When adding Avo to a Rails app that was previously a Rails 5 app you must ensure that it uses zeitwerk for autoloading and Rails 6.1 or higher defaults.

```ruby
# config/application.rb
config.autoloader = :zeitwerk
config.load_defaults 6.1 # 6.1 or higher, depending on your rails version
```
:::

## Installing Avo

### 1. One-command install

Use [this](https://railsbytes.com/public/templates/zyvsME) app template for a one-liner install process.

Run this command which will run all the required steps to install Avo in your app.

```
bin/rails app:template LOCATION='https://avohq.io/app-template'
```

### 2. Manual, step by step.

1. Add the appropiate Avo gem to the `Gemfile`

```ruby
# Add one of the following in your Gemfile depending on the tier you are on.

# Avo Community
gem "avo", ">= 3.2.1"

# Avo Pro
gem "avo", ">= 3.2.1"
gem "avo-pro", ">= 3.2.0", source: "https://packager.dev/avo-hq/"

# Avo Advanced
gem "avo", ">= 3.2.1"
gem "avo-advanced", ">= 3.2.0", source: "https://packager.dev/avo-hq/"
```


:::info
Please use [this guide](#gem-server-authentication) to find the best authentication strategy for your use-case.
:::

2. Run `bundle install`.
3. Run `bin/rails generate avo:install` to generate the initializer and add Avo to the `routes.rb` file.
4. [Generate an Avo Resource](#resource-options)

:::info
This will mount the app under `/avo` path. Visit the link to see the result.
:::

### 3. In popular Rails starter kits

We have integrations with the most popular starter kits.

#### Bullet Train

Avo comes pre-installed in all new Bullet Train applications.

I you have a Bullet Train app and you'd like to add Avo, please user [this template](https://avohq.io/templates/bullet-train).

```ruby
bin/rails app:template LOCATION=https://v3.avohq.io/templates/bullet-train.template
```

#### Jumpstart Pro

To install Avo in a Jumpstart Pro app use [this template](https://avohq.io/templates/jumpstart-pro).

```ruby
bin/rails app:template LOCATION=https://v3.avohq.io/templates/jumpstart-pro.template
```

## Install from GitHub

You may also install Avo from GitHub but when you do that you must compile the assets yourself. You do that using the `rake avo:build-assets` command.
When pushing to production, make sure you build the assets on deploy time using this task.

```ruby
# Rakefile
Rake::Task["assets:precompile"].enhance do
  Rake::Task["avo:build-assets"].execute
end
```

:::info
If you don't have the `assets:precompile` step in your deployment process, please adjust that with a different step you might have like `db:migrate`.
:::

## Mount Avo to a subdomain

You can use the regular `host` constraint in the `routes.rb` file.

```ruby
constraint host: 'avo' do
  mount_avo at: '/'
end
```

## Next steps

Please follow the next steps to ensure your app is secured and you have access to all the features you need.

1. Set up [authentication](#authentication) and tell Avo who is your `current_user`. This step is required for the authorization feature to work.
1. Set up [authorization](#authorization). Don't let your data be exposed. Give users access to the data they need to see.
1. Set up [licensing](#licensing).



# Map view

Some resources that contain geospatial data can benefit from being displayed on a map. For
resources to be displayed to the map view they require a `coordinates` field, but that's customizable.

## Enable map view

To enable map view for a resource, you need to add the `map_view` class attribute to a resource. That will add the view switcher to the <Index /> view.

<Image src="/assets/img/map-view.png" width="3240" height="1970" alt="Avo view switcher" />

```ruby
class Avo::Resources::City < Avo::BaseResource
  # ...
  self.map_view = {
    mapkick_options: {
      controls: true
    },
    record_marker: -> {
      {
        latitude: record.coordinates.first,
        longitude: record.coordinates.last,
        tooltip: record.name
      }
    },
    table: {
      visible: true,
      layout: :right
    }
  }
end
```

:::warning
You need to add the `mapkick-rb` (not `mapkick`) gem to your `Gemfile` and have the `MAPBOX_ACCESS_TOKEN` environment variable with a valid [Mapbox](https://account.mapbox.com/auth/signup/) key.
:::

<Option name="`mapkick_options`">

The options you pass here are forwarded to the [`mapkick` gem](https://github.com/ankane/mapkick).

</Option>

<Option name="`record_marker`">

This block is being applied to all the records present in the current query to fetch the coordinates of off the record.

You may use this block to fetch the coordinates from other places (API calls, cache queries, etc.) rather than the database.

This block has to return a hash compatible with the [`PointMap` items](https://github.com/ankane/mapkick#point-map). Has to have `latitude` and `longitude` and optionally `tooltip`, `label`, or `color`.
</Option>

<Option name="`table`">

This is the configuration for the adjacent table. You can set the visibility to `true` or `false`, and set the position of the table `:top`, `:right`, `:bottom`, or `:left`.
</Option>

<Option name="`extra_markers`">

Available since version <Version version="3.10.3" />

Allow to define extra markers. The `extra_markers` block is executed in the [`ExecutionContext`](#execution-context) and should return an array of hashes.

For each extra marker, you can specify a label, tooltip, and color.

```ruby
self.map_view = {
  # ...
  extra_markers: -> do
    [
      {
        latitude: 37.780411,
        longitude: -25.497047,
        label: "AÃ§ores",
        tooltip: "SÃ£o Miguel",
        color: "#0F0"
      }
    ]
  end,
  # ...
}
```
<Image src="/assets/img/extra-markers.png" width="3240" height="1970" alt="Map extra markers" />
</Option>

## Make it the default view

To make the map view the default way of viewing a resource on <Index />, we have to use the `default_view_type` class attribute.

```ruby{7}
class Avo::Resources::City < Avo::BaseResource
  self.default_view_type = :map
end
```


# Several fields in a cluster

<VersionReq version="3.18.0" class="mt-2" />

:::info
To fully understand this section, you should be familiar with the [`stacked`](#field-wrappers) field option and [`resource panels`](#resource-panels). These concepts will help you structure and customize your fields effectively.
:::

The `cluster` DSL allows you to group multiple fields horizontally within a [`panel`](#resource-panels). This is useful for organizing related fields in a structured layout.

To enhance readability and maintain a well-organized UI, it is recommended to use the [`stacked`](#field-wrappers) option for fields inside clusters.

<Image src="/assets/img/row.png" width="1028" height="230" alt="Field naming convention" />

```ruby{4-18}
# app/avo/resources/user.rb
class Avo::Resources::Person < Avo::BaseResource
  def fields
    panel "Address" do
      cluster do
        field :street_address, stacked: true do
          "1234 Elm Street"
        end

        field :city, stacked: true do
          "Los Angeles"
        end

        field :zip_code, stacked: true do
          "15234"
        end
      end
    end
  end
end
```



# Testing

:::info
We know the testing guides aren't very detailed, and some testing helpers are needed. So please send your feedback [here](https://github.com/avo-hq/avo/discussions/1168).
:::

Testing is an essential aspect of your app. Most Avo DSLs are Ruby classes, so regular testing methods should apply.

## Testing helpers

We prepared a few testing helpers for you to use in your apps. They will help with opening/closing datepickers, choosing the date, saving the records, add/remove tags, and also select a lot of elements throughout the UI.

You can find them all [here](https://github.com/avo-hq/avo/blob/main/lib/avo/test_helpers.rb),

## Testing Actions

Given this `Avo::Actions::ReleaseFish`, this is the `spec` that tests it.

```ruby

class Avo::Actions::ReleaseFish < Avo::BaseAction
  self.name = "Release fish"
  self.message = "Are you sure you want to release this fish?"

  def fields
    field :message, as: :textarea, help: "Tell the fish something before releasing."
  end

  def handle(query:, fields:, **_)
    query.each(&:release)

    succeed "#{query.count} fish released with message '#{fields[:message]}'."
  end
end

```

```ruby
require 'rails_helper'

RSpec.feature Avo::Actions::ReleaseFish, type: :feature do
  let(:fish) { create :fish }
  let(:current_user) { create :user }
  let(:resource) { Avo::Resources::User.new.hydrate model: fish }

  it "tests the dummy action" do
    args = {
      fields: {
        message: "Bye fishy!"
      },
      current_user: current_user,
      resource: resource,
      query: [fish]
    }

    action = described_class.new(resource: resource, user: current_user, view: :edit)

    expect(action).to receive(:succeed).with "1 fish released with message 'Bye fishy!'."
    expect(fish).to receive(:release)

    action.handle **args
  end
end
```


# Views

The Avo CRUD feature generates with four main views for each resource.

<Option name="`Index`">

The page where you see all your resources listed in a table or a [grid](#grid-view).
<br/>
<RelatedList>
  <RelatedItem href="./customization.html#click_row_to_view_record">Click row to view record</RelatedItem>
  <RelatedItem href="./resources.html#self.components">Resource custom components</RelatedItem>
</RelatedList>

</Option>

<Option name="`Show`">

The page where you see one resource in more detail.
<br/>
<RelatedList>
  <RelatedItem href="./resources.html#self.components">Resource custom components</RelatedItem>
</RelatedList>

</Option>

<Option name="`Edit`">

The page where you can edit one resource.
<br/>
<RelatedList>
  <RelatedItem href="./resources.html#self.components">Resource custom components</RelatedItem>
</RelatedList>

</Option>

<Option name="`New`">

The page where you can create a new resource.
<br/>
<RelatedList>
  <RelatedItem href="./resources.html#self.components">Resource custom components</RelatedItem>
</RelatedList>

</Option>

<Option name="`Display`">

`:display` is an alias for the the `Index` and `Show` views where you can display records and their details.

</Option>

<Option name="`Form`">

`:form` is an alias for the `Edit` and `New` views for creating and editing records.

</Option>

## Preview

The fields marked with `show_on :preview`, will be show in the [preview field](#preview) popup.
By default, all fields are hidden in `:preview`.

## Checking the current view

The `view` object, available in the code, is an instance of the `Avo::ViewInquirer` class.
This enables you to examine the existing `view` status through expressions such as `view.show?` and `view.index?`.
Essentially, these are equivalent to asserting whether view equals `show` or `index`.

## Multiple ways to check

```ruby
view == "edit" # Check against a string
view == :edit # Check against a symbol
view.edit? # Ask if it's a view
view.form? # Ask if it's a collection of views
view.in? [:edit, :new] # Check against an array of symbols
view.in? ["edit", "new"] # Check against an array of strings
```

::: code-group
```ruby [Ask]
if view.show?
  # Code for the "show" view
elsif view.index?
  # Code for the "index" view
elsif view.edit?
  # Code for the "edit" view
elsif view.new?
  # Code for the "new" view
elsif view.form?
  # Code for the "new" or "edit" views
elsif view.display?
  # Code for the "index or "show" views
end
```

```ruby [Symbol comparator]
if view == :show
  # Code for the "show" view
elsif view == :index
  # Code for the "index" view
elsif view == :edit
  # Code for the "edit" view
elsif view == :new
  # Code for the "new" view
end
```

```ruby [String comparator]
if view == "show"
  # Code for the "show" view
elsif view == "index"
  # Code for the "index" view
elsif view == "edit"
  # Code for the "edit" view
elsif view == "new"
  # Code for the "new" view
end
```
:::

It's also possible to check if the view is on a `form` (`new`, `edit`) or `display` (`index`, `show`).

::: code-group
```ruby [Ask]
if view.form?
  # Code for the "new" and "edit" views
elsif view.display?
  # Code for the "show" and "index" views
end
```

```ruby [Symbol comparator]
if view.in? [:new, :edit]
  # Code for the "new" and "edit" views
elsif view.in? [:show, :index]
  # Code for the "show" and "index" views
end
```

```ruby [String comparator]
if view.in? ["new", "edit"]
  # Code for the "new" and "edit" views
elsif view.in? ["show", "index"]
  # Code for the "show" and "index" views
end
```
:::



# Custom pages (custom tools)

You may use custom tools to create custom sections or views to add to your app.

## Generate tools

`bin/rails generate avo:tool dashboard` will generate the necessary files to show the new custom tool.

```bash{2-6}
â–¶ bin/rails generate avo:tool dashboard
      create  app/views/avo/sidebar/items/_dashboard.html.erb
      insert  app/controllers/avo/tools_controller.rb
      create  app/views/avo/tools/dashboard.html.erb
       route  namespace :avo do
  get "dashboard", to: "tools#dashboard"
end
```

### Controller

If this is your first custom tool, a new `ToolsController` will be generated for you. Within this controller, Avo created a new method.

```ruby
class Avo::ToolsController < Avo::ApplicationController
  def dashboard
  end
end
```

You can keep this action in this controller or move it to another controller and organize it differently.

### Route

```ruby{2-4}
Rails.application.routes.draw do
  namespace :avo do
    get "dashboard", to: "tools#dashboard"
  end

  authenticate :user, ->(user) { user.admin? } do
    mount_avo
  end
end
```

The route generated is wrapped inside a namespace with the `Avo.configuration.root_path` name. Therefore, you may move it inside your authentication block next to the Avo mounting call.

### Sidebar item

The `_dashboard.html.erb` partial will be added to the `app/views/avo/sidebar/items` directory. All the files in this directory will be loaded by Avo and displayed in the sidebar. They are displayed alphabetically, so you may change their names to reorder the items.

### Customize the sidebar

If you want to customize the sidebar partial further, you can [eject](#eject-views) and update it to your liking. We're planning on creating a better sidebar customization experience later this year.

## Add assets

You might want to import assets (javascript and stylesheets files) when creating custom tools or fields. You can do that so easily from v1.3. Please follow [this guide](#custom-asset-pipeline) to bring your assets with your asset pipeline.


## Using helpers from your app

You'll probably want to use some of your helpers in your custom tools. To have them available inside your custom controllers inherited from Avo's `ApplicationController`, you need to include them using the `helper` method.

```ruby{3-5,10}
# app/helpers/home_helper.rb
module HomeHelper
  def custom_helper
    'hey from custom helper'
  end
end

# app/controllers/avo/tools_controller.rb
class Avo::ToolsController < Avo::ApplicationController
  helper HomeHelper

  def dashboard
    @page_title = "Dashboard"
  end
end
```

```erb{13}
# app/views/avo/tools/dashboard.html.erb
<div class="flex flex-col">
  <%= render Avo::PanelComponent.new title: 'Dashboard', display_breadcrumbs: true do |c| %>
    <% c.with_tools do %>
      <div class="text-sm italic">This is the panels tools section.</div>
    <% end %>

    <% c.with_body do %>
      <div class="flex flex-col justify-between py-6 min-h-24">
        <div class="px-6 space-y-4">
          <h3>What a nice new tool ðŸ‘‹</h3>

          <%= custom_helper %>
        </div>
      </div>
    <% end %>
  <% end %>
</div>
```

### Using path helpers

Because you're in a Rails engine, you will have to prepend the engine object to the path.

#### For Avo paths

Instead of writing `resources_posts_path(1)` you have to write `avo.resources_posts_path(1)`.

#### For the main app paths

When you want to reference paths from your main app, instead of writing `posts_path(1)`, you have to write `main_app.posts_path`.



# Dashboards

:::warning
You must manually require the `chartkick` gem in your `Gemfile`.

```ruby
# Create beautiful JavaScript charts with one line of Ruby
gem "chartkick"
```
:::

There comes the point in your app's life when you need to display the data in an aggregated form like a metric or chart. That's what Avo's Dashboards are all about.

## Generate a dashboard

Run `bin/rails g avo:dashboard my_dashboard` to get a shiny new dashboard.

```ruby
class Avo::Dashboards::MyDashboard < Avo::Dashboards::BaseDashboard
  self.id = 'my_dashboard'
  self.name = 'Dashy'
  self.description = 'The first dashbaord'
  self.grid_cols = 3

  def cards
    card Avo::Cards::ExampleMetric
    card Avo::Cards::ExampleAreaChart
    card Avo::Cards::ExampleScatterChart
    card Avo::Cards::PercentDone
    card Avo::Cards::AmountRaised
    card Avo::Cards::ExampleLineChart
    card Avo::Cards::ExampleColumnChart
    card Avo::Cards::ExamplePieChart
    card Avo::Cards::ExampleBarChart
    divider label: "Custom partials"
    card Avo::Cards::ExampleCustomPartial
    card Avo::Cards::MapCard
  end
end
```

<Image src="/assets/img/dashboards/dashboard.jpg" width="1262" height="1094" alt="Avo Dashboard" />

## Settings

Each dashboard is a file. It holds information about itself like the `id`, `name`, `description`, and how many columns its grid has.

The `id` field has to be unique. The `name` is what the user sees in big letters on top of the page, and the `description` is some text you pass to give the user more details regarding the dashboard.

Using the ' grid_cols ' parameter, you may organize the cards in a grid with `3`, `4`, `5`, or `6` columns using the `grid_cols` parameter. The default is `3`.

## Cards
[This section has moved.](#cards)

### Override card arguments from the dashboard

We found ourselves in the position to add a few cards that were the same card but with a slight difference. Ex: Have one `Users count` card and another `Active users count` card. They both count users, but the latter has an `active: true` condition applied.

Before, we'd have to duplicate that card and modify the `query` method slightly but end up with duplicated boilerplate code.
For those scenarios, we created the `arguments` attribute. It allows you to send arbitrary arguments to the card from the parent.

```ruby{7-9}
class Avo::Dashboards::Dashy < Avo::Dashboards::BaseDashboard
  self.id = "dashy"
  self.name = "Dashy"

  def cards
    card Avo::Cards::UsersCount
    card Avo::Cards::UsersCount, arguments: {
      active_users: true
    }
  end
end
```

Now we can pick up that option in the card and update the query accordingly.

```ruby{9-11}
class Avo::Cards::UsersCount < Avo::Cards::MetricCard
  self.id = "users_metric"
  self.label = "Users count"

  # You have access to context, params, range, current parent, and current card
  def query
    scope = User

    if arguments[:active_users].present?
      scope = scope.active
    end

    result scope.count
  end
end
```

That gives you an extra layer of control without code duplication and the best developer experience.

#### Control the base settings from the parent

Evidently, you don't want to show the same `label`, `description`, and other details for that second card from the first card.
Therefore, you can control the `label`, `description`, `cols`, `rows`, `visible`, and `refresh_every` arguments from the parent declaration.

```ruby{8-16}
class Avo::Dashboards::Dashy < Avo::Dashboards::BaseDashboard
  self.id = "dashy"
  self.name = "Dashy"

  def cards
    card Avo::Cards::UsersCount
    card Avo::Cards::UsersCount,
      label: "Active users",
      description: "Active users count",
      cols: 2,
      rows: 2,
      visible: -> { true }
      refresh_every: 2.minutes,
      arguments: {
        active_users: true
      }
  end
end
```

## Dashboards visibility

You might want to hide specific dashboards from certain users. You can do that using the `visible` option. The option can be a boolean `true`/`false` or a block where you have access to the `params`, `current_user`, `context`, and `dashboard`.

If you don't pass anything to `visible`, the dashboard will be available for anyone.

```ruby{5-11}
class Avo::Dashboards::ComplexDash < Avo::Dashboards::BaseDashboard
  self.id = "complex_dash"
  self.name = "Complex dash"
  self.description = "Complex dash description"
  self.visible = -> do
    current_user.is_admin?
    # or
    params[:something] == 'something else'
    # or
    context[:your_param] == params[:something_else]
  end

  def cards
    card Avo::Cards::UsersCount
  end
end
```

## Dashboards authorization

<VersionReq version="2.22" />

You can set authorization rules for dashboards using the `authorize` block.

```ruby{3-6}
class Avo::Dashboards::Dashy < Avo::Dashboards::BaseDashboard
  self.id = 'dashy'
  self.authorize = -> do
    # You have access to current_user, params, request, context, adn view_context.
    current_user.is_admin?
  end
end
```

<Option name="`self.name`">

`self.name` is what is going to be displayed to the user as the dashboard name.

```ruby
self.name = "Dashy"
```

<VersionReq version="3.14.2" /> `self.name` can be configured using a Proc.

```ruby
self.name = -> { I18n.t("avo.dashboards.dashy.name") }
```

Within this block, you gain access to all attributes of [`Avo::ExecutionContext`](#execution-context) along with the `dashboard`.

</Option>



# Discreet Information

Sometimes you need to have some information available on the record page, but not necesarily front-and-center.
This is where the Discreet Information option is handy.

```ruby
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  self.discreet_information = [
    :timestamps,
    {
      tooltip: -> { sanitize("Product is <strong>#{record.published_at ? "published" : "draft"}</strong>", tags: %w[strong]) },
      icon: -> { "heroicons/outline/#{record.published_at ? "eye" : "eye-slash"}" }
    },
    {
      label: -> { record.published_at ? "ðŸš€" : "ðŸ˜¬" },
      url: -> { "https://avohq.io" },
      url_target: :_blank
    }
  ]
end
```

## Display the `id`

To save field space, you can use the discreet information area to display the id of the current record.

Set the option to the `:id` value and the id will be added next to the title.

```ruby
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  self.discreet_information = :id

  # fields and other resource configuration
end
```

You can alternatively use `:id_badge` to display the id as a badge.

## Display the `created_at` and `updated_at` timestamps

The reason why we built this feature was that we wanted a place to display the created and updated at timestamps but didn't want to use up a whole field for it.
That's why this is the most simple thing to add.

Set the option to the `:timestamps` value and a new icon will be added next to the title. When the user hovers over the icon, they will see the record's default timestamps.

```ruby
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  self.discreet_information = :timestamps

  # fields and other resource configuration
end
```

If the record doesn't have the `created_at` or `updated_at` attributes, they will be ommited.

You can alternatively use `:timestamps_badge` to display the timestamps as a badge.

## Options

You may fully customize the discreet information item by taking control of different options.
To do that, you can set it to a `Hash` with various keys.


```ruby
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  self.discreet_information = {
    tooltip: -> { "Product is #{record.published_at ? "published" : "draft"}" },
    icon: -> { "heroicons/outline/#{record.published_at ? "eye" : "eye-slash"}" }
    url: -> { main_app.post_path record }
  }
end
```

<Option name="`tooltip`">

Use the `tooltip` option to set the body of the tooltip.

```ruby
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  self.discreet_information = {
    tooltip: -> { "Product is #{record.published_at ? "published" : "draft"}" },
  }
end
```

You may return HTML for that tooltip but don't forget to sanitize the output.

```ruby
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  self.discreet_information = {
    tooltip: -> { sanitize("Product is <strong>#{record.published_at ? "published" : "draft"}</strong>", tags: %w[strong]) },
    icon: "heroicons/outline/academic-cap"
  }
end
```

</Option>

<Option name="`url`">

The `url` option will transform the icon into a link.

```ruby
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  self.discreet_information = {
    tooltip: -> { "Product is #{record.published_at ? "published" : "draft"}" },
    icon: "heroicons/outline/academic-cap",
    url: -> { main_app. }
  }
end
```

</Option>

<Option name="`as`">

The `as` option specifies the type of representation. Currently, only `:badge` is supported, but additional types may be introduced in the future.

```ruby{7}
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  self.discreet_information = {
    tooltip: -> { "Product is #{record.published_at ? "published" : "draft"}" },
    icon: "heroicons/outline/academic-cap",
    url: -> { main_app. },
    as: :badge
  }
end
```

</Option>

## Display multiple pieces of information

You can use it to display one or more pieces of information.

## Information properties

Each piece of information has a fe



## Full configuration


```ruby
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  self.discreet_information = [
    :timestamps,
    {
      tooltip: -> { sanitize("Product is <strong>#{record.published_at ? "published" : "draft"}</strong>", tags: %w[strong]) },
      icon: -> { "heroicons/outline/#{record.published_at ? "eye" : "eye-slash"}" }
    },
    {
      label: -> { record.published_at ? "âœ…" : "ðŸ™„" },
      url: -> { "https://avohq.io" },
      url_target: :_blank
    }
  ]

  # fields and other resource configuration
end
```



# Dynamic filters

The Dynamic filters make it so easy to add multiple, composable, and dynamic filters to the <Index /> view.

The first thing you need to do is add the `filterable: true` attribute to the fields you need to filter through. We use `ransack` behind the scenes so it's essential to configure the `ransackable_attributes` list to ensure that every filterable field is incorporated within it.


```ruby{4-6} [Fields]
class Avo::Resources::Project < Avo::BaseResource
  def fields
    field :name, as: :text
    field :status, as: :status, filterable: true
    field :stage, as: :badge, filterable: true
    field :country, as: :country, filterable: true
  end
end
```

Authorize ransackable_attributes
```ruby{3,11}
class Project < ApplicationRecord
  def self.ransackable_attributes(auth_object = nil)
    ["status", "stage", "country"] # the array items should be strings not symbols
  end
end

# Or authorize ALL attributes at once

class Project < ApplicationRecord
  def self.ransackable_attributes(auth_object = nil)
    authorizable_ransackable_attributes
  end
end
```

:::warning
  Ensure the array items are strings, not symbols.
:::

This will make Avo add this new "Filters" button to the <Index /> view of your resource.

When the user clicks the button, a new filters bar will appear below enabling them to add filters based on the attributes you marked as filterable.
The user can add multiple filters for the same attribute if they desire so.

## Filter types

The filter type determines the kind of input provided by the filter.

For instance, a [text](#text) type filter will render a text input field, while a [select](#select) type filter will render a dropdown menu with predefined options fetched from the field.

#### Conditions
Each filter type also offers a different set of conditions. Conditions specify how the input value should be applied to filter the data. For example, [text](#text) filters have conditions such as `Contains` or `Starts with`, while number filters include `=` (equals) or `>` (greater than).

#### Query
Avo uses the input value and the specified condition to build a Ransack query. The filter conditions and input values are translated into Ransack predicates, which are then used to fetch the filtered data.

For instance, in the text filter example above, the `Contains` condition and the input value `John` are translated into a Ransack query resulting into the SQL `LIKE` operator to find all records where the name contains `John`.

<Option name="Boolean">

### Conditions

 - Is true
 - Is false
 - Is null
 - Is not null

```ruby
{
  is_true: "Is true",
  is_false: "Is false",
  is_null: "Is null",
  is_not_null: "Is not null",
}.invert
```

<div class="flex justify-between items-start flex-wrap">
  <Image src="/assets/img/dynamic_filter_boolean.png" width="241" height="176" alt="" />
  <Image src="/assets/img/dynamic_filter_boolean2.png" width="241" height="192" alt="" />
</div>

Test it on [avodemo](https://main.avodemo.com/avo/resources/users?filters[is_admin?][is_true][]=), check the [source code](https://github.com/avo-hq/main.avodemo.com/blob/main/app/avo/resources/user.rb#L38)
</Option>

<Option name="Date">

### Conditions

- Is
- Is not
- Is on or before
- Is on or after
- Is within
- Is null
- Is not null

```ruby
{
  is: "Is",
  is_not: "Is not",
  lte: "Is on or before",
  gte: "Is on or after",
  is_within: "Is within",
  is_null: "Is null",
  is_not_null: "Is not null",
}.invert
```

<div class="flex justify-between items-start flex-wrap">
  <Image src="/assets/img/dynamic_filter_date3.png" width="340" height="500" alt="" />
  <Image src="/assets/img/dynamic_filter_date2.png" width="244" height="213" alt="" />
</div>

Test it on [avodemo](https://main.avodemo.com/avo/resources/teams?filters[created_at][lte][]=2024-07-02%2012%3A00), check the [source code](https://github.com/avo-hq/main.avodemo.com/blob/main/app/avo/resources/team.rb#L50)
</Option>

<Option name="Number">

### Conditions

 - `=` (equals)
 - `!=` (is different)
 - `>` (greater than)
 - `>=` (greater than or equal to)
 - `<` (lower than)
 - `<=` (lower than or equal to)
 - Is within <VersionReq version="3.10.11"/>
 - Is null
 - Is not null

```ruby
{
  is: "=",
  is_not: "!=",
  gt: ">",
  gte: ">=",
  lt: "<",
  lte: "<=",
  is_within: "Is within",
  is_null: "Is null",
  is_not_null: "Is not null",
}.invert
```

<div class="flex justify-between items-start flex-wrap">
  <Image src="/assets/img/dynamic_filter_number.png" width="244" height="205" alt="" />
  <Image src="/assets/img/dynamic_filter_number2.png" width="244" height="234" alt="" />
</div>

Test it on [avodemo](https://main.avodemo.com/avo/resources/teams?filters[id][gte][]=2), check the [source code](https://github.com/avo-hq/main.avodemo.com/blob/main/app/avo/resources/team.rb#L27)
</Option>

<Option name="Select">

### Conditions

 - Is
 - Is not
 - Is null
 - Is not null

```ruby
{
  is: "Is",
  is_not: "Is not",
  is_null: "Is null",
  is_not_null: "Is not null",
}.invert
```

<div class="flex justify-between items-start flex-wrap">
  <Image src="/assets/img/dynamic_filter_select.png" width="244" height="204" alt="" />
  <Image src="/assets/img/dynamic_filter_select2.png" width="244" height="204" alt="" />
</div>

Test it on [avodemo](https://main.avodemo.com/avo/resources/courses?filters[country][is][]=USA), check the [source code](https://github.com/avo-hq/main.avodemo.com/blob/main/app/avo/resources/course.rb#L55)
</Option>

<Option name="Text">

### Conditions

 - Contains
 - Does not contain
 - Is
 - Is not
 - Starts with
 - Ends with
 - Is null
 - Is not null
 - Is present
 - Is blank

```ruby
{
  contains: "Contains",
  does_not_contain: "Does not contain",
  is: "Is",
  is_not: "Is not",
  starts_with: "Starts with",
  ends_with: "Ends with",
  is_null: "Is null",
  is_not_null: "Is not null",
  is_present: "Is present",
  is_blank: "Is blank",
}.invert
```

<div class="flex justify-between items-start flex-wrap">
  <Image src="/assets/img/dynamic_filter_text.png" width="244" height="203" alt="" />
  <Image src="/assets/img/dynamic_filter_text2.png" width="244" height="327" alt="" />
</div>

Test it on [avodemo](https://main.avodemo.com/avo/resources/users?filters[first_name][contains][]=Avo), check the [source code](https://github.com/avo-hq/main.avodemo.com/blob/main/app/avo/resources/user.rb#L33)
</Option>
<Option name="Tags">

### Conditions

 - Are
 - Contain
 - Overlap
 - Contained in ([`active_record_extended`](https://github.com/GeorgeKaraszi/ActiveRecordExtended) gem required)

 ```ruby
{
  array_is: "Are",
  array_contains: "Contain",
  array_overlap: "Overlap",
  array_contained_in: "Contained in" # (active_record_extended gem required)
}.invert
```

:::warning
Contained in will not work when using the `acts-as-taggable-on` gem.
:::
<div class="flex justify-between items-start flex-wrap">
  <Image src="/assets/img/dynamic_filter_tags.png" width="244" height="204" alt="" />
  <Image src="/assets/img/dynamic_filter_tags2.png" width="244" height="204" alt="" />
</div>

Test it on [avodemo](https://main.avodemo.com/avo/resources/courses?filters[skills][array_contains][]=), check the [source code](https://github.com/avo-hq/main.avodemo.com/blob/main/app/avo/resources/course.rb#L46)

:::info
The source code uses custom dynamic filters DSL available <VersionReq version="3.10.0" />

Check how to do a more advanced configuration on the [custom dynamic filters](#custom-dynamic-filters) section.
:::

</Option>

## Options

You can have a few customization options available that you can add in your `avo.rb` initializer file.

```ruby
Avo.configure do |config|
  # Other Avo configurations
end

if defined?(Avo::DynamicFilters)
  Avo::DynamicFilters.configure do |config|
    config.button_label = "Advanced filters"
    config.always_expanded = true
  end
end
```

<Option name="`button_label`">

This will change the label on the expand label.
</Option>

<Option name="`always_expanded`">

You may opt-in to have them always expanded and have the button hidden.
</Option>

## Field to filter matching
On versions **lower** than <Version version="3.10.0" /> the filters are not configurable so each field will have a dedicated filter type. Check how to do a more advanced configuration on the [custom dynamic filters](#custom-dynamic-filters) section.

Field-to-filter matching in versions **lower** than <Version version="3.10.0" />:

```ruby
def field_to_filter(type)
  case type.to_sym
  when :boolean
    :boolean
  when :date, :date_time, :time
    :date
  when :id, :number, :progress_bar
    :number
  when :select, :badge, :country, :status
    :select
  when :text, :textarea, :code, :markdown, :password, :trix
    :text
  else
    :text
  end
end
```

## Caveats

At some point we'll integrate the [Basic filters](#filters) into the dynamic filters bar. Until then, if you have both basic and dynamic filters on your resource you'll have two `Filters` buttons on your <Index /> view.

To mitigate that you can toggle the `always_expanded` option to true.

## Custom Dynamic Filters

<BetaStatus label="Beta" />
<VersionReq version="3.10.0" />

Dynamic filters are great but strict, as each field creates a specific filter type, each with its own icon and query. The query remains static, targeting only that particular field. Since version <Version version="3.10" />, dynamic filters have become customizable and, even better, can be declared without being bound to a field.

There are two ways to define custom dynamic filters: the field's `filterable` option and the `dynamic_filter` method.

### Defining custom dynamic filters

To start customizing a dynamic filter from the `filterable` option, change its value to a hash:

```ruby
field :first_name,
  as: :text,
  filterable: true # [!code --]
  filterable: { } # [!code ++]
```

From this hash, you can configure several options specified below.

Alternatively, you can define a custom dynamic filter using the `dynamic_filter` method, which should be called inside the `filters` method:

```ruby
def filters
  # ...
  dynamic_filter :first_name
  # ...
end
```

Each option specified below can be used as a key in the hash definition or as a keyword argument in the method definition.

:::info Filters order
The filter order is computed. Dynamic filters defined by the `dynamic_filter` method will respect the definition order and will be rendered first in the filter list. Filters declared using the field's `filterable` option will be sorted by label.
:::

:::warning Custom Dynamic Filter IDs
When using a custom dynamic filter, the generated filter ID may not directly correspond to a database column. In such cases, you should use the [`query_attributes`](#query_attributes) option to specify which database columns the filter should apply to.

For example, consider a `City` model with a `population` column in the database:
```ruby
# The filter ID is custom_population
# However, the filter should apply the query to the population attribute.
dynamic_filter :custom_population, query_attributes: :population
```
:::
<Option name="`label`">

Customize filter's label

##### Default value

Field's / filter's ID humanized.

#### Possible values

Any string
</Option>


<Option name="`icon`">

Customize filter's icon. Check [icons documentation](#icons)

##### Default value

Boolean filter - `heroicons/outline/check-circle`<br>
Calendar filter - `heroicons/outline/calendar-days`<br>
Number filter - `heroicons/outline/hashtag`<br>
Select filter - `heroicons/outline/arrow-down-circle`<br>
Tags filter - `heroicons/outline/tag`<br>
Text filter - `avo/font`<br>

#### Possible values

Any icon from [avo](https://github.com/avo-hq/avo/tree/feature/allow_actions_to_render_turbo_streams/app/assets/svgs/avo) or [heroicons](https://heroicons.com/).
</Option>

<Option name="`type`">

Customize filter's type

##### Default value

Computed from field using [`field_to_filter` method](#field-to-filter-matching).

#### Possible values

- [`:boolean`](#boolean)<br>
- [`:date`](#date)<br>
- [`:number`](#number)<br>
- [`:select`](#select)<br>
- [`:text`](#text)<br>
- [`:tags`](#tags)<br>
</Option>

<Option name="`query`">

:::info
<VersionReq version="3.11.8" /> the default filtering system is no longer applied when a `query` is specified on a dynamic filter.
:::

Customize filter's query

##### Default value

Applies the condition to the field's attribute. For example, if the field is `first_name`, the condition is `contains`, and the value is `Bill`, the query will restrict to all records where the first name contains `Bill`.

#### Possible values

Any lambda function.

Within the function, you have access to `query` and `filter_param` as well as all attributes of [`Avo::ExecutionContext`](#execution-context).

`filter_param` is an Avo object that stores the filter's `id`, the applied `condition` and the `value`.

Usage example:

```ruby {6-13,19-26}
# Using field's filterable option
field :first_name,
  as: :text,
  filterable: {
    # ...
    query: -> {
      case filter_param.condition.to_sym
      when :case_sensitive
        query.where("name = ?", filter_param.value)
      when :not_case_sensitive
        query.where("LOWER(name) = ?", filter_param.value.downcase)
      end
    }
    # ...
  }

# Using dynamic_filter method
dynamic_filter :first_name,
  query: -> {
    case filter_param.condition.to_sym
    when :case_sensitive
      query.where("name = ?", filter_param.value)
    when :not_case_sensitive
      query.where("LOWER(name) = ?", filter_param.value.downcase)
    end
  }
```
</Option>

<Option name="`conditions`">

Customize filter's conditions

##### Default value

Check default conditions for each filter type above on this page.

#### Possible values

A hash with the desired key-values.

Usage example:
```ruby {6-9,15-18}
# Using field's filterable option
field :first_name,
  as: :text,
  filterable: {
    # ...
    conditions: {
      case_sensitive: "Case sensitive",
      not_case_sensitive: "Not case sensitive"
    }.invert
    # ...
  }

# Using dynamic_filter method
dynamic_filter :first_name,
  conditions: {
    case_sensitive: "Case sensitive",
    not_case_sensitive: "Not case sensitive"
  }.invert
```
</Option>

<Option name="`query_attributes`">

Customize filter's query attributes

##### Default value

Field's / filter's id

#### Possible values

Any model DB column(s). Use an array of symbols for multiple columns or a single symbol for a single column. If your model has DB columns like `first_name` and `last_name`, you can combine both on a single filter:

```ruby {6,13}
# Using field's filterable option
field :name,
  as: :text,
  filterable: {
    # ...
    query_attributes: [:first_name, :last_name]
    # ...
  }

# Using dynamic_filter method
dynamic_filter :name,
  type: :text,
  query_attributes: [:first_name, :last_name]
```

You can also add query attributes for a `belongs_to` association. For example, with a model that belongs to `User`:

```ruby {7,13}
# Using field's filterable option
field :user,
  as: :belongs_to,
  filterable: {
    label: "User (email & first_name)",
    icon: "heroicons/solid/users",
    query_attributes: [:user_email, :user_first_name]
  }

# Using dynamic_filter method
dynamic_filter label: "User (email & first_name)",
  icon: "heroicons/solid/users",
  query_attributes: [:user_email, :user_first_name]
```

This is possible due to a Ransack feature. To use it, you need to add the association name before the attribute.
</Option>

<Option name="`suggestions`">

Suggestions work on filters that provide text input, enhancing the user experience by offering relevant options. This functionality is especially useful in scenarios where users might need guidance or where the filter values are numerous or complex.

##### Default value

`nil`

:::info
<VersionReq version="3.11.8" /> on `tags` fields the `suggestions` are fetched from the field.
:::

#### Possible values

- Array of strings
```ruby {6,12}
# Using field's filterable option
field :first_name,
  as: :text,
  filterable: {
    # ...
    suggestions: ["Avo", "Cado"]
    # ...
  }

# Using dynamic_filter method
dynamic_filter :first_name,
  suggestions: ["Avo", "Cado"]
```

- Proc that returns an array of strings

<VersionReq version="3.15.1" /> when the filter is applied to an association, the `parent_record` becomes accessible within the `suggestions` block.

```ruby {6,12}
# Using field's filterable option
field :first_name,
  as: :text,
  filterable: {
    # ...
    suggestions: -> { ["Avo", "Cado", params[:extra_suggestion]] }
    # ...
  }

# Using dynamic_filter method
dynamic_filter :first_name,
  suggestions: -> { ["Avo", "Cado", params[:extra_suggestion]] }
```


- Array of hashes with the keys `value`, `label` and optionally an `avatar`
<VersionReq version="3.11.8" />
:::warning Applicable only to filters with type tags.
:::

:::code-group
```ruby {6-13,19-26} [Direct assign]
# Using field's filterable option
field :tags,
  as: :tags,
  filterable: {
    # ...
    suggestions: [
      {
        value: 1,
        label: 'one',
        avatar: 'https://images.unsplash.com/photo-1560363199-a1264d4ea5fc?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&w=256&h=256&fit=crop',
      },
      # ...
    ]
    # ...
  }

# Using dynamic_filter method
dynamic_filter :tags,
  suggestions: [
    {
      value: 1,
      label: 'one',
      avatar: 'https://images.unsplash.com/photo-1560363199-a1264d4ea5fc?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&w=256&h=256&fit=crop',
    },
    # ...
  ]
```

```ruby {6-15,21-30} [Proc]
# Using field's filterable option
field :tags,
  as: :tags,
  filterable: {
    # ...
    suggestions: -> {
      [
        {
          value: 1,
          label: 'one', # or params[:something]
          avatar: 'https://images.unsplash.com/photo-1560363199-a1264d4ea5fc?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&w=256&h=256&fit=crop',
        },
        # ...
      ]
    }
    # ...
  }

# Using dynamic_filter method
dynamic_filter :tags,
  suggestions: -> {
    [
      {
        value: 1,
        label: 'one', # or params[:something]
        avatar: 'https://images.unsplash.com/photo-1560363199-a1264d4ea5fc?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&w=256&h=256&fit=crop',
      },
      # ...
    ]
  }
```
:::

</Option>

<Option name="`fetch_values_from`">

<VersionReq version="3.13" />

:::warning
This option is compatible **only** with `tags` filters.
:::

In some cases, you may need to retrieve values dynamically from an API. The `fetch_values_from` option allows you to provide a URL from which the filter will suggest values, functioning similarly to the `fetch_values_from` option in the tags field.

When a user searches for a record, the filter's input will send a request to the server to fetch records that match the query.

##### Default value

`nil`

:::info
If you're using a `filterable` field the `fetch_values_from` are fetched from the field.

```ruby
field :tags, as: :tags,
  fetch_values_from: -> { "/avo-filters/resources/cities/tags" }
  filterable: true
```
:::

#### Possible values

- String
```ruby
fetch_values_from: "/avo-filters/resources/cities/tags"
```

- Proc that evaluates to a string.
```ruby
fetch_values_from: -> { "/avo-filters/resources/cities/tags" }
```

The string should resolve to an endpoint that returns an array of objects with the keys `value`, `label` and optionally `avatar`.

The endpoint will receive the user input as `q` in the params. It is accessible by using `params["q"]`.

::: code-group
```ruby{3-20} [app/controllers/avo/cities_controller.rb]
class Avo::CitiesController < Avo::ResourcesController
  def tags
    # You can access the user input by using params["q"]
    render json: [
      {
        value: 1,
        label: "one",
        avatar: "https://images.unsplash.com/photo-1560363199-a1264d4ea5fc?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&w=256&h=256&fit=crop"
      },
      {
        value: 2,
        label: "two",
        avatar: "https://images.unsplash.com/photo-1567254790685-6b6d6abe4689?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&w=256&h=256&fit=crop"
      },
      {
        value: 3,
        label: "three",
        avatar: "https://images.unsplash.com/photo-1560765447-da05a55e72f8?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&w=256&h=256&fit=crop"
      }
    ]
  end
end
```

```ruby{5-11} [config/routes.rb]
Rails.application.routes.draw do
  # your routes...
end

if defined? ::Avo
  Avo::Engine.routes.draw do
    scope :resources do
      get "cities/tags", to: "cities#tags"
    end
  end
end
```
:::

</Option>

<Option name="`options`">

<VersionReq version="3.10.10" />

Customize the options **for select type filters**. **This is available only for select type filters** and determines the options visible in the select dropdown.

##### Default value

Fetched from field if bond to a field or `[]`

#### Possible values

An array or hash where the key-value pairs represent the options.

- If a hash is provided, the key is the option label and the value is the option value.
- If an array is provided, the array elements are used as both the option value and the option label.

##### Usage examples
###### Array
```ruby{3}
dynamic_filter :version,
  type: :select,
  options: ["Label 1", "Label 2"]
```

###### Hash (with invert)
```ruby{3-6}
dynamic_filter :version,
  type: :select,
  options: {
    value_1: "Label 1",
    value_2: "Label 2"
  }.invert
```

###### Hash (without invert)
```ruby{3-6}
dynamic_filter :version,
  type: :select,
  options: {
    "Label 1" => :value_1,
    "Label 2" => :value_2
  }
```
</Option>


# Execution context

Avo enables developers to hook into different points of the application lifecycle using blocks.
That functionality can't always be performed in void but requires some pieces of state to set up some context.

Computed fields are one example.

```ruby
field :full_name, as: :text do
  "#{record.first_name} #{record.last_name}"
end
```

In that block we need to pass the `record` so you can compile that value. We send more information than just the `record`, we pass on the `resource`, `view`, `view_context`, `request`, `current_user` and more depending on the block that's being run.

## How does the `ExecutionContext` work?

The `ExecutionContext` is an object that holds some pieces of state on which we execute a lambda function.

```ruby
module Avo
  class ExecutionContext

    attr_accessor :target, :context, :params, :view_context, :current_user, :request

    def initialize(**args)
      # If target don't respond to call, handle will return target
      # In that case we don't need to initialize the others attr_accessors
      return unless (@target = args[:target]).respond_to? :call

      args.except(:target).each do |key,value|
        singleton_class.class_eval { attr_accessor "#{key}" }
        instance_variable_set("@#{key}", value)
      end

      # Set defaults on not initialized accessors
      @context      ||= Avo::Current.context
      @params       ||= Avo::Current.params
      @view_context ||= Avo::Current.view_context
      @current_user ||= Avo::Current.current_user
      @request      ||= Avo::Current.request
    end

    delegate :authorize, to: Avo::Services::AuthorizationService

    # Return target if target is not callable, otherwise, execute target on this instance context
    def handle
      target.respond_to?(:call) ? instance_exec(&target) : target
    end
  end
end

# Use it like so.
SOME_BLOCK = -> {
  "#{record.first_name} #{record.last_name}"
}

Avo::ExecutionContext.new(target: &SOME_BLOCK, record: User.first).handle
```

This means you could throw any type of object at it and it it responds to a `call` method wil will be called with all those objects.

<Option name="`target`">

The block you'll pass to be evaluated. It may be anything but will only be evaluated if it responds to a `call` method.
</Option>

<Option name="`context`">

Aliased to [`Avo::Current.context`](#avo-current).
</Option>

<Option name="`current_user`">

Aliased to [`Avo::Current.user`](#avo-current).
</Option>

<Option name="`view_context`">

Aliased to [`Avo::Current.view_context`](#avo-current).
</Option>

<Option name="`request`">

Aliased to [`Avo::Current.request`](#avo-current).
</Option>

<Option name="`params`">

Aliased to [`Avo::Current.params`](#avo-current).
</Option>

<Option name="Custom variables">

You can pass any variable to the `ExecutionContext` and it will be available in that block.
This is how we can expose `view`, `record`, and `resource` in the computed field example.

```ruby
Avo::ExecutionContext.new(target: &SOME_BLOCK, record: User.first, view: :index, resource: resource).handle
```
</Option>

<Option name="`helpers`">

Within the `ExecutionContext` you might want to use some of your already defined helpers. You can do that using the `helpers` object.

```ruby
# products_helper.rb
class ProductsHelper
  # Strips the "CODE_" prefix from the name
  def simple_name(name)
    name.gsub "CODE_", ""
  end
end

field :name, as: :text, format_using: -> { helpers.simple_name(value) }
```
</Option>



# Field wrappers

Each field display in your Avo resource has a field wrapper that helps display it in a cohesive way across the whole app.
This not only helps with a unitary design, but also with styling in a future theming feature.

:::info
You'll probably never have to use these components and helpers by themselves, but we'd like to document how they work as a future reference for everyone.
:::

# Index field wrapper

<Image src="/assets/img/field-wrappers/index_field_wrapper.jpg" width="1024" height="639" alt="" />

Each field displayed on the <Index /> view is wrapped in this component that regulates the way content is displayed and makes it easy to control some options.

You may use the component `Avo::Index::FieldWrapperComponent` or the helper `index_field_wrapper`.

<Option name="`dash_if_blank`">

This option renders a dash `â€”` if the content inside responds to true on the `blank?` method.
In the example below, we'd like to show the field as a red checkmark even if the content is `nil`.

#### Default

`true`

```erb
<%= index_field_wrapper **field_wrapper_args, dash_if_blank: false do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`center_content`">

Wraps the content in a container with `flex items-center justify-center` classes making everything centered horizontally and vertically.

#### Default

`false`

```erb
<%= index_field_wrapper **field_wrapper_args, center_content: true do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`flush`">

Removes the padding around the field allowing it to flow from edge to edge.

#### Default

`false`

```erb
<%= index_field_wrapper **field_wrapper_args, flush: false do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`field`">

The instance of the field. It's usually passed in with the `field_wrapper_args`.

```erb
<%= index_field_wrapper **field_wrapper_args do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`resource`">

The instance of the resource. It's usually passed in with the `field_wrapper_args`.

```erb
<%= index_field_wrapper **field_wrapper_args do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

# Show & Edit field wrapper

<Image src="/assets/img/field-wrappers/show_field_wrapper.jpg" width="1024" height="639" alt="" />
<Image src="/assets/img/field-wrappers/edit_field_wrapper.jpg" width="1024" height="639" alt="" />

The <Show /> and <Edit /> field wrappers are actually the same component.

You may use the component `Avo::Index::FieldWrapperComponent` or the helper `field_wrapper`.

## Field wrapper areas

<Image src="/assets/img/field-wrappers/field_wrapper_areas.jpg" width="1024" height="639" alt="" />

Each field wrapper is divided in three areas.

### Label

This is where the field name is being displayed. This is also where the [required](#field-options) asterisk is added for required fields.

### Value

This area holds the actual value of the field or it's representation. The falue can be simple text or more advanced types like images, advanced pickers, and content editors.

At the bottom the [help text](#field-options) is going to be shown on the <Edit /> view and below it the validation error.

### Extra

This space is rarely used and it's there just to fill some horizontal space so the content doesn't span to the whole width and maintain its readability. With the introduction of the sidebar, this space will be ignored

## Options

<Option name="`dash_if_blank`">

This option renders a dash `â€”` if the content inside responds to true on the `blank?` method.
In the example below, we'd like to show the field as a red checkmark even if the content is `nil`.

#### Default

`true`

```erb
<%= field_wrapper **field_wrapper_args, dash_if_blank: false do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`compact`">

This renders the field in a more compact way by removing the **Extra** area and decresing the width of the **Label** and **Content** areas.

This is enabled on the fields displayed in actions.

#### Default

`false`

```erb
<%= field_wrapper **field_wrapper_args, compact: true do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`data`">

Pass in some data attributes. Perhaps you would like to attach a StimulusJS controller to this field.

```erb
<%= field_wrapper **field_wrapper_args, data: {controller: "boolean-check"} do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`full_width`">

This removes the **Extra** area and renders the **Value** area full width.

This is used on fields that require a larger area to be displayed like [WYSIWYG editors](#trix), [`KeyValue`](#keyvalue), or [file fields](#files).

#### Default

`false`

```erb
<%= field_wrapper **field_wrapper_args, full_width: true do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`form`">

The instance of the form that is going to be populated. It's usually passed in with the `field_wrapper_args` on the <Edit /> view.

```erb
<%= field_wrapper **field_wrapper_args do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`field`">

The instance of the field. It's usually passed in with the `field_wrapper_args`.

```erb
<%= field_wrapper **field_wrapper_args do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`help`">

The text that is going to be displayed below the actual field on the <Edit /> view.

```erb
<%= field_wrapper **field_wrapper_args, help: "Specify if the post is published or not." do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`label`">

The text that is going to be displayed in the **Label** area. You might want to override it.

```erb
<%= field_wrapper **field_wrapper_args, label: "Post is published" do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`resource`">

The instance of the resource. It's usually passed in with the `field_wrapper_args`.

```erb
<%= field_wrapper **field_wrapper_args do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`stacked`">

Display the field in a column layout with the label on top of the value

```erb
<%= field_wrapper **field_wrapper_args, style: "background: red" do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Image src="/assets/img/field-wrappers/stacked_field.jpg" width="1024" height="639" alt="" />


<Option name="`style`">

The you might want to pass some styles to the wrapper to change it's looks.

```erb
<%= field_wrapper **field_wrapper_args, style: "background: red" do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`view`">

The view where the field is diplayed so it knows if it's a <Show /> or <Edit /> view. It's usually passed in with the `field_wrapper_args`.

```erb
<%= field_wrapper **field_wrapper_args do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>




# Fields

Fields are the backbone of a [`Resource`](#resource-options).
Through fields you tell Avo what to fetch from the database and how to display it on the <Index />, <Show />, and <Edit /> views.

Avo ships with various simple fields like `text`, `textarea`, `number`, `password`, `boolean`, `select`, and more complex ones like `markdown`, `key_value`, `trix`, `tags`, and `code`.

## Declaring fields

You add fields to a resource through the `fields` method using the `field DATABASE_COLUMN, as: FIELD_TYPE, **FIELD_OPTIONS` notation.

```ruby
def fields
  field :name, as: :text
end
```

The `name` property is the column in the database where Avo looks for information or a property on your model.

That will add a few fields in your new Avo app.

On the <Index /> and <Show /> views, we'll get a new text column of that record's database value.
Finally, on the <Edit /> and <New /> views, we will get a text input field that will display & update the `name` field on that model.

### Specific methods for each view

The `fields` method in your resource is invoked whenever non-specific view methods are present. To specify fields for each view or a group of views, you can use the following methods:

`index` view -> `index_fields`<br>
`show` view -> `show_fields`<br>
`edit` / `update` views -> `edit_fields`<br>
`new` / `create` views -> `new_fields`

You can also register fields for a specific group of views as follows:

`index` / `show` views -> `display_fields`<br>
`edit` / `update` / `new` / `create` views -> `form_fields`

When specific view fields are defined, they take precedence over view group fields. If neither specific view fields nor view group fields are defined, the fields will be retrieved from the `fields` method.

The below example use two custom helpers methods to organize the fields through `display_fields` and `form_fields`

:::code-group
```ruby [display_fields]
def display_fields
  base_fields
  tool_fields
end
```

```ruby [form_fields]
def form_fields
  base_fields
  tool_fields
  tool Avo::ResourceTools::CityEditor, only_on: :forms
end
```

```ruby [tool_fields (helper method)]
# Notice that even if those fields are hidden on the form, we still include them on `form_fields`.
# This is because we want to be able to edit them using the tool.
# When submitting the form, we need this fields declared on the resource in order to know how to process them and fill the record.
def tool_fields
  with_options hide_on: :forms do
    field :name, as: :text, help: "The name of your city", filterable: true
    field :population, as: :number, filterable: true
    field :is_capital, as: :boolean, filterable: true
    field :features, as: :key_value
    field :image_url, as: :external_image
    field :tiny_description, as: :markdown
    field :status, as: :badge, enum: ::City.statuses
  end
end
```

```ruby [base_fields (helper method)]
def base_fields
  field :id, as: :id
  field :coordinates, as: :location, stored_as: [:latitude, :longitude]
  field :city_center_area,
    as: :area,
    geometry: :polygon,
    mapkick_options: {
      style: "mapbox://styles/mapbox/satellite-v9",
      controls: true
    },
    datapoint_options: {
      label: "Paris City Center",
      tooltip: "Bonjour mes amis!",
      color: "#009099"
    }
  field :description,
    as: :trix,
    attachment_key: :description_file,
    visible: -> { resource.params[:show_native_fields].blank? }
  field :metadata,
    as: :code,
    format_using: -> {
      if view.edit?
        JSON.generate(value)
      else
        value
      end
    },
    update_using: -> do
      ActiveSupport::JSON.decode(value)
    end

  field :created_at, as: :date_time, filterable: true
end
```
:::

:::warning In some scenarios fields require presence even if not visible
In certain situations, fields must be present in your resource configuration, even if they are hidden from view. Consider the following example where `tool_fields` are included within `form_fields` despite being wrapped in a `with_options hide_on: :forms do ... end` block.

For instance, when using `tool Avo::ResourceTools::CityEditor, only_on: :forms`, it will render the `features` field, which is of type `key_value`. When the form is submitted, Avo relies on the presence of the `features` field to determine its type and properly parse the submitted value.

If you omit the declaration of `field :features, as: :key_value, hide_on: :forms`, Avo will be unable to update that specific database column.
:::


## Field conventions

When we declare a field, we pinpoint the specific database row for that field. Usually, that's a snake case value.

Each field has a label. Avo will convert the snake case name to a humanized version.
In the following example, the `is_available` field will render the label as *Is available*.

```ruby
field :is_available, as: :boolean
```

<Image src="/assets/img/fields-reference/naming-convention.jpg" width="490" height="78" alt="Field naming convention" />

:::info
If having the fields stacked one on top of another is not the right layout, try the [resource-sidebar](#resource-sidebar).
:::

### A more complex example

```ruby
class Avo::Resources::User < Avo::BaseResource
  def fields
    field :id, as: :id
    field :first_name, as: :text
    field :last_name, as: :text
    field :email, as: :text
    field :active, as: :boolean
    field :cv, as: :file
    field :is_admin?, as: :boolean
  end
end
```

The `fields` method is already hydrated with the `current_user`, `params`, `request`, `view_context`, and `context` variables so you can use them to conditionally show/hide fields

```ruby
class Avo::Resources::User < Avo::BaseResource
  def fields
    field :id, as: :id
    field :first_name, as: :text
    field :last_name, as: :text
    field :email, as: :text
    field :is_admin?, as: :boolean
    field :active, as: :boolean

    if current_user.is_admin?
      field :cv, as: :file
    end
  end
end
```

## Field Types

<FieldTypesList />


# HTTP Resources

## Overview

An **HTTP Resource** is a flexible resource that can be backed by an **endpoint** request. Unlike traditional resources tied to Active Record models, HTTP Resources allow dynamic interaction with external APIs and non-persistent data sources.

:::warning âš ï¸ Limitations

- The HTTP Resource does **not support sorting** at this time.

**Please note that these limitations stem from the current implementation and may evolve in future releases.**

:::

## Installing the gem

To enable HTTP Resource functionality in your Avo project, you need to include the `avo-http_resource` gem.

Add it to your Gemfile:

```ruby
gem "avo-http_resource", source: "https://packager.dev/avo-hq/"
```

Then install it:

```bash
bundle install
```

Once the gem is installed, HTTP Resources will be available as a new type of resource, enabling you to connect seamlessly with external APIs and custom data endpoints, no Active Record necessary.

## Creating an HTTP Resource

You can generate an HTTP Resource using the `--http` flag in the generator:

```bash
bin/rails generate avo:resource Author --http
```

## Parsing Data from an Endpoint

To wire an HTTP Resource to a data source, you must configure several attributes. Below is a breakdown of the supported options, each with an illustrative example.

```ruby
# app/avo/resources/author.rb
class Avo::Resources::Author < Avo::Core::Resources::Http
  # The base URL for your external API
  self.endpoint = "https://api.openalex.org/authors"

  # How to extract the list of records from the API response
  self.parse_collection = -> {
    raise Avo::HttpError.new response["message"] if response["error"].present?
    response["results"]
  }

  # How to extract a single record from the API response
  self.parse_record = -> {
    raise Avo::HttpError.new response["message"] if response["error"].present?
    response
  }

  # How to extract the total count of records (useful for pagination)
  self.parse_count = -> { response["meta"]["count"] }

  # Optional: custom method to find a record if the ID is encoded or non-standard
  self.find_record_method = -> { query.find Base64.decode64(id) }

  # Optional: redefines model behavior to obfuscate the ID via Base64
  self.model_class_eval = -> {
    define_method :to_param do
      Base64.encode64(id)
    end
  }

  def fields
    field :id, as: :id
    field :display_name
    field :cited_by_count, name: "Total citations"
    field :works_count, name: "Total works"
  end
end
```

### Option Reference

Hereâ€™s a brief reference for the main configuration options:

| Option              | Description                                                                 |
|---------------------|-----------------------------------------------------------------------------|
| `endpoint`          | Base URL for the external API                                               |
| `parse_collection`  | Proc that returns the array of records                                      |
| `parse_record`      | Proc that returns a single record                                           |
| `parse_count`       | Proc that returns the total number of records                              |
| `model_class_eval`  | Optional: proc to define extra model behavior, often used for `to_param`   |

All HTTP Resource options accept a **proc** (i.e., a lambda or block). These procs are executed in a rich runtime context that gives you full access to the HTTP response and metadata around the request.

Within this block, you gain access to all attributes of [`Avo::ExecutionContext`](#execution-context), including:

- `raw_response` â€” the raw `HTTParty::Response` response object
- `response` â€” the parsed body from `raw_response` (`raw_response.parsed_response`)
- `headers` â€” the headers from the response, available via `raw_response.headers`

This contextual access empowers you to define your resourceâ€™s behavior with a high degree of precision. Whether you're extracting deeply nested structures or implementing nuanced error handling, the execution context provides all the necessary components to **structure your parsing logic with clarity and control**.

## Handling API Errors Gracefully

When interacting with external APIs, it's important to handle error responses gracefully. Avo provides a custom exception, `Avo::HttpError`, for this exact purpose.

You can raise this error within your parsing procs like so:

```ruby
raise Avo::HttpError.new response["message"] if response["error"].present?
```

This signals to Avo that the API returned an error, and the HTTP controller will automatically **rescue** the exception and **display the message as a flash error in the UI**. This allows you to surface meaningful error feedback to users without breaking the experience or having to manually handle exceptions across the interface.

This pattern ensures your integration remains **resilient** and **intuitive**, providing a seamless user experience even when interacting with unreliable or unpredictable external data sources.

## Controlling Create, Update, and Destroy Behavior

By default, the HTTP Resource controller provides built-in methods to handle **creation**, **updates**, and **deletion** of records through your API client. These methods are designed to be flexible and easy to override when you need custom behavior.

### Default Implementation

```ruby
class Avo::Core::Controllers::Http
  def save_record
    # Perform either a create or update request based on the current controller action
    response = @resource.client.send(action_name, @record)

    # Should return true if the operation succeeded, false otherwise
    response.success?
  end

  def destroy_model
    # Perform a DELETE request to remove the record via the external API
    @resource.client.delete(@record.id)
  end
end
```

### Customizing the Behavior

If your external API requires additional parameters, or conditional logic, you can override these methods in your custom controller.

- `save_record` should return a **boolean**, indicating whether the create or update operation was successful.
- You can determine if the operation is a **create** or an **update** by inspecting the `action_name`, which will be `"create"` or `"update"` respectively.

### Example Override


```ruby
# app/controllers/avo/authors_controller.rb
class Avo::AuthorsController < Avo::Core::Controllers::Http
  def save_record
    if action_name == "create"
      response = MyCustomApi.post("/authors", body: @record.to_json, headers: auth_headers)
    else
      response = MyCustomApi.put("/authors/#{@record.id}", body: @record.to_json, headers: auth_headers)
    end

    response.status == 200
  end
end
```

This approach grants you complete control over how HTTP Resources interact with your external services, allowing seamless integration, even with APIs that have unconventional or highly specific requirements.



# Kanban boards

:::warning
The feature and docs are both work in progress. Please read the `info` sections below.
:::


Having a kanban board is a great way to organize your work and keep track of your records.

## Overview

The Kanban Board feature is a way to create a kanban board for your resources. They support multiple resources. Think about GitHub's Projects. You can have Issues, PRs, and simple tasks on them.

The boards and columns and items are database backed and you can create them on the fly.

## Requirements

Some of these requirements might change over time.

- We tested this on an app with Avo Advanced license
- [`acts_as_list`](https://github.com/brendon/acts_as_list) gem (comes automatically as a requirement)
- [`hotwire_combobox`](https://github.com/josefarias/hotwire_combobox) gem (comes automatically as a requirement)

## Installation

To install the `avo-kanban` gem, follow the steps below:

1. Add the following line to your Gemfile:
    ```ruby
    gem "avo-kanban", source: "https://packager.dev/avo-hq/"
    ```

2. Run the `bundle install` command to install the gem:
    ```bash
    bundle install
    ```

3. Generate the necessary resources and controllers by running:
    ```bash
    rails generate avo:kanban install
    ```

    This command will create pre-configured resources and controllers for managing boards, columns, and items in your application. You can further customize the generated code to suit your needs.

    This command will also generate the item's partial and a migration.

4. Run the migration to apply the database changes:
    ```bash
    rails db:migrate
    ```

## DB schema

`Avo::Kanban::Board` -> has_many `Avo::Kanban::Column` -> has_many `Avo::Kanban::Item`

The `Avo::Kanban::Column` has a polymorphic `belongs_to` association with any other model you might have in your app.

## Create a kanban board

We can create a kanban board by going to the Boards resource and clicking on the `Create board` button.

Once you create the board, add it to the menu using the `link_to` option (for now. we'll add `board` soon).

## Create columns

For now you can create the columns from the resource view.

By default, each column will have a `name` and `value` assigned to it. It will also have a `position` that you can use to sort the columns.

The `value` is what is being used to update the record when it's dropped into a new column.

## Configure the board

Each board has a configuration attached to it.
We can configure what kind of resources can be added to the board.

Similar we can change the column names and the value from the settings screen.

## Adding items to the board

This is best done on the board. Under each column you'll find the new field. This will search throught the resources that you've selected in the configuration.
It will use the `self.search[:query]` block to search for the records. It will send two `for_kanban_board` and `board_id` arguments to the block so you can customize the query.

When an item is added to the a column, it will have an `Avo::Kanban::Item` record created for it. This `Item` record is responsible for keeping track of the board, column, position properties and more.

When an item is added to the a column it will update the property on the record to the column's `value`. More on what this means in the next section.

## How does it work?

<!-- Let's take a look -->
Each board updates one `property` on the `record`, and each column represents a `value`.
The record is the actual record from the database (User, Project, To Do, etc.).

Let's say we are replicating the GitHub Projects boards.


### `Board` and `Column`s

We should have a `Board` record with the following columns:

- `No status` with an empty string as value
- `Backlog` with the value `backlog`
- `In progress` with the value `in_progress`
- `Done` with the value `done`

The board has the `property` option set to `status` so we ensure that the `status` property of the record is updated when we move the item to a new column.

### `Resource`s and `Item`s

We should have `Issue`, `PullRequest`, and `ToDo` models and resources. The resources should have the `self.search[:query]` block configured.

The models should have the `to_combobox_display` method configured so we know what to show in the search result. We might remove this requirement in the future.

Next in our board we should select these resources as allowed from the board settings.

### Add items to the board

At the bottom of the `No status` column we can search for an `Issue`. When we select that issue, an `Avo::Kanban::Item` record will be created for it with references to the board, column, and record (that issue).
This automatically triggers the issue to change the status to an empty string because we added it to the `No status` column which has the `value` set to an empty string.

If we were to add it to the `Backlog` column, it would change the status to `backlog`.

### Move items between columns

Now, if we move the item to the `In progress` column, it will change the status to `in_progress`.

### Items without that property

Some models might belong on the same board but have different properties to show the status.
Some models might use a timestamp like `published_at` to show the status.
Or some models might belong to a a status but that isn't dictated by a single property but a collection of properties.

In order to mitigate that we can create virtual properties on the model.

Let's imagine that a new board that displays the posts in columns based on their "published" status. the board uses the `status` property to but the `Post` model doesn't have the `status` property as a column in the database.
We can create a virtual property on the model.

```ruby
class Post < ApplicationRecord
  def status
    if published_at.present?
      "published"
    elsif published_status == "draft"
      "draft"
    else
      "private"
    end
  end

  def status=(value)
    if value == "published"
      published_at = Time.now
      published_status = "draft"
    elsif value == "draft"
      published_at = nil
      published_status = "draft"
    elsif value == "draft"
      published_at = nil
      published_status = nil
    end

    save!
  end
end
```

## Customize the card

:::warning
This might change in the future.
:::

In order to customize the card, you can eject the `Avo::Kanban::Items::ItemComponent` component.

```bash
rails generate avo:eject --component Avo::Kanban::Items::ItemComponent
```

Then customize it at `app/components/avo/kanban/items/item_component.html.erb`

```erb
<%= item.record.name %>
```

The `item` is the `Avo::Kanban::Item` and the `record` is the actual record from the database.

## Authorization

This section assumes that you have already set up [authorization](#authorization) in your application using Pundit.

1. Generate a policy for the `Board` resource by running:
```bash
rails generate pundit:policy board
```

### Authorization Methods

You can control access to various parts of the Kanban board by defining the following methods in your `BoardPolicy`:

- `manage_column?`

  Controls the visibility of the three-dot menu on each column (used for column management).

- `edit?`

  Controls the "Edit board" button on the board itself.
  :::warning
    Also controls the ability to edit the board in the resource view.
  :::

- `add_item?`

  Controls the visibility of the "Add item" button on the board, which allows users to add new items to a column.
  :::warning
    Doesn't impact the ability to add items via the bottom of each column.
  :::



# Media Library

<Image src="/assets/img/3_0/media-library/media-library.gif" alt="Media Library" size="800x453" />

If you run an asset-intensive, having a place to view all those asses would be great. It's becoming easier with Avo and it's Media Library feature.

The Media Library has two goals in mind.

1. Browse and manage all your assets
2. Use it to inject assets in all three of Avo's rich text editors ([trix](#trix), [rhino](#rhino), and [markdown](#markdown)).

:::warning
The Media Library feature is still in alpha and future releases might contain breaking changes so keep an eye out for the upgrade guide.

This is just the initial version and we'll be adding more features as we progress and get more feedback on usage.
:::

<div class="aspect-video">
  <iframe width="100%" height="100%" src="https://www.youtube.com/embed/wnWvzQyyo6A?start=1698" title="Avo 3.17 - Media Library, new Markdown field &amp; the Array Adapter" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

## How to enable it

The Media Library feature is disabled by default (until we release the stable version). To enable it, you need to do the following:

```ruby{4}
# config/initializers/avo.rb
if defined?(Avo::MediaLibrary)
  Avo::MediaLibrary.configure do |config|
    config.enabled = true
  end
end
```

This is the killswitch of the whole feature.
When disabled, the Media Library will not be available to anyone. It will hide the menu item, block the all the routes, and hide media the library icons from the editors.

## Hide menu item

You can hide the menu item from the sidebar by setting the `visible` option to `false`.

```ruby
# config/initializers/avo.rb
if defined?(Avo::MediaLibrary)
  Avo::MediaLibrary.configure do |config|
    config.visible = false
  end
end
```

You may also use a [block](#execution-context) to conditionally show the menu item. You'll have access to the `Avo::Current` object and you can use it to show the menu item based on the current user.

```ruby
# config/initializers/avo.rb
if defined?(Avo::MediaLibrary)
  Avo::MediaLibrary.configure do |config|
    config.visible = -> { Avo::Current.user.is_developer? }
  end
end
```

This will hide the menu item from the sidebar if the current user is not a developer.

## Add it to the menu editor

The Media Library is a menu item in the sidebar. You can add it to the menu editor by using the `media_library` helper.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.main_menu = lambda {
    link_to 'Media Library', avo.media_library_index_path
  }
end
```

## Use it with the rich text editors

The Media Library will seamlessly integrate with all the rich text editors.

<Image src="/assets/img/3_0/media-library/media-library-rhino.gif" alt="Media Library with Rhino field" size="800x453" />

```ruby
field :body, as: :trix
field :body, as: :rhino
field :body, as: :markdown
```

The editors will each have a button to open the Media Library modal.
Once open, after the user selects the asset, it will be injected into the editor.



# Resource panels
<br>
<Image src="/assets/img/tabs-and-panels/panel.png" width="1024" height="640" alt="Panel" />

Panels are the backbone of Avo's display infrastructure. Most of the information that's on display is wrapped inside a panel. They help maintain a consistent design throughout Avo's pages. They are also available as a view component `Avo::PanelComponent` for custom tools, and you can make your own pages using it.

When using the fields DSL for resources, all fields declared in the root will be grouped into a "main" panel, but you can add your panels.

```ruby
class Avo::Resources::User < Avo::BaseResource
  def fields
    field :id, as: :id, link_to_record: true
    field :email, as: :text, name: "User Email", required: true

    panel name: "User information", description: "Some information about this user" do
      field :first_name, as: :text, required: true, placeholder: "John"
      field :last_name, as: :text, required: true, placeholder: "Doe"
      field :active, as: :boolean, name: "Is active", show_on: :show
    end
  end
end
```
<Image src="/assets/img/tabs-and-panels/root-and-panel.png" width="1024" height="724" alt="Root fields and panel fields" />

You can customize the panel `name` and panel `description`.

## What is the Main Panel?
The Main Panel is the primary container for fields in a resource. It typically includes the resource's title, action buttons, and fields that are part of the resource's core data. You can think of it as the central hub for managing and displaying the resource's information.

The Main Panel is automatically created by Avo based on your resource's field definitions. However, you can also customize it to meet your specific requirements.


## How does Avo compute panels?
By default Avo's field organization occurs behind the scenes, leveraging multiple panels to simplify the onboarding process and reduce complexity when granular customization is not needed.

When retrieving the fields, the first step involves categorizing them based on whether or not they have their own panel. Fields without their own panels are referred to as "standalone" fields. Notably, most association fields, such as `field :users, as: :has_many`, automatically have their dedicated panels.

During the Avo's grouping process, we ensure that the fields maintain the order in which they were declared.

Once the groups are established, we check whether the main panel has been explicitly declared within the resource. If it has been declared, this step is skipped. However, if no main panel declaration exists, we compute a main panel and assign the first group of standalone fields to it. This ensures that the field arrangement aligns with your resource's structure and maintains the desired order.

## Computed panels vs Manual customization
Let's focus on the `fields` method for the next examples. In these examples, we demonstrate how to achieve the same field organization using both computed panels and manual customization. Each example have the code that makes Avo compute the panels and also have an example on how to intentionally declare the panels in order to achieve the same result.

:::code-group
```ruby [Computed]
def fields
  field :id, as: :id
  field :name, as: :text
  field :user, as: :belongs_to
  field :type, as: :text
end
```

```ruby [Customized]
def fields
  main_panel do
    field :id, as: :id
    field :name, as: :text
    field :user, as: :belongs_to
    field :type, as: :text
  end
end
```
:::

On this example Avo figured out that a main panel was not declared and it computes one with all standalone fields.

<Image src="/assets/img/resource-panels/1.png" width="1942" height="455" alt="" />

<br>

Now let's add some field that is not standalone between `name` and `user` fields.

:::code-group
```ruby{5} [Computed]
def fields
  field :id, as: :id
  field :name, as: :text

  field :reviews, as: :has_many

  field :user, as: :belongs_to
  field :type, as: :text
end
```

```ruby [Customized]
def fields
  main_panel do
    field :id, as: :id
    field :name, as: :text
  end

  field :reviews, as: :has_many

  panel do
    field :user, as: :belongs_to
    field :type, as: :text
  end
end
```
:::

Since the field that has it owns panel was inserted between a bunch of standalone fields Avo will compute a main panel for the first batch of standalone fields (`id` and `name`) and will compute a simple panel for the remaining groups of standalone fields (`user` and `type`)

<Image src="/assets/img/resource-panels/2.png" width="1956" height="885" alt="" />

<br>

With these rules on mind we have the ability to keep the resource simple and also to fully customize it, for example, if we want to switch the computed main panel with the computed panel we can declare them in the desired order.

```ruby
def fields
  panel do
    field :user, as: :belongs_to
    field :type, as: :text
  end

  field :reviews, as: :has_many

  main_panel do
    field :id, as: :id
    field :name, as: :text
  end
end
```

<Image src="/assets/img/resource-panels/3.png" width="1917" height="875" alt="" />

By using the `main_panel` and `panel` method, you can manually customize the organization of fields within your resource, allowing for greater flexibility and control.

## Index view fields

By default, only the fields declared in the root and the fields declared inside `main_panel` will be visible on the `Index` view.

```ruby{4-8}
class Avo::Resources::User < Avo::BaseResource
  def fields
    # Only these fields will be visible on the `Index` view
    field :id, as: :id, link_to_record: true
    field :email, as: :text, name: "User Email", required: true
    field :name, as: :text, only_on: :index do
      "#{record.first_name} #{record.last_name}"
    end

    # These fields will be hidden on the `Index` view
    panel name: "User information", description: "Some information about this user" do
      field :first_name, as: :text, required: true, placeholder: "John"
      field :last_name, as: :text, required: true, placeholder: "Doe"
      field :active, as: :boolean, name: "Is active", show_on: :show
    end
  end
end
```

<Image src="/assets/img/tabs-and-panels/index-view.png" width="1024" height="724" alt="Index view" />

<Option name="`visible`">

<VersionReq version="3.10.7" />
The `visible` option allows you to dynamically control the visibility of a panel and all its children based on certain conditions.

This option is particularly useful when you need to show or hide entire sections of your resource at once without having to do it for each field.

Example:
```ruby
panel name: "User information", visible: -> { resource.record.enabled? } do
  field :first_name, as: :text
  field :last_name, as: :text
end
```
</Option>


# Best practices

Due of the dynamic nature of Ruby, Rails, and Avo, you might be tempted to do a few things differently than how we envisioned them to be done.
It's ok if you want to keep doing them like that, but they might not be the most the optimum way of running Avo.

Here's a collection of best practices that we'd like you to know about.

## Avoiding `n+1` using `self.includes`

`n+1` issues happen, but they are pretty simple to mitigate using Avo.

Each resource has the `self.includes` option that helps you eager-load associations.

:::info Detailed documentation
[`self.includes`](#resources)
:::

## Avoid using `if/else` statements in `def fields`

You might be tempted to using `if/else` statements inside the `def fields` method.
This practice is discouraged and we'll try to explain why here.

Because of checks Avo makes during the request lifecycle, we need to know exactly which fields you have defined for your resource, no matter if they should be hidden or not to a user or in a certain scenario.

The alternative is to use the [`visible`](#field-options) field option which will add the field on the list, but keep it hidden from the user based on the computed value.

### Example:

```ruby
# Scenario 1
def fields
  if params[:special_case].present?
    field :special_field, as: :text
  else
    field :regular_field, as: :text
  end
end

# Scenario 2
def fields
  field :special_field, as: :text, visible: -> { params[:special_case].present? }
  field :regular_field, as: :text, visible: -> { params[:special_case].present? }
end
```

In the first scenario, where we use the `if/else` statements, depending on how the `params` are set, the fields list will be `[special_field]` or `[regular_field]`, but never both.
This will lead to many issues like filters not being visible, params not being properly permitted, and more.

In the second scenario, the field list will always be `[special_field, regular_field]` with different visibility rules.
Now Avo will know they are both there and set up the request and UI properly.

So, please use the `visibility` option and avoid `if/else` in `def fields` whenever possible.

## Add an index on the `created_at` column

Avo, by default, sorts the the record on the <Index /> view by the `created_at` attribute, so it's a good idea to add an index for that column.

```ruby
# Example migration
class AddIndexOnUsersCreatedAt < ActiveRecord::Migration[7.1]
  def change
    add_index :users, :created_at
  end
end
```



# Branding

```ruby
Avo.configure do |config|
  config.branding = {
    colors: {
      background: "248 246 242",
      100 => "#C5F1D4",
      400 => "#3CD070",
      500 => "#30A65A",
      600 => "#247D43",
    },
    chart_colors: ['#FFB435', "#FFA102", "#CC8102", '#FFB435', "#FFA102", "#CC8102"],
    logo: "/avo-assets/logo.png",
    logomark: "/avo-assets/logomark.png",
    placeholder: "/avo-assets/placeholder.svg",
    favicon: "/avo-assets/favicon.ico"
  }
end
```

Using the branding feature, you can easily change the look of your app. You tweak it inside your `avo.rb` initializer in the `branding` attribute. It takes a hash with a few properties.

## Configure brand color

To customize the primary color of Avo, you must configure the `colors` key with four color variants. `100` for color hints, `500` for the base primary color, and `400` and `600` values for highlights.

```ruby{4-8}
Avo.configure do |config|
  config.branding = {
    colors: {
      background: "248 246 242",
      100 => "#C5F1D4",
      400 => "#3CD070",
      500 => "#30A65A",
      600 => "#247D43",
    }
  }
end
```

You may also customize the color of Avo's background using the `background` key.

<Image src="/assets/img/branding/green.jpg" width="2560" height="1280" alt="" />

<Image src="/assets/img/branding/red.jpg" width="2560" height="1280" alt="" />

<Image src="/assets/img/branding/orange.jpg" width="2560" height="1280" alt="" />

:::info
The color format can be hex (starting with `#`) or rgb (three groups split by a space, not a comma).
:::


Avo uses [Tailwinds color system](https://tailwindcss.com/docs/customizing-colors). You can generate your own using the tools below.

 - [Palettte](https://palettte.app/)
 - [ColorBox](https://colorbox.io/)
 - [TailwindInk](https://tailwind.ink/)

Here are a few for you to choose from.

```ruby
config.branding = {
  colors: {
    # BLUE
    100 => "#CEE7F8",
    400 => "#399EE5",
    500 => "#0886DE",
    600 => "#066BB2",
    # RED
    100 => "#FACDD4",
    400 => "#F06A7D",
    500 => "#EB3851",
    600 => "#E60626",
    # GREEN
    100 => "#C5F1D4",
    400 => "#3CD070",
    500 => "#30A65A",
    600 => "#247D43",
    # ORANGE
    100 => "#FFECCC",
    400 => "#FFB435",
    500 => "#FFA102",
    600 => "#CC8102",
  }
}
```

## Customize the chart colors

For your dashboard, you can further customize the colors of the charts. You can do that using the `chart_colors` option. Pass in an array of colors, and Avo will do the rest.

```ruby
Avo.configure do |config|
  config.branding = {
    chart_colors: ['#FFB435', "#FFA102", "#CC8102", '#FFB435', "#FFA102", "#CC8102"],
  }
end
```

<Image src="/assets/img/branding/chart-colors.jpg" width="2236" height="1588" alt="" />

:::warning
The chart colors should be hex colors. They are forwarded to chart.js
:::

## Customize the logo

We want to make it easy to change the logo for your app, so we added the `logo` and `logomark` options to the branding feature.

The `logo` should be the "big" logo you want to display on the desktop version of your app, and `logomark` should be a squared-aspect image that Avo displays on the mobile version.

<Image src="/assets/img/branding/logomark.gif" width="800" height="572" alt="" />

## Customize the missing image placeholder

When you view the data in the <Index /> view in a grid, when the `cover` field does not have an image, an avocado is going to be displayed instead as a placeholder.

You might want to change that to something else using the `placeholder` option.

```ruby
Avo.configure do |config|
  config.branding = {
    placeholder: "/YOUR_PLACEHOLDER_IMAGE.jpg",
  }
end
```

## Customize the favicon

We want to make it easy to change the logo for your app, so we added the `favicon` option to the branding feature.
Overwrite it using an `.ico` file.



# Cards

Cards are one way of quickly adding custom content for your users.

Cards can be used on dashboards or resources, we'll refer to both of them as "parent" since they're hosting the cards.

You can add three types of cards to your parent: `partial`, `metric`, and `chartkick`.

## Base settings

All cards have some standard settings like `id`, which must be unique, `label` and `description`. The `label` will be the title of your card, and `description` will show a tiny question mark icon on the bottom right with a tooltip with that description.

Each card has its own `cols` and `rows` settings to control the width and height of the card inside the parent's grid. They can have values from `1` to `6`.

All this settings can be called as an lambda.

The lambda will be executed using [`Avo::ExecutionContext`](#execution-context). Within this blocks, you gain access to all attributes of [`Avo::ExecutionContext`](#execution-context) along with the `parent`, `resource`, `dashboard` and `card`.

```ruby{2-7}
class Avo::Cards::UsersMetric < Avo::Cards::MetricCard
  self.id = "users_metric"
  self.label = -> { "Users count" }
  self.description = -> { "Users description" }
  self.cols = 1
  self.rows = 1
  self.display_header = true
end
```

<Image src="/assets/img/dashboards/users_metric.jpg" width="331" height="170" alt="Avo Metric Card" />

## Ranges
#### Control the aggregation using ranges

You may also want to give the user the ability to query data in different ranges. You can control what's passed in the dropdown using the' ranges' attribute. The array passed here will be parsed and displayed on the card. All integers are transformed to days, and other string variables will be passed as they are.

You can also set a default range using the `initial_range` attribute.

The ranges have been changed a bit since **version 2.8**. The parameter you pass to the `range` option will be directly passed to the [`options_for_select`](https://apidock.com/rails/v5.2.3/ActionView/Helpers/FormOptionsHelper/options_for_select) helper, so it behaves more like a regular `select_tag`.

```ruby{4-15}
class Avo::Cards::UsersMetric < Avo::Cards::MetricCard
  self.id = 'users_metric'
  self.label = 'Users count'
  self.initial_range = 30
  self.ranges = {
    "7 days": 7,
    "30 days": 30,
    "60 days": 60,
    "365 days": 365,
    Today: "TODAY",
    "Month to date": "MTD",
    "Quarter to date": "QTD",
    "Year to date": "YTD",
    All: "ALL"
  }
end
```

## Keep the data fresh

If the parent is something that you keep on the big screen, you need to keep the data fresh at all times. That's easy using `refresh_every`. You pass the number of seconds you need to be refreshed and forget about it. Avo will do it for you.

```ruby{3}
class Avo::Cards::UsersMetric < Avo::Cards::MetricCard
  self.id = 'users_metric'
  self.refresh_every = 10.minutes
end
```

## Hide the header

In cases where you need to embed some content that should fill the whole card (like a map, for example), you can choose to hide the label and ranges dropdown.

```ruby{3}
class Avo::Cards::UsersMetric < Avo::Cards::MetricCard
  self.id = 'users_metric'
  self.display_header = false
end
```
<Image src="/assets/img/dashboards/map_card.jpg" width="653" height="602" alt="Avo Map card" />

## Format

Option `self.format` is useful when you want to format the data that `result` returns from `query`.

Example without format:

```ruby
class Avo::Cards::AmountRaised < Avo::Cards::MetricCard
  self.id = "amount_raised"
  self.label = "Amount raised"
  self.prefix = "$"

  def query
    result 9001
  end
end
```

<Image src="/assets/img/3_0/cards/amount_raised_without_format.png" width="296" height="196" alt="amount raised without format" />


Example with format:

```ruby
class Avo::Cards::AmountRaised < Avo::Cards::MetricCard
  self.id = "amount_raised"
  self.label = "Amount raised"
  self.prefix = "$"
  self.format = -> {
    number_to_social value, start_at: 1_000
  }

  def query
    result 9001
  end
end
```

<Image src="/assets/img/3_0/cards/amount_raised_with_format.png" width="300" height="204" alt="amount raised with format" />

## Metric card

The metric card is your friend when you only need to display a simple big number. To generate one run `bin/rails g avo:card users_metric --type metric`.

<Image src="/assets/img/dashboards/users_metric.jpg" width="331" height="170" alt="Avo Metric" />

#### Calculate results

To calculate your result, you may use the `query` method. After you make the query, use the `result` method to store the value displayed on the card.

In the `query` method you have access to a few variables like `context` (the [App context](#customization)), `params` (the request params), `range` (the range that was requested), `dashboard`, `resource` or `parent` (the current dashboard or resource the card is on), and current `card`.

```ruby{23-47,36}
class Avo::Cards::UsersMetric < Avo::Cards::MetricCard
  self.id = 'users_metric'
  self.label = 'Users count'
  self.description = 'Some tiny description'
  self.cols = 1
  # self.rows = 1
  # self.initial_range = 30
  # self.ranges = {
  #   "7 days": 7,
  #   "30 days": 30,
  #   "60 days": 60,
  #   "365 days": 365,
  #   Today: "TODAY",
  #   "Month to date": "MTD",
  #   "Quarter to date": "QTD",
  #   "Year to date": "YTD",
  #   All: "ALL",
  # }
  # self.prefix = '$'
  # self.suffix = '%'
  # self.refresh_every = 10.minutes

  def query
    from = Date.today.midnight - 1.week
    to = DateTime.current

    if range.present?
      if range.to_s == range.to_i.to_s
        from = DateTime.current - range.to_i.days
      else
        case range
        when 'TODAY'
          from = DateTime.current.beginning_of_day
        when 'MTD'
          from = DateTime.current.beginning_of_month
        when 'QTD'
          from = DateTime.current.beginning_of_quarter
        when 'YTD'
          from = DateTime.current.beginning_of_year
        when 'ALL'
          from = Time.at(0)
        end
      end
    end

    result User.where(created_at: from..to).count
  end
end
```

### Decorate the data using `prefix` and `suffix`

Some metrics might want to add a `prefix` or a `suffix` to display the data better.

```ruby{3,4}
class Avo::Cards::UsersMetric < Avo::Cards::MetricCard
  self.id = 'users_metric'
  self.prefix = '$'
  self.suffix = '%'
end
```

<Image src="/assets/img/dashboards/prefix-suffix.jpg" width="651" height="168" alt="Avo Prefix & suffix" />

<br>

<VersionReq version="3.13" /> `prefix` and `suffix` became callable options.

The blocks are executed using [`Avo::ExecutionContext`](#execution-context). Within this blocks, you gain access to all attributes of [`Avo::ExecutionContext`](#execution-context) along with the `parent`.

```ruby{3,4}
class Avo::Cards::UsersMetric < Avo::Cards::MetricCard
  self.id = 'users_metric'
  self.prefix = -> { params[:prefix] || parent.prefix }
  self.suffix = -> { params[:suffix] || parent.suffix }
end
```

## Chartkick card

A picture is worth a thousand words. So maybe a chart a hundred? Who knows? But creating charts in Avo is very easy with the help of the [chartkick](https://github.com/ankane/chartkick) gem.

You start by running `bin/rails g avo:card users_chart --type chartkick`.

```ruby
class Avo::Cards::UserSignups < Avo::Cards::ChartkickCard
  self.id = 'user_signups'
  self.label = 'User signups'
  self.chart_type = :area_chart
  self.description = 'Some tiny description'
  self.cols = 2
  # self.rows = 1
  # self.chart_options = { library: { plugins: { legend: { display: true } } } }
  # self.flush = true
  # self.legend = false
  # self.scale = false
  # self.legend_on_left = false
  # self.legend_on_right = false

  def query
    points = 16
    i = Time.new.year.to_i - points
    base_data =
      Array
        .new(points)
        .map do
          i += 1
          [i.to_s, rand(0..20)]
        end
        .to_h

    data = [
      { name: 'batch 1', data: base_data.map { |k, v| [k, rand(0..20)] }.to_h },
      { name: 'batch 2', data: base_data.map { |k, v| [k, rand(0..40)] }.to_h },
      { name: 'batch 3', data: base_data.map { |k, v| [k, rand(0..10)] }.to_h }
    ]

    result data
  end
end
```

<Image src="/assets/img/dashboards/chartkick.jpg" width="650" height="169" alt="Chartkick card" />

### Chart types

Using the `self.chart_type` class attribute you can change the type of the chart. Supported types are `line_chart`, `pie_chart`, `column_chart`, `bar_chart`, `area_chart`, and `scatter_chart`.

### Customize chart

Because the charts are being rendered with padding initially, we offset that before rendering to make the chart look good on the card. To disable that, you can set `self.flush = false`. That will set the chart loose for you to customize further.

After you set `flush` to `false`, you can add/remove the `scale` and `legend`. You can also place the legend on the left or right using `legend_on_left` and `legend_on_right`.

These are just some of the predefined options we provide out of the box, but you can send different [chartkick options](https://github.com/ankane/chartkick#options) to the chart using `chart_options`.

If you'd like to use [Groupdate](https://github.com/ankane/groupdate), [Hightop](https://github.com/ankane/hightop), and [ActiveMedian](https://github.com/ankane/active_median) you should require them in your `Gemfile`. Only `chartkick` is required by default.

`chart.js` is supported for the time being. So if you need support for other types, please reach out or post a PR (ðŸ™ PRs are much appreciated).

<VersionReq version="3.6.1" />
`self.chartkick_options` accepts callable blocks:
```ruby
class Avo::Cards::ExampleAreaChart < Avo::Cards::ChartkickCard
  self.chart_options: -> do
    {
      library: {
        plugins: {
          legend: {display: true}
        }
      }
    }
  end
end
```


`chartkick_options` can also be declared when registering the card:

```ruby
class Avo::Dashboards::Dashy < Avo::Dashboards::BaseDashboard
  def cards
    card Avo::Cards::ExampleAreaChart,
      chart_options: {
        library: {
          plugins: {
            legend: {display: true}
          }
        }
      }

    # OR

    card Avo::Cards::ExampleAreaChart,
      chart_options: -> do
        {
          library: {
            plugins: {
              legend: {display: true}
            }
          }
        }
      end
  end
end
```

The blocks are executed using [`Avo::ExecutionContext`](#execution-context). Within this blocks, you gain access to all attributes of [`Avo::ExecutionContext`](#execution-context) along with the `parent`, `arguments` and `result_data`.

## Partial card

You can use a partial card to add custom content to a card. Generate one by running `bin/rails g avo:card custom_card --type partial`. That will create the card class and the partial for it.

```ruby{5}
class Avo::Cards::ExampleCustomPartial < Avo::Cards::PartialCard
  self.id = "users_custom_card"
  self.cols = 1
  self.rows = 4
  self.partial = "avo/cards/custom_card"
  # self.display_header = true
end
```
<Image src="/assets/img/dashboards/custom_partial_card.jpg" width="330" height="598" alt="Custom partial card" />

You can embed a piece of content from another app using an iframe. You can hide the header using the `self.display_header = false` option. That will render the embedded content flush to the container.

```ruby{5}
# app/avo/cards/map_card.rb
class Avo::Cards::MapCard < Avo::Cards::PartialCard
  self.id = "map_card"
  self.label = "Map card"
  self.partial = "avo/cards/map_card"
  self.display_header = false
  self.cols = 2
  self.rows = 4
end
```

```html
<!-- app/views/avo/cards/_map_card.html.erb -->
<iframe src="https://www.google.com/maps/embed?pb=!1m14!1m12!1m3!1d17991.835132857846!2d-73.98926852562143!3d40.742050491245955!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!5e0!3m2!1sen!2sro!4v1647079626880!5m2!1sen!2sro" width="100%" height="100%" style="border:0;" allowfullscreen="" loading="lazy"></iframe>
```

<Image src="/assets/img/dashboards/map_card.jpg" width="653" height="602" alt="Avo Map card" />

## Cards visibility

<VersionReq version="2.28" />

It's common to show the same card to multiple types of users (admins, regular users). In that scenario you might want to hide some cards for the regular users and show them just to the admins.

You can use the `visible` option to do that. It can be a `boolean` or a `block` where you can access the `params`, `current_user`, `context`, `parent`, and `card` object.

```ruby{4-11}
class Avo::Cards::UsersCount < Avo::Cards::MetricCard
  self.id = "users_metric"
  self.label = "Users count"
  self.visible = -> do
    # You have access to:
    # context
    # params
    # parent (the current dashboard or resource)
    # dashboard (will be nil when parent is resource)
    # resource (will be nil when parent is dashboard)
    # current card
    true
  end

  def query
    result User.count
  end
end
```

You may also control the visibility from the parent class.

:::code-group
```ruby [On Dashboards]
class Avo::Dashboards::Dashy < Avo::Dashboards::BaseDashboard
  def cards
    card Avo::Cards::UsersCount, visible: -> { true }
  end
end
```

```ruby [On Resources]
class Avo::Resources::User < Avo::BaseResource
  def cards
    card Avo::Cards::UsersCount, visible: -> { true }
  end
end
```
:::

## Dividers

You may want to separate the cards. You can use dividers to do that.

<!-- :::code-group -->
```ruby [On Dashboards]
class Avo::Dashboards::Dashy < Avo::Dashboards::BaseDashboard
  def cards
    card Avo::Cards::ExampleColumnChart
    card Avo::Cards::ExamplePieChart
    card Avo::Cards::ExampleBarChart
    divider label: "Custom partials"
    card Avo::Cards::ExampleCustomPartial
    card Avo::Cards::MapCard
  end
end
```
<!-- ```ruby [On Resources]
class Avo::Resources::User < Avo::BaseResource
  def cards
    card Avo::Cards::ExampleColumnChart
    card Avo::Cards::ExamplePieChart
    card Avo::Cards::ExampleBarChart
    divider label: "Custom partials"
    card Avo::Cards::ExampleCustomPartial
    card Avo::Cards::MapCard
  end
end
```
::: -->

<Image src="/assets/img/dashboards/divider.jpg" width="980" height="379" alt="Avo Dashboard Divider" />

Dividers can be a simple line between your cards or have some text on them that you control using the `label` option.
When you don't want to show the line, you can enable the `invisible` option, which adds the divider but does not display a border or label.


## Dividers visibility

<VersionReq version="2.28" />

You might want to conditionally show/hide a divider based on a few factors. You can do that using the `visible` option.

```ruby
divider label: "Custom partials", visible: -> {
  # You have access to:
  # context
  # params
  # parent (the current dashboard or resource)
  # dashboard (will be nil when parent is resource)
  # resource (will be nil when parent is dashboard)
  true
}
```



# Collaboration

Keep your team in sync with built-in comments and status updates. No more scattered communication across multiple tools.

:::info
Docs are a work in progress
:::



# Cover and Profile photos

<Image src="/assets/img/3_0/cover-and-profile-photo/cover-and-profile-photo.png" alt="Cover and Profile Photos" width="2560â€Š" height="â€Š1876" class="mt-8" />

It's common to want to display the information in different ways than just "key" and "value". That's why Avo has rich fields like [`key_value`](#keyvalue), [`trix`](#trix), [`tip_tap`](#tip-tap), [`files`](#files), and more.

Avo now also has the Cover and Profile photo areas where you can customize the experience even more.
The APIs used are pretty similar and easy to use.

## Profile photo

The `profile_photo` option takes two arguments: `visible_on` and `source`.

```ruby
self.profile_photo = {
  source: -> {
    if view.index?
      # We're on the index page and don't have a record to reference
      DEFAULT_IMAGE
    else
      # We have a record so we can reference it's profile_photo
      record.profile_photo
    end
  }
}
```

<Option name="`visible_on`">

This controls where the cover photo should be displayed.

It defaults to the <Show />, <Edit />, and <New /> views, but you can change that to be displayed to the <Index /> view or a combination of views.

##### Optional

`true`

##### Default value

`[:show, :forms]`

#### Possible values

You may choose one view or a combination of them using an array.

`:show`, `:edit`, `:new`, `:index`, `:forms`, `:display`, `[:show, :edit]`;
</Option>

<Option name="`source`">

This controls what should be displayed as the image.

You can call a field on the record using a `Symbol`, or you can open a block where you have access to the `record` and add your own value.

##### Default value

`nil`

#### Possible values

You can call a field on the `record` using a symbol.

```ruby
self.profile_photo = {
  source: :profile_photo # this will run `record.profile_photo`
}
```

Use a block to compute your own value.

```ruby
self.profile_photo = {
  source: -> {
    if view.index?
      # We're on the index page and don't have a record to reference
      DEFAULT_IMAGE
    else
      # We have a record so we can reference it's profile_photo
      record.profile_photo
    end
  }
}
```
</Option>

## Cover photo

The `cover_photo` option takes three arguments: `size`, `visible_on`, and `source`.

```ruby
self.cover_photo = {
  size: :md, # :sm, :md, :lg
  visible_on: [:show, :forms], # can be :show, :index, :edit, or a combination [:show, :index]
  source: -> {
    if view.index?
      # We're on the index page and don't have a record to reference
      DEFAULT_IMAGE
    else
      # We have a record so we can reference it's cover_photo
      record.cover_photo
    end
  }
}
```

<Option name="`size`">

This represents the height of the cover photo. It can be small, medium or large.

##### Optional

`true`

##### Default value

`:md`

#### Possible values

`:sm`, `:md`, or `:lg`
</Option>

<Option name="`visible_on`">

This controls where the cover photo should be displayed.

It defaults to the <Show />, <Edit />, and <New /> views, but you can change that to be displayed to the <Index /> view or a combination of views.

##### Optional

`true`

##### Default value

`[:show, :forms]`

#### Possible values

You may choose one view or a combination of them using an array.

`:show`, `:edit`, `:new`, `:index`, `:forms`, `:display`, `[:show, :edit]`;
</Option>

<Option name="`source`">

This controls what should be displayed as the image.

You can call a field on the record using a `Symbol`, or you can open a block where you have access to the `record` and add your own value.

##### Default value

`nil`

#### Possible values

You can call a field on the `record` using a symbol.

```ruby
self.cover_photo = {
  source: :cover_photo # this will run `record.cover_photo`
}
```

Use a block to compute your own value.

```ruby
self.cover_photo = {
  source: -> {
    if view.index?
      # We're on the index page and don't have a record to reference
      DEFAULT_IMAGE
    else
      # We have a record so we can reference it's cover_photo
      record.cover_photo
    end
  }
}
```
</Option>



# Custom asset pipeline

Avo plays well with most Rails asset pipelines.

| Asset pipeline | Avo compatibility |
|---------------|------------|
| [importmap](https://github.com/rails/importmap-rails) | âœ… Fully supported |
| [Propshaft](https://github.com/rails/propshaft)       | âœ… Fully supported |
| [Sprockets](https://github.com/rails/sprockets)       | âœ… Fully supported |
| [Webpacker](https://github.com/rails/webpacker)       | ðŸ›» Only with Sprockets or Propshaft |

There are two things we need to mention when communicating about assets.

1. Avo's assets
2. You custom assets

## Avo's assets

We chose to impact your app, and your deploy processes as little as possible. That's why we bundle up Avo's assets when we publish on [rubygems](https://rubygems.org/gems/avo), so you don't have to do anything else when you deploy your app. Avo doesn't require a NodeJS, or any kind of any other special environment in your deploy process.

Under the hood Avo uses TailwindCSS 3.0 with the JIT engine and bundles the assets using [`jsbundling`](https://github.com/rails/jsbundling-rails) with `esbuild`.

## Exclude servings Avo assets from a CDN?
If you utilize a Content Delivery Network (CDN) for serving assets and you want to exclude Avo paths from the default asset host you may use the following code snippet.

```ruby
config.action_controller.asset_host = Proc.new do |source|
  # Exclude assets under the "/avo" path from CDN
  next nil if source.start_with?("/avo")

  # Set the general asset host (CDN) using an environment variable
  ENV.fetch("ASSET_HOST")
end
```

This configuration ensures that assets are served through the specified CDN, except for those under the `/avo` path. Adjust the paths and environment variable as needed for your application.

## Your custom assets

Avo makes it easy to use your own styles and javascript through your already set up asset pipeline. It just hooks on to it to inject the new assets to be used in Avo.

## Use TailwindCSS utility classes

Please follow the dedicated [TailwindCSS integration guide](#tailwindcss-integration).

## Add custom JS code and Stimulus controllers

There are more ways of dealing with JS assets, and Avo handles that well.

## Use Importmap to add your assets

Importmap has become the default way of dealing with assets in Rails 7. For you to start using custom JS assets with Avo and importmap you should run this install command `bin/rails generate avo:js:install`. That will:

- create your `avo.custom.js` file as your JS entrypoint;
- add it to the `app/views/avo/partials/_head.html.erb` partial so Avo knows to load it;
- pin it in your `importmap.rb` file so `importmap-rails` knows to pick it up.

## Use `js-bundling` with `esbuild`

`js-bundling` gives you a bit more flexibility and power when it comes to assets. We use that under the hood and we'll use it to expose your custom JS assets.

When you install `js-bundling` with `esbuild` you get this npm script `"build": esbuild app/javascript/*.* --bundle --sourcemap --outdir=app/assets/builds --public-path=assets`. That script will take all your JS entrypoint files under `app/javascript` and bundle them under `assets/builds`.

```bash
bin/rails generate avo:js:install --bundler esbuild
```

That command will:

- eject the `_head.html.erb` file;
- add the `avo.custom.js` asset to it;
- create the `avo.custom.js` file under `app/javascript` which will be your entrypoint.

That will be picked up by the `build` script and create it's own `assets/builds/avo.custom.js` file that will, in turn, be picked up by sprockets or propshaft and loaded into your app.

## Use `js-bundling` with `rollup` or `webpack`

Avo supports the other bundlers too but we just don't have a generator command to configure them for you. If you use the other bundlers and have configured them to use custom assets, then please [open up a PR](https://github.com/avo-hq/avo) and help the community get started faster.

## Manually add your CSS and JS assets

In order to manually add your assets you have to eject the `_pre_head.html.erb` partial (`bin/rails generate avo:eject --partial :pre_head`), create the asset files (examples below), and add the asset files from your pipeline to the `_pre_head` partial. Then, your asset pipeline will pick up those assets and use add them to your app.

:::warning
You should add your custom styles to `_pre_head.html.erb`, versus `_head.html.erb` to avoid overriding Avo's default styles. This

The order in which Avo loads the partials and asset files is this one:

1. `_pre_head.html.erb`
2. Avo's CSS and JS assets
3. `_head.html.erb`
:::

<Image src="/assets/img/asset-pipeline.jpg" width="2258" height="1874" alt="Avo and the asset pipeline" />

### Sprockets and Propshaft

Create `avo.custom.js` to the `app/javascripts` directory and `avo.custom.css` to `app/assets/stylesheets` with the desired scripts and styles.
Then add them to Avo using the `_pre_head.html.erb` partial (`rails generate avo:eject --partial :pre_head`).

```erb
# app/views/avo/partials/_pre_head.html.erb

<%= javascript_include_tag 'avo.custom', defer: true %>
<%= stylesheet_link_tag 'avo.custom', media: 'all' %>
```

:::warning
Please ensure that when using `javascript_include_tag` you add the `defer: true` option so the browser will use the same loading strategy as Avo's and the javascript files are loaded in the right order.
:::

### Webpacker

:::warning
We removed support for webpacker. In order to use Avo with your assets you must install Sprockets or Propshaft in order to serve assets like SVG, CSS, or JS files.
:::

:::info
Instructions below are for Webpacker version 6. Version 5 has different paths (`app/javascript/packs`).
:::

Create `avo.custom.js` and `avo.custom.css` inside `app/packs/entrypoints` with the desired scripts and styles.
Then add them to Avo using the `_pre_head.html.erb` partial (`rails generate avo:eject --partial :pre_head`).

```erb
# app/views/avo/partials/_pre_head.html.erb

<%= javascript_pack_tag 'avo.custom', defer: true %>
<%= stylesheet_pack_tag 'avo.custom', media: 'all' %>
```



# Custom fields

Avo ships with 20+ well polished and ready to be used, fields out of the box.

When you need a field that is not provided by default, Avo makes it easy to add it.

## Generate a new field

Every new field comes with three [view components](https://viewcomponent.org/), `Edit` (which is also used in the `New` view), and `Show` and `Index`. There's also a `Field` configuration file.

`bin/rails generate avo:field progress_bar` generates the files for you.

:::info
Please restart your rails server after adding a new custom field.
:::

```bash{2-9}
â–¶ bin/rails generate avo:field progress_bar
      create  app/components/avo/fields/progress_bar_field
      create  app/components/avo/fields/progress_bar_field/edit_component.html.erb
      create  app/components/avo/fields/progress_bar_field/edit_component.rb
      create  app/components/avo/fields/progress_bar_field/index_component.html.erb
      create  app/components/avo/fields/progress_bar_field/index_component.rb
      create  app/components/avo/fields/progress_bar_field/show_component.html.erb
      create  app/components/avo/fields/progress_bar_field/show_component.rb
      create  app/avo/fields/progress_bar_field.rb
```

The `ProgressBarField` file is what registers the field in your admin.

```ruby
class Avo::Fields::ProgressBarField < Avo::Fields::BaseField
  def initialize(name, **args, &block)
    super(name, **args, &block)
  end
end
```

Now you can use your field like so:

```ruby{7}
# app/avo/resources/project.rb
class Avo::Resources::Project < Avo::BaseResource
  self.title = :name

  def fields
    field :id, as: :id, link_to_record: true
    field :progress, as: :progress_bar
  end
end
```
<Image src="/assets/img/custom-fields/progress-show.jpg" width="1046" height="180" alt="Progress custom field" />

The generated view components are basic text fields for now.

```erb{1,9,14}
# app/components/avo/fields/progress_bar_field/edit_component.html.erb
<%= edit_field_wrapper field: @field, index: @index, form: @form, resource: @resource, displayed_in_modal: @displayed_in_modal do %>
  <%= @form.text_field @field.id,
    class: helpers.input_classes('w-full', has_error: @field.model_errors.include?(@field.id)),
    placeholder: @field.placeholder,
    disabled: @field.readonly %>
<% end %>

# app/components/avo/fields/progress_bar_field/index_component.html.erb
<%= index_field_wrapper field: @field do %>
  <%= @field.value %>
<% end %>

# app/components/avo/fields/progress_bar_field/show_component.html.erb
<%= show_field_wrapper field: @field, index: @index do %>
  <%= @field.value %>
<% end %>
```

You can customize them and add as much or as little content as needed. More on customization [below](#customize-the-views).

<Option name="Use existent field template">

There may be times when you want to duplicate an existing field and start from there.

To achieve this behavior, use the `--field_template` argument and pass the original field as a value.

Now, all components will have the exact same code (except the name) as the original field.

```bash
$ bin/rails generate avo:field super_text --field_template text
      create  app/components/avo/fields/super_text_field
      create  app/components/avo/fields/super_text_field/edit_component.html.erb
      create  app/components/avo/fields/super_text_field/edit_component.rb
      create  app/components/avo/fields/super_text_field/index_component.html.erb
      create  app/components/avo/fields/super_text_field/index_component.rb
      create  app/components/avo/fields/super_text_field/show_component.html.erb
      create  app/components/avo/fields/super_text_field/show_component.rb
      create  app/avo/fields/super_text_field.rb
```

We can verify that all components have the text field code. From here there are endless possibilities to extend the original field features.

```ruby
# app/avo/fields/super_text_field.rb
module Avo
  module Fields
    class SuperTextField < BaseField
      attr_reader :link_to_record
      attr_reader :as_html
      attr_reader :protocol

      def initialize(id, **args, &block)
        super(id, **args, &block)

        add_boolean_prop args, :link_to_record
        add_boolean_prop args, :as_html
        add_string_prop args, :protocol
      end
    end
  end
end

# lib/avo/fields/text_field.rb
module Avo
  module Fields
    class TextField < BaseField
      attr_reader :link_to_record
      attr_reader :as_html
      attr_reader :protocol

      def initialize(id, **args, &block)
        super(id, **args, &block)

        add_boolean_prop args, :link_to_record
        add_boolean_prop args, :as_html
        add_string_prop args, :protocol
      end
    end
  end
end
```
</Option>

## Field options

This file is where you may add field-specific options.

 ```ruby{3-6,11-14}
# app/avo/fields/progress_bar_field.rb
class Avo::Fields::ProgressBarField < Avo::Fields::BaseField
  attr_reader :max
  attr_reader :step
  attr_reader :display_value
  attr_reader :value_suffix

  def initialize(name, **args, &block)
    super(name, **args, &block)

    @max = 100
    @step = 1
    @display_value = false
    @value_suffix = nil
  end
end
```

The field-specific options can come from the field declaration as well.

```ruby{11-14,24}
# app/avo/fields/progress_bar_field.rb
class Avo::Fields::ProgressBarField < Avo::Fields::BaseField
  attr_reader :max
  attr_reader :step
  attr_reader :display_value
  attr_reader :value_suffix

  def initialize(name, **args, &block)
    super(name, **args, &block)

    @max = args[:max] || 100
    @step = args[:step] || 1
    @display_value = args[:display_value] || false
    @value_suffix = args[:value_suffix] || nil
  end
end

# app/avo/resources/project.rb
class Avo::Resources::Project < Avo::BaseResource
  self.title = :name

  def fields
    field :id, as: :id, link_to_record: true
    field :progress, as: :progress_bar, step: 10, display_value: true, value_suffix: "%"
  end
end
```

## Field Visibility

If you need to hide the field in some view, you can use the [visibility helpers](#field-options).

```ruby{16}
# app/avo/fields/progress_bar_field.rb
class Avo::Fields::ProgressBarField < Avo::Fields::BaseField
  attr_reader :max
  attr_reader :step
  attr_reader :display_value
  attr_reader :value_suffix

  def initialize(name, **args, &block)
    super(name, **args, &block)

    @max = args[:max] || 100
    @step = args[:step] || 1
    @display_value = args[:display_value] || false
    @value_suffix = args[:value_suffix] || nil

    hide_on :forms
  end
end
```

## Customize the views

No let's do something about those views. Let's add a progress bar to the `Index` and `Show` views.

```erb{1,15}
# app/components/avo/fields/progress_bar_field/show_component.html.erb
<%= show_field_wrapper field: @field, index: @index do %>
  <!-- If display_value is set to true, show the value above the progress bar -->
  <% if @field.display_value %>
    <div class="text-center text-sm font-semibold w-full leading-none mb-1">
      <!-- Add the suffix if value_suffix is set -->
      <%= @field.value %><%= @field.value_suffix if @field.value_suffix.present? %>
    </div>
  <% end %>

  <!-- Show the progress input with the settings we passed to the field. -->
  <progress max="<%= @field.max %>" value="<%= @field.value %>" class="block w-full"></progress>
<% end %>

# app/components/avo/fields/progress_bar_field/index_component.html.erb
<%= index_field_wrapper field: @field do %>
  <!-- If display_value is set to true, show the value above the progress bar -->
  <% if @field.display_value %>
    <div class="text-center text-sm font-semibold w-full leading-none mb-1">
      <!-- Add the suffix if value_suffix is set -->
      <%= @field.value %><%= @field.value_suffix if @field.value_suffix.present? %>
    </div>
  <% end %>

  <!-- Show the progress input with the settings we passed to the field. -->
  <progress max="<%= @field.max %>" value="<%= @field.value %>" class="block w-24"></progress>
<% end %>
```

<Image src="/assets/img/custom-fields/progress-index.jpg" width="764" height="212" alt="Progress bar custom field on index" />

For the `Edit` view, we're going to do something different. We'll implement a `range` input.

```erb{1}
# app/components/avo/fields/progress_bar_field/edit_component.html.erb
<%= edit_field_wrapper field: @field, index: @index, form: @form, resource: @resource, displayed_in_modal: @displayed_in_modal do %>
  <!-- Show the progress input with the settings we passed to the field. -->
  <% if @field.display_value %>
    <div class="text-center text-sm font-semibold w-full leading-none mb-1">
      <!-- Add the suffix if value_suffix is set -->
      <span class="js-progress-bar-value-<%= @field.id %>"><%= @field.value %></span><%= @field.value_suffix if @field.value_suffix.present? %>
    </div>
  <% end %>
  <!-- Add the range input with the settings we passed to the field -->
  <%= @form.range_field @field.id,
    class: 'w-full',
    placeholder: @field.placeholder,
    disabled: @field.readonly,
    min: 0,
    # add the field-specific options
    max: @field.max,
    step: @field.step,
    %>
<% end %>

<script>
// Get the input and value elements
var input = document.getElementById('project_progress');
// Scope the selector to the current field. You might have more than one progress field on the page.
var log = document.querySelector('.js-progress-bar-value-<%= @field.id %>');

// Add an event listener for when the input is updated
input.addEventListener('input', updateValue);

// Update the value element with the value from the input
function updateValue(e) {
  log.textContent = e.target.value;
}
</script>
```
<Image src="/assets/img/custom-fields/progress-edit.jpg" width="1144" height="182" alt="Progress bar custom field edit" />

## Field assets

Because there isn't just one standardized way of handling assets in Rails, we decided we won't provide **asset loading** support for custom fields for now. That doesn't mean that you can't use custom assets (javascript or CSS files), but you will have to load them in your own pipeline in dedicated Avo files.

In the example above, we added javascript on the page just to demonstrate the functionality. In reality, you might add that to a stimulus controller inside your own Avo [dedicated pipeline](#custom-asset-pipeline) (webpacker or sprockets).

Some styles were added in the asset pipeline directly.
```css
progress {
  @apply h-2 bg-white border border-gray-400 rounded shadow-inner;
}
progress[value]::-webkit-progress-bar {
  @apply bg-white border border-gray-500 rounded shadow-inner;
}
progress[value]::-webkit-progress-value{
  @apply bg-green-600 rounded;

}
progress[value]::-moz-progress-bar {
  @apply bg-green-600 rounded appearance-none;
}
```

## Use pre-built Stimulus controllers

Avo ships with a few Stimulus controllers that help you build more dynamic fields.

### Hidden input controller

This controller allows you to hide your content and add a trigger to show it. You'll find it in the Trix field.

<Image src="/assets/img/stimulus/hidden_input_trix.gif" width="1000" height="272" alt="Hidden input controller" />

You should add the `:always_show` `attr_reader` and `@always_show` instance variables to your field.

```ruby{3,8}
# app/avo/fields/color_picker_field.rb
class Avo::Fields::ColorPickerField < Avo::Fields::BaseField
  attr_reader :always_show

  def initialize(id, **args, &block)
    super(id, **args, &block)

    @always_show = args[:always_show] || false
    @allow_non_colors = args[:allow_non_colors]
  end
end
```

Next, in your fields `Show` component, you need to do a few things.

1. Wrap the field inside a controller tag
1. Add the trigger that will show the content.
1. Wrap the value in a div with the `hidden` class applied if the condition `@field.always_show` is `false`.
1. Add the `content` target (`data-hidden-input-target="content"`) to that div.

```erb{4-7,8}
# app/components/avo/fields/color_picker_field/show_component.html.erb

<%= show_field_wrapper field: @field, index: @index do %>
  <div data-controller="hidden-input">
    <% unless @field.always_show %>
      <%= link_to t('avo.show_content'), 'javascript:void(0);', class: 'font-bold inline-block', data: { action: 'click->hidden-input#showContent' } %>
    <% end %>
    <div <% unless @field.always_show %> class="hidden" <% end %> data-hidden-input-target="content">
      <div style="background-color: <%= @field.value %>"
        class="h-6 px-1 rounded-md text-white text-sm flex items-center justify-center leading-none"
      >
        <%= @field.value %>
      </div>
    </div>
  </div>
<% end %>
```

<Image src="/assets/img/stimulus/hidden_input_color.gif" width="1000" height="76" alt="Hidden input controller" />

### Non existing model field

To ensure proper rendering of a custom field that lacks getters and setters at the model level, you must implement these methods within the model.

```ruby
  def custom_field
  end

  def custom_field=(value)
  end
```


# Custom view types
By default, Avo displays all the configured view types on the view switcher. For example, if you have `map_view` and `grid_view` configured, both of them, along with the `table_view`, will be available on the view switcher.

However, there might be cases where you only want to make a specific view type available without removing the configurations for other view types. This can be achieved using the `view_types` class attribute on the resource. Note that when only one view type is available, the view switcher will not be displayed.

```ruby{3}
class Avo::Resources::City < Avo::BaseResource
  # ...
  self.view_types = :table
  #...
end
```

If you want to make multiple view types available, you can use an array. The icons on the view switcher will follow the order in which they are declared in the configuration.

```ruby{3}
class Avo::Resources::City < Avo::BaseResource
  # ...
  self.view_types = [:table, :grid]
  #...
end
```

You can also dynamically restrict the view types based on user roles, params, or other business logic. To do this, assign a block to the `view_types` attribute. Within the block, you'll have access to `resource`, `record`, `params`, `current_user`, and other default accessors provided by `ExecutionContext`.


```ruby{3-9}
class Avo::Resources::City < Avo::BaseResource
  # ...
  self.view_types = -> do
    if current_user.is_admin?
      [:table, :grid]
    else
      :table
    end
  end
  #...
end
```



# Customization options

## Change the app name

On the main navbar next to the logo, Avo generates a link to the homepage of your app. The label for the link is usually computed from your Rails app name. You can customize that however, you want using `config.app_name = 'Avocadelicious'`.

The `app_name` option is also callable using a block. This is useful if you want to reference a `I18n.t` method or something more dynamic.

```ruby
Avo.configure do |config|
  config.app_name = -> { I18n.t "app_name" }
end
```

## Timezone and Currency

Your data-rich app might have a few fields where you reference `date`, `datetime`, and `currency` fields. You may customize the global timezone and currency with `config.timezone = 'UTC'` and `config.currency = 'USD'` config options.

## Resource Index view

There are a few customization options to change how resources are displayed in the **Index** view.

### Resources per page

You may customize how many resources you can view per page with `config.per_page = 24`.

<Image src="/assets/img/resource-index/per-page-config.jpg" width="648" height="438" alt="Per page config" />

### Per page steps

Similarly customize the per-page steps in the per-page picker with `config.per_page_steps = [12, 24, 48, 72]`.

<Image src="/assets/img/resource-index/per-page-steps.jpg" width="628" height="422" alt="Per page config" />

### Resources via per page

For `has_many` associations you can control how many resources are visible in their `Index view` with `config.via_per_page = 8`.

### Default view type

The `ResourceIndex` component supports two view types `:table` and `:grid`. You can change that by `config.default_view_type = :table`. Read more on the [grid view configuration page](#grid-view).

<div class="grid grid-flow-row sm:grid-flow-col sm:grid-cols-2 gap-2 w-full">
  <div class="w-full">
    <strong>Table view</strong>
    <Image src="/assets/img/customization/table-view.png" width="2400" height="1500" alt="Table view" />
  </div>
  <div class="w-full">
    <strong>Grid view</strong>
    <Image src="/assets/img/customization/grid-view.jpg" width="1312" height="1096" alt="Grid view" />
  </div>
</div>

## ID links to resource

On the **Index** view, each row has the controls component at the end, which allows the user to go to the **Show** and **Edit** views and delete that entry. If you have a long row and a not-so-wide display, it might not be easy to scroll to the right-most section to click the **Show** link.

You can enable the `id_links_to_resource` config option to make it easier.

```ruby{4}
Avo.configure do |config|
  config.root_path = '/avo'
  config.app_name = 'Avocadelicious'
  config.id_links_to_resource = true
end
```

That will render all `id` fields in the **Index** view as a link to that resource.

<Image src="/assets/img/fields-reference/as-link-to-resource.jpg" width="694" height="166" alt="As link to resource" />

## Resource controls on the left or both sides

:::warning
<VersionReq version="3.16.3" /> `resource_controls_placement` option is **obsolete**.

Check [row controls configuration on table view](#table-view) instead
:::

<DemoVideo demo-video="https://youtu.be/MfryUtcXqvU?t=706" />

By default, the resource controls are located on the right side of the record rows, which might be hidden if there are a lot of columns. You might want to move the controls to the left side in that situation using the `resource_controls_placement` option.

```ruby{3}
# config/initializers/avo.rb
Avo.configure do |config|
  config.resource_controls_placement = :left
end
```

<Image src="/assets/img/customization/resource-controls-left.jpg" width="1206" height="920" alt="Resource controls on the left side" />

<VersionReq version="3.13.7" class="mt-2" /> You're able to render the controls on both sides

```ruby{3}
# config/initializers/avo.rb
Avo.configure do |config|
  config.resource_controls_placement = :both
end
```

## Container width

```ruby{2-3}
Avo.configure do |config|
  config.full_width_index_view = false
  config.full_width_container = false
end
```

Avo's default main content is constrained to a regular [Tailwind CSS container](https://tailwindcss.com/docs/container). If you have a lot of content or prefer to display it full-width, you have two options.

### Display the `Index` view full-width

Using `full_width_index_view: true` tells Avo to display the **Index** view full-width.

### Display all views full-width

Using `full_width_container: true` tells Avo to display all views full-width.

## Cache resources on the `Index` view

Avo caches each resource row (or Grid item for Grid view) for performance reasons. You can disable that cache using the `cache_resources_on_index_view` configuration option. The cache key is using the record's `id` and `created_at` attributes and the resource file `md5`.

:::info
If you use the `visibility` option to show/hide fields based on the user's role, you should disable this setting.
:::

```ruby{2}
Avo.configure do |config|
  config.cache_resources_on_index_view = false
end
```

## Context

In the `Resource` and `Action` classes, you have a global `context` object to which you can attach a custom payload. For example, you may add the `current_user`, the current request `params`, or any other arbitrary data.

You can configure it using the `set_context` method in your initializer. The block you pass in will be instance evaluated in `Avo::ApplicationController`, so it will have access to the `_current_user` method or `Current` object.

```ruby{3-6}
Avo.configure do |config|
  config.set_context do
    {
      foo: 'bar',
      params: request.params,
    }
  end
end
```

:::warning `_current_user`
It's recommended you don't store your current user here but using the [`current_user_method`](#authentication) config.
:::

You can access the context data with `::Avo::Current.context` object.

## Eject
[This section has moved.](#eject)

## Breadcrumbs

By default, Avo ships with breadcrumbs enabled.

<Image src="/assets/img/customization/breadcrumbs.jpg" width="618" height="297" alt="Avo breadcrumbs" />

You may disable them using the `display_breadcrumbs` configuration option.

```ruby{2}
Avo.configure do |config|
  config.display_breadcrumbs = false
end
```

The first item on the breadcrumb is **Home** with the `root_path` URL. You can customize that using the `set_initial_breadcrumbs` block.

```ruby{2-5}
Avo.configure do |config|
  config.set_initial_breadcrumbs do
    add_breadcrumb "Casa", root_path
    add_breadcrumb "Something else", something_other_path
  end
end
```

Avo uses the [breadcrumbs_on_rails](https://github.com/weppos/breadcrumbs_on_rails) gem under the hood.

### Breadcrumbs for custom pages

You can add breadcrumbs to custom pages in the controller action.

```ruby{3}
class Avo::ToolsController < Avo::ApplicationController
  def custom_tool
    add_breadcrumb "Custom tool"
  end
end
```

## Page titles

When you want to update the page title for a custom tool or page, you only need to assign a value to the `@page_title` instance variable in the controller method.

```ruby{3}
class Avo::ToolsController < Avo::ApplicationController
  def custom_tool
    @page_title = "Custom tool page title"
  end
end
```

Avo uses the [meta-tags](https://github.com/kpumuk/meta-tags) gem to compile and render the page title.

## Home path

When a user clicks your logo inside Avo or goes to the `/avo` URL, they will be redirected to one of your resources. You might want to change that path to something else, like a custom page. You can do that with the `home_path` configuration.

```ruby{2}
Avo.configure do |config|
  config.home_path = "/avo/dashboard"
end
```

### Use a lambda function for the home_path

<VersionReq version="2.8.0" class="mt-2" />

You can also use a lambda function to define that path.

```ruby{2}
Avo.configure do |config|
  config.home_path = -> { avo_dashboards.dashboard_path(:dashy) }
end
```

When you configure the `home_path` option, the `Get started` sidebar item will be hidden in the development environment.

Now, users will be redirected to `/avo/dashboard` whenever they click the logo. You can use this configuration option alongside the `set_initial_breadcrumbs` option to create a more cohesive experience.

```ruby{2-5}
Avo.configure do |config|
  config.home_path = "/avo/dashboard"
  config.set_initial_breadcrumbs do
    add_breadcrumb "Dashboard", "/avo/dashboard"
  end
end
```

## Mount Avo under a nested path

You may need to mount Avo under a nested path, something like `/uk/admin`. In order to do that, you need to consider a few things.

1. Move the engine mount point below any route for custom tools.

```ruby{7,10}
Rails.application.routes.draw do
  # other routes

  authenticate :user, ->(user) { user.is_admin? } do
    scope :uk do
      scope :admin do
        get "dashboard", to: "avo/tools#dashboard" # custom tool added before engine
      end

      mount_avo # engine mounted last
    end
  end
end
```

2. The `root_path` configuration should only be the last path segment.

```ruby
# ðŸš« Don't add the scope to the root_path
Avo.configure do |config|
  config.root_path = "/uk/admin"
end

# âœ… Do this instead
Avo.configure do |config|
  config.root_path = "/admin"
end
```

3. Use full paths for other configurations.

```ruby
Avo.configure do |config|
  config.home_path = "/uk/admin/dashboard"

  config.set_initial_breadcrumbs do
    add_breadcrumb "Dashboard", "/uk/admin/dashboard"
  end
end
```

## Custom `view_component` path

You may not keep your view components under `app/components` and want the generated field `view_component`s to be generated in your custom directory. You can change that using the `view_component_path` configuration key.

```ruby
Avo.configure do |config|
  config.view_component_path = "app/frontend/components"
end
```

## Custom query scopes

You may want to change Avo's queries to add sorting or use gems like [friendly](https://github.com/norman/friendly_id).
You can do that using `index_query` for multiple records and `find_record_method` when fetching one record.

### Custom scope for `Index` page

Using `index_query` you tell Avo how to fetch the records for the `Index` view.

```ruby
class Avo::Resources::User < Avo::BaseResource
  self.index_query = -> {
    query.order(last_name: :asc)
  }
end
```

### Custom find method for `Show` and `Edit` pages

Using `find_record_method` you tell Avo how to fetch one record for `Show` and `Edit` views and other contexts where a record needs to be fetched from the database.

This is very useful when you use something like `friendly` gem, custom `to_param` methods on your model, and even the wonderful `prefix_id` gem.

#### Custom `to_param` method

The following example shows how you can update the `to_param` (to use the post name) method on the `User` model to use a custom attribute and then update the `Avo::Resources::User` so it knows how to search for that model.

::: code-group
```ruby [app/avo/resources/post.rb]
class Avo::Resource::Post < Avo::BaseResource
  self.find_record_method = -> {
    # When using friendly_id, we need to check if the id is a slug or an id.
    # If it's a slug, we need to use the find_by_slug method.
    # If it's an id, we need to use the find method.
    # If the id is an array, we need to use the where method in order to return a collection.
    if id.is_a?(Array)
      id.first.to_i == 0 ? query.where(slug: id) : query.where(id: id)
    else
      id.to_i == 0 ? query.find_by_slug(id) : query.find(id)
    end
  }
end
```

```ruby [app/models/post.rb]
class Post < ApplicationRecord
  before_save :update_slug

  def to_param
    slug || id
  end

  def update_slug
    self.slug = name.parameterize
  end
end
```
:::

#### Using the `friendly` gem

::: code-group
```ruby [app/avo/resources/user.rb]
class Avo::Resources::User < Avo::BaseResource
  self.find_record_method = -> {
    if id.is_a?(Array)
      query.where(slug: id)
    else
      # We have to add .friendly to the query
      query.friendly.find id
    end
  }
end
```

```ruby [app/models/user.rb]
class User < ApplicationRecord
  extend FriendlyId

  friendly_id :name, use: :slugged
end
```
:::

#### Using `prefixed_ids` gem

You really don't have to do anything on Avo's side for this to work. You only need to add the `has_prefix_id` the model as per the documentation. Avo will know how to search for the record.

```ruby
class Course < ApplicationRecord
  has_prefix_id :course
end
```

## Disable features

You might want to disable some Avo features. You can do that using the `disabled_features` option.

```ruby{3}
# config/initializers/avo.rb
Avo.configure do |config|
  config.disabled_features = [:global_search]
end
```

<VersionReq version="3.13.5" /> `disabled_features` become callable. Within this block, you gain access to all attributes of [`Avo::ExecutionContext`](#execution-context)

```ruby{3}
# config/initializers/avo.rb
Avo.configure do |config|
  config.disabled_features = -> { current_user.is_admin? ? [] : [:global_search] }
end
```

After this setting, the global search will be hidden for users.

Supported options:

- `global_search`

## Customize profile name, photo, and title

You might see on the sidebar footer a small profile widget. The widget displays three types of information about the user; `name`, `photo`, and `title`.

### Customize the name of the user

Avo checks to see if the object returned by your [`current_user_method`](#authentication) responds to a `name` method. If not, it will try the `email` method and then fall back to `Avo user`.

### Customize the profile photo

Similarly, it will check if that current user responds to `avatar` and use that as the `src` of the photo.

### Customize the title of the user

Lastly, it will check if it responds to the `avo_title` method and uses that to display it under the name.

### Customize the sign-out link

Please follow [this](#authentication) guide in [authentication](#authentication).

## Skip show view

<div class="space-x-2">
  <VersionReq version="2.16" />
  <BetaStatus label="Public beta"></BetaStatus>
</div>

In the CRUD interface Avo adds the <Show /> view by default. This means that when your users will see the view icon to go to that detail page and they will be redirected to the <Show /> page when doing certain tasks (update a record, run an action, etc.).

You might not want that behavior and you might not use the <Show /> view at all and prefer to skip that and just use the <Edit /> view.
Adding `config.skip_show_view = true` to your `avo.rb` configuration file will tell Avo to skip it and use the <Edit /> view as the default resource view.

```ruby{3}
# config/initializers/avo.rb
Avo.configure do |config|
  config.skip_show_view = true
end
```

<Image src="/assets/img/customization/skip_show_view.gif" width="1870" height="880" alt="" />

## Logger

You may want to set a different output stream for avo logs, you can do that by returning it on a `config.logger` Proc

```ruby
## == Logger ==
config.logger = -> {
  file_logger = ActiveSupport::Logger.new(Rails.root.join("log", "avo.log"))

  file_logger.datetime_format = "%Y-%m-%d %H:%M:%S"
  file_logger.formatter = proc do |severity, time, progname, msg|
    "[Avo] #{time}: #{msg}\n".tap do |i|
      puts i
    end
  end

  file_logger
}
```

<Option name="`default_url_options`">

`default_url_options` is a Rails [controller method](https://apidock.com/rails/ActionController/Base/default_url_options) that will append params automatically to the paths you generate through path helpers.

In order to implement some features like route-level Multitenancy we exposed an API to add to Avo's `default_url_options` method.

::: code-group
```ruby [config/initializers/avo.rb]{2}
Avo.configure do |config|
  config.default_url_options = [:account_id]
end
```
```ruby [app/config/routes.rb]{3}
Rails.application.routes.draw do
  # Use to test out route-based multitenancy
  scope "/account/:account_id" do
    mount_avo
  end
end
```
:::

Now, when you visit `https://example.org/account/adrian/avo`, the `account_id` param is `adrian` and it will be appended to all path helpers.
</Option>

<Option name="`turbo`">

You may want to configure how turbo behave on Avo.

You can configure it using `config.turbo` option on `avo.rb` initializer

Supported options with default values:

```ruby
  config.turbo = -> do
    {
      instant_click: true
    }
  end
```
</Option>

<Option name="`pagination`">

You can configure the default pagination settings key by key.

```ruby
config.pagination = {
  type: :countless
}

# Or

config.pagination = -> do
  {
    type: :countless,
  }
end
```

This will make all your application's tables countless keeping the size key / value as the default one.

Verify all possible options [here](#resources).
</Option>

<Option name="`click_row_to_view_record`">

<!-- <BetaStatus status="beta" /> -->

This setting allows your users to click on a record to navigate to its <Show /> view.

:::warning
This interaction (clicking a `tr` element to behave as a link) is not natively supported in HTML.

Avo enhances this functionality with JavaScript, which may lead to side effects. Please report any issues you encounter on our [issue queue](https://avo.cool/new-issue).
:::

Enable this setting by using the `click_row_to_view_record` configuration option.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.click_row_to_view_record = true
end
```

<Image src="/assets/img/3_0/customization/click-row-to-view-record.gif" width="" height="" alt="Click to view record in Avo" />
</Option>

## Associations lookup list limit

<Option name="`associations_lookup_list_limit`">

<VersionReq version="3.14.1" />

By default, there is a limit of a 1000 records per query when listing the association options. This limit ensures that the page will not crash due to large collections.
Use `associations_lookup_list_limit` configuration to change the limit value.

```ruby{3}
# config/initializers/avo.rb
Avo.configure do |config|
  config.associations_lookup_list_limit = 1000
end
```

The message `There are more records available.` is shown when the limit is reached. To localize the message you can use `I18n.translate("avo.more_records_available")`.

Using [searchable](#belongs_to) is recommended for listing unlimited records with better performance and user experience.

<Image src="/assets/img/customization/associations-lookup-list-limit.png" width="2466" height="1098" alt="Associations lookup list limit configuration" />
</Option>

<Option name="`persistence`">

### Persistent UI State Configuration <VersionReq version="3.15.4" />

#### Overview

The `persistence` configuration enables retention of specific UI settings, such as pagination and static filters, across user interactions.

---

#### Configuration

By default, the `:driver` is `nil`, which means no persistence is applied. You can configure the `:driver` for persistence as follows:

```ruby
Avo.configure do |config|
  config.persistence = {
    driver: :session
  }

  # Or with a dynamic block

  config.persistence = -> do
    {
      driver: :session
    }
  end
end
```

---

#### Behavior

When enabled, the `persistence` configuration ensures the following:

1. **Associations Pagination**
   The pagination state (e.g., `page` and `per_page` settings) for association tables (e.g., `has_many` fields) is retained across requests.

2. **Static Filters**
   Static filter selections applied by users are preserved during their session.

---

#### How It Works

Setting `:driver` to `:session` stores the UI state in the user session, enabling it to persist while the session remains active.

---

:::warning
**Important**:
To prevent issues with session storage limits, avoid relying solely on the default **cookie store** for session management. The **cookie store** in Rails has a size limit of 4096 bytes. Storing multiple pagination states and filter settings may exceed this limit, resulting in an `ActionDispatch::Cookies::CookieOverflow` error.
:::

#### Recommended Session Store

To mitigate potential storage overflow, it is advisable to use a more scalable session store, such as:

- **Redis Store**
- **MemCache Store**

For detailed guidance, refer to the [Rails session store configuration](https://guides.rubyonrails.org/v8.0/configuring.html#config-session-store).

---

By adopting the `persistence` configuration with a suitable session store, you can ensure a seamless user experience.
</Option>

<Option name="alert_dismiss_time" default="5000">

Specifies the duration (in milliseconds) for which alerts remain visible before automatically dismissing.
A lower value results in quicker dismissal, while a higher value keeps the alert on screen for longer.

### Default value

`5000`

### Example

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.alert_dismiss_time = 8000
end
```

</Option>


# Code editors and LLM setup

Use `https://avohq.io/llms.txt` to setup your LLM integration in Cursor, VSCode, and other code editors.

It's a compact, text version of Avo's docs to help AI generate accurate Avo code based on your prompt.

```bash
https://avohq.io/llms.txt
```

## Pick your tool

<EditorList />

<br>

> [!INFO] Thanks DaisyUI!
> We sourced most of these docs from [DaisyUI's excellent editors page](https://daisyui.com/docs/editor/)


# Eject

If you want to change one of Avo's built-in views, you can eject it, update it and use it in your admin panel.

:::warning
Once ejected, the views will not receive updates on new Avo releases. You must maintain them yourself.
:::

<Option name="`--partial`">

Utilize the `--partial` option when you intend to extract certain partial

## Prepared templates

We prepared a few templates to make it easier for you.

`bin/rails generate avo:eject --partial :logo` will eject the `_logo.html.erb` partial.

```
â–¶ bin/rails generate avo:eject --partial :logo
Running via Spring preloader in process 20947
      create  app/views/avo/logo/_logo.html.erb
```

A list of prepared templates:

- `:logo` âž¡ï¸ &nbsp; `app/views/avo/partials/_logo.html.erb`
- `:head` âž¡ï¸ &nbsp; `app/views/avo/partials/_head.html.erb`
- `:header` âž¡ï¸ &nbsp; `app/views/avo/partials/_header.html.erb`
- `:scripts` âž¡ï¸ &nbsp; `app/views/avo/partials/_scripts.html.erb`
- `:sidebar_extra` âž¡ï¸ &nbsp; `app/views/avo/partials/_sidebar_extra.html.erb`

### Logo

In the `app/views/avo/partials` directory, you will find the `_logo.html.erb` partial, which you may customize however you want. It will be displayed in place of Avo's logo.

### Header

The `_header.html.erb` partial enables you to customize the name and link of your app.

### Scripts

The `_scripts.html.erb` partial enables you to insert scripts in the footer of your admin.

## Eject any template

You can eject any partial from Avo using the partial path.

```
â–¶ bin/rails generate avo:eject --partial app/views/layouts/avo/application.html.erb
      create  app/views/layouts/avo/application.html.erb
```
</Option>

<Option name="`--component`">

You can eject any view component from Avo using the `--component` option.

```bash
$ bin/rails generate avo:eject --component Avo::Index::TableRowComponent
```
or

```bash
$ bin/rails generate avo:eject --component avo/index/table_row_component
```

Have the same output:
```bash
create  app/components/avo/index/table_row_component.rb
create  app/components/avo/index/table_row_component.html.erb
```
</Option>

<Option name="`--field-components`">

With `--field-components` option is easy to eject, one or multiple field components. Notice that without using the `--scope`, the ejected components will override the original components for that field everywhere on the project.

Check the `--scope` and the [`components`](#field-options) field options for more details on how to override the components only on specific parts of the project.

```bash
$ rails g avo:eject --field-components text
      create  app/components/avo/fields/text_field
      create  app/components/avo/fields/text_field/edit_component.html.erb
      create  app/components/avo/fields/text_field/edit_component.rb
      create  app/components/avo/fields/text_field/index_component.html.erb
      create  app/components/avo/fields/text_field/index_component.rb
      create  app/components/avo/fields/text_field/show_component.html.erb
      create  app/components/avo/fields/text_field/show_component.rb
```

Let's say you want to override only the edit component of the `TextField`, that can be achieved with this simple command.

```bash
$ rails g avo:eject --field-components text --view edit
      create  app/components/avo/fields/text_field/edit_component.rb
      create  app/components/avo/fields/text_field/edit_component.html.erb
```

</Option>

<Option name="`--view`">

While utilizing the `--field-components` option, you can selectively extract a specific view using the `--view` parameter, as demonstrated in the example above. If this option is omitted, all components of the field will be ejected.

</Option>


<Option name="`--scope`">

When you opt to eject a view component that exists under `Avo::Views` or a field component under `Avo::Fields` namespace, for example the `Avo::Views::ResourceIndexComponent` or `Avo::Fields::TextField::ShowComponent` you can employ the `--scope` option to specify the namespace that should be adopted by the ejected component, extending from `Avo::Views` / `Avo::Fields`.

```bash
$ rails g avo:eject --component Avo::Views::ResourceIndexComponent --scope admins
      create  app/components/avo/views/admins/resource_index_component.rb
      create  app/components/avo/views/admins/resource_index_component.html.erb

$ rails g avo:eject --field-components text --view show --scope admins
      create  app/components/avo/fields/admins/text_field/show_component.rb
      create  app/components/avo/fields/admins/text_field/show_component.html.erb
```

The ejected file have the same code that original `Avo::Views::ResourceIndexComponent` or `Avo::Fields::TextField::ShowComponent` but you can notice that the class name and the directory has changed

```ruby
class Avo::Views::Admins::ResourceIndexComponent < Avo::ResourceComponent

class Avo::Fields::Admins::TextField::ShowComponent < Avo::Fields::ShowComponent
```

:::info Scopes transformation
`--scope users_admins` -> `Avo::Views::UsersAdmins::ResourceIndexComponent`<br>
`--scope users/admins` -> `Avo::Views::Users::Admins::ResourceIndexComponent`
:::
</Option>



# Filters

Most content management systems need a way to filter the data.

Avo provides two types of filters you can use when building your app.

1. [Basic filters](#filters)
2. [Dynamic filters](#dynamic-filters)

## Differences

### 1. Basic filters

- configured as one filter per file
- there are four types of filters (Text, Boolean, Select, Multiple select)
- they are more configurable
- you can scope out the information better
- you can use outside APIs or configurations
- you must add and configure each filter for a resource

### 2. Dynamic filters

- easier to set up. They only require one option on the field
- the user can choose the condition on which they filter the records
- a lot more conditions than basic filters
- the user can add multiple conditions per attribute
- they are more composable


# Grid view

<br>
<Image src="/assets/img/grid-view.jpg" width="1312" height="1096" alt="Avo grid view" />

Some resources are best displayed in a grid view. We can do that with Avo using a `cover_url`, a `title`, and a `body`.

## Enable grid view

To enable grid view for a resource, you need to configure the `grid_view` class attribute on the resource. That will add the grid view to the view switcher on the <Index /> view.

```ruby{2-13}
class Avo::Resources::Post < Avo::BaseResource
  self.grid_view = {
    card: -> do
      {
        cover_url:
          if record.cover_photo.attached?
            main_app.url_for(record.cover_photo.url)
          end,
        title: record.name,
        body: record.truncated_body
      }
    end
  }
end
```

<Image src="/assets/img/view-switcher.png" width="822" height="153" alt="Avo view switcher" />

## Make default view

To make the grid the default way of viewing a resource **Index**, we have to use the `default_view_type` class attribute.

```ruby{2}
class Avo::Resources::Post < Avo::BaseResource
  self.default_view_type = :grid
end
```

## Custom style

You may want to customize the card a little bit. That's possible using the `html` option.

```ruby{13-37}
class Avo::Resources::Post < Avo::BaseResource
  self.grid_view = {
    card: -> do
      {
        cover_url:
          if record.cover_photo.attached?
            main_app.url_for(record.cover_photo.url)
          end,
        title: record.name,
        body: record.truncated_body
      }
    end,
    html: -> do
      {
        title: {
          index: {
            wrapper: {
              classes: "bg-blue-50 rounded-md p-2"
            }
          }
        },
        body: {
          index: {
            wrapper: {
              classes: "bg-gray-50 rounded-md p-1"
            }
          }
        },
        cover: {
          index: {
            wrapper: {
              classes: "blur-sm"
            }
          }
        }
      }
    end
  }
end
```

<Image src="/assets/img/grid-html-option.png" width="1014" height="637" alt="Grid html option" />

## Grid Item Badge

<VersionReq version="3.15" />

<br>
<br>

<Image src="/assets/img/3_0/grid-view/grid-badge.png" size="2080â€Šx1210" alt="Avo Grid View Badge Element" />

One common scenario is to show a badge on top of your grid items. Avo enables you to do that pretty easy using these three options.

<Option name="`badge_label`">

The label is what the user sees on top of your grid item.

```ruby{7}
self.grid_view = {
  card: -> do
    {
      cover_url: record.image.attached? ? main_app.url_for(record.image.variant(resize: "300x300")) : nil,
      title: record.title,
      body: simple_format(record.description),
      badge_label: (record.updated_at < 1.week.ago ? "New" : "Updated"),
    }
  end
}
```

<Image src="/assets/img/3_0/grid-view/badge-label.png" size="1022â€Šx686" alt="Avo Grid View Badge Label" />

</Option>

<Option name="`badge_color`">

You may style it in any [TailwindCSS color](https://tailwindcss.com/docs/customizing-colors#default-color-palette) you prefer.

It only needs to know the color name (`green`, `blue`, `fuchsia`, etc.).

```ruby{8}
self.grid_view = {
  card: -> do
    {
      cover_url: record.image.attached? ? main_app.url_for(record.image.variant(resize: "300x300")) : nil,
      title: record.title,
      body: simple_format(record.description),
      badge_label: (record.updated_at < 1.week.ago ? "New" : "Updated"),
      badge_color: (record.updated_at < 1.week.ago ? "green" : "orange")
    }
  end
}
```

<Image src="/assets/img/3_0/grid-view/badge-color.png" size="1016xâ€Š678" alt="Avo Grid View Badge Color" />

</Option>

<Option name="`badge_title`">

The title refers to the tooltip that the user gets when they hover over the badge.

```ruby{9}
self.grid_view = {
  card: -> do
    {
      cover_url: record.image.attached? ? main_app.url_for(record.image.variant(resize: "300x300")) : nil,
      title: record.title,
      body: simple_format(record.description),
      badge_label: (record.updated_at < 1.week.ago ? "New" : "Updated"),
      badge_color: (record.updated_at < 1.week.ago ? "green" : "orange"),
      badge_title: (record.updated_at < 1.week.ago ? "New product here" : "Updated product here")
    }
  end
}
```

<Image src="/assets/img/3_0/grid-view/badge-title.png" size="1088xâ€Š740" alt="Avo Grid View Badge Title" />

</Option>


# License troubleshooting

There might be times when the configurations isn't up to date and you'd like to troubleshoot it. There are a couple of things you can do to perform a self-diagnostics session.

## Check the license status page

Every Avo app has the license status page where you can see a few things about your license and the response from the license checking server.

Go to `https://yourapp.com/avo/avo_private/status`. If you mounted Avo under a different path (like `admin`) it will be `https://yourapp.com/admin/avo_private/status`.

In order to see that page your user has to be an an admin in Avo. Follow [this guide](#authentication) to mark your user as an admin.

This should tell you if the license authenticated correctly, what is your used license key and what was the response from our checking server.

## Frequent issues

<Option name="License key not properly set on the server">

The most frequent scenario is to not have the license key set on the server.
If you use environment variables to register it in your app you should make sure your key is properly set on your production server.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.license_key = ENV["AVO_LICENSE_KEY"]
end
```

In order to check that, use the status page described above.

</Option>


# Multitenancy

Multitenancy is a very talked-about subject. We're not going to go very deep into how to achieve it on the database level, but will talk a little bit about how it's supported in Avo.

## Breakdown

Usually, with multitenancy you add a new layer just one level below authentication. You don't have just a user to think about, but now that user might act on the behalf of a tenant. That tenant can be an `Account` or a `Team`, or any other model you design in your database.

So now, the mission is to pinpoint which tenant is the user acting for. Because Avo has such an integrated experience and we use our own `ApplicationController`, you might think it's difficult to add that layer, when in fact it's really not. There are a couple of steps to do.

:::info
We'll use the `foo` tenant id from now on.
:::

## Route-based tenancy

There are a couple of strategies here, but the a common one is to use route-based tenancy. That means that your user uses a URL like `https://example.com/foo/` and the app should know to scope everything to that `foo` tenant.

We need to do a few things:

#### 1. Set the proper routing pattern

Mount Avo under the `tenant_id` scope

```ruby
# config/routes.rb
Rails.application.routes.draw do
  scope "/:tenant_id" do
    mount_avo
  end
end
```

#### 2. Set the tenant for each request

:::code-group
```ruby [config/initializers/avo.rb]{6}
Avo.configure do |config|
  # configuration values
end

Rails.configuration.to_prepare do
  Avo::ApplicationController.include Multitenancy
end
```
```ruby [app/controllers/concerns/multitenancy.rb]
module Multitenancy
  extend ActiveSupport::Concern

  included do
    prepend_before_action :set_tenant
  end

  def set_tenant
    Avo::Current.tenant_id = params[:tenant_id]
    Avo::Current.tenant = Account.find params[:tenant_id]
  end
end
```
:::

Now, whenever you navigate to `https://example.com/lol` the tenant the `tenant_id` will be set to `lol`.

## Session-based tenancy

Using a session-based tenancy strategy is a bit simpler as we don't meddle with the routing.

:::warning
The code below shows how it's possible to do session-based multitenancy but your use-case or model names may vary a bit.
:::

We need to do a few things:

#### 1. Set the tenant for each request
:::code-group
```ruby [config/initializers/avo.rb]{6}
Avo.configure do |config|
  # configuration values
end

Rails.configuration.to_prepare do
  Avo::ApplicationController.include Multitenancy
end
```
```ruby [app/controllers/concerns/multitenancy.rb]
module Multitenancy
  extend ActiveSupport::Concern

  included do
    prepend_before_action :set_tenant
  end

  def set_tenant
    Avo::Current.tenant = Account.find session[:tenant_id] || current_user.accounts.first
  end
end
```
:::

#### 2. Add an account switcher

Somewhere in a view on a navbar or sidebar add an account switcher.

:::code-group
```erb [app/views/avo/session_switcher.html.erb]
<% current_user.accounts.each do |account| %>
  <%= link_to account.name, switch_account_path(account.id), class: class_names({"underline": session[:tenant_id].to_s == account.id.to_s}), data: {turbo_method: :put} %>
<% end %>
```

```ruby [app/controllers/avo/switch_accounts_controller.rb]
class Avo::SwitchAccountsController < Avo::ApplicationController
  def update
    # set the new tenant in session
    session[:tenant_id] = params[:id]

    redirect_back fallback_location: root_path
  end
end
```
:::



# Resource Sidebar

By default, all declared fields are going to be stacked vertically in the main area. But there are some fields with information that needs to be displayed in a smaller area, like boolean, date, and badge fields.
Those fields don't need all that horizontal space and can probably be displayed in a different space.
That's we created the **resource sidebar**.

## Adding fields to the sidebar

Using the `sidebar` block on a resource you may declare fields the same way you would do on the root level. Notice that the sidebar should be declared inside a panel. Each resource can have several panels or main panels and each panel can have it's own sidebars.

```ruby
class Avo::Resources::User < Avo::BaseResource
  def fields
    main_panel do
      field :id, as: :id, link_to_record: true
      field :first_name, as: :text, placeholder: "John"
      field :last_name, as: :text, placeholder: "Doe"

      # We can also add custom resource tools
      tool UserTimeline

      sidebar do
        field :email, as: :gravatar, link_to_record: true, only_on: :show
        field :active, as: :boolean, name: "Is active", only_on: :show
      end
    end
  end
end
```

<Image src="/assets/img/resource-sidebar/sidebar.jpg" width="1024" height="640" alt="" />


The fields will be stacked in a similar way in a narrower area on the side of the main panel. You may notice that inside each field, the tabel and value zones are also stacked one on top of the other to allow for a larger area to display the field value.

<Option name="panel_wrapper">

The `panel_wrapper` it's helpful when you want to render a custom tool inside a sidebar and you don't want to apply the `white_panel_classes` to it

```ruby
sidebar panel_wrapper: false do
  tool Avo::ResourceTools::SidebarTool
end
```
</Option>



# Array Resources

## Overview

An **Array Resource** is a flexible resource that can be backed by an **array of hashes** or an **array of Active Record objects**. It is not constrained to an Active Record model and allows dynamic data handling.

:::info Related field
The Array Resource can be used in conjunction with the `Array` field to manage structured array data in your resources.

For more details on using the `Array` field, including examples and hierarchy of data fetching, check out the [Array Field documentation](#array).

This integration allows for seamless configuration of dynamic or predefined array-based data within your application.
:::

:::warning âš ï¸ Limitations

#### Sorting
- The array resource does **not support sorting**.

#### Performance Considerations
- When dealing with large datasets, you might experience suboptimal performance due to inherent architectural constraints.
- **Caching Recommendation:**
  - It is advisable to implement caching mechanisms as a viable solution to ameliorate these performance bottlenecks.
  - **Note:** These caching mechanisms should ideally be integrated into the methods that fetch data, such as the `def records` method.

**Please note that these caveats are based on the current implementation and may be subject to revisions in future releases.**

:::


<div class="aspect-video">
  <iframe width="100%" height="100%" src="https://www.youtube.com/embed/wnWvzQyyo6A?start=1030" title="Avo 3.17 - Media Library, new Markdown field &amp; the Array Adapter" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

## Creating an Array Resource

Generate an **Array Resource** using the `--array` flag:

```bash
bin/rails generate avo:resource Movie --array
```

This sets up a resource designed to work with an array of data.

## Defining the `records` Method

The `records` method serves as the fallback source for data in the resource. It returns an array of hashes or Active Record objects.

### Example

```ruby
def records
  [
    {
      id: 1,
      name: "The Shawshank Redemption",
      release_date: "1994-09-23"
    },
    {
      id: 2,
      name: "The Godfather",
      release_date: "1972-03-24",
      fun_fact: "The iconic cat in the opening scene was a stray found by director Francis Ford Coppola on the studio lot."
    },
    {
      id: 3,
      name: "Pulp Fiction",
      release_date: "1994-10-14"
    }
  ]
end
```

## Defining Fields

Array Resources use fields like any other Avo resource. Hereâ€™s an example for a `Movie` resource:

```ruby
class Avo::Resources::Movie < Avo::Resources::ArrayResource
  def records
    [
      {
        id: 1,
        name: "The Shawshank Redemption",
        release_date: "1994-09-23"
      },
      {
        id: 2,
        name: "The Godfather",
        release_date: "1972-03-24",
        fun_fact: "The iconic cat in the opening scene was a stray found by director Francis Ford Coppola on the studio lot."
      },
      {
        id: 3,
        name: "Pulp Fiction",
        release_date: "1994-10-14"
      }
    ]
  end

  def fields
    main_panel do
      field :id, as: :id
      field :name, as: :text
      field :release_date, as: :date
      field :fun_fact, only_on: :index, visible: -> { resource.record.fun_fact.present? } do
        record.fun_fact.truncate_words(10)
      end

      sidebar do
        field :fun_fact do
          record.fun_fact || "There is no register of a fun fact for #{record.name}"
        end
      end
    end
  end
end
```


# Asset manager

In your plugins or custom content you might want to add a new stylesheet or javascript file to be loaded inside Avo.

You can manually add them to the `_head.html.erb` or `_pre_head.html.erb` files or you can use the `AssetManager`.

Next, the asset manager will add them to the `<head>` element of Avo's layout file.

## Add a stylesheet file

Use `Avo.asset_manager.add_stylesheet PATH`

Example:

```ruby
Avo.asset_manager.add_stylesheet "/public/magic_file.css"
Avo.asset_manager.add_stylesheet Avo::Engine.root.join("app", "assets", "stylesheets", "magic_file.css")
```

## Add a javascript file

Use `Avo.asset_manager.add_javascript PATH`

Example:

```ruby
Avo.asset_manager.add_javascript "/public/magic_file.js"
Avo.asset_manager.add_javascript Avo::Engine.root.join("app", "javascripts", "magic_file.js")
```


# Associations

One of the most amazing things about Ruby on Rails is how easy it is to create [Active Record associations](https://guides.rubyonrails.org/association_basics.html) between models. We try to keep the same simple approach in Avo too.

:::warning
It's important to set the `inverse_of` as often as possible to your model's association attribute.
:::

 - [Belongs to](#belongs-to)
 - [Has one](#has-one)
 - [Has many](#has-many)
 - [Has many through](#has_many)
 - [Has and belongs to many](#has-and-belongs-to-many)

## Single Table Inheritance (STI)

When you have models that share behavior and fields with STI, Rails will cast the model as the final class no matter how you query it.

```ruby
# app/models/user.rb
class User < ApplicationRecord
end

# app/models/super_user.rb
class SuperUser < User
end

# User.all.map(&:class) => [User, SuperUser]
```

For example, when you have two models, `User` and `SuperUser` with STI, when you call `User.all`, Rails will return an instance of `User` and an instance of `SuperUser`. That confuses Avo in producing the proper resource of `User`. That's why when you deal with STI, the final resource `Avo::Resources::SuperUser` should receive the underlying `model_class` so Avo knows which model it represents.

```ruby{5}
# app/avo/resources/super_user.rb
class Avo::Resources::SuperUser < Avo::BaseResource
  self.title = :name
  self.includes = []
  self.model_class = "SuperUser"

  def fields
    field :id, as: :id
    field :name, as: :text
  end
end
```

## Link to child resource when using STI

Let's take another example. We have a `Person` model and `Sibling` and `Spouse` models that inherit from it.

You may want to use the `Avo::Resources::Person` to list all the records, but when your user clicks on a person, you want to use the inherited resources (`Avo::Resources::Sibiling` and `Avo::Resources::Spouse`) to display the details. The reason is that you may want to display different fields or resource tools for each resource type.

There are two ways you can use this:

1. `self.link_to_child_resource = true` Declare this option on the parent resource. When a user is on the <Index /> view of your the `Avo::Resources::Person` and clicks on the view button of a `Person` they will be redirected to a `Child` or `Spouse` resource instead of a `Person` resource.
2. `field :peoples, as: :has_many, link_to_child_resource: false` Use it on a `has_many` field. On the `Avo::Resources::Person` you may want to show all the related people on the <Show /> page, but when someone click on a record, they are redirected to the inherited `Child` or `Spouse` resource.

## Add custom labels to the associations' pages

You might want to change the name that appears on the association page. For example, if you're displaying a `team_members` association, your users will default see `Team members` as the title, but you'd like to show them `Members`.

You can customize that using [fields localization](#i18n).

<Image src="/assets/img/associations/custom-label.jpg" width="1224" height="692" alt="Custom label" />



# Authentication

With Avo, you have the flexibility to build apps either with or without authentication. While Avo has minimal assumptions about its users, a few guidelines still apply:

1. Users can be either authenticated or not. Avo apps can be developed without requiring user authentication.
2. If you choose to implement authentication, you need to [define the current_user](#customize-the-current-user-method).
3. You can assign [lightweight roles](#user-roles) to your users.
4. Any authentication strategy or gem of your choice can be utilized.

:::info Rails 8 authentication scaffold
In essence, the [authentication scaffold](https://github.com/rails/rails/pull/52328) that Rails 8 comes with is custom authentication so we need to do a few things to ensure it's working.

Please follow [this guide](#authentication-using-rails-scaffold) to enable it.
:::

## Customize the `current_user` method

Avo will not assume your authentication provider (the `current_user` method returns `nil`). That means that you have to tell Avo who the `current_user` is.

<Option name="Rails authentication scaffold">

Please follow [this guide](#authentication-using-rails-scaffold) to Rails' authentication scaffold.

</Option>

<Option name="Devise">

For [devise](https://github.com/heartcombo/devise), you should set it to `current_user`.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.current_user_method = :current_user
end
```
</Option>

<Option name="Other methods">

Using another authentication provider, you may customize the `current_user` method to something else.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.current_user_method = :current_admin
end
```

If you get the current user from another object like `Current.user`, you may pass a block to the `current_user_method` key.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.current_user_method do
    Current.user
  end
end
```

</Option>

## Customize the sign-out link

If your app responds to `destroy_user_session_path`, a sign-out menu item will be added on the bottom sidebar (when you click the three dots). If your app does not respond to this method, the link will be hidden unless you provide a custom sign-out path. There are two ways to customize the sign-out path.

### Customize the current user resource name

You can customize just the "user" part of the path name by setting `current_user_resource_name`. For example if you follow the `User` -> `current_user` convention, you might have a `destroy_current_user_session_path` that logs the user out.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.current_user_resource_name = :current_user
end
```

Or if your app provides a `destroy_current_admin_session_path` then you would need to set `current_user_resource_name` to `current_admin`.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.current_user_resource_name = :current_admin
end
```

### Customize the entire sign-out path

Alternatively, you can customize the sign-out path name completely by setting `sign_out_path_name`. For example, if your app provides `logout_path` then you would pass this name to `sign_out_path_name`.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.sign_out_path_name = :logout_path
end
```

If both `current_user_resource_name` and `sign_out_path_name` are set, `sign_out_path_name` takes precedence.

## Filter out requests

You probably do not want to allow Avo access to everybody. If you're using [devise](https://github.com/heartcombo/devise) in your app, use this block to filter out requests in your `routes.rb` file.

```ruby
authenticate :user do
  mount_avo at: '/avo'
end
```

You may also add custom user validation such as `user.admin?` to only permit a subset of users to your Avo instance.

```ruby
authenticate :user, -> user { user.admin? } do
  mount_avo at: '/avo'
end
```

Check out more examples of authentication on [sidekiq's authentication section](https://github.com/mperham/sidekiq/wiki/Monitoring#authentication).

## `authenticate_with` method

Alternatively, you can use the `authenticate_with` config attribute. It takes a block and evaluates it in Avo's `ApplicationController` as a `before_action`.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.authenticate_with do
    authenticate_admin_user
  end
end
```

Note that Avo's `ApplicationController` does not inherit from your app's `ApplicationController`, so any protected methods you defined would not work. Instead, you would need to explicitly write the authentication logic in the block. For example, if you store your `user_id` in the session hash, then you can do:

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.authenticate_with do
    redirect_to '/' unless session[:user_id] == 1 # hard code user ids here
  end
end
```

## User roles

There might be cases where you want to signal to Avo that the current user has a role.

Avo roles are very lightweight and that's for a reason. Building with roles in mind requires a bit more integration with the parent app. This is something that you can definitely take upon yourself to build if you need it.

There are two extra roles that you can give to a user, besides the regular user. These roles can be assigned with a check on the `current_user` object.

<Option name="1. Admin user">

The check that Avo will do to figure that out is to run the `is_admin?` method on the [`current_user`](#customize-the-current-user-method) object.

#### Check if a user is an admin

You can do that check yourself using the `Avo::Current.user_is_admin?`.

#### When does Avo check if the use is an admin (`is_admin?`)

Avo doesn't use this setting momentarily but might in the future.

</Option>

<Option name="2. Developer user">

There might be cases where you want to signal that a user is a developer. The developer will be able to see extra things like long backtrace messages in errors.

The check that Avo will do to figure that out is to run the `is_developer?` method on the [`current_user`](#customize-the-current-user-method) object.

### Check if a user is an developer

You can do that check yourself using the `Avo::Current.user_is_developer?`.

### When does Avo check if the use is an developer (`is_developer?`)

Avo uses this role to display long backtraces on non-validation errors.
Ex: on record save, you might call an API which by some reason errors out. Instead of just getting a generic "Something went wrong" error, the developer user will see the error message and backtrace

<Image src="/assets/img/3_0/authentication/backtrace.png" alt="Backtrace alert" width="1602" height="780" />

</Option>

### Customize the methods that check for roles

You may customize the methods that Avo uses to assign roles in the initializer.

```ruby
# config/avo.rb
Avo.configure do |config|
  config.is_admin_method = :is_admin?
  config.is_developer_method = :is_developer?
end
```

## Authorization

When you share access to Avo with your clients or large teams, you may want to restrict access to a resource or a subset of resources. You should set up your authorization rules (policies) to do that. Check out the [authorization page](#authorization) for details on how to set that up.



# Authorization

When you share access to Avo with your clients or large teams, you may want to restrict access to a resource or a subset of resources. One example may be that only admin-level users may delete or update records.

Avo provides a [Pundit](https://github.com/varvet/pundit) client out of the box for authorization that uses a policy system to manage access.

:::info Pundit alternative
Pundit is just the default client. You may plug in your own client using the instructions [here](#custom-authorization-clients).
You can use [this](https://github.com/avo-hq/avo/issues/1922) `action_policy` client as well.
:::

:::warning
You must manually require `pundit` or your authorization library in your `Gemfile`.

```ruby
# Minimal authorization through OO design and pure Ruby classes
gem "pundit"
```
And update config/initializers/avo.rb with following configuration:
```ruby
# Example of enabling authorization client in Avo configuration
config.authorization_client = :pundit
```
:::

## Ensure Avo knows who your current user is

Before setting any policies up, please ensure Avo knows your current user. Usually, this ðŸ‘‡ set up should be fine, but follow [the authentication guide](#authentication) for more information.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.current_user_method = :current_user
end
```

## Policies

Just run the regular pundit `bin/rails g pundit:policy Post` to generate a new policy.

**If this is a new app you need to install pundit first <code>bin/rails g pundit:install</code>.**

With this new policy, you may control what every type of user can do with Avo. The policy has the default methods for the regular controller actions: `index?`, `show?`, `create?`, `new?`, `update?`, `edit?` and `destroy?`.

These methods control whether the resource appears on the sidebar, if the view/edit/destroy buttons are visible or if a user has access to those index/show/edit/create pages.

<Option name="index?">

`index?` is used to display/hide the resources on the sidebar and restrict access to the resources **Index** view.

:::info
  This option is used in the **auto-generated menu**, not in the **menu editor**.

  You'll have to use your own logic in the [`visible`](#menu-editor) block for that.
:::

</Option>

<Option name="`show?`">

When setting `show?` to `false`, the user will not see the show icon on the resource row and will not have access to the **Show** view of a resource.

</Option>

<Option name="`create?`">

The `create?` method will prevent the users from creating a resource. That will also apply to the `Create new {model}` button on the <Index />, the `Save` button on the `/new` page, and `Create new {model}` button on the association `Show` page.

</Option>

<Option name="`new?`">

The `new?` method will control whether the users can save the new resource. You can also access the `record` variable with the form values pre-filled.

</Option>

<Option name="`edit?`">

`edit?` to `false` will hide the edit button on the resource row and prevent the user from seeing the edit view.

</Option>

<Option name="`update?`">

`update?` to `false` will prevent the user from updating a resource. You can also access the `record` variable with the form values pre-filled.

</Option>

<Option name="`destroy?`">

`destroy?` to `false` will prevent the user from destroying a resource and hiding the delete button.

:::info More granular file authorization
These are per-resource and general settings. If you want to control the authorization per individual file, please see the [granular settings](#attachments).
:::

</Option>

<Option name="`act_on?`">

Controls whether the user can see the actions button on the <Index /> page.

</Option>

<Option name="`reorder?`">

Controls whether the user can see the [records reordering](#records-ordering) buttons on the <Index /> page.

<Image src="/assets/img/authorization/actions_button.jpg" width="1220" height="632" alt="Actions button" />

</Option>

<Option name="`search?`">

Controls whether the user can see the [resource search input](#search) on top of the <Index /> page.

</Option>

<Option name="`preview?`">

<VersionReq version="3.18.0" />

Controls access to the preview endpoint, which is triggered by the [preview field](#record-previews).

:::info
This policy method does not control the visibility of the [preview field](#record-previews). It only manages authorization at the endpoint level. To hide the preview field, use the `visible` field option.
:::

</Option>

## Associations

When using associations, you would like to set policies for `creating` new records on the association, allowing to `attach`, `detach`, `create` or `destroy` relevant records. Again, Avo makes this easy using a straightforward naming schema.

:::warning
Make sure you use the same pluralization as the association name.

For a `has_many :users` association use the plural version method `view_users?`, `edit_users?`, `detach_users?`, etc., not the singular version `detach_user?`.
:::

### Example scenario

We'll have this example of a `Post` resource with many `Comment`s through the `has_many :comments` association.


:::info The `record` variable in policy methods
In the `Post` `has_many` `Comments` example, when you want to authorize `show_comments?` in `PostPolicy` you will have a `Comment` instance as the `record` variable, but when you try to authorize the `attach_comments?`, you won't have that `Comment` instance because you want to create one, but we expose the parent `Post` instance so you have more information about that authorization action that you're trying to make.
:::

<Option name="`attach_{association}?`">

Controls whether the `Attach comment` button is visible. The `record` variable is the parent record (a `Post` instance in our scenario).

<Image src="/assets/img/authorization/attach.jpg" width="1224" height="692" alt="" />

</Option>
<Option name="`detach_{association}?`">

Controls whether the **detach button is available** on the associated record row on the <Index /> view. The `record` variable is the actual row record (a `Comment` instance in our scenario).

<Image src="/assets/img/authorization/detach.jpg" width="1224" height="692" alt="" />

</Option>
<Option name="`view_{association}?`">

Controls whether the whole association is being displayed on the parent record. The `record` variable is the actual row record (a `Comment` instance in our scenario).

</Option>
<Option name="`show_{association}?`">

Controls whether the **view button is visible** on the associated record row on the <Index /> page. The `record` variable is the actual row record (a `Comment` instance in our scenario).

:::warning
This **does not** control whether the user has access to that record. You control that using the Policy of that record (`PostPolicy.show?` in our example).
:::

<Image src="/assets/img/authorization/show.jpg" width="1224" height="692" alt="" />

:::info Difference between `view_{association}?` and `show_{association}?`
Let's take a `Post` `has_many` `Comment`s.

When you use the `view_comments?` policy method you get the `Post` instance as the `record` and you control if the whole listing of comments appears on that record's <Show /> page.

When you use `show_comments?` policy method, the `record` variable is each `Comment` instance and you control whether the view button is displayed on each individual row.
:::

</Option>
<Option name="`edit_{association}?`">

Controls whether the **edit button is visible** on the associated record row on the <Index /> page.The `record` variable is the actual row record (a `Comment` instance in our scenario).

:::warning
This **does not** control whether the user has access to that record's edit page. You control that using the Policy of that record (`PostPolicy.show?` in our example).
:::

<Image src="/assets/img/authorization/edit.jpg" width="1224" height="692" alt="" />
</Option>

<Option name="`create_{association}?`">

Controls whether the `Create comment` button is visible. The `record` variable is the parent record (a `Post` instance in our scenario).

<Image src="/assets/img/authorization/create.jpg" width="1224" height="692" alt="" />

</Option>
<Option name="`destroy_{association}?`">

Controls whether the **delete button is visible** on the associated record row on the <Index /> page.The `record` variable is the actual row record (a `Comment` instance in our scenario).

<Image src="/assets/img/authorization/destroy.jpg" width="1224" height="692" alt="" />

</Option>
<Option name="`act_on_{association}?`">

Controls whether the `Actions` dropdown is visible. The `record` variable is the parent record (a `Post` instance in our scenario).

<Image src="/assets/img/authorization/actions.jpg" width="1224" height="692" alt="" />

</Option>
<Option name="`reorder_{association}?`">

Controls whether the user can see the [records reordering](#records-ordering) buttons on the `has_many` <Index /> page.
</Option>

## Removing duplication

:::info A note on duplication
Let's take the following example:

A `User` has many `Contract`s. And you represent that in your Avo resource. How do you handle authorization to the `ContractResource`?

For one, you set the `ContractPolicy.index?` and `ContractPolicy.edit?` methods to `false` so regular users don't have access to all contracts (see and edit), and the `UserPolicy.view_contracts?` and `UserPolicy.edit_contracts?` set to `false`, because, when viewing a user you want to see all the contracts associated with that user and don't let them edit it.

You might be thinking that there's code duplication here. "Why do I need to set a different rule for `UserPolicy.edit_contracts?` when I already set the `ContractPolicy.edit?` to `false`? Isn't that going to take precedence?"

Now, let's imagine we have a user that is an admin in the application. The business need is that an admin has access to all contracts and can edit them. This is when we go back to the `ContractPolicy.edit?` and turn that to true for the admin user. And now we can separately control who and where a user can edit a contract.
:::

You may remove duplication by applying the same policy rule from the original policy.

```ruby
class CommentPolicy
  # ... more policy methods
  def edit
    record.user_id == current_user.id
  end
end

class PostPolicy
  # ... more policy methods
  def edit_comments?
    Pundit.policy!(user, record).edit?
  end
end
```

Now, whatever action you take for one comment, it will be available for the `edit_comments?` method in `PostPolicy`.

<VersionReq version="2.31" />

From version 2.31 we introduced a concern that removes the duplication and helps you apply the same rules to associations. You should include `Avo::Pro::Concerns::PolicyHelpers` in the `ApplicationPolicy` for it to be applied to all policy classes.

`PolicyHelpers` allows you to use the method `inherit_association_from_policy`. This method takes two arguments; `association_name` and the policy file you want to be used as a template.

```ruby
inherit_association_from_policy :comments, CommentPolicy
```

With just one line of code, it will define the following methods to policy your association:

```ruby
def create_comments?
  CommentPolicy.new(user, record).create?
end

def edit_comments?
  CommentPolicy.new(user, record).edit?
end

def update_comments?
  CommentPolicy.new(user, record).update?
end

def destroy_comments?
  CommentPolicy.new(user, record).destroy?
end

def show_comments?
  CommentPolicy.new(user, record).show?
end

def reorder_comments?
  CommentPolicy.new(user, record).reorder?
end

def act_on_comments?
  CommentPolicy.new(user, record).act_on?
end

def view_comments?
  CommentPolicy.new(user, record).index?
end

# Since Version 3.10.0

def attach_comments?
  CommentPolicy.new(user, record).attach?
end

def detach_comments?
  CommentPolicy.new(user, record).detach?
end
```

Although these methods won't be visible in your policy code, you can still override them. For instance, if you include the following code in your `CommentPolicy`, it will be executed in place of the one defined by the helper:

```ruby
inherit_association_from_policy :comments, CommentPolicy

def destroy_comments?
  false
end
```

## Attachments

<VersionReq version="2.28" />

When working with files, it may be necessary to establish policies that determine whether users can `upload`, `download` or `delete` files. Fortunately, Avo simplifies this process by providing a straightforward naming schema for these policies.

Both the `record` and the `user` will be available for you to access.

<Image src="/assets/img/authorization/file_actions.png" width="472" height="93" alt="" />

<Option name="`upload_{FIELD_ID}?`">

Controls whether the user can upload the attachment.
</Option>

<Option name="`download_{FIELD_ID}?`">

Controls whether the user can download the attachment.
</Option>

<Option name="`delete_{FIELD_ID}?`">

Controls whether the user can destroy the attachment.
</Option>

:::info AUTHORIZE IN BULK
If you want to allow or disallow these methods in bulk you can use a little meta-programming to assign all the same value.

```ruby
[:cover_photo, :audio].each do |file|
  [:upload, :download, :delete].each do |action|
    define_method "#{action}_#{file}?" do
      true
    end
  end
end
```
:::

## Scopes

You may specify a scope for the <Index />, <Show />, and <Edit /> views.

```ruby{3-9}
class PostPolicy < ApplicationPolicy
  class Scope < Scope
    def resolve
      if user.admin?
        scope.all
      else
        scope.where(published: true)
      end
    end
  end
end
```

:::warning
This scope will be applied only to the <Index /> view of Avo. It will not be applied to the association view.

Example:

A `Post` has_many `Comment`s. The `CommentPolicy::Scope` will not affect the `has_many` field. You need to add the [`scope` option](#has_many) to the `has_many` field where you can modify the query.

```ruby
# The `parent` is the Post instance that the user is seeing. ex: Post.find(1)
# The `query` is the Active Record query being done on the comments. ex: post.comments
field :comments, as: :has_many, scope: -> { Pundit.policy_scope(parent, query) }
```
:::

## Using different policy methods

By default Avo will use the generated Pundit methods (`index?`, `show?`, `create?`, `new?`, `update?`, `edit?` and `destroy?`). But maybe, in your app, you're already using these methods and would like to use different ones for Avo. You may want override these methods inside your configuration with a simple map using the `authorization_methods` key.


```ruby{6-14}
Avo.configure do |config|
  config.root_path = '/avo'
  config.app_name = 'Avocadelicious'
  config.license_key = ENV['AVO_LICENSE_KEY']
  config.authorization_methods = {
    index: 'avo_index?',
    show: 'avo_show?',
    edit: 'avo_edit?',
    new: 'avo_new?',
    update: 'avo_update?',
    create: 'avo_create?',
    destroy: 'avo_destroy?',
    search: 'avo_search?',
  }
end
```

Now, Avo will use `avo_index?` instead of `index?` to manage the **Index** view authorization.

## Use Resource's Policy to authorize custom actions

It may be necessary to authorize a specific field or custom action of a resource using a policy class rather than defining the authorization logic directly within the resource class. By doing so, we can delegate control to the policy class, ensuring a cleaner and more maintainable authorization structure.

:::code-group
```ruby [app/resources/product.rb]{8}
field :amount,
      as: :money,
      currencies: %w[USD],
      sortable: true,
      filterable: true,
      copyable: true,
      # define ability to change the amount in policy class instead of doing it here
      disabled: -> { !@resource.authorization.authorize_action(:amount?, raise_exception: false) }
```
```ruby [app/policies/product_policy.rb]{2-4}
# Define ability to change the amount in Product Policy
def amount?
  user.admin?
end

```
:::



## Raise errors when policies are missing

The default behavior of Avo is to allow missing policies for resources silently. So, if you have a `User` model and a `Avo::Resources::User` but don't have a `UserPolicy`, Avo will not raise errors regarding missing policies and authorize that resource.

If, however, you need to be on the safe side of things and raise errors when a Resource is missing a Policy, you can toggle on the `raise_error_on_missing_policy` configuration.

```ruby{7}
# config/initializers/avo.rb
Avo.configure do |config|
  config.root_path = '/avo'
  config.app_name = 'Avocadelicious'
  config.license_key = ENV['AVO_LICENSE_KEY']
  config.raise_error_on_missing_policy = true
end
```

Now, you'll have to provide a policy for each resource you have in your app, thus making it a more secure app.

## Logs
<VersionReq version="3.11.7" />
[Developers](#authentication) have the ability to monitor any unauthorized actions. When a [developer user](#authentication) makes a request that triggers an unauthorized action, a log entry similar to the following will be generated:

In development each log entry provides details about the policy class, the action attempted, the global id of the user who made the request, and the global id of the record involved:
```bash
web     | [Avo->] Unauthorized action 'reorder?' for 'UserPolicy'
web     | user: gid://dummy/User/20
web     | record: gid://dummy/User/31
```

To find a record based on its global id you can use `GlobalID::Locator.locate`

```ruby
gid = "gid://dummy/User/20"
user = GlobalID::Locator.locate(gid)
```

In production each log entry provides details only about the policy class and the attempted action:
```bash
web     | [Avo->] Unauthorized action 'act_on?' for 'UserPolicy'
```

## Custom policies

<VersionReq version="2.17" />

By default, Avo will infer the policy from the model of the resource object. If you wish to use a different policy for a given resource, you can specify it directly in the resource using the `authorization_policy` option.

```ruby
# app/avo/resources/photo_comment.rb
class Avo::Resources::PhotoComment < Avo::BaseResource
  self.model_class = "Comment"
  self.authorization_policy = PhotoCommentPolicy
  # ...
end
```

## Custom authorization clients

:::info
Check out the [Pundit client](https://github.com/avo-hq/avo/blob/main/lib/avo/services/authorization_clients/pundit_client.rb) for reference.
:::

### Change the authorization client

In order to use a different client change the `authorization_client` option in the initializer.

The built-in possible values are `nil` and `:pundit`.

When you create your own client, pass the class name.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.authorization_client = 'Services::AuthorizationClients::CustomClient'
end
```

### Client methods

Each authorization client must expose a few methods.

<Option name="`authorize`">

Receives the `user`, `record`, `action`, and optionally, the `policy_class` (you may want to use custom policy classes for some resources).

```ruby
# Pundit example
def authorize(user, record, action, policy_class: nil)
  Pundit.authorize(user, record, action, policy_class: policy_class)
rescue Pundit::NotDefinedError => error
  raise NoPolicyError.new error.message
rescue Pundit::NotAuthorizedError => error
  raise NotAuthorizedError.new error.message
end
```

</Option>
<Option name="`policy`">

Receives the `user` and `record` and returns the policy to use.

```ruby
def policy(user, record)
  Pundit.policy(user, record)
end
```

</Option>
<Option name="`policy!`">

Receives the `user` and `record` and returns the policy to use. It will raise an error if no policy is found.

```ruby
def policy!(user, record)
  Pundit.policy!(user, record)
rescue Pundit::NotDefinedError => error
  raise NoPolicyError.new error.message
end
```

</Option>
<Option name="`apply_policy`">

Receives the `user`, `record`, and optionally, the policy class to use. It will apply a scope to a query.

```ruby
def apply_policy(user, model, policy_class: nil)
  # Try and figure out the scope from a given policy or auto-detected one
  scope_from_policy_class = scope_for_policy_class(policy_class)

  # If we discover one use it.
  # Else fallback to pundit.
  if scope_from_policy_class.present?
    scope_from_policy_class.new(user, model).resolve
  else
    Pundit.policy_scope!(user, model)
  end
rescue Pundit::NotDefinedError => error
  raise NoPolicyError.new error.message
end
```
</Option>

## Explicit authorization

<Option name="`explicit_authorization`">

:::warning Option Renamed
In versions between <Version version="3.13.4" /> and <Version version="3.13.6" />, this option is named `implicit_authorization`.
:::

<VersionReq version="3.13.4" />

 This option gives you control over how missing policy classes or methods are handled during authorization checks in your Avo application.

### Possible values

**`true`**
  - If a policy class or method is **missing** for a given resource or action, that action will automatically be considered **unauthorized**.
  - This behavior enhances security by ensuring that any unconfigured or unhandled actions are denied by default.

**`false`**
  - If a policy class or method is **missing**, the action will be considered **authorized** by default.

**`Proc`**
  - You can also set `explicit_authorization` as a `Proc` to apply custom logic. Within this block, you gain access to all attributes of [`Avo::ExecutionContext`](#execution-context)

    For example:

    ```ruby
    config.explicit_authorization = -> {
      current_user.access_to_admin_panel? && !current_user.admin?
    }
    ```

    In this case, missing policies will be handled based on the condition: if the user has access to the admin panel but isn't an admin, the `explicit_authorization` will be enabled. This option allows you to customize authorization decisions based on the context of the current user or other factors.
### Default

- For **new applications** (starting from Avo `3.13.4`) the default value for `explicit_authorization` is `true`. This provides a more secure out-of-the-box experience by ensuring actions without explicit authorization are denied.

- For **existing applications** upgrading to `3.13.4` or later the default value for `explicit_authorization` remains `false` to preserve backward compatibility. Existing applications will retain the permissive behavior unless explicitly changed.

### Configuration:

You can configure this setting in your `config/avo.rb` file:

```ruby{4}
Avo.configure do |config|
  # Set to true to deny access when policies or methods are missing
  # Set to false to allow access when policies or methods are missing
  config.explicit_authorization = true
end
```

### Examples:

1. **When `explicit_authorization` is `true`**
    - **Scenario**: You have a `Post` resource, but there is no policy class defined for it.
    - **Result**: All actions for the `Post` resource (index, show, create, etc.) will be **unauthorized** unless you explicitly define a policy class and methods for those actions.

    ---
    - **Scenario**: You have a `Post` resource, and the policy class defined for it only defines the `show?` method.

    ```ruby
    class PostPolicy < ApplicationPolicy
      def show?
        user.admin?
      end
    end
    ```
    - **Result**: In this case, since the `PostPolicy` lacks an `index?` method, attempting to access the `index` action will be denied by default.

2. **When `explicit_authorization: false`**
    - **Scenario**: Same `Post` resource without a policy class.
    - **Result**: All actions for the `Post` resource will be **authorized** even though there are no explicit policy methods. This could expose unintended behavior, as any unprotected action will be accessible.

    ---

    - **Scenario**: You have a `Post` resource, and the policy class defined for it only defines the `show?` method.
    ```ruby
    class PostPolicy < ApplicationPolicy
      def show?
        user.admin?
      end
    end
    ```
    - **Result**: In this case, missing methods like `index?` will allow access to the `index` action by default.


### Migration Recommendations:

- **For applications after from Avo `3.13.4`**

    It is recommended to leave `explicit_authorization` set to `true`, ensuring all actions must be explicitly authorized to prevent unintentional access.

- **For applications before from Avo `3.13.4`**

    - If upgrading from an earlier version, carefully review your policies before enabling `explicit_authorization`. Missing policy methods that were previously allowing access will now deny access unless explicitly defined.

    - Itâ€™s recommended to disable [`raise_error_on_missing_policy`](#authorization) in production, though it's not mandatory. When `explicit_authorization` is set to `true`, the default behavior is to deny access for actions without a defined policy. In this case, itâ€™s often better to show an unauthorized message to users rather than raise an error. However, keeping [`raise_error_on_missing_policy`](#authorization) enabled in development can be helpful for identifying missing policy classes.
</Option>

## Rolify integration

Check out [this guide](#integration-with-rolify) to add rolify role management with Avo.


# `Avo::ApplicationController`

## On extending the `ApplicationController`

You may sometimes want to add functionality to Avo's `ApplicationController`. That functionality may be setting attributes to `Current` or multi-tenancy scenarios.

When you need to do that, you may feel the need to override it with your own version. That means you go into the source code, find `AVO_REPO/app/controllers/avo/application_controller.rb`, copy the whole thing into your own `YOUR_APP/app/controllers/avo/application_controller.rb` file inside your app, and add your own piece of functionality.

```ruby{10,14-16}
# Copied from Avo to `app/controllers/avo/application_controller.rb`
module Avo
  class ApplicationController < ::ActionController::Base
    include Pagy::Backend
    include Avo::ApplicationHelper
    include Avo::UrlHelpers

    protect_from_forgery with: :exception
    around_action :set_avo_locale
    before_action :multitenancy_detector

    # ... more Avo::ApplicationController methods

    def multitenancy_detector
      # your logic here
    end
  end
end
```

That will work just fine until the next time we update it. After that, we might add a method, remove one, change the before/after actions, update the helpers and do much more to it.
**That will definitely break your app the next time when you upgrade Avo**. Avo's private controllers are still considered private APIs that may change at any point. These changes will not appear in the changelog or the upgrade guide.

## Responsibly extending the `ApplicationController`

There is a right way of approaching this scenario using Ruby modules or concerns.

First, you create a concern with your business logic; then you include it in the parent `Avo::ApplicationController` like so:

```ruby{6-8,11-13,18}
# app/controllers/concerns/multitenancy.rb
module Multitenancy
  extend ActiveSupport::Concern

  included do
    before_action :multitenancy_detector
    # or
    prepend_before_action :multitenancy_detector
  end

  def multitenancy_detector
    # your logic here
  end
end

# configuration/initializers/avo.rb
Rails.configuration.to_prepare do
  Avo::ApplicationController.include Multitenancy
end
```

With this technique, the `multitenancy_detector` method and its `before_action` will be included safely in `Avo::ApplicationController`.

:::info
If you'd like to add a `before_action` before all of Avo's before actions, use `prepend_before_action` instead. That will run that code first and enable you to set an account or do something early on.
:::

## Override `ApplicationController` methods

Sometimes you don't want to add methods but want to override the current ones.

For example, you might want to take control of the `Avo::ApplicationController.fill_record` method and add your own behavior.

TO do that you should change a few things in the approach we mentioned above. First we want to `prepend` the concern instead of `include` it and next, if we want to run a class method, we used `prepended` instead of `included`.


```ruby{5-8,10-12,14-17,23}
# app/controllers/concerns/application_controller_overrides.rb
module ApplicationControllerOverrides
  extend ActiveSupport::Concern

  # we use the `prepended` block instead of `included`
  prepended do
    before_action :some_hook
  end

  def some_hook
    # your logic here
  end

  def fill_record
    # do some logic here
    super
  end
end

# configuration/initializers/avo.rb
Rails.configuration.to_prepare do
  # we will prepend instead of include
  Avo::ApplicationController.prepend ApplicationControllerOverrides
end
```

**Related:**
  - [Multitenancy](#multitenancy)


# `Avo::Current`

`Avo::Current` is based on the `Current` pattern Rails exposes using [`ActiveSupport/CurrentAttributes`](https://api.rubyonrails.org/classes/ActiveSupport/CurrentAttributes.html).

On each request Avo will set some values on it.

<Option name="`user`">

This is what will be returned by the [`current_user_method`](#authentication) that you've set in your initializer.
</Option>

<Option name="`params`">

Equivalent of `request.params`.
</Option>

<Option name="`request`">

The Rails `request`.
</Option>

<Option name="`context`">

The [`context`](#customization) that you configured in your initializer evaluated in `Avo::ApplicationController`.
</Option>

<Option name="`view_context`">

An instance of [`ActionView::Rendering`](https://api.rubyonrails.org/classes/ActionView/Rendering.html#method-i-view_context) off of which you can run any methods or variables that are available in your partials.

```ruby
view_context.link_to "Avo", "https://avohq.io"
```
</Option>

<Option name="`locale`">

The `locale` of the app.
</Option>

<Option name="`tenant_id`">

You can set the `tenant_id` for the current request.
</Option>

<Option name="`tenant`">

You can set the `tenant` for the current request.
</Option>

**Related:**
  - [Multitenancy](#multitenancy)




# Avo::Meta

## Overview

`Avo::Meta` equips your [Avo](https://github.com/avo-hq/avo/) application with the ability to add arbitrary _"meta"_ attributes to your resources in a no-code manner.

Under the hood, it leverages a JSON database column and [StoreModel](https://github.com/DmitryTsepelev/store_model) to manage it.

## Installation
Add this line to your application's Gemfile:

```ruby
gem "avo-meta", source: "https://packager.dev/avo-hq/"
```

And then execute:
```bash
$ bundle
```

To use `Avo::Meta`, an additional database table containing the _schemas_ for each resource has to be created. For this, simply install the necessary migrations:

```bash
$ bin/rails avo_meta:install:migrations
$ bin/rails db:migrate
```

## Usage

### Preparation

First, add a `meta` JSON column to your model:

```sh
$ bin/rails g migration AddMetaToUsers meta:json
$ bin/rails db:migrate
```

After that, simply include the `Avo::Metaable` module in said model:

```rb
class User < ApplicationRecord
  include Avo::Metaable
end
```

This will create two things under the hood:

- a _"Meta Properties"_ resource available in the sidebar. Here, you can add new meta properties for each associated resource by adding a name and a type. Under the hood, it modifies the `avo_meta_schemas` database table created via the migrations.

> [!NOTE]
> If the `meta` JSON column is missing on your model, a reminder to add it will be emitted.

- a `meta` class attribute for the associated Avo resource (in the example above, the `User` resource). This class attribute contains the schema definition (essentially a hash containing `name`, `type`, `as`, and other attributes) of the meta entries stored with the model. This will result in a "Meta" panel in your resource `New/Show/Edit` views where you can edit the defined attributes.

To display the meta panel in your resource view to modify these attributes, simply add `meta_panel` to your `def fields` definition:

```rb
class Avo::Resources::User < Avo::BaseResource
  # ...

  def fields
    # ...

    meta_panel
  end
end
```


### Accessing Meta Attributes

To use the meta attributes in your application, simply access them like you would access a `has_one` association:

`@user.meta.shoe_size`

## Menu entry

By default, "Meta Properties" will automatically appear in the sidebar if you are not using a custom menu.

If you are using a custom menu, you need to explicitly add the menu entry:

```ruby{5}
# config/initializers/avo.rb
Avo.configure do |config|
  config.main_menu = -> {
    section "Meta" do
      resource :meta_schema
    end
  }
end
```

# Back button

[WIP]



# Filters

Filters allow you to better scope the index queries for records you are looking for.

Each filter is configured in a class with a few dedicated [methods and options](#filter-options). To use a filter on a resource you must [register it](#register-filters) and it will be displayed on the <Index /> view.

## Filter options

<Option name="`self.name`">

`self.name` is what is going to be displayed to the user in the filters panel.

```ruby
self.name = "User names filter"
```

<VersionReq version="3.14.0" />

```ruby
self.name = -> { I18n.t("avo.filter.name") }
```
Within this block, you gain access to all attributes of [`Avo::ExecutionContext`](#execution-context) along with the `arguments`.

</Option>

<Option name="`self.button_label`">

The value of `self.button_label` is the label displayed on the button that applies the filter.

```ruby
self.button_label = "Filter by user names"
```

<VersionReq version="3.14.0" />

```ruby
self.button_label = -> { I18n.t("avo.filter.button_label") }
```
Within this block, you gain access to all attributes of [`Avo::ExecutionContext`](#execution-context) along with the `arguments`.

</Option>

<Option name="`self.visible`">

You may want to show/hide the filter in some scenarios. You can do that using the `self.visible` attribute.

Inside the visible block you can acces the following variables and you should return a boolean (`true`/`false`).

```ruby
  self.visible = -> do
    #   You have access to:
    #   block
    #   context
    #   current_user
    #   params
    #   parent_model
    #   parent_resource
    #   resource
    #   view
    #   view_context
    true
  end
```
</Option>

<Option name="`self.empty_message`">

There might be times when you will want to show a message to the user when you're not returning any options.

More on this in the [Empty message guide](#empty-message-text).
</Option>
<Option name="`options`">

Some filters allow you to pass options to the user. For example on the [select filter](#select_filter) you can set the options in the dropdown, and on the [boolean filter](#boolean_filter) you may set the checkbox values.
Each filter type has their own `options` configuration explained below.

In the `options` method you have access to the `request`, `params`, [`context`](#customization), `view_context`, and `current_user` objects.
</Option>

<Option name="`apply`">

The `apply` method is what is going to be run when Avo fetches the records on the <Index /> view.

It recieves the `request` form which you can get all the `params` if you need them, it gets the `query` which is the query Avo made to fetch the records. It's a regular [Active Record](https://guides.rubyonrails.org/active_record_querying.html) which you can manipulate.

It also receives the `values` variable which holds the actual choices the user made on the front-end for the [options](#options) you set.
</Option>

<Option name="`default`">

You may set default values for the `options` you set. For example you may set which option to be selected for the [select filter](#select_filter) and which checkboxes to be set for the [boolean filter](#boolean_filter).

In the `default` method you have access to the `request`, `params`, [`context`](#customization), `view_context`, and `current_user` objects.
</Option>

<Option name="`react`">

This is a hook in which you can change the value of the filter based on what other filters have for values.

More on this in the [React to filters guide](#react-to-filters)
</Option>

## Register filters

In order to use a filter you must register it on a `Resource` using the `filter` method inside the `filters` method.

```ruby{9}
class Avo::Resources::Post < Avo::BaseResource
  self.title = :name

  def fields
    field :id, as: :id
  end

  def filters
    filter Avo::Filters::Published
  end
end
```

## Filter types

Avo has several types of filters available [Boolean filter](#Boolean%20Filter), [Select filter](#Select%20Filter), [Multiple select filter](#Multiple%20select%20filter), [Text filter](#Text%20Filter) and since version <Version version="3.11.8" /> [Date time filter](#Date%20time%20Filter).

<Image src="/assets/img/filters.png" width="404" height="727" alt="Avo filters" />

### Filter values

Because the filters get serialized back and forth, the final `value`/`values` in the `apply` method will be stringified or have the stringified keys if they are hashes. You can declare them as regular hashes in the `options` method, but they will get stringified.

<Option name="Boolean Filter">

The boolean filter is a filter where the user can filter the records using one or more checkboxes.

To generate one run:

```bash
bin/rails generate avo:filter featured
```
or
```bash
bin/rails generate avo:filter featured --type boolean
```

Here's a sample filter

```ruby
class Avo::Filters::Featured < Avo::Filters::BooleanFilter
  self.name = 'Featured filter'

  # `values` comes as a hash with stringified keys
  # Eg:
  # {
  #   'is_featured': true
  # }
  def apply(request, query, values)
    return query if values['is_featured'] && values['is_unfeatured']

    if values['is_featured']
      query = query.where(is_featured: true)
    elsif values['is_unfeatured']
      query = query.where(is_featured: false)
    end

    query
  end

  def options
    {
      is_featured: "Featured",
      is_unfeatured: "Unfeatured"
    }
  end

  # Optional method to set the default state.
  # def default
  #   {
  #     is_featured: true
  #   }
  # end
end
```

Each filter file comes with a `name`, `apply`, and `options` methods.

The `name` method lets you set the name of the filter.

The `apply` method is responsible for filtering out the records by giving you access to modify the `query` object. The `apply` method also gives you access to the current `request` object and the passed `values`. The `values` object is a `Hash` containing all the configured `options` with the option name as the key and `true`/`false` as the value.

```ruby
# Example values payload
{
  'is_featured': true,
  'is_unfeatured': false,
}
```

The `options` method defines the available values of your filter. They should return a `Hash` with the option id as a key and option label as value.

### Default value

You can set a default value to the filter, so it has a predetermined state on load. To do that, return the state you desire from the `default` method.

```ruby{23-27}
class Avo::Filters::Featured < Avo::Filters::BooleanFilter
  self.name = 'Featured status'

  def apply(request, query, values)
    return query if values['is_featured'] && values['is_unfeatured']

    if values['is_featured']
      query = query.where(is_featured: true)
    elsif values['is_unfeatured']
      query = query.where(is_featured: false)
    end

    query
  end

  def options
    {
      is_featured: "Featured",
      is_unfeatured: "Unfeatured"
    }
  end

  def default
    {
      is_featured: true
    }
  end
end
```
</Option>

<Option name="Select Filter">

Select filters are similar to Boolean ones but they give the user a dropdown with which to filter the values.

```bash
rails generate avo:filter published --type select
```

The most significant difference from the **Boolean filter** is in the `apply` method. You only get back one `value` attribute, which represents which entry from the `options` method is selected.

A finished, select filter might look like this.

```ruby
class Avo::Filters::Published < Avo::Filters::SelectFilter
  self.name = 'Published status'

  # `value` comes as a string
  # Eg: 'published'
  def apply(request, query, value)
    case value
    when 'published'
      query.where.not(published_at: nil)
    when 'unpublished'
      query.where(published_at: nil)
    else
      query
    end
  end

  def options
    {
      published: "Published",
      unpublished: "Unpublished"
    }
  end

  # Optional method to set the default state.
  # def default
  #   :published
  # end
end
```

### Default value

The select filter supports setting a default too. That should be a string or symbol with the select item. It will be stringified by Avo automatically.

```ruby{22-24}
class Avo::Filters::Published < Avo::Filters::SelectFilter
  self.name = 'Published status'

  def apply(request, query, value)
    case value
    when 'published'
      query.where.not(published_at: nil)
    when 'unpublished'
      query.where(published_at: nil)
    else
      query
    end
  end

  def options
    {
      'published': 'Published',
      'unpublished': 'Unpublished',
    }
  end

  def default
    :published
  end
end
```
</Option>

<Option name="Multiple select filter">

You may also use a multiple select filter.

```bash
rails generate avo:filter post_status --type multiple_select
```

```ruby
class Avo::Filters::PostStatus < Avo::Filters::MultipleSelectFilter
  self.name = "Status"

  # `value` comes as an array of strings
  # Ex: ['admins', 'non_admins']
  def apply(request, query, value)
    if value.include? 'admins'
      query = query.admins
    end

    if value.include? 'non_admins'
      query = query.non_admins
    end

    query
  end

  def options
    {
      admins: "Admins",
      non_admins: "Non admins",
    }
  end

  # Optional method to set the default state.
  # def default
  #   ['admins', 'non_admins']
  # end
end
```

<Image src="/assets/img/multiple-select-filter.png" width="404" height="310" alt="Avo multiple select filter" />

### Dynamic options

The select filter can also take dynamic options:

```ruby{15-17}
class Avo::Filters::Author < Avo::Filters::SelectFilter
  self.name = 'Author'

  def apply(request, query, value)
    query = query.where(author_id: value) if value.present?
    query
  end

  # Example `applied_filters`
  # applied_filters = {
  #   "Avo::Filters::CourseCountryFilter" => {
  #     "USA" => true,
  #     "Japan" => true,
  #     "Spain" => false,
  #     "Thailand" => false,
  #   }
  # }
  def options
    # Here you have access to the `applied_filters` object too
    Author.select(:id, :name).each_with_object({}) { |author, options| options[author.id] = author.name }
  end
end
```
</Option>

<Option name="Text Filter">

You can add complex text filters to Avo using the Text filter

```bash
rails generate avo:filter name --type text
```

```ruby
class Avo::Filters::Name < Avo::Filters::TextFilter
  self.name = "Name filter"
  self.button_label = "Filter by name"

  # `value` comes as text
  # Eg: 'avo'
  def apply(request, query, value)
    query.where('LOWER(name) LIKE ?', "%#{value}%")
  end

  # def default
  #   'avo'
  # end
end
```
</Option>

<Option name="Date time Filter">

<VersionReq version="3.11.8" />

The ideal filter for date selection. This filter allows you to generate a date input, with options to include time selection and even a range selection mode. Customizable to suit your specific needs.

:::warning Timezone Handling
This filter sends the selected value exactly as selected, without any timezone adjustments. If you need to apply timezone conversion or adjustments, please ensure to handle it during the [`apply`](#apply) method.
:::

Generate one by using:
```bash
rails generate avo:filter created_at --type date_time
```

The generated file should be following a similar format:
```ruby
# frozen_string_literal: true

class Avo::Filters::CreatedAt < Avo::Filters::DateTimeFilter
  self.name = "Created at"
  # self.type = :date_time
  # self.mode = :range
  # self.visible = -> do
  #   true
  # end

  def apply(request, query, value)
    query
  end

  # def format
  #   case type
  #   when :date_time
  #     'yyyy-LL-dd TT'
  #   when :date
  #     'yyyy-LL-dd'
  #   end
  # end

  # def picker_format
  #   case type
  #   when :date_time
  #     'Y-m-d H:i:S'
  #   when :time
  #     'Y-m-d'
  #   end
  # end
end

```

### Type
Determines the format of the input field.

##### Default value

`:date_time`

By default, the input allows users to select both a date and a time.

##### Possible values

- `:date`
  - This option restricts the input to date selection only, ideal for scenarios where time input is unnecessary.
  <Image src="/assets/img/date_type.png" class="mt-2" width="385" height="377" alt="Avo date time filter date type" />

- `:time`
  - This option limits the input to time selection only, suitable to apply where only the time is relevant.
  <Image src="/assets/img/time_type.png" class="mt-2" width="385" height="50" alt="Avo date time filter time type" />

- `:date_time`
  - This combined option enables both date and time selection, providing a comprehensive input for more detailed needs.
  <Image src="/assets/img/date_time_type.png" class="mt-2" width="385" height="427" alt="Avo date time filter date_time type" />

### Mode
Defines whether the input allows selection of a single date or a range of dates.

##### Default value

`:range`

By default, the input permits users to select a range of dates, ideal for scenarios such as booking periods or event durations.

##### Possible values
- `:range`
  - Allows users to choose a start and end date, making it suitable for applications that require a time span, such as reservations or scheduling.
  <Image src="/assets/img/range_mode.png" class="mt-2" width="385" height="377" alt="Avo date time filter range mode" />
  :::info
  In `:range` mode the `value` will be formatted as `"2024-08-13 to 2024-08-16"`.

  To separate the start and end dates, use `date_1, date_2 = value.split(" to ")`, which will split the value into `["2024-08-13", "2024-08-16"]`
  :::

- `:single`
  - Limits the selection to a single date, perfect for use cases where only one specific day needs to be selected, such as an appointment or event date.
  <Image src="/assets/img/single_mode.png" class="mt-2" width="385" height="370" alt="Avo date time filter single mode" />

### `picker_options`

This filter uses [flatpickr](https://flatpickr.js.org) as the date and time picker. If you wish to customize the pickerâ€™s options, you can do so by overriding the [`picker_options(value)`](https://github.com/avo-hq/avo/blob/menu/lib/avo/filters/date_time_filter.rb#L22) method. You can merge your custom options with those provided by [flatpickr](https://flatpickr.js.org), which are detailed [here](https://flatpickr.js.org/options/).

```ruby{10-14}
# frozen_string_literal: true

class Avo::Filters::StartingAt < Avo::Filters::DateTimeFilter
  self.name = "The starting at filter"
  self.button_label = "Filter by start time"
  self.empty_message = "Search by start time"
  self.type = :time
  self.mode = :single

  def picker_options(value)
    super.merge({
      minuteIncrement: 3
    })
  end

  def apply(request, query, value)
    query.where("to_char(starting_at, 'HH24:MI:SS') = ?", value)
  end
end
```
</Option>

## Dynamic filter options

<DemoVideo demo-video="https://youtu.be/M2RsNPPFOio" />

You might want to compose more advanced filters, like when you have two filters, one for the country and another for cities, and you'd like to have the cities one populated with cities from the selected country.

Let's take the `Avo::Resources::Course` as an example.

```ruby{3-5,7-14}
# app/models/course.rb
class Course < ApplicationRecord
  def self.countries
    ["USA", "Japan", "Spain", "Thailand"]
  end

  def self.cities
    {
      USA: ["New York", "Los Angeles", "San Francisco", "Boston", "Philadelphia"],
      Japan: ["Tokyo", "Osaka", "Kyoto", "Hiroshima", "Yokohama", "Nagoya", "Kobe"],
      Spain: ["Madrid", "Valencia", "Barcelona"],
      Thailand: ["Chiang Mai", "Bangkok", "Phuket"]
    }
  end
end
```

We will create two filtersâ€”one for choosing countries and another for cities.

```ruby{4-5}
# app/avo/resources/course.rb
class Avo::Resources::Course < Avo::BaseResource
  def filters
    filter Avo::Filters::CourseCountryFilter
    filter Avo::Filters::CourseCityFilter
  end
end
```

The country filter is pretty straightforward. Set the query so the `country` field to be one of the selected countries and the `options` are the available countries as `Hash`.

```ruby{6,10}
# app/avo/filters/course_country.rb
class Avo::Filters::CourseCountry < Avo::Filters::BooleanFilter
  self.name = "Course country filter"

  def apply(request, query, values)
    query.where(country: values.select { |country, selected| selected }.keys)
  end

  def options
    Course.countries.map { |country| [country, country] }.to_h
  end
end
```

The cities filter has a few more methods to manage the data better, but the gist is the same. The `query` makes sure the records have the city value in one of the cities that have been selected.

The `options` method gets the selected countries from the countries filter (`Avo::Filters::CourseCountryFilter`) and formats them to a `Hash`.

```ruby{6,10}
# app/avo/filters/course_city.rb
class Avo::Filters::CourseCity < Avo::Filters::BooleanFilter
  self.name = "Course city filter"

  def apply(request, query, values)
    query.where(city: values.select { |city, selected| selected }.keys)
  end

  def options
    cities_for_countries countries
  end

  private

  # Get a hash of cities for certain countries
  # Example payload:
  # countries = ["USA", "Japan"]
  def cities_for_countries(countries_array = [])
    countries_array
      .map do |country|
        # Get the cities for this country
        Course.cities.stringify_keys[country]
      end
      .flatten
      # Prepare to transform to a Hash
      .map { |city| [city, city] }
      # Turn to a Hash
      .to_h
  end

  # Get the value of the selected countries
  # Example payload:
  # applied_filters = {
  #   "Avo::Filters::CourseCountryFilter" => {
  #     "USA" => true,
  #     "Japan" => true,
  #     "Spain" => false,
  #     "Thailand" => false,
  #   }
  # }
  def countries
    if applied_filters["Avo::Filters::CourseCountryFilter"].present?
      # Fetch the value of the countries filter
      applied_filters["Avo::Filters::CourseCountryFilter"]
        # Keep only the ones selected
        .select { |country, selected| selected }
        # Pluck the name of the coutnry
        .keys
    else
      # Return empty array
      []
    end
  end
end
```

<Image src="/assets/img/filters/dynamic-options.png" width="688" height="1042" alt="Avo filters" />

The `countries` method above will check if the `Avo::Filters::CourseCountryFilter` has anything selected. If so, get the names of the chosen ones. This way, you show only the cities from the selected countries and not all of them.

## React to filters

<DemoVideo demo-video="https://youtu.be/M2RsNPPFOio?t=219" />

Going further with the example above, a filter can react to other filters. For example, let's say that when a user selects `USA` from the list of countries, you want to display a list of cities from the USA (that's already happening in `options`), and you'd like to select the first one on the list. You can do that with the `react` method.

```ruby{21-36}
# app/avo/filters/course_city.rb
class Avo::Filters::CourseCity < Avo::Filters::BooleanFilter
  self.name = "Course city filter"

  def apply(request, query, values)
    query.where(city: values.select { |city, selected| selected }.keys)
  end

  def options
    cities_for_countries countries
  end

  # applied_filters = {
  #   "Avo::Filters::CourseCountryFilter" => {
  #     "USA" => true,
  #     "Japan" => true,
  #     "Spain" => false,
  #     "Thailand" => false,
  #   }
  # }
  def react
    # Check if the user selected a country
    if applied_filters["Avo::Filters::CourseCountryFilter"].present? && applied_filters["Avo::Filters::CourseCityFilter"].blank?
      # Get the selected countries, get their cities, and select the first one.
      selected_countries = applied_filters["Avo::Filters::CourseCountryFilter"].select do |name, selected|
        selected
      end

      # Get the first city
      cities = cities_for_countries(selected_countries.keys)
      first_city = cities.first.first

      # Return the first city as selected
      [[first_city, true]].to_h
    end
  end

  private

  # Get a hash of cities for certain countries
  # Example payload:
  # countries = ["USA", "Japan"]
  def cities_for_countries(countries_array = [])
    countries_array
      .map do |country|
        # Get the cities for this country
        Course.cities.stringify_keys[country]
      end
      .flatten
      # Prepare to transform to a Hash
      .map { |city| [city, city] }
      # Turn to a Hash
      .to_h
  end

  # Get the value of the selected countries
  # Example `applied_filters` payload:
  # applied_filters = {
  #   "Avo::Filters::CourseCountryFilter" => {
  #     "USA" => true,
  #     "Japan" => true,
  #     "Spain" => false,
  #     "Thailand" => false,
  #   }
  # }
  def countries
    if applied_filters["Avo::Filters::CourseCountryFilter"].present?
      # Fetch the value of the countries filter
      applied_filters["Avo::Filters::CourseCountryFilter"]
        # Keep only the ones selected
        .select { |country, selected| selected }
        # Pluck the name of the coutnry
        .keys
    else
      # Return empty array
      []
    end
  end
end
```

After all, filters are applied, the `react` method is called, so you have access to the `applied_filters` object.
Using the applied filter payload, you can return the value of the current filter.

```ruby
def react
  # Check if the user selected a country
  if applied_filters["Avo::Filters::CourseCountryFilter"].present? && applied_filters["Avo::Filters::CourseCityFilter"].blank?
    # Get the selected countries, get their cities, and select the first one.
    selected_countries = applied_filters["Avo::Filters::CourseCountryFilter"]
      .select do |name, selected|
        selected
      end

    # Get the first city
    cities = cities_for_countries(selected_countries.keys)
    first_city = cities.first.first

    # Return the first city selected as a Hash
    [[first_city, true]].to_h
  end
end
```

Besides checking if the countries filter is populated (`applied_filters["Avo::Filters::CourseCountryFilter"].present?`), we also want to allow the user to customize the cities filter further, so we need to check if the user has added a value to that filter (`applied_filters["Avo::Filters::CourseCountryFilter"].blank?`).
If these conditions are true, the country filter has a value, and the user hasn't selected any values from the cities filter, we can react to it and set a value as the default one.

<Image src="/assets/img/filters/dynamic-options.gif" width="528" height="800" alt="Avo filters" />

Of course, you can modify the logic and return all kinds of values based on your needs.

## Empty message text

<DemoVideo demo-video="https://youtu.be/M2RsNPPFOio?t=347" />

There might be times when you will want to show a message to the user when you're not returning any options. You may customize that message using the `empty_message` option.

<Image src="/assets/img/filters/empty-message.gif" width="528" height="800" alt="Avo filters" />

```ruby{4}
# app/avo/filters/course_city.rb
class Avo::Filters::CourseCity < Avo::Filters::BooleanFilter
  self.name = "Course city filter"
  self.empty_message = "Please select a country to view options."

  def apply(request, query, values)
    query.where(city: values.select { |city, selected| selected }.keys)
  end

  def options
    if countries.present?
      []
    else
      ["Los Angeles", "New York"]
    end
  end

  private

  def countries
    # logic to fetch the countries
  end
end
```

## Keep filters panel open

<DemoVideo demo-video="https://youtu.be/M2RsNPPFOio?t=374" />

There are scenarios where you wouldn't want to close the filters panel when you change the values. For that, you can use the `keep_filters_panel_open` resource option.

More on this on the [`keep_filters_panel_open` resource option](#resources).

## Filter arguments

Filters can have different behaviors according to their host resource. In order to achieve that, arguments must be passed like on the example below:

```ruby{12-14}
class Avo::Resources::Fish < Avo::BaseResource
  self.title = :name

  def fields
    field :id, as: :id
    field :name, as: :text
    field :user, as: :belongs_to
    field :type, as: :text, hide_on: :forms
  end

  def filters
    filter Avo::Filters::NameFilter, arguments: {
      case_insensitive: true
    }
  end
end
```

Now, the arguments can be accessed inside `Avo::Filters::NameFilter` ***`apply` method***, ***`options` method*** and on the ***`visible` block***!

```ruby{4-6,8-14}
class Avo::Filters::Name < Avo::Filters::TextFilter
  self.name = "Name filter"
  self.button_label = "Filter by name"
  self.visible = -> do
    arguments[:case_insensitive]
  end

  def apply(request, query, value)
    if arguments[:case_insensitive]
      query.where("LOWER(name) LIKE ?", "%#{value.downcase}%")
    else
      query.where("name LIKE ?", "%#{value}%")
    end
  end
end
```

## Manually create encoded URLs

You may want to redirect users to filtered states of the <Index /> view from other places in your app. In order to create those filtered states you may use these helpers functions or Rails helpers.


### Rails helpers

<Option name="`decode_filter_params`">

Decodes the `filters` param. This Rails helper can be used anywhere in a view or off the `view_context`.

#### Usage

```ruby
# in a view
decode_filter_params params[:filters] # {"NameFilter"=>"Apple"}

# Or somewhere in an Avo configuration file

class Avo::Actions::DummyAction < Avo::BaseAction
  self.name = "Dummy action"

  def handle(**args)
    filters = view_context.decode_filter_params(params[:filters])

    do_something_important_with_the_filters filters
  end
end
```
</Option>

<Option name="`encode_filter_params`">

Encodes a `filters` object into a serialized state that Avo understands. This Rails helper can be used anywhere in a view or off the `view_context`.

#### Usage

```ruby
# in a view
filters = {"NameFilter"=>"Apple"}
encode_filter_params filters # eyJOYW1lRmlsdGVyIjoiQXBwbGUifQ==

# Or somewhere in an Avo configuration file

class Avo::Actions::DummyAction < Avo::BaseAction
  self.name = "Dummy action"

  def handle(**args)
    do_something_important

    redirect_to avo.resources_users_path(filters: view_context.decode_filter_params({"NameFilter"=>"Apple"}))
  end
end
```
</Option>

### Standalone helpers

<Option name="`Avo::Filters::BaseFilter.decode_filters`">

Decodes the `filters` param. This standalone method can be used anywhere.

#### Usage

```ruby
class Avo::Actions::DummyAction < Avo::BaseAction
  self.name = "Dummy action"

  def handle(**args)
    filters = Avo::Filters::BaseFilter.decode_filters(params[:filters])

    do_something_important_with_the_filters filters
  end
end
```
</Option>

<Option name="`Avo::Filters::BaseFilter.encode_filters`">

Encodes a `filters` object into a serialized state that Avo understands. This standalone method can be used anywhere.

#### Usage

```ruby
class Avo::Actions::DummyAction < Avo::BaseAction
  self.name = "Dummy action"

  def handle(**args)
    do_something_important

    redirect_to avo.resources_users_path(encoded_filters: Avo::Filters::BaseFilter.encode_filters({"Avo::Filters::NameFilter"=>"Apple"}))
  end
end
```
</Option>


# Cache

Avo uses the application's cache system to enhance performance. The cache system is especially beneficial when dealing with resource index tables and license requests.

## Cache store selection

The cache system dynamically selects the appropriate cache store based on the application's environment:

### Production

In production, if the existing cache store is one of the following: `ActiveSupport::Cache::MemoryStore` or `ActiveSupport::Cache::NullStore` it will use the default `:file_store` with a cache path of `tmp/cache`. Otherwise, the existing cache store `Rails.cache` will be used.

### Test

In testing, it directly uses the `Rails.cache` store.

### Development and other environments

In all other environments the `:memory_store` is used.

### Custom selection

You can force Avo to use a particular store.

```ruby
# config/initializers/avo.rb
config.cache_store = -> {
  ActiveSupport::Cache.lookup_store(:solid_cache_store)
}

# or

config.cache_store = ActiveSupport::Cache.lookup_store(:solid_cache_store)
```

`cache_store` configuration option is expecting a cache store object, the lambda syntax can be useful if different stores are desired on different environments.

:::warning `MemoryStore` in production
Our recomendation is to not use MemoryStore in production because it will not be shared between multiple processes (when using Puma).
:::

<Option name="`cache_hash`">

The `cache_hash` method is used to compute the cache key for each row.

More about this on the [resource options page](#resources).
</Option>

## Caching caveats

Avo caches each record on the <Index /> view for improved performance. However side-effects may occur from this strategy. We'll try to outline some of them below and keep this page up to date as we find them or as they get reported to us.

These are things that may happen to regular Rails apps, not just in the Avo context.

### Rows may not be automatically updated when certain associations change

There are two things you could do to prevent this:

#### Option 1: Use `touch: true` on association

Example with Parent Model and Association
```ruby
  class Post < ApplicationRecord
    has_many :comments, dependent: :destroy
  end
```
Example with Child Model and Association with `touch: true`
```ruby
  class Comment < ApplicationRecord
    belongs_to :post, touch: true
  end
```

#### Option 2: override `cache_hash` method on resource to take associations in consideration

Avo, internally, uses the [`cache_hash`](#resources) method to compute the hash that will be remembered by the caching driver when displaying the rows.

You can take control and override it on that particular resource to take the association into account.
```ruby
  class Avo::Resources::User < Avo::BaseResource
    def fields
      # your fields
    end

    def cache_hash(parent_record)
      # record.post will now be taken under consideration
      result = [record, file_hash, record.post]

      if parent_record.present?
        result << parent_record
      end

      result
    end
  end
```

### `root_path` change won't break the cache keys

When the rows are cached, the links from the controls, [`belongs_to`](#belongs-to) and [`record_link`](#record-link) fields, and maybe others will be cached along.

The best solution here is to clear the cache with this ruby command `Rails.cache.clear`. If that's not an option then you can try to add the `root_path` to the [`cache_hash`](#resources) method in your particular resource.

## Solid Cache

Avo seamlessly integrates with [Solid Cache](https://github.com/rails/solid_cache). To setup Solid Cache follow these essential steps

Add this line to your application's Gemfile:

```ruby
gem "solid_cache"
```

And then execute:
```bash
$ bundle
```

Or install it yourself as:
```bash
$ gem install solid_cache
```

Add the migration to your app:

```bash
$ bin/rails solid_cache:install:migrations
```

Then run it:
```bash
$ bin/rails db:migrate
```

To set Solid Cache as your Rails cache, you should add this to your environment config:

```ruby
# config/environments/production.rb

config.cache_store = :solid_cache_store
```

Check [Solid Cache repository](https://github.com/rails/solid_cache) for additional valuable information.



# Resource controllers

In order to benefit from Rails' amazing REST architecture, Avo generates a controller alongside every resource.
Generally speaking you don't need to touch those controllers. Everything just works out of the box with configurations added to the resource file.

However, sometimes you might need more granular control about what is happening in the controller actions or their callbacks. In that scenario you may take over and override that behavior.

## Request-Response lifecycle

Each interaction with the CRUD UI results in a request - response cycle. That cycle passes through the `BaseController`. Each auto-generated controller for your resource inherits from `ResourcesController`, which inherits from `BaseController`.

```ruby
class Avo::CoursesController < Avo::ResourcesController
end
```

In order to make your controllers more flexible, there are several overridable methods similar to how [devise](https://github.com/heartcombo/devise#controller-filters-and-helpers:~:text=You%20can%20also%20override%20after_sign_in_path_for%20and%20after_sign_out_path_for%20to%20customize%20your%20redirect%20hooks) overrides `after_sign_in_path_for` and `after_sign_out_path_for`.

## Create methods
For the `create` method, you can modify the `after_create_path`, the messages, and the actions both on success or failure.

<Option name="`after_create_path`">

Overriding this method, you can tell Avo what path to follow after a record was created with success.

```ruby
def after_create_path
  "/avo/resources/users"
end
```
</Option>

<Option name="`create_success_action`">

Override this method to create a custom response when a record was created with success.

```ruby
def create_success_action
  respond_to do |format|
    format.html { redirect_to after_create_path, notice: create_success_message}
  end
end
```
</Option>

<Option name="`create_fail_action`">

Override this method to create a custom response when a record failed to be created.

```ruby
def create_fail_action
  respond_to do |format|
    flash.now[:error] = create_fail_message
    format.html { render :new, status: :unprocessable_entity }
  end
end
```
</Option>

<Option name="`create_success_message`">

Override this method to change the message the user receives when a record was created with success.

```ruby
def create_success_message
  "#{@resource.name} #{t("avo.was_successfully_created")}."
end
```
</Option>

<Option name="`create_fail_message`">

Override this method to change the message the user receives when a record failed to be created.

```ruby
def create_fail_message
  t "avo.you_missed_something_check_form"
end
```
</Option>

## Update methods
For the `update` method, you can modify the `after_update_path`, the messages, and the actions both on success or failure.

<Option name="`after_update_path`">

Overriding this method, you can tell Avo what path to follow after a record was updated with success.

```ruby
def after_update_path
  "/avo/resources/users"
end
```
</Option>

<Option name="`update_success_action`">

Override this method to create a custom response when a record was updated with success.

```ruby
def update_success_action
  respond_to do |format|
    format.html { redirect_to after_update_path, notice: update_success_message }
  end
end
```
</Option>

<Option name="`update_fail_action`">

Override this method to create a custom response when a record failed to be updated.

```ruby
def update_fail_action
  respond_to do |format|
    flash.now[:error] = update_fail_message
    format.html { render :edit, status: :unprocessable_entity }
  end
end
```
</Option>

<Option name="`update_success_message`">

Override this method to change the message the user receives when a record was updated with success.

```ruby
def update_success_message
  "#{@resource.name} #{t("avo.was_successfully_updated")}."
end
```
</Option>

<Option name="`update_fail_message`">

Override this method to change the message the user receives when a record failed to be updated.

```ruby
def update_fail_message
  t "avo.you_missed_something_check_form"
end
```
</Option>

## Destroy methods
For the `destroy` method, you can modify the `after_destroy_path`, the messages, and the actions both on success or failure.

<Option name="`after_destroy_path`">

Overriding this method, you can tell Avo what path to follow after a record was destroyed with success.

```ruby
def after_update_path
  "/avo/resources/users"
end
```
</Option>

<Option name="`destroy_success_action`">

Override this method to create a custom response when a record was destroyed with success.

```ruby
def destroy_success_action
  respond_to do |format|
    format.html { redirect_to after_destroy_path, notice: destroy_success_message }
  end
end
```
</Option>

<Option name="`destroy_fail_action`">

Override this method to create a custom response when a record failed to be destroyed.

```ruby
def destroy_fail_action
  respond_to do |format|
    format.html { redirect_back fallback_location: params[:referrer] || resources_path(resource: @resource, turbo_frame: params[:turbo_frame], view_type: params[:view_type]), error: destroy_fail_message }
  end
end
```
</Option>

<Option name="`destroy_success_message`">

Override this method to change the message the user receives when a record was destroyed with success.

```ruby
def destroy_success_message
  t("avo.resource_destroyed", attachment_class: @attachment_class)
end
```
</Option>

<Option name="`destroy_fail_message`">

Override this method to change the message the user receives when a record failed to be destroyed.

```ruby
def destroy_fail_message
  @errors.present? ? @errors.join(". ") : t("avo.failed")
end
```
</Option>




# Custom errors

Actions such as create, update, attach, etc... will not be completed if the record contains any errors. This ensures that only valid data is processed and saved, maintaining the integrity of your application. Custom validations can be added to your models to enforce specific rules and provide meaningful error messages to users.

## Adding Custom Errors

To add custom errors, you can define a validation method in your model. If the validation fails it adds an error to the record. These errors will prevent the action from completing and will be displayed as notifications to the user.

## In a Simple Record

Consider a simple `User` model where you want to enforce a custom validation rule, such as ensuring that the user's age is over a certain value.

```ruby
# app/models/user.rb
class User < ApplicationRecord
  validate :age_must_be_over_18

  private

  def age_must_be_over_18
    # Add a custom error to the record if age is less than 18.
    if age < 18
      errors.add(:age, "must be over 18.")
    end
  end
end
```

In this example, the `age_must_be_over_18` method checks if the user's age is less than 18. If so, it adds an error to the `age` attribute with a custom message. This error prevents any further Avo action on the record and notifies the user of the issue.

## In a Join Table

Consider a join table `TeamMembership` which links `Team` and `User` models. You might want to add a custom validation to ensure some business logic is enforced.

```ruby
# app/models/team_membership.rb
class TeamMembership < ApplicationRecord
  belongs_to :team
  belongs_to :user

  validate :custom_validation

  private

  def custom_validation
    if user.banned?
      errors.add(:user, "is banned.")
    end
  end
end
```

In this example, the `custom_validation` method is called whenever a `TeamMembership` record is validated. If the conditions in this method are not met, an error is added to the `user` attribute with a custom message. This error prevents any further Avo action on the record and notifies the user of the issue.



# Customizable controls

<Image src="/assets/img/resources/customizable-controls/index.jpg" width="1020" height="469" alt="" />

One of the things that we wanted to support from day one is customizable controls on resource pages, and now, Avo supports customizable controls on <Index />, <Show />, and <Edit /> views and for the table row.

## Default controls

By default, Avo displays a few buttons (controls) for the user to use on the <Index />, <Show />, and <Edit /> views which you can override using the appropriate resource options.

<Image src="/assets/img/3_0/customizable-controls/default-controls.png" width="654" height="164" alt="" />

## Customize the controls

You can take over and customize them all using the `index_controls`, `show_controls`, `edit_controls`, and `row_controls` class attributes.

<Option name="Show page">

On the <Show /> view the default configuration is `back_button`, `delete_button`, `detach_button`, `actions_list`, and `edit_button`.

To start customizing the controls, add a `show_controls` block and start adding the desired controls.

```ruby
class Avo::Resources::Fish < Avo::BaseResource
  self.show_controls = -> do
    back_button label: "", title: "Go back now"
    link_to "Fish.com", "https://fish.com", icon: "heroicons/outline/academic-cap", target: :_blank
    link_to "Turbo demo", "/admin/resources/fish/#{params[:id]}?change_to=ðŸš€ðŸš€ðŸš€ New content here ðŸš€ðŸš€ðŸš€",
      class: ".custom-class",
      data: {
        turbo_frame: "fish_custom_action_demo"
      }
    delete_button label: "", title: "something"
    detach_button label: "", title: "something"
    actions_list label: "Runnables", exclude: [ReleaseFish], style: :primary, color: :slate
    action Avo::Actions::ReleaseFish, style: :primary, color: :fuchsia, icon: "heroicons/outline/globe"
    edit_button label: ""
  end
end
```

<Image src="/assets/img/3_0/customizable-controls/show-controls.png" width="1344" height="164" alt="" />
</Option>

<Option name="Edit page">

On the <Edit /> view the default configuration is `back_button`, `delete_button`, `actions_list`, and `save_button`.

To start customizing the controls, add a `edit_controls` block and start adding the desired controls.

```ruby
class Avo::Resources::Fish < Avo::BaseResource
  self.edit_controls = -> do
    back_button label: "", title: "Go back now"
    link_to "Fish.com", "https://fish.com", icon: "heroicons/outline/academic-cap", target: :_blank
    delete_button label: "", title: "something"
    detach_button label: "", title: "something"
    actions_list exclude: [Avo::Actions::ReleaseFish], style: :primary, color: :slate, label: "Runnables"
    action Avo::Actions::ReleaseFish, style: :primary, color: :fuchsia, icon: "heroicons/outline/globe" if view != :new
    save_button label: "Save Fish"
  end
end
```

<Image src="/assets/img/3_0/customizable-controls/show-controls.png" width="1344" height="164" alt="" />
</Option>

<Option name="Index page">

On the <Index /> view the default configuration contains the `actions_list`, `attach_button`, and `create_button`.

To start customizing the controls, add a `index_controls` block and start adding the desired controls.

```ruby
class Avo::Resources::Fish < Avo::BaseResource
  self.index_controls = -> do
    link_to "Fish.com", "https://fish.com", icon: "heroicons/outline/academic-cap", target: :_blank
    actions_list exclude: [Avo::Actions::DummyAction], style: :primary, color: :slate, label: "Runnables" if Fish.count > 0
    action Avo::Actions::DummyAction, style: :primary, color: :fuchsia, icon: "heroicons/outline/globe" if Fish.count > 0
    attach_button label: "Attach one Fish"
    create_button label: "Create a new and fresh Fish"
  end
end
```

<Image src="/assets/img/3_0/customizable-controls/index-controls.png" width="1300" height="164" alt="" />
</Option>

<Option name="Row controls">

On the <Index /> view the on the end of each table row the default configuration contains the `order_controls` `show_button`, `edit_button`, `detach_button`, and `delete_button`.

To start customizing the controls, add a `row_controls` block and start adding the desired controls.

The controls you customize here will be displayed on the grid view too.

```ruby
class Avo::Resources::Fish < Avo::BaseResource
  self.row_controls = -> do
    action Avo::Actions::ReleaseFish, label: "Release #{record.name}", style: :primary, color: :blue,
      icon: "heroicons/outline/hand-raised" unless params[:view_type] == "grid"
    edit_button title: "Edit this Fish now!"
    show_button title: "Show this Fish now!"
    delete_button title: "Delete this Fish now!", confirmation_message: "Are you sure you want to delete this Fish?"
    actions_list style: :primary, color: :slate, label: "Actions" unless params[:view_type] == "grid"
    action Avo::Actions::ReleaseFish, title: "Release #{record.name}", icon: "heroicons/outline/hand-raised", style: :icon
    link_to "Information about #{record.name}", "https://en.wikipedia.org/wiki/#{record.name}",
      icon: "heroicons/outline/information-circle", target: :_blank, style: :icon
  end
end
```

<Image src="/assets/img/3_0/customizable-controls/row-controls.png" width="834" height="120" alt="" />
</Option>

## Controls

A control is an item that you can place in a designated area. They can be one of the default ones like `back_button`, `delete_button`, or `edit_button` to custom ones like `link_to` or `action`.

You may use the following controls:

<Option name="`back_button`">

Links to a previous page. The link is not a `history.back()` action. It's computed based on the parameters sent by Avo. That ensures the user has consistent hierarchical progress through the app.

#### Supported options

`label`, `title`, `style`, `color`, and `icon`.
</Option>

<Option name="`delete_button`">

Adds the appropriate destroy form. It will take into account your authorization policy rules.

#### Supported options

`label`, `title`, `style`, `color`, and `icon`.
</Option>

<Option name="`detach_button`">

Adds the appropriate detach form. It's visible only on the association (`has_one`) page. It will take into account your authorization policy rules.

#### Supported options

`label`, `title`, `style`, `color`, and `icon`.
</Option>

<Option name="`actions_list`">

A dropdown where the user can see and run all the actions assigned to that resource.

#### Supported options

`label`, `title`, `style`, `color`, `icon`, `include` and `exclude`.

#### `exclude` option

Filters out the specified actions.

It's used in conjunction with the `action` control. For example, when you extract an action, you don't want it to be displayed in the `actions_list` anymore, so you use the `exclude` option to filter it out.

#### Example

```ruby
actions_list exclude: DisableAccount
# Or
actions_list exclude: [ExportSelection, PublishPost]
```
:::info
The list action's [icon](#registration) and the [dividers](#registration) are defined in `def actions` method.
:::
</Option>

<Option name="`list`">

<VersionReq version="3.13" />

A dropdown that displays all the specified actions and links.

#### Supported options

`label`, `title`, `style`, `color` and `icon`


#### Example

```ruby
list label: "Custom Index List", icon: "heroicons/outline/cube-transparent", style: :primary, color: :slate, title: "A custom list" do
  link_to "Google", "https://google.com", icon: "heroicons/outline/academic-cap"
  action Avo::Actions::Sub::DummyAction, icon: "heroicons/outline/globe"
  link_to "Fish.com", "https://fish.com", icon: "heroicons/outline/fire", target: :_blank
end
```

<Image src="/assets/img/resources/customizable-controls/custom_list.png" width="404" height="256" alt="Custom list opened" />


Within the `list` block, the only permitted elements are `link_to` and `action`. For both `link_to` and `action`, you can include an optional `icon` parameter.

:::info
<VersionReq version="3.14.1" /> [`divider`](#registration) is also permitted within the `list` block.
:::

In addition to the `icon`, the `link_to` element can accept additional parameters such as `target: :_blank` or `rel: "noopener"`, or any other extra arguments you may want to provide for the link. These extra arguments help define specific behaviors for the link, like opening it in a new tab or ensuring security best practices are followed.

</Option>

<Option name="`edit_button`">

Links to the record edit page.

#### Supported options

`label`, `title`, `style`, `color`, and `icon`.
</Option>

<Option name="`link_to`">

Renders a link to a path set by you.

#### Supported options

`title`, `style`, `color`, `icon`, `target`, `data`, and `class`.
</Option>

<Option name="`action`">

Renders a button that triggers an action. You must provide it an [Action](#actions-overview) class.

#### Supported options

`title`, `style`, `color`, `arguments` and `icon`.

#### Example

```ruby
action Avo::Actions::DisableAccount
action Avo::Actions::DisableAccount, arguments: { hide_some_fields: true }
action Avo::Actions::ExportSelection, style: :text
action Avo::Actions::PublishPost, color: :fuchsia, icon: "heroicons/outline/eye"
```

</Option>

:::warning WARNING (**NOT** applicable for versions greater than <Version version="3.10.7" />)

When you use the `action` helper in any customizable block it will act only as a shortcut to display the action button, it will not also register it to the resource.

You must manually register it with the `action` declaration.

```ruby{6-8,13-15}
class Avo::Resources::Fish < Avo::BaseResource
  self.title = :name

  self.show_controls = -> do
    # In order to use it here
    action Avo::Actions::ReleaseFish, style: :primary, color: :fuchsia, arguments: {
      action_on_show_controls: "Will use this arguments"
    }
  end

  # ðŸ‘‡ Also declare it here ðŸ‘‡
  def actions
    action Avo::Actions::ReleaseFish, arguments: {
      action_from_list: "Will use this arguments"
    }
  end
end
```
:::

<Option name="`default_controls`">

There are times when you just want to add a link before or after the default controls and don't want to re-add them all.
Avo's got you covered! `default_controls` to the rescue.

```ruby
self.show_controls = -> do
  # This link will be added before all other controls.
  link_to "View on site", post_path(record), target: :_blank
  default_controls
end
```

<Image src="/assets/img/3_0/customizable-controls/default_controls.png" alt="Default controls" width="884" height="140" />
</Option>

## Control Options

Some controls take options. Not all controls take all options.
Example: The `link_to` control is the only one that will take the `target` option, but most other controls use the `class` option.

<Option name="`title`">

Sets the tooltip for that control.

#### Possible values

Any string value.
</Option>

<Option name="`style`">

Sets the `style` attribute for the [`Avo::ButtonComponent`](https://github.com/avo-hq/avo/blob/main/app/components/avo/button_component.rb).

#### Possible values

`:primary`, `:outline`, `:text`
</Option>

<Option name="`color`">

Sets the `color` attribute for the [`Avo::ButtonComponent`](https://github.com/avo-hq/avo/blob/main/app/components/avo/button_component.rb)

#### Possible values

Can be any color of [Tailwind`s default color pallete](https://tailwindcss.com/docs/customizing-colors#default-color-palette) as a symbol.
</Option>

<Option name="`icon`">

Sets the icon for that button.

#### Possible values

Any [Heroicon](https://heroicons.com) you want. You must specify the style of the heroicon like so `heoricons/outline/academic-cap` or `heroicons/solid/adjustments`.
</Option>

<Option name="`target`">

Sets the target for that control. So whatever you pass here will be passed to the control.

#### Possible values

`:_blank`, `:_top`, `:_self`
</Option>

<Option name="`class`">

Sets the classes for that control.

#### Possible values

Any string value.
</Option>

## Default values

If you're curious what are the default controls Avo adds for each block, here they are:

```ruby
# show controls
back_button
delete_button
detach_button
actions_list
edit_button

# form (edit & new) controls
back_button
delete_button
actions_list
save_button

# index controls
attach_button
actions_list
create_button

# row controls
order_controls
show_button
edit_button
detach_button
delete_button
```

## Conditionally hiding/showing actions

Actions have the `visible` block where you can control the visibility of an action. In the context of `show_controls` that block is not taken into account, but you can use regular `if`/`else` statements because the action declaration is wrapped in a block.

```ruby{6-8}
class Avo::Resources::Fish < Avo::BaseResource
  self.show_controls = -> do
    back_button label: "", title: "Go back now"

    # visibility conditional
    if record.something?
      action Avo::Actions::ReleaseFish, style: :primary, color: :fuchsia, icon: "heroicons/outline/globe"
    end

    edit_button label: ""
  end
end
```


# Execution context

[`Avo::Services::EncryptionService`](https://github.com/avo-hq/avo/blob/main/lib/avo/services/encryption_service.rb) it's used internally by Avo when is needed to encrypt sensible params.

One example is the select all feature, where we pass the query, encrypted, through params.

## How does the [`Avo::Services::EncryptionService`](https://github.com/avo-hq/avo/blob/main/lib/avo/services/encryption_service.rb) work?

The `EncryptionService` is an service that can be called anywhere on the app.

### Public methods

<Option name="`encrypt`">

Used to encrypt data
</Option>

<Option name="`decrypt`">

Used to decrypt data
</Option>

<br><br>

### Mandatory arguments:

<Option name="`message`">

Object to be encrypted
</Option>

<Option name="`purpose`">

A symbol with the purpose of encryption, can be anything, it just ***need to match when decrypting***.
</Option>

<br><br>

### Optional arguments
This service uses [`ActiveSupport::MessageEncryptor`](https://api.rubyonrails.org/v5.2.3/classes/ActiveSupport/MessageEncryptor.html) as encryptor so [`Avo::Services::EncryptionService`](https://github.com/avo-hq/avo/blob/main/lib/avo/services/encryption_service.rb) accepts any argument specified on [`ActiveSupport::MessageEncryptor` documentation](https://api.rubyonrails.org/v5.2.3/classes/ActiveSupport/MessageEncryptor.html)

## Usage example

### Basic text:
```ruby
secret_encryption = Avo::Services::EncryptionService.encrypt(message: "Secret string", purpose: :demo)
# "x+rnETtClF2cb80PtYzlULnVB0vllf+FvwoqBpPbHWa8q6vlml5eRWrwFMcYrjI6--h2MiT1P5ctTUjwfQ--k2WsIRknFVE53QwXADDDJw=="

Avo::Services::EncryptionService.decrypt(message: secret_encryption, purpose: :demo)
# "Secret string"
```

### Objects with custom serializer:
```ruby
secret_encryption = Avo::Services::EncryptionService.encrypt(message:Course::Link.first, purpose: :demo, serializer: Marshal)
# "1UTtkhu9BDywzz8yl8/7cBZnOoM1wnILDJbT7gP+zz8M/t1Dve4QTFQP5nfHZdYK9KvFDwkizm8DTHyNZdixDtCO/M7yNMlzL8Mry1RQ3AF0qhhTzFeqb5UqyQv/Cuq+NWvQ+GXv3gFckXaNqsFSX5yDccEpRDpyNkYT4MFxOa+8hVR4roebkNKB89lb73anBDTHsTAd37y2LFiv2YaiFguPQ/...

Avo::Services::EncryptionService.decrypt(message: secret_encryption, purpose: :demo, serializer: Marshal)
# #<Course::Link:0x00007fd28dc44c00 id: 1, link: "http://ortiz.com/cher_mohr", course_id: 1, created_at: Thu, 07 Dec 2023 11:05:13.779644000 UTC +00:00, updated_at: Thu, 07 Dec 2023 11:05:13.779644000 UTC +00:00, position: 1>
```

## Secret key base
:::warning
[`Avo::Services::EncryptionService`](https://github.com/avo-hq/avo/blob/main/lib/avo/services/encryption_service.rb) fetches a secret key base to be used on the encrypt / decrypt process. Make sure that you have it defined in any of the following:

`ENV["SECRET_KEY_BASE"] || Rails.application.credentials.secret_key_base || Rails.application.secrets.secret_key_base`
:::


# Icons

Avo provides a collection of SVG icons organized into two directories: [`avo`](https://github.com/avo-hq/avo/tree/main/app/assets/svgs/avo) and [`heroicons`](https://github.com/avo-hq/avo/tree/main/app/assets/svgs/heroicons) ([check heroicons](https://heroicons.com/)). These icons are easily accessible using the [`svg` method](https://github.com/avo-hq/avo/blob/main/app/helpers/avo/application_helper.rb#L63).

To render an icon in your application, use the svg method. This method allows you to specify the icon's path and class.

Examples:
```ruby
# in a View Component
helpers.svg("avo/editor-strike")

# in a Rails helper
svg("heroicons/outline/magnifying-glass-circle", class: "block h-6 text-gray-600")
```

```erb
<%= svg 'avo/bell.svg', class: "h-4" %>
```

There are some places where Avo have custom DSL accepting the `icon` option. There you only need to specify the `icon`'s path (`avo/...` or `heroicons/...`). Behind the scenes Avo applies the [`svg` method](https://github.com/avo-hq/avo/blob/main/app/helpers/avo/application_helper.rb#L63).

## Avo icons

Avo uses a [set of custom icons](https://github.com/avo-hq/avo/tree/main/app/assets/svgs/avo) which you can use yourself with this notation: `avo/ICON_NAME`.

#### Example:

```erb
<%= svg "avo/bell.svg", class: "h-4" %>
```

## Using heroicons

Avo uses the delightful [`heroicons` library](https://heroicons.com/) which is kept up to date by the team.

Heroicons come in 4 variants `outline`, `solid`, `mini`, and `micro`.

You can use these icons with this notation: `heroicons/VARIANT/ICON_NAME`.
We usually use the `outline` variant.

#### Examples:


```erb
<%= svg "heroicons/outline/academic-cap.svg" %>

<%= svg "heroicons/mini/arrow-path-rounded-square.svg" %>
```


# Avo â¤ï¸ Rails & Hotwire

In order to provide this all-in-one full-interface experience, we are using Rails' built-in [engines functionality](https://guides.rubyonrails.org/engines.html).

## Avo as a Rails engine

Avo is a **Ruby on Rails engine** that runs isolated and side-by-side with your app. You configure it using a familiar DSL and sometimes regular Rails code through controller methods and partials.

Avo's philosophy is to have as little business logic in your app as possible and give the developer the right tools to extend the functionality when needed.

That means we use a few files to configure most of the interface. When that configuration is not enough, we enable the developer to export ([eject](#eject-views)) partials or even generate new ones for their total control.

### Prepend engine name in URL path helpers

Because it's a **Rails engine** you'll have to follow a few engine rules. One of them is that [routes are isolated](https://guides.rubyonrails.org/engines.html#routes). That means that whenever you're using Rails' [path helpers](https://guides.rubyonrails.org/routing.html#generating-paths-and-urls-from-code) you'll need to prepend the name of the engine. For example, Avo's name is `avo,` and your app's engine name is `main_app`.

```ruby
# When referencing an Avo route, use avo
link_to 'Users', avo.resources_users_path
link_to user.name, avo.resources_user_path(user)

# When referencing a path for your app, use main_app
link_to "Contact", main_app.contact_path
link_to post.name, main_app.posts_path(post)
```

### Use your helpers inside Avo

This is something that we'd like to improve in the future, but the flow right now is to 1. include the helper module inside the controller you need it for and then 2. reference the methods from the `view_context.controller` object in resource files or any other place you'd need them.

```ruby{3-5,10,16}
# app/helpers/application_helper.rb
module ApplicationHelper
  def render_copyright_info
    "Copyright #{Date.today.year}"
  end
end

# app/controller/avo/products_controller.rb
class Avo::ProductsController < Avo::ResourcesController
  include ApplicationHelper
end

# app/avo/resources/products_resource.rb
class ProductsResource < Avo::BaseResource
  field :copyright, as: :text do
    view_context.controller.render_copyright_info
  end
end
```

## Hotwire

Avo's built with Hotwire, so anytime you'd like to use Turbo Frames, that's supported out of the box.

## StimulusJS

Avo comes loaded with Stimulus JS and has a quite deep integration with it by providing useful built-in helpers that improve the development experience.

Please follow the [Stimulus JS guide](#stimulus-integration.html ) that takes an in-depth look at all the possible ways of extending the UI.


