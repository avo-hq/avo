(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a2, b2) => {
    for (var prop in b2 || (b2 = {}))
      if (__hasOwnProp.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b2)) {
        if (__propIsEnum.call(b2, prop))
          __defNormalProp(a2, prop, b2[prop]);
      }
    return a2;
  };
  var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
    get: (a2, b2) => (typeof require !== "undefined" ? require : a2)[b2]
  }) : x2)(function(x2) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x2 + '" is not supported');
  });
  var __esm = (fn2, res) => function __init() {
    return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __reExport = (target, module, copyDefault, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toESM = (module, isNodeMode) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", !isNodeMode && module && module.__esModule ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // node_modules/core-js/internals/global.js
  var require_global = __commonJS({
    "node_modules/core-js/internals/global.js"(exports, module) {
      var check = function(it) {
        return it && it.Math == Math && it;
      };
      module.exports = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof global == "object" && global) || function() {
        return this;
      }() || Function("return this")();
    }
  });

  // node_modules/core-js/internals/fails.js
  var require_fails = __commonJS({
    "node_modules/core-js/internals/fails.js"(exports, module) {
      module.exports = function(exec) {
        try {
          return !!exec();
        } catch (error2) {
          return true;
        }
      };
    }
  });

  // node_modules/core-js/internals/descriptors.js
  var require_descriptors = __commonJS({
    "node_modules/core-js/internals/descriptors.js"(exports, module) {
      var fails = require_fails();
      module.exports = !fails(function() {
        return Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1] != 7;
      });
    }
  });

  // node_modules/core-js/internals/function-bind-native.js
  var require_function_bind_native = __commonJS({
    "node_modules/core-js/internals/function-bind-native.js"(exports, module) {
      var fails = require_fails();
      module.exports = !fails(function() {
        var test = function() {
        }.bind();
        return typeof test != "function" || test.hasOwnProperty("prototype");
      });
    }
  });

  // node_modules/core-js/internals/function-call.js
  var require_function_call = __commonJS({
    "node_modules/core-js/internals/function-call.js"(exports, module) {
      var NATIVE_BIND = require_function_bind_native();
      var call = Function.prototype.call;
      module.exports = NATIVE_BIND ? call.bind(call) : function() {
        return call.apply(call, arguments);
      };
    }
  });

  // node_modules/core-js/internals/object-property-is-enumerable.js
  var require_object_property_is_enumerable = __commonJS({
    "node_modules/core-js/internals/object-property-is-enumerable.js"(exports) {
      "use strict";
      var $propertyIsEnumerable = {}.propertyIsEnumerable;
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
      exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
        var descriptor = getOwnPropertyDescriptor(this, V);
        return !!descriptor && descriptor.enumerable;
      } : $propertyIsEnumerable;
    }
  });

  // node_modules/core-js/internals/create-property-descriptor.js
  var require_create_property_descriptor = __commonJS({
    "node_modules/core-js/internals/create-property-descriptor.js"(exports, module) {
      module.exports = function(bitmap, value) {
        return {
          enumerable: !(bitmap & 1),
          configurable: !(bitmap & 2),
          writable: !(bitmap & 4),
          value
        };
      };
    }
  });

  // node_modules/core-js/internals/function-uncurry-this.js
  var require_function_uncurry_this = __commonJS({
    "node_modules/core-js/internals/function-uncurry-this.js"(exports, module) {
      var NATIVE_BIND = require_function_bind_native();
      var FunctionPrototype = Function.prototype;
      var bind3 = FunctionPrototype.bind;
      var call = FunctionPrototype.call;
      var uncurryThis = NATIVE_BIND && bind3.bind(call, call);
      module.exports = NATIVE_BIND ? function(fn2) {
        return fn2 && uncurryThis(fn2);
      } : function(fn2) {
        return fn2 && function() {
          return call.apply(fn2, arguments);
        };
      };
    }
  });

  // node_modules/core-js/internals/classof-raw.js
  var require_classof_raw = __commonJS({
    "node_modules/core-js/internals/classof-raw.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      var toString = uncurryThis({}.toString);
      var stringSlice = uncurryThis("".slice);
      module.exports = function(it) {
        return stringSlice(toString(it), 8, -1);
      };
    }
  });

  // node_modules/core-js/internals/indexed-object.js
  var require_indexed_object = __commonJS({
    "node_modules/core-js/internals/indexed-object.js"(exports, module) {
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var classof = require_classof_raw();
      var Object2 = global2.Object;
      var split = uncurryThis("".split);
      module.exports = fails(function() {
        return !Object2("z").propertyIsEnumerable(0);
      }) ? function(it) {
        return classof(it) == "String" ? split(it, "") : Object2(it);
      } : Object2;
    }
  });

  // node_modules/core-js/internals/require-object-coercible.js
  var require_require_object_coercible = __commonJS({
    "node_modules/core-js/internals/require-object-coercible.js"(exports, module) {
      var global2 = require_global();
      var TypeError2 = global2.TypeError;
      module.exports = function(it) {
        if (it == void 0)
          throw TypeError2("Can't call method on " + it);
        return it;
      };
    }
  });

  // node_modules/core-js/internals/to-indexed-object.js
  var require_to_indexed_object = __commonJS({
    "node_modules/core-js/internals/to-indexed-object.js"(exports, module) {
      var IndexedObject = require_indexed_object();
      var requireObjectCoercible = require_require_object_coercible();
      module.exports = function(it) {
        return IndexedObject(requireObjectCoercible(it));
      };
    }
  });

  // node_modules/core-js/internals/is-callable.js
  var require_is_callable = __commonJS({
    "node_modules/core-js/internals/is-callable.js"(exports, module) {
      module.exports = function(argument) {
        return typeof argument == "function";
      };
    }
  });

  // node_modules/core-js/internals/is-object.js
  var require_is_object = __commonJS({
    "node_modules/core-js/internals/is-object.js"(exports, module) {
      var isCallable = require_is_callable();
      module.exports = function(it) {
        return typeof it == "object" ? it !== null : isCallable(it);
      };
    }
  });

  // node_modules/core-js/internals/get-built-in.js
  var require_get_built_in = __commonJS({
    "node_modules/core-js/internals/get-built-in.js"(exports, module) {
      var global2 = require_global();
      var isCallable = require_is_callable();
      var aFunction = function(argument) {
        return isCallable(argument) ? argument : void 0;
      };
      module.exports = function(namespace, method) {
        return arguments.length < 2 ? aFunction(global2[namespace]) : global2[namespace] && global2[namespace][method];
      };
    }
  });

  // node_modules/core-js/internals/object-is-prototype-of.js
  var require_object_is_prototype_of = __commonJS({
    "node_modules/core-js/internals/object-is-prototype-of.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      module.exports = uncurryThis({}.isPrototypeOf);
    }
  });

  // node_modules/core-js/internals/engine-user-agent.js
  var require_engine_user_agent = __commonJS({
    "node_modules/core-js/internals/engine-user-agent.js"(exports, module) {
      var getBuiltIn = require_get_built_in();
      module.exports = getBuiltIn("navigator", "userAgent") || "";
    }
  });

  // node_modules/core-js/internals/engine-v8-version.js
  var require_engine_v8_version = __commonJS({
    "node_modules/core-js/internals/engine-v8-version.js"(exports, module) {
      var global2 = require_global();
      var userAgent = require_engine_user_agent();
      var process2 = global2.process;
      var Deno = global2.Deno;
      var versions = process2 && process2.versions || Deno && Deno.version;
      var v8 = versions && versions.v8;
      var match;
      var version;
      if (v8) {
        match = v8.split(".");
        version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
      }
      if (!version && userAgent) {
        match = userAgent.match(/Edge\/(\d+)/);
        if (!match || match[1] >= 74) {
          match = userAgent.match(/Chrome\/(\d+)/);
          if (match)
            version = +match[1];
        }
      }
      module.exports = version;
    }
  });

  // node_modules/core-js/internals/native-symbol.js
  var require_native_symbol = __commonJS({
    "node_modules/core-js/internals/native-symbol.js"(exports, module) {
      var V8_VERSION = require_engine_v8_version();
      var fails = require_fails();
      module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
        var symbol = Symbol();
        return !String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION && V8_VERSION < 41;
      });
    }
  });

  // node_modules/core-js/internals/use-symbol-as-uid.js
  var require_use_symbol_as_uid = __commonJS({
    "node_modules/core-js/internals/use-symbol-as-uid.js"(exports, module) {
      var NATIVE_SYMBOL = require_native_symbol();
      module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
    }
  });

  // node_modules/core-js/internals/is-symbol.js
  var require_is_symbol = __commonJS({
    "node_modules/core-js/internals/is-symbol.js"(exports, module) {
      var global2 = require_global();
      var getBuiltIn = require_get_built_in();
      var isCallable = require_is_callable();
      var isPrototypeOf = require_object_is_prototype_of();
      var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
      var Object2 = global2.Object;
      module.exports = USE_SYMBOL_AS_UID ? function(it) {
        return typeof it == "symbol";
      } : function(it) {
        var $Symbol = getBuiltIn("Symbol");
        return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, Object2(it));
      };
    }
  });

  // node_modules/core-js/internals/try-to-string.js
  var require_try_to_string = __commonJS({
    "node_modules/core-js/internals/try-to-string.js"(exports, module) {
      var global2 = require_global();
      var String2 = global2.String;
      module.exports = function(argument) {
        try {
          return String2(argument);
        } catch (error2) {
          return "Object";
        }
      };
    }
  });

  // node_modules/core-js/internals/a-callable.js
  var require_a_callable = __commonJS({
    "node_modules/core-js/internals/a-callable.js"(exports, module) {
      var global2 = require_global();
      var isCallable = require_is_callable();
      var tryToString = require_try_to_string();
      var TypeError2 = global2.TypeError;
      module.exports = function(argument) {
        if (isCallable(argument))
          return argument;
        throw TypeError2(tryToString(argument) + " is not a function");
      };
    }
  });

  // node_modules/core-js/internals/get-method.js
  var require_get_method = __commonJS({
    "node_modules/core-js/internals/get-method.js"(exports, module) {
      var aCallable = require_a_callable();
      module.exports = function(V, P2) {
        var func = V[P2];
        return func == null ? void 0 : aCallable(func);
      };
    }
  });

  // node_modules/core-js/internals/ordinary-to-primitive.js
  var require_ordinary_to_primitive = __commonJS({
    "node_modules/core-js/internals/ordinary-to-primitive.js"(exports, module) {
      var global2 = require_global();
      var call = require_function_call();
      var isCallable = require_is_callable();
      var isObject3 = require_is_object();
      var TypeError2 = global2.TypeError;
      module.exports = function(input, pref) {
        var fn2, val;
        if (pref === "string" && isCallable(fn2 = input.toString) && !isObject3(val = call(fn2, input)))
          return val;
        if (isCallable(fn2 = input.valueOf) && !isObject3(val = call(fn2, input)))
          return val;
        if (pref !== "string" && isCallable(fn2 = input.toString) && !isObject3(val = call(fn2, input)))
          return val;
        throw TypeError2("Can't convert object to primitive value");
      };
    }
  });

  // node_modules/core-js/internals/is-pure.js
  var require_is_pure = __commonJS({
    "node_modules/core-js/internals/is-pure.js"(exports, module) {
      module.exports = false;
    }
  });

  // node_modules/core-js/internals/set-global.js
  var require_set_global = __commonJS({
    "node_modules/core-js/internals/set-global.js"(exports, module) {
      var global2 = require_global();
      var defineProperty = Object.defineProperty;
      module.exports = function(key, value) {
        try {
          defineProperty(global2, key, { value, configurable: true, writable: true });
        } catch (error2) {
          global2[key] = value;
        }
        return value;
      };
    }
  });

  // node_modules/core-js/internals/shared-store.js
  var require_shared_store = __commonJS({
    "node_modules/core-js/internals/shared-store.js"(exports, module) {
      var global2 = require_global();
      var setGlobal = require_set_global();
      var SHARED = "__core-js_shared__";
      var store = global2[SHARED] || setGlobal(SHARED, {});
      module.exports = store;
    }
  });

  // node_modules/core-js/internals/shared.js
  var require_shared = __commonJS({
    "node_modules/core-js/internals/shared.js"(exports, module) {
      var IS_PURE = require_is_pure();
      var store = require_shared_store();
      (module.exports = function(key, value) {
        return store[key] || (store[key] = value !== void 0 ? value : {});
      })("versions", []).push({
        version: "3.21.0",
        mode: IS_PURE ? "pure" : "global",
        copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)",
        license: "https://github.com/zloirock/core-js/blob/v3.21.0/LICENSE",
        source: "https://github.com/zloirock/core-js"
      });
    }
  });

  // node_modules/core-js/internals/to-object.js
  var require_to_object = __commonJS({
    "node_modules/core-js/internals/to-object.js"(exports, module) {
      var global2 = require_global();
      var requireObjectCoercible = require_require_object_coercible();
      var Object2 = global2.Object;
      module.exports = function(argument) {
        return Object2(requireObjectCoercible(argument));
      };
    }
  });

  // node_modules/core-js/internals/has-own-property.js
  var require_has_own_property = __commonJS({
    "node_modules/core-js/internals/has-own-property.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      var toObject = require_to_object();
      var hasOwnProperty2 = uncurryThis({}.hasOwnProperty);
      module.exports = Object.hasOwn || function hasOwn(it, key) {
        return hasOwnProperty2(toObject(it), key);
      };
    }
  });

  // node_modules/core-js/internals/uid.js
  var require_uid = __commonJS({
    "node_modules/core-js/internals/uid.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      var id = 0;
      var postfix = Math.random();
      var toString = uncurryThis(1 .toString);
      module.exports = function(key) {
        return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);
      };
    }
  });

  // node_modules/core-js/internals/well-known-symbol.js
  var require_well_known_symbol = __commonJS({
    "node_modules/core-js/internals/well-known-symbol.js"(exports, module) {
      var global2 = require_global();
      var shared = require_shared();
      var hasOwn = require_has_own_property();
      var uid = require_uid();
      var NATIVE_SYMBOL = require_native_symbol();
      var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
      var WellKnownSymbolsStore = shared("wks");
      var Symbol2 = global2.Symbol;
      var symbolFor = Symbol2 && Symbol2["for"];
      var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
      module.exports = function(name) {
        if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == "string")) {
          var description = "Symbol." + name;
          if (NATIVE_SYMBOL && hasOwn(Symbol2, name)) {
            WellKnownSymbolsStore[name] = Symbol2[name];
          } else if (USE_SYMBOL_AS_UID && symbolFor) {
            WellKnownSymbolsStore[name] = symbolFor(description);
          } else {
            WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
          }
        }
        return WellKnownSymbolsStore[name];
      };
    }
  });

  // node_modules/core-js/internals/to-primitive.js
  var require_to_primitive = __commonJS({
    "node_modules/core-js/internals/to-primitive.js"(exports, module) {
      var global2 = require_global();
      var call = require_function_call();
      var isObject3 = require_is_object();
      var isSymbol = require_is_symbol();
      var getMethod = require_get_method();
      var ordinaryToPrimitive = require_ordinary_to_primitive();
      var wellKnownSymbol = require_well_known_symbol();
      var TypeError2 = global2.TypeError;
      var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
      module.exports = function(input, pref) {
        if (!isObject3(input) || isSymbol(input))
          return input;
        var exoticToPrim = getMethod(input, TO_PRIMITIVE);
        var result;
        if (exoticToPrim) {
          if (pref === void 0)
            pref = "default";
          result = call(exoticToPrim, input, pref);
          if (!isObject3(result) || isSymbol(result))
            return result;
          throw TypeError2("Can't convert object to primitive value");
        }
        if (pref === void 0)
          pref = "number";
        return ordinaryToPrimitive(input, pref);
      };
    }
  });

  // node_modules/core-js/internals/to-property-key.js
  var require_to_property_key = __commonJS({
    "node_modules/core-js/internals/to-property-key.js"(exports, module) {
      var toPrimitive = require_to_primitive();
      var isSymbol = require_is_symbol();
      module.exports = function(argument) {
        var key = toPrimitive(argument, "string");
        return isSymbol(key) ? key : key + "";
      };
    }
  });

  // node_modules/core-js/internals/document-create-element.js
  var require_document_create_element = __commonJS({
    "node_modules/core-js/internals/document-create-element.js"(exports, module) {
      var global2 = require_global();
      var isObject3 = require_is_object();
      var document2 = global2.document;
      var EXISTS = isObject3(document2) && isObject3(document2.createElement);
      module.exports = function(it) {
        return EXISTS ? document2.createElement(it) : {};
      };
    }
  });

  // node_modules/core-js/internals/ie8-dom-define.js
  var require_ie8_dom_define = __commonJS({
    "node_modules/core-js/internals/ie8-dom-define.js"(exports, module) {
      var DESCRIPTORS = require_descriptors();
      var fails = require_fails();
      var createElement2 = require_document_create_element();
      module.exports = !DESCRIPTORS && !fails(function() {
        return Object.defineProperty(createElement2("div"), "a", {
          get: function() {
            return 7;
          }
        }).a != 7;
      });
    }
  });

  // node_modules/core-js/internals/object-get-own-property-descriptor.js
  var require_object_get_own_property_descriptor = __commonJS({
    "node_modules/core-js/internals/object-get-own-property-descriptor.js"(exports) {
      var DESCRIPTORS = require_descriptors();
      var call = require_function_call();
      var propertyIsEnumerableModule = require_object_property_is_enumerable();
      var createPropertyDescriptor = require_create_property_descriptor();
      var toIndexedObject = require_to_indexed_object();
      var toPropertyKey = require_to_property_key();
      var hasOwn = require_has_own_property();
      var IE8_DOM_DEFINE = require_ie8_dom_define();
      var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P2) {
        O = toIndexedObject(O);
        P2 = toPropertyKey(P2);
        if (IE8_DOM_DEFINE)
          try {
            return $getOwnPropertyDescriptor(O, P2);
          } catch (error2) {
          }
        if (hasOwn(O, P2))
          return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P2), O[P2]);
      };
    }
  });

  // node_modules/core-js/internals/v8-prototype-define-bug.js
  var require_v8_prototype_define_bug = __commonJS({
    "node_modules/core-js/internals/v8-prototype-define-bug.js"(exports, module) {
      var DESCRIPTORS = require_descriptors();
      var fails = require_fails();
      module.exports = DESCRIPTORS && fails(function() {
        return Object.defineProperty(function() {
        }, "prototype", {
          value: 42,
          writable: false
        }).prototype != 42;
      });
    }
  });

  // node_modules/core-js/internals/an-object.js
  var require_an_object = __commonJS({
    "node_modules/core-js/internals/an-object.js"(exports, module) {
      var global2 = require_global();
      var isObject3 = require_is_object();
      var String2 = global2.String;
      var TypeError2 = global2.TypeError;
      module.exports = function(argument) {
        if (isObject3(argument))
          return argument;
        throw TypeError2(String2(argument) + " is not an object");
      };
    }
  });

  // node_modules/core-js/internals/object-define-property.js
  var require_object_define_property = __commonJS({
    "node_modules/core-js/internals/object-define-property.js"(exports) {
      var global2 = require_global();
      var DESCRIPTORS = require_descriptors();
      var IE8_DOM_DEFINE = require_ie8_dom_define();
      var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
      var anObject = require_an_object();
      var toPropertyKey = require_to_property_key();
      var TypeError2 = global2.TypeError;
      var $defineProperty = Object.defineProperty;
      var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var ENUMERABLE = "enumerable";
      var CONFIGURABLE = "configurable";
      var WRITABLE = "writable";
      exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P2, Attributes) {
        anObject(O);
        P2 = toPropertyKey(P2);
        anObject(Attributes);
        if (typeof O === "function" && P2 === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
          var current = $getOwnPropertyDescriptor(O, P2);
          if (current && current[WRITABLE]) {
            O[P2] = Attributes.value;
            Attributes = {
              configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
              enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
              writable: false
            };
          }
        }
        return $defineProperty(O, P2, Attributes);
      } : $defineProperty : function defineProperty(O, P2, Attributes) {
        anObject(O);
        P2 = toPropertyKey(P2);
        anObject(Attributes);
        if (IE8_DOM_DEFINE)
          try {
            return $defineProperty(O, P2, Attributes);
          } catch (error2) {
          }
        if ("get" in Attributes || "set" in Attributes)
          throw TypeError2("Accessors not supported");
        if ("value" in Attributes)
          O[P2] = Attributes.value;
        return O;
      };
    }
  });

  // node_modules/core-js/internals/create-non-enumerable-property.js
  var require_create_non_enumerable_property = __commonJS({
    "node_modules/core-js/internals/create-non-enumerable-property.js"(exports, module) {
      var DESCRIPTORS = require_descriptors();
      var definePropertyModule = require_object_define_property();
      var createPropertyDescriptor = require_create_property_descriptor();
      module.exports = DESCRIPTORS ? function(object, key, value) {
        return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
      } : function(object, key, value) {
        object[key] = value;
        return object;
      };
    }
  });

  // node_modules/core-js/internals/inspect-source.js
  var require_inspect_source = __commonJS({
    "node_modules/core-js/internals/inspect-source.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      var isCallable = require_is_callable();
      var store = require_shared_store();
      var functionToString = uncurryThis(Function.toString);
      if (!isCallable(store.inspectSource)) {
        store.inspectSource = function(it) {
          return functionToString(it);
        };
      }
      module.exports = store.inspectSource;
    }
  });

  // node_modules/core-js/internals/native-weak-map.js
  var require_native_weak_map = __commonJS({
    "node_modules/core-js/internals/native-weak-map.js"(exports, module) {
      var global2 = require_global();
      var isCallable = require_is_callable();
      var inspectSource = require_inspect_source();
      var WeakMap2 = global2.WeakMap;
      module.exports = isCallable(WeakMap2) && /native code/.test(inspectSource(WeakMap2));
    }
  });

  // node_modules/core-js/internals/shared-key.js
  var require_shared_key = __commonJS({
    "node_modules/core-js/internals/shared-key.js"(exports, module) {
      var shared = require_shared();
      var uid = require_uid();
      var keys = shared("keys");
      module.exports = function(key) {
        return keys[key] || (keys[key] = uid(key));
      };
    }
  });

  // node_modules/core-js/internals/hidden-keys.js
  var require_hidden_keys = __commonJS({
    "node_modules/core-js/internals/hidden-keys.js"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/core-js/internals/internal-state.js
  var require_internal_state = __commonJS({
    "node_modules/core-js/internals/internal-state.js"(exports, module) {
      var NATIVE_WEAK_MAP = require_native_weak_map();
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this();
      var isObject3 = require_is_object();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var hasOwn = require_has_own_property();
      var shared = require_shared_store();
      var sharedKey = require_shared_key();
      var hiddenKeys = require_hidden_keys();
      var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
      var TypeError2 = global2.TypeError;
      var WeakMap2 = global2.WeakMap;
      var set;
      var get;
      var has;
      var enforce = function(it) {
        return has(it) ? get(it) : set(it, {});
      };
      var getterFor = function(TYPE) {
        return function(it) {
          var state;
          if (!isObject3(it) || (state = get(it)).type !== TYPE) {
            throw TypeError2("Incompatible receiver, " + TYPE + " required");
          }
          return state;
        };
      };
      if (NATIVE_WEAK_MAP || shared.state) {
        store = shared.state || (shared.state = new WeakMap2());
        wmget = uncurryThis(store.get);
        wmhas = uncurryThis(store.has);
        wmset = uncurryThis(store.set);
        set = function(it, metadata) {
          if (wmhas(store, it))
            throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
          metadata.facade = it;
          wmset(store, it, metadata);
          return metadata;
        };
        get = function(it) {
          return wmget(store, it) || {};
        };
        has = function(it) {
          return wmhas(store, it);
        };
      } else {
        STATE = sharedKey("state");
        hiddenKeys[STATE] = true;
        set = function(it, metadata) {
          if (hasOwn(it, STATE))
            throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
          metadata.facade = it;
          createNonEnumerableProperty(it, STATE, metadata);
          return metadata;
        };
        get = function(it) {
          return hasOwn(it, STATE) ? it[STATE] : {};
        };
        has = function(it) {
          return hasOwn(it, STATE);
        };
      }
      var store;
      var wmget;
      var wmhas;
      var wmset;
      var STATE;
      module.exports = {
        set,
        get,
        has,
        enforce,
        getterFor
      };
    }
  });

  // node_modules/core-js/internals/function-name.js
  var require_function_name = __commonJS({
    "node_modules/core-js/internals/function-name.js"(exports, module) {
      var DESCRIPTORS = require_descriptors();
      var hasOwn = require_has_own_property();
      var FunctionPrototype = Function.prototype;
      var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
      var EXISTS = hasOwn(FunctionPrototype, "name");
      var PROPER = EXISTS && function something() {
      }.name === "something";
      var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
      module.exports = {
        EXISTS,
        PROPER,
        CONFIGURABLE
      };
    }
  });

  // node_modules/core-js/internals/redefine.js
  var require_redefine = __commonJS({
    "node_modules/core-js/internals/redefine.js"(exports, module) {
      var global2 = require_global();
      var isCallable = require_is_callable();
      var hasOwn = require_has_own_property();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var setGlobal = require_set_global();
      var inspectSource = require_inspect_source();
      var InternalStateModule = require_internal_state();
      var CONFIGURABLE_FUNCTION_NAME = require_function_name().CONFIGURABLE;
      var getInternalState = InternalStateModule.get;
      var enforceInternalState = InternalStateModule.enforce;
      var TEMPLATE = String(String).split("String");
      (module.exports = function(O, key, value, options) {
        var unsafe = options ? !!options.unsafe : false;
        var simple = options ? !!options.enumerable : false;
        var noTargetGet = options ? !!options.noTargetGet : false;
        var name = options && options.name !== void 0 ? options.name : key;
        var state;
        if (isCallable(value)) {
          if (String(name).slice(0, 7) === "Symbol(") {
            name = "[" + String(name).replace(/^Symbol\(([^)]*)\)/, "$1") + "]";
          }
          if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
            createNonEnumerableProperty(value, "name", name);
          }
          state = enforceInternalState(value);
          if (!state.source) {
            state.source = TEMPLATE.join(typeof name == "string" ? name : "");
          }
        }
        if (O === global2) {
          if (simple)
            O[key] = value;
          else
            setGlobal(key, value);
          return;
        } else if (!unsafe) {
          delete O[key];
        } else if (!noTargetGet && O[key]) {
          simple = true;
        }
        if (simple)
          O[key] = value;
        else
          createNonEnumerableProperty(O, key, value);
      })(Function.prototype, "toString", function toString() {
        return isCallable(this) && getInternalState(this).source || inspectSource(this);
      });
    }
  });

  // node_modules/core-js/internals/to-integer-or-infinity.js
  var require_to_integer_or_infinity = __commonJS({
    "node_modules/core-js/internals/to-integer-or-infinity.js"(exports, module) {
      var ceil = Math.ceil;
      var floor = Math.floor;
      module.exports = function(argument) {
        var number = +argument;
        return number !== number || number === 0 ? 0 : (number > 0 ? floor : ceil)(number);
      };
    }
  });

  // node_modules/core-js/internals/to-absolute-index.js
  var require_to_absolute_index = __commonJS({
    "node_modules/core-js/internals/to-absolute-index.js"(exports, module) {
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var max2 = Math.max;
      var min2 = Math.min;
      module.exports = function(index, length) {
        var integer = toIntegerOrInfinity(index);
        return integer < 0 ? max2(integer + length, 0) : min2(integer, length);
      };
    }
  });

  // node_modules/core-js/internals/to-length.js
  var require_to_length = __commonJS({
    "node_modules/core-js/internals/to-length.js"(exports, module) {
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var min2 = Math.min;
      module.exports = function(argument) {
        return argument > 0 ? min2(toIntegerOrInfinity(argument), 9007199254740991) : 0;
      };
    }
  });

  // node_modules/core-js/internals/length-of-array-like.js
  var require_length_of_array_like = __commonJS({
    "node_modules/core-js/internals/length-of-array-like.js"(exports, module) {
      var toLength = require_to_length();
      module.exports = function(obj) {
        return toLength(obj.length);
      };
    }
  });

  // node_modules/core-js/internals/array-includes.js
  var require_array_includes = __commonJS({
    "node_modules/core-js/internals/array-includes.js"(exports, module) {
      var toIndexedObject = require_to_indexed_object();
      var toAbsoluteIndex = require_to_absolute_index();
      var lengthOfArrayLike = require_length_of_array_like();
      var createMethod = function(IS_INCLUDES) {
        return function($this, el, fromIndex) {
          var O = toIndexedObject($this);
          var length = lengthOfArrayLike(O);
          var index = toAbsoluteIndex(fromIndex, length);
          var value;
          if (IS_INCLUDES && el != el)
            while (length > index) {
              value = O[index++];
              if (value != value)
                return true;
            }
          else
            for (; length > index; index++) {
              if ((IS_INCLUDES || index in O) && O[index] === el)
                return IS_INCLUDES || index || 0;
            }
          return !IS_INCLUDES && -1;
        };
      };
      module.exports = {
        includes: createMethod(true),
        indexOf: createMethod(false)
      };
    }
  });

  // node_modules/core-js/internals/object-keys-internal.js
  var require_object_keys_internal = __commonJS({
    "node_modules/core-js/internals/object-keys-internal.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      var hasOwn = require_has_own_property();
      var toIndexedObject = require_to_indexed_object();
      var indexOf2 = require_array_includes().indexOf;
      var hiddenKeys = require_hidden_keys();
      var push = uncurryThis([].push);
      module.exports = function(object, names) {
        var O = toIndexedObject(object);
        var i2 = 0;
        var result = [];
        var key;
        for (key in O)
          !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
        while (names.length > i2)
          if (hasOwn(O, key = names[i2++])) {
            ~indexOf2(result, key) || push(result, key);
          }
        return result;
      };
    }
  });

  // node_modules/core-js/internals/enum-bug-keys.js
  var require_enum_bug_keys = __commonJS({
    "node_modules/core-js/internals/enum-bug-keys.js"(exports, module) {
      module.exports = [
        "constructor",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "toLocaleString",
        "toString",
        "valueOf"
      ];
    }
  });

  // node_modules/core-js/internals/object-get-own-property-names.js
  var require_object_get_own_property_names = __commonJS({
    "node_modules/core-js/internals/object-get-own-property-names.js"(exports) {
      var internalObjectKeys = require_object_keys_internal();
      var enumBugKeys = require_enum_bug_keys();
      var hiddenKeys = enumBugKeys.concat("length", "prototype");
      exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
        return internalObjectKeys(O, hiddenKeys);
      };
    }
  });

  // node_modules/core-js/internals/object-get-own-property-symbols.js
  var require_object_get_own_property_symbols = __commonJS({
    "node_modules/core-js/internals/object-get-own-property-symbols.js"(exports) {
      exports.f = Object.getOwnPropertySymbols;
    }
  });

  // node_modules/core-js/internals/own-keys.js
  var require_own_keys = __commonJS({
    "node_modules/core-js/internals/own-keys.js"(exports, module) {
      var getBuiltIn = require_get_built_in();
      var uncurryThis = require_function_uncurry_this();
      var getOwnPropertyNamesModule = require_object_get_own_property_names();
      var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
      var anObject = require_an_object();
      var concat = uncurryThis([].concat);
      module.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys17(it) {
        var keys = getOwnPropertyNamesModule.f(anObject(it));
        var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
        return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
      };
    }
  });

  // node_modules/core-js/internals/copy-constructor-properties.js
  var require_copy_constructor_properties = __commonJS({
    "node_modules/core-js/internals/copy-constructor-properties.js"(exports, module) {
      var hasOwn = require_has_own_property();
      var ownKeys17 = require_own_keys();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var definePropertyModule = require_object_define_property();
      module.exports = function(target, source, exceptions) {
        var keys = ownKeys17(source);
        var defineProperty = definePropertyModule.f;
        var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
        for (var i2 = 0; i2 < keys.length; i2++) {
          var key = keys[i2];
          if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
            defineProperty(target, key, getOwnPropertyDescriptor(source, key));
          }
        }
      };
    }
  });

  // node_modules/core-js/internals/is-forced.js
  var require_is_forced = __commonJS({
    "node_modules/core-js/internals/is-forced.js"(exports, module) {
      var fails = require_fails();
      var isCallable = require_is_callable();
      var replacement = /#|\.prototype\./;
      var isForced = function(feature, detection) {
        var value = data[normalize(feature)];
        return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
      };
      var normalize = isForced.normalize = function(string) {
        return String(string).replace(replacement, ".").toLowerCase();
      };
      var data = isForced.data = {};
      var NATIVE = isForced.NATIVE = "N";
      var POLYFILL = isForced.POLYFILL = "P";
      module.exports = isForced;
    }
  });

  // node_modules/core-js/internals/export.js
  var require_export = __commonJS({
    "node_modules/core-js/internals/export.js"(exports, module) {
      var global2 = require_global();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var redefine = require_redefine();
      var setGlobal = require_set_global();
      var copyConstructorProperties = require_copy_constructor_properties();
      var isForced = require_is_forced();
      module.exports = function(options, source) {
        var TARGET = options.target;
        var GLOBAL = options.global;
        var STATIC = options.stat;
        var FORCED, target, key, targetProperty, sourceProperty, descriptor;
        if (GLOBAL) {
          target = global2;
        } else if (STATIC) {
          target = global2[TARGET] || setGlobal(TARGET, {});
        } else {
          target = (global2[TARGET] || {}).prototype;
        }
        if (target)
          for (key in source) {
            sourceProperty = source[key];
            if (options.noTargetGet) {
              descriptor = getOwnPropertyDescriptor(target, key);
              targetProperty = descriptor && descriptor.value;
            } else
              targetProperty = target[key];
            FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
            if (!FORCED && targetProperty !== void 0) {
              if (typeof sourceProperty == typeof targetProperty)
                continue;
              copyConstructorProperties(sourceProperty, targetProperty);
            }
            if (options.sham || targetProperty && targetProperty.sham) {
              createNonEnumerableProperty(sourceProperty, "sham", true);
            }
            redefine(target, key, sourceProperty, options);
          }
      };
    }
  });

  // node_modules/core-js/internals/function-apply.js
  var require_function_apply = __commonJS({
    "node_modules/core-js/internals/function-apply.js"(exports, module) {
      var NATIVE_BIND = require_function_bind_native();
      var FunctionPrototype = Function.prototype;
      var apply = FunctionPrototype.apply;
      var call = FunctionPrototype.call;
      module.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
        return call.apply(apply, arguments);
      });
    }
  });

  // node_modules/core-js/internals/is-array.js
  var require_is_array = __commonJS({
    "node_modules/core-js/internals/is-array.js"(exports, module) {
      var classof = require_classof_raw();
      module.exports = Array.isArray || function isArray(argument) {
        return classof(argument) == "Array";
      };
    }
  });

  // node_modules/core-js/internals/to-string-tag-support.js
  var require_to_string_tag_support = __commonJS({
    "node_modules/core-js/internals/to-string-tag-support.js"(exports, module) {
      var wellKnownSymbol = require_well_known_symbol();
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var test = {};
      test[TO_STRING_TAG] = "z";
      module.exports = String(test) === "[object z]";
    }
  });

  // node_modules/core-js/internals/classof.js
  var require_classof = __commonJS({
    "node_modules/core-js/internals/classof.js"(exports, module) {
      var global2 = require_global();
      var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
      var isCallable = require_is_callable();
      var classofRaw = require_classof_raw();
      var wellKnownSymbol = require_well_known_symbol();
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var Object2 = global2.Object;
      var CORRECT_ARGUMENTS = classofRaw(function() {
        return arguments;
      }()) == "Arguments";
      var tryGet = function(it, key) {
        try {
          return it[key];
        } catch (error2) {
        }
      };
      module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
        var O, tag, result;
        return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = Object2(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && isCallable(O.callee) ? "Arguments" : result;
      };
    }
  });

  // node_modules/core-js/internals/to-string.js
  var require_to_string = __commonJS({
    "node_modules/core-js/internals/to-string.js"(exports, module) {
      var global2 = require_global();
      var classof = require_classof();
      var String2 = global2.String;
      module.exports = function(argument) {
        if (classof(argument) === "Symbol")
          throw TypeError("Cannot convert a Symbol value to a string");
        return String2(argument);
      };
    }
  });

  // node_modules/core-js/internals/object-keys.js
  var require_object_keys = __commonJS({
    "node_modules/core-js/internals/object-keys.js"(exports, module) {
      var internalObjectKeys = require_object_keys_internal();
      var enumBugKeys = require_enum_bug_keys();
      module.exports = Object.keys || function keys(O) {
        return internalObjectKeys(O, enumBugKeys);
      };
    }
  });

  // node_modules/core-js/internals/object-define-properties.js
  var require_object_define_properties = __commonJS({
    "node_modules/core-js/internals/object-define-properties.js"(exports) {
      var DESCRIPTORS = require_descriptors();
      var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
      var definePropertyModule = require_object_define_property();
      var anObject = require_an_object();
      var toIndexedObject = require_to_indexed_object();
      var objectKeys = require_object_keys();
      exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
        anObject(O);
        var props = toIndexedObject(Properties);
        var keys = objectKeys(Properties);
        var length = keys.length;
        var index = 0;
        var key;
        while (length > index)
          definePropertyModule.f(O, key = keys[index++], props[key]);
        return O;
      };
    }
  });

  // node_modules/core-js/internals/html.js
  var require_html = __commonJS({
    "node_modules/core-js/internals/html.js"(exports, module) {
      var getBuiltIn = require_get_built_in();
      module.exports = getBuiltIn("document", "documentElement");
    }
  });

  // node_modules/core-js/internals/object-create.js
  var require_object_create = __commonJS({
    "node_modules/core-js/internals/object-create.js"(exports, module) {
      var anObject = require_an_object();
      var definePropertiesModule = require_object_define_properties();
      var enumBugKeys = require_enum_bug_keys();
      var hiddenKeys = require_hidden_keys();
      var html = require_html();
      var documentCreateElement = require_document_create_element();
      var sharedKey = require_shared_key();
      var GT = ">";
      var LT = "<";
      var PROTOTYPE = "prototype";
      var SCRIPT = "script";
      var IE_PROTO = sharedKey("IE_PROTO");
      var EmptyConstructor = function() {
      };
      var scriptTag = function(content) {
        return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
      };
      var NullProtoObjectViaActiveX = function(activeXDocument2) {
        activeXDocument2.write(scriptTag(""));
        activeXDocument2.close();
        var temp = activeXDocument2.parentWindow.Object;
        activeXDocument2 = null;
        return temp;
      };
      var NullProtoObjectViaIFrame = function() {
        var iframe = documentCreateElement("iframe");
        var JS = "java" + SCRIPT + ":";
        var iframeDocument;
        iframe.style.display = "none";
        html.appendChild(iframe);
        iframe.src = String(JS);
        iframeDocument = iframe.contentWindow.document;
        iframeDocument.open();
        iframeDocument.write(scriptTag("document.F=Object"));
        iframeDocument.close();
        return iframeDocument.F;
      };
      var activeXDocument;
      var NullProtoObject = function() {
        try {
          activeXDocument = new ActiveXObject("htmlfile");
        } catch (error2) {
        }
        NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
        var length = enumBugKeys.length;
        while (length--)
          delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
        return NullProtoObject();
      };
      hiddenKeys[IE_PROTO] = true;
      module.exports = Object.create || function create(O, Properties) {
        var result;
        if (O !== null) {
          EmptyConstructor[PROTOTYPE] = anObject(O);
          result = new EmptyConstructor();
          EmptyConstructor[PROTOTYPE] = null;
          result[IE_PROTO] = O;
        } else
          result = NullProtoObject();
        return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
      };
    }
  });

  // node_modules/core-js/internals/create-property.js
  var require_create_property = __commonJS({
    "node_modules/core-js/internals/create-property.js"(exports, module) {
      "use strict";
      var toPropertyKey = require_to_property_key();
      var definePropertyModule = require_object_define_property();
      var createPropertyDescriptor = require_create_property_descriptor();
      module.exports = function(object, key, value) {
        var propertyKey = toPropertyKey(key);
        if (propertyKey in object)
          definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
        else
          object[propertyKey] = value;
      };
    }
  });

  // node_modules/core-js/internals/array-slice-simple.js
  var require_array_slice_simple = __commonJS({
    "node_modules/core-js/internals/array-slice-simple.js"(exports, module) {
      var global2 = require_global();
      var toAbsoluteIndex = require_to_absolute_index();
      var lengthOfArrayLike = require_length_of_array_like();
      var createProperty = require_create_property();
      var Array2 = global2.Array;
      var max2 = Math.max;
      module.exports = function(O, start4, end2) {
        var length = lengthOfArrayLike(O);
        var k2 = toAbsoluteIndex(start4, length);
        var fin = toAbsoluteIndex(end2 === void 0 ? length : end2, length);
        var result = Array2(max2(fin - k2, 0));
        for (var n2 = 0; k2 < fin; k2++, n2++)
          createProperty(result, n2, O[k2]);
        result.length = n2;
        return result;
      };
    }
  });

  // node_modules/core-js/internals/object-get-own-property-names-external.js
  var require_object_get_own_property_names_external = __commonJS({
    "node_modules/core-js/internals/object-get-own-property-names-external.js"(exports, module) {
      var classof = require_classof_raw();
      var toIndexedObject = require_to_indexed_object();
      var $getOwnPropertyNames = require_object_get_own_property_names().f;
      var arraySlice = require_array_slice_simple();
      var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
      var getWindowNames = function(it) {
        try {
          return $getOwnPropertyNames(it);
        } catch (error2) {
          return arraySlice(windowNames);
        }
      };
      module.exports.f = function getOwnPropertyNames(it) {
        return windowNames && classof(it) == "Window" ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
      };
    }
  });

  // node_modules/core-js/internals/array-slice.js
  var require_array_slice = __commonJS({
    "node_modules/core-js/internals/array-slice.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      module.exports = uncurryThis([].slice);
    }
  });

  // node_modules/core-js/internals/well-known-symbol-wrapped.js
  var require_well_known_symbol_wrapped = __commonJS({
    "node_modules/core-js/internals/well-known-symbol-wrapped.js"(exports) {
      var wellKnownSymbol = require_well_known_symbol();
      exports.f = wellKnownSymbol;
    }
  });

  // node_modules/core-js/internals/path.js
  var require_path = __commonJS({
    "node_modules/core-js/internals/path.js"(exports, module) {
      var global2 = require_global();
      module.exports = global2;
    }
  });

  // node_modules/core-js/internals/define-well-known-symbol.js
  var require_define_well_known_symbol = __commonJS({
    "node_modules/core-js/internals/define-well-known-symbol.js"(exports, module) {
      var path = require_path();
      var hasOwn = require_has_own_property();
      var wrappedWellKnownSymbolModule = require_well_known_symbol_wrapped();
      var defineProperty = require_object_define_property().f;
      module.exports = function(NAME) {
        var Symbol2 = path.Symbol || (path.Symbol = {});
        if (!hasOwn(Symbol2, NAME))
          defineProperty(Symbol2, NAME, {
            value: wrappedWellKnownSymbolModule.f(NAME)
          });
      };
    }
  });

  // node_modules/core-js/internals/set-to-string-tag.js
  var require_set_to_string_tag = __commonJS({
    "node_modules/core-js/internals/set-to-string-tag.js"(exports, module) {
      var defineProperty = require_object_define_property().f;
      var hasOwn = require_has_own_property();
      var wellKnownSymbol = require_well_known_symbol();
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      module.exports = function(target, TAG, STATIC) {
        if (target && !STATIC)
          target = target.prototype;
        if (target && !hasOwn(target, TO_STRING_TAG)) {
          defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
        }
      };
    }
  });

  // node_modules/core-js/internals/function-bind-context.js
  var require_function_bind_context = __commonJS({
    "node_modules/core-js/internals/function-bind-context.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      var aCallable = require_a_callable();
      var NATIVE_BIND = require_function_bind_native();
      var bind3 = uncurryThis(uncurryThis.bind);
      module.exports = function(fn2, that) {
        aCallable(fn2);
        return that === void 0 ? fn2 : NATIVE_BIND ? bind3(fn2, that) : function() {
          return fn2.apply(that, arguments);
        };
      };
    }
  });

  // node_modules/core-js/internals/is-constructor.js
  var require_is_constructor = __commonJS({
    "node_modules/core-js/internals/is-constructor.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var isCallable = require_is_callable();
      var classof = require_classof();
      var getBuiltIn = require_get_built_in();
      var inspectSource = require_inspect_source();
      var noop3 = function() {
      };
      var empty = [];
      var construct = getBuiltIn("Reflect", "construct");
      var constructorRegExp = /^\s*(?:class|function)\b/;
      var exec = uncurryThis(constructorRegExp.exec);
      var INCORRECT_TO_STRING = !constructorRegExp.exec(noop3);
      var isConstructorModern = function isConstructor(argument) {
        if (!isCallable(argument))
          return false;
        try {
          construct(noop3, empty, argument);
          return true;
        } catch (error2) {
          return false;
        }
      };
      var isConstructorLegacy = function isConstructor(argument) {
        if (!isCallable(argument))
          return false;
        switch (classof(argument)) {
          case "AsyncFunction":
          case "GeneratorFunction":
          case "AsyncGeneratorFunction":
            return false;
        }
        try {
          return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
        } catch (error2) {
          return true;
        }
      };
      isConstructorLegacy.sham = true;
      module.exports = !construct || fails(function() {
        var called;
        return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
          called = true;
        }) || called;
      }) ? isConstructorLegacy : isConstructorModern;
    }
  });

  // node_modules/core-js/internals/array-species-constructor.js
  var require_array_species_constructor = __commonJS({
    "node_modules/core-js/internals/array-species-constructor.js"(exports, module) {
      var global2 = require_global();
      var isArray = require_is_array();
      var isConstructor = require_is_constructor();
      var isObject3 = require_is_object();
      var wellKnownSymbol = require_well_known_symbol();
      var SPECIES = wellKnownSymbol("species");
      var Array2 = global2.Array;
      module.exports = function(originalArray) {
        var C2;
        if (isArray(originalArray)) {
          C2 = originalArray.constructor;
          if (isConstructor(C2) && (C2 === Array2 || isArray(C2.prototype)))
            C2 = void 0;
          else if (isObject3(C2)) {
            C2 = C2[SPECIES];
            if (C2 === null)
              C2 = void 0;
          }
        }
        return C2 === void 0 ? Array2 : C2;
      };
    }
  });

  // node_modules/core-js/internals/array-species-create.js
  var require_array_species_create = __commonJS({
    "node_modules/core-js/internals/array-species-create.js"(exports, module) {
      var arraySpeciesConstructor = require_array_species_constructor();
      module.exports = function(originalArray, length) {
        return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
      };
    }
  });

  // node_modules/core-js/internals/array-iteration.js
  var require_array_iteration = __commonJS({
    "node_modules/core-js/internals/array-iteration.js"(exports, module) {
      var bind3 = require_function_bind_context();
      var uncurryThis = require_function_uncurry_this();
      var IndexedObject = require_indexed_object();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var arraySpeciesCreate = require_array_species_create();
      var push = uncurryThis([].push);
      var createMethod = function(TYPE) {
        var IS_MAP = TYPE == 1;
        var IS_FILTER = TYPE == 2;
        var IS_SOME = TYPE == 3;
        var IS_EVERY = TYPE == 4;
        var IS_FIND_INDEX = TYPE == 6;
        var IS_FILTER_REJECT = TYPE == 7;
        var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
        return function($this, callbackfn, that, specificCreate) {
          var O = toObject($this);
          var self2 = IndexedObject(O);
          var boundFunction = bind3(callbackfn, that);
          var length = lengthOfArrayLike(self2);
          var index = 0;
          var create = specificCreate || arraySpeciesCreate;
          var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : void 0;
          var value, result;
          for (; length > index; index++)
            if (NO_HOLES || index in self2) {
              value = self2[index];
              result = boundFunction(value, index, O);
              if (TYPE) {
                if (IS_MAP)
                  target[index] = result;
                else if (result)
                  switch (TYPE) {
                    case 3:
                      return true;
                    case 5:
                      return value;
                    case 6:
                      return index;
                    case 2:
                      push(target, value);
                  }
                else
                  switch (TYPE) {
                    case 4:
                      return false;
                    case 7:
                      push(target, value);
                  }
              }
            }
          return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
        };
      };
      module.exports = {
        forEach: createMethod(0),
        map: createMethod(1),
        filter: createMethod(2),
        some: createMethod(3),
        every: createMethod(4),
        find: createMethod(5),
        findIndex: createMethod(6),
        filterReject: createMethod(7)
      };
    }
  });

  // node_modules/core-js/modules/es.symbol.js
  var require_es_symbol = __commonJS({
    "node_modules/core-js/modules/es.symbol.js"() {
      "use strict";
      var $2 = require_export();
      var global2 = require_global();
      var getBuiltIn = require_get_built_in();
      var apply = require_function_apply();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var IS_PURE = require_is_pure();
      var DESCRIPTORS = require_descriptors();
      var NATIVE_SYMBOL = require_native_symbol();
      var fails = require_fails();
      var hasOwn = require_has_own_property();
      var isArray = require_is_array();
      var isCallable = require_is_callable();
      var isObject3 = require_is_object();
      var isPrototypeOf = require_object_is_prototype_of();
      var isSymbol = require_is_symbol();
      var anObject = require_an_object();
      var toObject = require_to_object();
      var toIndexedObject = require_to_indexed_object();
      var toPropertyKey = require_to_property_key();
      var $toString = require_to_string();
      var createPropertyDescriptor = require_create_property_descriptor();
      var nativeObjectCreate = require_object_create();
      var objectKeys = require_object_keys();
      var getOwnPropertyNamesModule = require_object_get_own_property_names();
      var getOwnPropertyNamesExternal = require_object_get_own_property_names_external();
      var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var definePropertyModule = require_object_define_property();
      var definePropertiesModule = require_object_define_properties();
      var propertyIsEnumerableModule = require_object_property_is_enumerable();
      var arraySlice = require_array_slice();
      var redefine = require_redefine();
      var shared = require_shared();
      var sharedKey = require_shared_key();
      var hiddenKeys = require_hidden_keys();
      var uid = require_uid();
      var wellKnownSymbol = require_well_known_symbol();
      var wrappedWellKnownSymbolModule = require_well_known_symbol_wrapped();
      var defineWellKnownSymbol = require_define_well_known_symbol();
      var setToStringTag = require_set_to_string_tag();
      var InternalStateModule = require_internal_state();
      var $forEach = require_array_iteration().forEach;
      var HIDDEN = sharedKey("hidden");
      var SYMBOL = "Symbol";
      var PROTOTYPE = "prototype";
      var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(SYMBOL);
      var ObjectPrototype = Object[PROTOTYPE];
      var $Symbol = global2.Symbol;
      var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
      var TypeError2 = global2.TypeError;
      var QObject = global2.QObject;
      var $stringify = getBuiltIn("JSON", "stringify");
      var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      var nativeDefineProperty = definePropertyModule.f;
      var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
      var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
      var push = uncurryThis([].push);
      var AllSymbols = shared("symbols");
      var ObjectPrototypeSymbols = shared("op-symbols");
      var StringToSymbolRegistry = shared("string-to-symbol-registry");
      var SymbolToStringRegistry = shared("symbol-to-string-registry");
      var WellKnownSymbolsStore = shared("wks");
      var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
      var setSymbolDescriptor = DESCRIPTORS && fails(function() {
        return nativeObjectCreate(nativeDefineProperty({}, "a", {
          get: function() {
            return nativeDefineProperty(this, "a", { value: 7 }).a;
          }
        })).a != 7;
      }) ? function(O, P2, Attributes) {
        var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P2);
        if (ObjectPrototypeDescriptor)
          delete ObjectPrototype[P2];
        nativeDefineProperty(O, P2, Attributes);
        if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
          nativeDefineProperty(ObjectPrototype, P2, ObjectPrototypeDescriptor);
        }
      } : nativeDefineProperty;
      var wrap2 = function(tag, description) {
        var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
        setInternalState(symbol, {
          type: SYMBOL,
          tag,
          description
        });
        if (!DESCRIPTORS)
          symbol.description = description;
        return symbol;
      };
      var $defineProperty = function defineProperty(O, P2, Attributes) {
        if (O === ObjectPrototype)
          $defineProperty(ObjectPrototypeSymbols, P2, Attributes);
        anObject(O);
        var key = toPropertyKey(P2);
        anObject(Attributes);
        if (hasOwn(AllSymbols, key)) {
          if (!Attributes.enumerable) {
            if (!hasOwn(O, HIDDEN))
              nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
            O[HIDDEN][key] = true;
          } else {
            if (hasOwn(O, HIDDEN) && O[HIDDEN][key])
              O[HIDDEN][key] = false;
            Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
          }
          return setSymbolDescriptor(O, key, Attributes);
        }
        return nativeDefineProperty(O, key, Attributes);
      };
      var $defineProperties = function defineProperties(O, Properties) {
        anObject(O);
        var properties = toIndexedObject(Properties);
        var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
        $forEach(keys, function(key) {
          if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key))
            $defineProperty(O, key, properties[key]);
        });
        return O;
      };
      var $create = function create(O, Properties) {
        return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
      };
      var $propertyIsEnumerable = function propertyIsEnumerable(V) {
        var P2 = toPropertyKey(V);
        var enumerable = call(nativePropertyIsEnumerable, this, P2);
        if (this === ObjectPrototype && hasOwn(AllSymbols, P2) && !hasOwn(ObjectPrototypeSymbols, P2))
          return false;
        return enumerable || !hasOwn(this, P2) || !hasOwn(AllSymbols, P2) || hasOwn(this, HIDDEN) && this[HIDDEN][P2] ? enumerable : true;
      };
      var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P2) {
        var it = toIndexedObject(O);
        var key = toPropertyKey(P2);
        if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key))
          return;
        var descriptor = nativeGetOwnPropertyDescriptor(it, key);
        if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
          descriptor.enumerable = true;
        }
        return descriptor;
      };
      var $getOwnPropertyNames = function getOwnPropertyNames(O) {
        var names = nativeGetOwnPropertyNames(toIndexedObject(O));
        var result = [];
        $forEach(names, function(key) {
          if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key))
            push(result, key);
        });
        return result;
      };
      var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
        var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
        var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
        var result = [];
        $forEach(names, function(key) {
          if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
            push(result, AllSymbols[key]);
          }
        });
        return result;
      };
      if (!NATIVE_SYMBOL) {
        $Symbol = function Symbol2() {
          if (isPrototypeOf(SymbolPrototype, this))
            throw TypeError2("Symbol is not a constructor");
          var description = !arguments.length || arguments[0] === void 0 ? void 0 : $toString(arguments[0]);
          var tag = uid(description);
          var setter = function(value) {
            if (this === ObjectPrototype)
              call(setter, ObjectPrototypeSymbols, value);
            if (hasOwn(this, HIDDEN) && hasOwn(this[HIDDEN], tag))
              this[HIDDEN][tag] = false;
            setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
          };
          if (DESCRIPTORS && USE_SETTER)
            setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
          return wrap2(tag, description);
        };
        SymbolPrototype = $Symbol[PROTOTYPE];
        redefine(SymbolPrototype, "toString", function toString() {
          return getInternalState(this).tag;
        });
        redefine($Symbol, "withoutSetter", function(description) {
          return wrap2(uid(description), description);
        });
        propertyIsEnumerableModule.f = $propertyIsEnumerable;
        definePropertyModule.f = $defineProperty;
        definePropertiesModule.f = $defineProperties;
        getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
        getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
        getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
        wrappedWellKnownSymbolModule.f = function(name) {
          return wrap2(wellKnownSymbol(name), name);
        };
        if (DESCRIPTORS) {
          nativeDefineProperty(SymbolPrototype, "description", {
            configurable: true,
            get: function description() {
              return getInternalState(this).description;
            }
          });
          if (!IS_PURE) {
            redefine(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
          }
        }
      }
      $2({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
        Symbol: $Symbol
      });
      $forEach(objectKeys(WellKnownSymbolsStore), function(name) {
        defineWellKnownSymbol(name);
      });
      $2({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
        "for": function(key) {
          var string = $toString(key);
          if (hasOwn(StringToSymbolRegistry, string))
            return StringToSymbolRegistry[string];
          var symbol = $Symbol(string);
          StringToSymbolRegistry[string] = symbol;
          SymbolToStringRegistry[symbol] = string;
          return symbol;
        },
        keyFor: function keyFor(sym) {
          if (!isSymbol(sym))
            throw TypeError2(sym + " is not a symbol");
          if (hasOwn(SymbolToStringRegistry, sym))
            return SymbolToStringRegistry[sym];
        },
        useSetter: function() {
          USE_SETTER = true;
        },
        useSimple: function() {
          USE_SETTER = false;
        }
      });
      $2({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
        create: $create,
        defineProperty: $defineProperty,
        defineProperties: $defineProperties,
        getOwnPropertyDescriptor: $getOwnPropertyDescriptor
      });
      $2({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
        getOwnPropertyNames: $getOwnPropertyNames,
        getOwnPropertySymbols: $getOwnPropertySymbols
      });
      $2({ target: "Object", stat: true, forced: fails(function() {
        getOwnPropertySymbolsModule.f(1);
      }) }, {
        getOwnPropertySymbols: function getOwnPropertySymbols(it) {
          return getOwnPropertySymbolsModule.f(toObject(it));
        }
      });
      if ($stringify) {
        FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function() {
          var symbol = $Symbol();
          return $stringify([symbol]) != "[null]" || $stringify({ a: symbol }) != "{}" || $stringify(Object(symbol)) != "{}";
        });
        $2({ target: "JSON", stat: true, forced: FORCED_JSON_STRINGIFY }, {
          stringify: function stringify(it, replacer, space) {
            var args = arraySlice(arguments);
            var $replacer = replacer;
            if (!isObject3(replacer) && it === void 0 || isSymbol(it))
              return;
            if (!isArray(replacer))
              replacer = function(key, value) {
                if (isCallable($replacer))
                  value = call($replacer, this, key, value);
                if (!isSymbol(value))
                  return value;
              };
            args[1] = replacer;
            return apply($stringify, null, args);
          }
        });
      }
      var FORCED_JSON_STRINGIFY;
      if (!SymbolPrototype[TO_PRIMITIVE]) {
        valueOf = SymbolPrototype.valueOf;
        redefine(SymbolPrototype, TO_PRIMITIVE, function(hint) {
          return call(valueOf, this);
        });
      }
      var valueOf;
      setToStringTag($Symbol, SYMBOL);
      hiddenKeys[HIDDEN] = true;
    }
  });

  // node_modules/core-js/modules/es.symbol.description.js
  var require_es_symbol_description = __commonJS({
    "node_modules/core-js/modules/es.symbol.description.js"() {
      "use strict";
      var $2 = require_export();
      var DESCRIPTORS = require_descriptors();
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this();
      var hasOwn = require_has_own_property();
      var isCallable = require_is_callable();
      var isPrototypeOf = require_object_is_prototype_of();
      var toString = require_to_string();
      var defineProperty = require_object_define_property().f;
      var copyConstructorProperties = require_copy_constructor_properties();
      var NativeSymbol = global2.Symbol;
      var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;
      if (DESCRIPTORS && isCallable(NativeSymbol) && (!("description" in SymbolPrototype) || NativeSymbol().description !== void 0)) {
        EmptyStringDescriptionStore = {};
        SymbolWrapper = function Symbol2() {
          var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : toString(arguments[0]);
          var result = isPrototypeOf(SymbolPrototype, this) ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
          if (description === "")
            EmptyStringDescriptionStore[result] = true;
          return result;
        };
        copyConstructorProperties(SymbolWrapper, NativeSymbol);
        SymbolWrapper.prototype = SymbolPrototype;
        SymbolPrototype.constructor = SymbolWrapper;
        NATIVE_SYMBOL = String(NativeSymbol("test")) == "Symbol(test)";
        symbolToString = uncurryThis(SymbolPrototype.toString);
        symbolValueOf = uncurryThis(SymbolPrototype.valueOf);
        regexp = /^Symbol\((.*)\)[^)]+$/;
        replace = uncurryThis("".replace);
        stringSlice = uncurryThis("".slice);
        defineProperty(SymbolPrototype, "description", {
          configurable: true,
          get: function description() {
            var symbol = symbolValueOf(this);
            var string = symbolToString(symbol);
            if (hasOwn(EmptyStringDescriptionStore, symbol))
              return "";
            var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, "$1");
            return desc === "" ? void 0 : desc;
          }
        });
        $2({ global: true, forced: true }, {
          Symbol: SymbolWrapper
        });
      }
      var EmptyStringDescriptionStore;
      var SymbolWrapper;
      var NATIVE_SYMBOL;
      var symbolToString;
      var symbolValueOf;
      var regexp;
      var replace;
      var stringSlice;
    }
  });

  // node_modules/core-js/modules/es.symbol.async-iterator.js
  var require_es_symbol_async_iterator = __commonJS({
    "node_modules/core-js/modules/es.symbol.async-iterator.js"() {
      var defineWellKnownSymbol = require_define_well_known_symbol();
      defineWellKnownSymbol("asyncIterator");
    }
  });

  // node_modules/core-js/modules/es.symbol.has-instance.js
  var require_es_symbol_has_instance = __commonJS({
    "node_modules/core-js/modules/es.symbol.has-instance.js"() {
      var defineWellKnownSymbol = require_define_well_known_symbol();
      defineWellKnownSymbol("hasInstance");
    }
  });

  // node_modules/core-js/modules/es.symbol.is-concat-spreadable.js
  var require_es_symbol_is_concat_spreadable = __commonJS({
    "node_modules/core-js/modules/es.symbol.is-concat-spreadable.js"() {
      var defineWellKnownSymbol = require_define_well_known_symbol();
      defineWellKnownSymbol("isConcatSpreadable");
    }
  });

  // node_modules/core-js/modules/es.symbol.iterator.js
  var require_es_symbol_iterator = __commonJS({
    "node_modules/core-js/modules/es.symbol.iterator.js"() {
      var defineWellKnownSymbol = require_define_well_known_symbol();
      defineWellKnownSymbol("iterator");
    }
  });

  // node_modules/core-js/modules/es.symbol.match.js
  var require_es_symbol_match = __commonJS({
    "node_modules/core-js/modules/es.symbol.match.js"() {
      var defineWellKnownSymbol = require_define_well_known_symbol();
      defineWellKnownSymbol("match");
    }
  });

  // node_modules/core-js/modules/es.symbol.match-all.js
  var require_es_symbol_match_all = __commonJS({
    "node_modules/core-js/modules/es.symbol.match-all.js"() {
      var defineWellKnownSymbol = require_define_well_known_symbol();
      defineWellKnownSymbol("matchAll");
    }
  });

  // node_modules/core-js/modules/es.symbol.replace.js
  var require_es_symbol_replace = __commonJS({
    "node_modules/core-js/modules/es.symbol.replace.js"() {
      var defineWellKnownSymbol = require_define_well_known_symbol();
      defineWellKnownSymbol("replace");
    }
  });

  // node_modules/core-js/modules/es.symbol.search.js
  var require_es_symbol_search = __commonJS({
    "node_modules/core-js/modules/es.symbol.search.js"() {
      var defineWellKnownSymbol = require_define_well_known_symbol();
      defineWellKnownSymbol("search");
    }
  });

  // node_modules/core-js/modules/es.symbol.species.js
  var require_es_symbol_species = __commonJS({
    "node_modules/core-js/modules/es.symbol.species.js"() {
      var defineWellKnownSymbol = require_define_well_known_symbol();
      defineWellKnownSymbol("species");
    }
  });

  // node_modules/core-js/modules/es.symbol.split.js
  var require_es_symbol_split = __commonJS({
    "node_modules/core-js/modules/es.symbol.split.js"() {
      var defineWellKnownSymbol = require_define_well_known_symbol();
      defineWellKnownSymbol("split");
    }
  });

  // node_modules/core-js/modules/es.symbol.to-primitive.js
  var require_es_symbol_to_primitive = __commonJS({
    "node_modules/core-js/modules/es.symbol.to-primitive.js"() {
      var defineWellKnownSymbol = require_define_well_known_symbol();
      defineWellKnownSymbol("toPrimitive");
    }
  });

  // node_modules/core-js/modules/es.symbol.to-string-tag.js
  var require_es_symbol_to_string_tag = __commonJS({
    "node_modules/core-js/modules/es.symbol.to-string-tag.js"() {
      var defineWellKnownSymbol = require_define_well_known_symbol();
      defineWellKnownSymbol("toStringTag");
    }
  });

  // node_modules/core-js/modules/es.symbol.unscopables.js
  var require_es_symbol_unscopables = __commonJS({
    "node_modules/core-js/modules/es.symbol.unscopables.js"() {
      var defineWellKnownSymbol = require_define_well_known_symbol();
      defineWellKnownSymbol("unscopables");
    }
  });

  // node_modules/core-js/internals/a-possible-prototype.js
  var require_a_possible_prototype = __commonJS({
    "node_modules/core-js/internals/a-possible-prototype.js"(exports, module) {
      var global2 = require_global();
      var isCallable = require_is_callable();
      var String2 = global2.String;
      var TypeError2 = global2.TypeError;
      module.exports = function(argument) {
        if (typeof argument == "object" || isCallable(argument))
          return argument;
        throw TypeError2("Can't set " + String2(argument) + " as a prototype");
      };
    }
  });

  // node_modules/core-js/internals/object-set-prototype-of.js
  var require_object_set_prototype_of = __commonJS({
    "node_modules/core-js/internals/object-set-prototype-of.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      var anObject = require_an_object();
      var aPossiblePrototype = require_a_possible_prototype();
      module.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var CORRECT_SETTER = false;
        var test = {};
        var setter;
        try {
          setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set);
          setter(test, []);
          CORRECT_SETTER = test instanceof Array;
        } catch (error2) {
        }
        return function setPrototypeOf(O, proto) {
          anObject(O);
          aPossiblePrototype(proto);
          if (CORRECT_SETTER)
            setter(O, proto);
          else
            O.__proto__ = proto;
          return O;
        };
      }() : void 0);
    }
  });

  // node_modules/core-js/internals/inherit-if-required.js
  var require_inherit_if_required = __commonJS({
    "node_modules/core-js/internals/inherit-if-required.js"(exports, module) {
      var isCallable = require_is_callable();
      var isObject3 = require_is_object();
      var setPrototypeOf = require_object_set_prototype_of();
      module.exports = function($this, dummy, Wrapper) {
        var NewTarget, NewTargetPrototype;
        if (setPrototypeOf && isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject3(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype)
          setPrototypeOf($this, NewTargetPrototype);
        return $this;
      };
    }
  });

  // node_modules/core-js/internals/normalize-string-argument.js
  var require_normalize_string_argument = __commonJS({
    "node_modules/core-js/internals/normalize-string-argument.js"(exports, module) {
      var toString = require_to_string();
      module.exports = function(argument, $default) {
        return argument === void 0 ? arguments.length < 2 ? "" : $default : toString(argument);
      };
    }
  });

  // node_modules/core-js/internals/install-error-cause.js
  var require_install_error_cause = __commonJS({
    "node_modules/core-js/internals/install-error-cause.js"(exports, module) {
      var isObject3 = require_is_object();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      module.exports = function(O, options) {
        if (isObject3(options) && "cause" in options) {
          createNonEnumerableProperty(O, "cause", options.cause);
        }
      };
    }
  });

  // node_modules/core-js/internals/clear-error-stack.js
  var require_clear_error_stack = __commonJS({
    "node_modules/core-js/internals/clear-error-stack.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      var replace = uncurryThis("".replace);
      var TEST = function(arg) {
        return String(Error(arg).stack);
      }("zxcasd");
      var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
      var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
      module.exports = function(stack, dropEntries) {
        if (IS_V8_OR_CHAKRA_STACK && typeof stack == "string") {
          while (dropEntries--)
            stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, "");
        }
        return stack;
      };
    }
  });

  // node_modules/core-js/internals/error-stack-installable.js
  var require_error_stack_installable = __commonJS({
    "node_modules/core-js/internals/error-stack-installable.js"(exports, module) {
      var fails = require_fails();
      var createPropertyDescriptor = require_create_property_descriptor();
      module.exports = !fails(function() {
        var error2 = Error("a");
        if (!("stack" in error2))
          return true;
        Object.defineProperty(error2, "stack", createPropertyDescriptor(1, 7));
        return error2.stack !== 7;
      });
    }
  });

  // node_modules/core-js/internals/wrap-error-constructor-with-cause.js
  var require_wrap_error_constructor_with_cause = __commonJS({
    "node_modules/core-js/internals/wrap-error-constructor-with-cause.js"(exports, module) {
      "use strict";
      var getBuiltIn = require_get_built_in();
      var hasOwn = require_has_own_property();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var isPrototypeOf = require_object_is_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var copyConstructorProperties = require_copy_constructor_properties();
      var inheritIfRequired = require_inherit_if_required();
      var normalizeStringArgument = require_normalize_string_argument();
      var installErrorCause = require_install_error_cause();
      var clearErrorStack = require_clear_error_stack();
      var ERROR_STACK_INSTALLABLE = require_error_stack_installable();
      var IS_PURE = require_is_pure();
      module.exports = function(FULL_NAME, wrapper, FORCED, IS_AGGREGATE_ERROR) {
        var OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;
        var path = FULL_NAME.split(".");
        var ERROR_NAME = path[path.length - 1];
        var OriginalError = getBuiltIn.apply(null, path);
        if (!OriginalError)
          return;
        var OriginalErrorPrototype = OriginalError.prototype;
        if (!IS_PURE && hasOwn(OriginalErrorPrototype, "cause"))
          delete OriginalErrorPrototype.cause;
        if (!FORCED)
          return OriginalError;
        var BaseError = getBuiltIn("Error");
        var WrappedError = wrapper(function(a2, b2) {
          var message = normalizeStringArgument(IS_AGGREGATE_ERROR ? b2 : a2, void 0);
          var result = IS_AGGREGATE_ERROR ? new OriginalError(a2) : new OriginalError();
          if (message !== void 0)
            createNonEnumerableProperty(result, "message", message);
          if (ERROR_STACK_INSTALLABLE)
            createNonEnumerableProperty(result, "stack", clearErrorStack(result.stack, 2));
          if (this && isPrototypeOf(OriginalErrorPrototype, this))
            inheritIfRequired(result, this, WrappedError);
          if (arguments.length > OPTIONS_POSITION)
            installErrorCause(result, arguments[OPTIONS_POSITION]);
          return result;
        });
        WrappedError.prototype = OriginalErrorPrototype;
        if (ERROR_NAME !== "Error") {
          if (setPrototypeOf)
            setPrototypeOf(WrappedError, BaseError);
          else
            copyConstructorProperties(WrappedError, BaseError, { name: true });
        }
        copyConstructorProperties(WrappedError, OriginalError);
        if (!IS_PURE)
          try {
            if (OriginalErrorPrototype.name !== ERROR_NAME) {
              createNonEnumerableProperty(OriginalErrorPrototype, "name", ERROR_NAME);
            }
            OriginalErrorPrototype.constructor = WrappedError;
          } catch (error2) {
          }
        return WrappedError;
      };
    }
  });

  // node_modules/core-js/modules/es.error.cause.js
  var require_es_error_cause = __commonJS({
    "node_modules/core-js/modules/es.error.cause.js"() {
      var $2 = require_export();
      var global2 = require_global();
      var apply = require_function_apply();
      var wrapErrorConstructorWithCause = require_wrap_error_constructor_with_cause();
      var WEB_ASSEMBLY = "WebAssembly";
      var WebAssembly = global2[WEB_ASSEMBLY];
      var FORCED = Error("e", { cause: 7 }).cause !== 7;
      var exportGlobalErrorCauseWrapper = function(ERROR_NAME, wrapper) {
        var O = {};
        O[ERROR_NAME] = wrapErrorConstructorWithCause(ERROR_NAME, wrapper, FORCED);
        $2({ global: true, forced: FORCED }, O);
      };
      var exportWebAssemblyErrorCauseWrapper = function(ERROR_NAME, wrapper) {
        if (WebAssembly && WebAssembly[ERROR_NAME]) {
          var O = {};
          O[ERROR_NAME] = wrapErrorConstructorWithCause(WEB_ASSEMBLY + "." + ERROR_NAME, wrapper, FORCED);
          $2({ target: WEB_ASSEMBLY, stat: true, forced: FORCED }, O);
        }
      };
      exportGlobalErrorCauseWrapper("Error", function(init) {
        return function Error2(message) {
          return apply(init, this, arguments);
        };
      });
      exportGlobalErrorCauseWrapper("EvalError", function(init) {
        return function EvalError(message) {
          return apply(init, this, arguments);
        };
      });
      exportGlobalErrorCauseWrapper("RangeError", function(init) {
        return function RangeError2(message) {
          return apply(init, this, arguments);
        };
      });
      exportGlobalErrorCauseWrapper("ReferenceError", function(init) {
        return function ReferenceError2(message) {
          return apply(init, this, arguments);
        };
      });
      exportGlobalErrorCauseWrapper("SyntaxError", function(init) {
        return function SyntaxError2(message) {
          return apply(init, this, arguments);
        };
      });
      exportGlobalErrorCauseWrapper("TypeError", function(init) {
        return function TypeError2(message) {
          return apply(init, this, arguments);
        };
      });
      exportGlobalErrorCauseWrapper("URIError", function(init) {
        return function URIError(message) {
          return apply(init, this, arguments);
        };
      });
      exportWebAssemblyErrorCauseWrapper("CompileError", function(init) {
        return function CompileError(message) {
          return apply(init, this, arguments);
        };
      });
      exportWebAssemblyErrorCauseWrapper("LinkError", function(init) {
        return function LinkError(message) {
          return apply(init, this, arguments);
        };
      });
      exportWebAssemblyErrorCauseWrapper("RuntimeError", function(init) {
        return function RuntimeError(message) {
          return apply(init, this, arguments);
        };
      });
    }
  });

  // node_modules/core-js/internals/error-to-string.js
  var require_error_to_string = __commonJS({
    "node_modules/core-js/internals/error-to-string.js"(exports, module) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var fails = require_fails();
      var anObject = require_an_object();
      var create = require_object_create();
      var normalizeStringArgument = require_normalize_string_argument();
      var nativeErrorToString = Error.prototype.toString;
      var INCORRECT_TO_STRING = fails(function() {
        if (DESCRIPTORS) {
          var object = create(Object.defineProperty({}, "name", { get: function() {
            return this === object;
          } }));
          if (nativeErrorToString.call(object) !== "true")
            return true;
        }
        return nativeErrorToString.call({ message: 1, name: 2 }) !== "2: 1" || nativeErrorToString.call({}) !== "Error";
      });
      module.exports = INCORRECT_TO_STRING ? function toString() {
        var O = anObject(this);
        var name = normalizeStringArgument(O.name, "Error");
        var message = normalizeStringArgument(O.message);
        return !name ? message : !message ? name : name + ": " + message;
      } : nativeErrorToString;
    }
  });

  // node_modules/core-js/modules/es.error.to-string.js
  var require_es_error_to_string = __commonJS({
    "node_modules/core-js/modules/es.error.to-string.js"() {
      var redefine = require_redefine();
      var errorToString = require_error_to_string();
      var ErrorPrototype = Error.prototype;
      if (ErrorPrototype.toString !== errorToString) {
        redefine(ErrorPrototype, "toString", errorToString);
      }
    }
  });

  // node_modules/core-js/internals/correct-prototype-getter.js
  var require_correct_prototype_getter = __commonJS({
    "node_modules/core-js/internals/correct-prototype-getter.js"(exports, module) {
      var fails = require_fails();
      module.exports = !fails(function() {
        function F() {
        }
        F.prototype.constructor = null;
        return Object.getPrototypeOf(new F()) !== F.prototype;
      });
    }
  });

  // node_modules/core-js/internals/object-get-prototype-of.js
  var require_object_get_prototype_of = __commonJS({
    "node_modules/core-js/internals/object-get-prototype-of.js"(exports, module) {
      var global2 = require_global();
      var hasOwn = require_has_own_property();
      var isCallable = require_is_callable();
      var toObject = require_to_object();
      var sharedKey = require_shared_key();
      var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
      var IE_PROTO = sharedKey("IE_PROTO");
      var Object2 = global2.Object;
      var ObjectPrototype = Object2.prototype;
      module.exports = CORRECT_PROTOTYPE_GETTER ? Object2.getPrototypeOf : function(O) {
        var object = toObject(O);
        if (hasOwn(object, IE_PROTO))
          return object[IE_PROTO];
        var constructor = object.constructor;
        if (isCallable(constructor) && object instanceof constructor) {
          return constructor.prototype;
        }
        return object instanceof Object2 ? ObjectPrototype : null;
      };
    }
  });

  // node_modules/core-js/internals/iterators.js
  var require_iterators = __commonJS({
    "node_modules/core-js/internals/iterators.js"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/core-js/internals/is-array-iterator-method.js
  var require_is_array_iterator_method = __commonJS({
    "node_modules/core-js/internals/is-array-iterator-method.js"(exports, module) {
      var wellKnownSymbol = require_well_known_symbol();
      var Iterators = require_iterators();
      var ITERATOR = wellKnownSymbol("iterator");
      var ArrayPrototype = Array.prototype;
      module.exports = function(it) {
        return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
      };
    }
  });

  // node_modules/core-js/internals/get-iterator-method.js
  var require_get_iterator_method = __commonJS({
    "node_modules/core-js/internals/get-iterator-method.js"(exports, module) {
      var classof = require_classof();
      var getMethod = require_get_method();
      var Iterators = require_iterators();
      var wellKnownSymbol = require_well_known_symbol();
      var ITERATOR = wellKnownSymbol("iterator");
      module.exports = function(it) {
        if (it != void 0)
          return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
      };
    }
  });

  // node_modules/core-js/internals/get-iterator.js
  var require_get_iterator = __commonJS({
    "node_modules/core-js/internals/get-iterator.js"(exports, module) {
      var global2 = require_global();
      var call = require_function_call();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var tryToString = require_try_to_string();
      var getIteratorMethod = require_get_iterator_method();
      var TypeError2 = global2.TypeError;
      module.exports = function(argument, usingIterator) {
        var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
        if (aCallable(iteratorMethod))
          return anObject(call(iteratorMethod, argument));
        throw TypeError2(tryToString(argument) + " is not iterable");
      };
    }
  });

  // node_modules/core-js/internals/iterator-close.js
  var require_iterator_close = __commonJS({
    "node_modules/core-js/internals/iterator-close.js"(exports, module) {
      var call = require_function_call();
      var anObject = require_an_object();
      var getMethod = require_get_method();
      module.exports = function(iterator, kind, value) {
        var innerResult, innerError;
        anObject(iterator);
        try {
          innerResult = getMethod(iterator, "return");
          if (!innerResult) {
            if (kind === "throw")
              throw value;
            return value;
          }
          innerResult = call(innerResult, iterator);
        } catch (error2) {
          innerError = true;
          innerResult = error2;
        }
        if (kind === "throw")
          throw value;
        if (innerError)
          throw innerResult;
        anObject(innerResult);
        return value;
      };
    }
  });

  // node_modules/core-js/internals/iterate.js
  var require_iterate = __commonJS({
    "node_modules/core-js/internals/iterate.js"(exports, module) {
      var global2 = require_global();
      var bind3 = require_function_bind_context();
      var call = require_function_call();
      var anObject = require_an_object();
      var tryToString = require_try_to_string();
      var isArrayIteratorMethod = require_is_array_iterator_method();
      var lengthOfArrayLike = require_length_of_array_like();
      var isPrototypeOf = require_object_is_prototype_of();
      var getIterator = require_get_iterator();
      var getIteratorMethod = require_get_iterator_method();
      var iteratorClose = require_iterator_close();
      var TypeError2 = global2.TypeError;
      var Result = function(stopped, result) {
        this.stopped = stopped;
        this.result = result;
      };
      var ResultPrototype = Result.prototype;
      module.exports = function(iterable, unboundFunction, options) {
        var that = options && options.that;
        var AS_ENTRIES = !!(options && options.AS_ENTRIES);
        var IS_ITERATOR = !!(options && options.IS_ITERATOR);
        var INTERRUPTED = !!(options && options.INTERRUPTED);
        var fn2 = bind3(unboundFunction, that);
        var iterator, iterFn, index, length, result, next, step;
        var stop = function(condition) {
          if (iterator)
            iteratorClose(iterator, "normal", condition);
          return new Result(true, condition);
        };
        var callFn = function(value) {
          if (AS_ENTRIES) {
            anObject(value);
            return INTERRUPTED ? fn2(value[0], value[1], stop) : fn2(value[0], value[1]);
          }
          return INTERRUPTED ? fn2(value, stop) : fn2(value);
        };
        if (IS_ITERATOR) {
          iterator = iterable;
        } else {
          iterFn = getIteratorMethod(iterable);
          if (!iterFn)
            throw TypeError2(tryToString(iterable) + " is not iterable");
          if (isArrayIteratorMethod(iterFn)) {
            for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
              result = callFn(iterable[index]);
              if (result && isPrototypeOf(ResultPrototype, result))
                return result;
            }
            return new Result(false);
          }
          iterator = getIterator(iterable, iterFn);
        }
        next = iterator.next;
        while (!(step = call(next, iterator)).done) {
          try {
            result = callFn(step.value);
          } catch (error2) {
            iteratorClose(iterator, "throw", error2);
          }
          if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result))
            return result;
        }
        return new Result(false);
      };
    }
  });

  // node_modules/core-js/modules/es.aggregate-error.js
  var require_es_aggregate_error = __commonJS({
    "node_modules/core-js/modules/es.aggregate-error.js"() {
      "use strict";
      var $2 = require_export();
      var global2 = require_global();
      var isPrototypeOf = require_object_is_prototype_of();
      var getPrototypeOf = require_object_get_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var copyConstructorProperties = require_copy_constructor_properties();
      var create = require_object_create();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var createPropertyDescriptor = require_create_property_descriptor();
      var clearErrorStack = require_clear_error_stack();
      var installErrorCause = require_install_error_cause();
      var iterate = require_iterate();
      var normalizeStringArgument = require_normalize_string_argument();
      var wellKnownSymbol = require_well_known_symbol();
      var ERROR_STACK_INSTALLABLE = require_error_stack_installable();
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var Error2 = global2.Error;
      var push = [].push;
      var $AggregateError = function AggregateError(errors, message) {
        var options = arguments.length > 2 ? arguments[2] : void 0;
        var isInstance = isPrototypeOf(AggregateErrorPrototype, this);
        var that;
        if (setPrototypeOf) {
          that = setPrototypeOf(new Error2(), isInstance ? getPrototypeOf(this) : AggregateErrorPrototype);
        } else {
          that = isInstance ? this : create(AggregateErrorPrototype);
          createNonEnumerableProperty(that, TO_STRING_TAG, "Error");
        }
        if (message !== void 0)
          createNonEnumerableProperty(that, "message", normalizeStringArgument(message));
        if (ERROR_STACK_INSTALLABLE)
          createNonEnumerableProperty(that, "stack", clearErrorStack(that.stack, 1));
        installErrorCause(that, options);
        var errorsArray = [];
        iterate(errors, push, { that: errorsArray });
        createNonEnumerableProperty(that, "errors", errorsArray);
        return that;
      };
      if (setPrototypeOf)
        setPrototypeOf($AggregateError, Error2);
      else
        copyConstructorProperties($AggregateError, Error2, { name: true });
      var AggregateErrorPrototype = $AggregateError.prototype = create(Error2.prototype, {
        constructor: createPropertyDescriptor(1, $AggregateError),
        message: createPropertyDescriptor(1, ""),
        name: createPropertyDescriptor(1, "AggregateError")
      });
      $2({ global: true }, {
        AggregateError: $AggregateError
      });
    }
  });

  // node_modules/core-js/modules/es.aggregate-error.cause.js
  var require_es_aggregate_error_cause = __commonJS({
    "node_modules/core-js/modules/es.aggregate-error.cause.js"() {
      var $2 = require_export();
      var getBuiltIn = require_get_built_in();
      var apply = require_function_apply();
      var fails = require_fails();
      var wrapErrorConstructorWithCause = require_wrap_error_constructor_with_cause();
      var AGGREGATE_ERROR = "AggregateError";
      var $AggregateError = getBuiltIn(AGGREGATE_ERROR);
      var FORCED = !fails(function() {
        return $AggregateError([1]).errors[0] !== 1;
      }) && fails(function() {
        return $AggregateError([1], AGGREGATE_ERROR, { cause: 7 }).cause !== 7;
      });
      $2({ global: true, forced: FORCED }, {
        AggregateError: wrapErrorConstructorWithCause(AGGREGATE_ERROR, function(init) {
          return function AggregateError(errors, message) {
            return apply(init, this, arguments);
          };
        }, FORCED, true)
      });
    }
  });

  // node_modules/core-js/internals/add-to-unscopables.js
  var require_add_to_unscopables = __commonJS({
    "node_modules/core-js/internals/add-to-unscopables.js"(exports, module) {
      var wellKnownSymbol = require_well_known_symbol();
      var create = require_object_create();
      var definePropertyModule = require_object_define_property();
      var UNSCOPABLES = wellKnownSymbol("unscopables");
      var ArrayPrototype = Array.prototype;
      if (ArrayPrototype[UNSCOPABLES] == void 0) {
        definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
          configurable: true,
          value: create(null)
        });
      }
      module.exports = function(key) {
        ArrayPrototype[UNSCOPABLES][key] = true;
      };
    }
  });

  // node_modules/core-js/modules/es.array.at.js
  var require_es_array_at = __commonJS({
    "node_modules/core-js/modules/es.array.at.js"() {
      "use strict";
      var $2 = require_export();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var addToUnscopables = require_add_to_unscopables();
      $2({ target: "Array", proto: true }, {
        at: function at(index) {
          var O = toObject(this);
          var len = lengthOfArrayLike(O);
          var relativeIndex = toIntegerOrInfinity(index);
          var k2 = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
          return k2 < 0 || k2 >= len ? void 0 : O[k2];
        }
      });
      addToUnscopables("at");
    }
  });

  // node_modules/core-js/internals/array-method-has-species-support.js
  var require_array_method_has_species_support = __commonJS({
    "node_modules/core-js/internals/array-method-has-species-support.js"(exports, module) {
      var fails = require_fails();
      var wellKnownSymbol = require_well_known_symbol();
      var V8_VERSION = require_engine_v8_version();
      var SPECIES = wellKnownSymbol("species");
      module.exports = function(METHOD_NAME) {
        return V8_VERSION >= 51 || !fails(function() {
          var array = [];
          var constructor = array.constructor = {};
          constructor[SPECIES] = function() {
            return { foo: 1 };
          };
          return array[METHOD_NAME](Boolean).foo !== 1;
        });
      };
    }
  });

  // node_modules/core-js/modules/es.array.concat.js
  var require_es_array_concat = __commonJS({
    "node_modules/core-js/modules/es.array.concat.js"() {
      "use strict";
      var $2 = require_export();
      var global2 = require_global();
      var fails = require_fails();
      var isArray = require_is_array();
      var isObject3 = require_is_object();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var createProperty = require_create_property();
      var arraySpeciesCreate = require_array_species_create();
      var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
      var wellKnownSymbol = require_well_known_symbol();
      var V8_VERSION = require_engine_v8_version();
      var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
      var MAX_SAFE_INTEGER = 9007199254740991;
      var MAXIMUM_ALLOWED_INDEX_EXCEEDED = "Maximum allowed index exceeded";
      var TypeError2 = global2.TypeError;
      var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
        var array = [];
        array[IS_CONCAT_SPREADABLE] = false;
        return array.concat()[0] !== array;
      });
      var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("concat");
      var isConcatSpreadable = function(O) {
        if (!isObject3(O))
          return false;
        var spreadable = O[IS_CONCAT_SPREADABLE];
        return spreadable !== void 0 ? !!spreadable : isArray(O);
      };
      var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
      $2({ target: "Array", proto: true, forced: FORCED }, {
        concat: function concat(arg) {
          var O = toObject(this);
          var A2 = arraySpeciesCreate(O, 0);
          var n2 = 0;
          var i2, k2, length, len, E;
          for (i2 = -1, length = arguments.length; i2 < length; i2++) {
            E = i2 === -1 ? O : arguments[i2];
            if (isConcatSpreadable(E)) {
              len = lengthOfArrayLike(E);
              if (n2 + len > MAX_SAFE_INTEGER)
                throw TypeError2(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
              for (k2 = 0; k2 < len; k2++, n2++)
                if (k2 in E)
                  createProperty(A2, n2, E[k2]);
            } else {
              if (n2 >= MAX_SAFE_INTEGER)
                throw TypeError2(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
              createProperty(A2, n2++, E);
            }
          }
          A2.length = n2;
          return A2;
        }
      });
    }
  });

  // node_modules/core-js/internals/array-copy-within.js
  var require_array_copy_within = __commonJS({
    "node_modules/core-js/internals/array-copy-within.js"(exports, module) {
      "use strict";
      var toObject = require_to_object();
      var toAbsoluteIndex = require_to_absolute_index();
      var lengthOfArrayLike = require_length_of_array_like();
      var min2 = Math.min;
      module.exports = [].copyWithin || function copyWithin(target, start4) {
        var O = toObject(this);
        var len = lengthOfArrayLike(O);
        var to = toAbsoluteIndex(target, len);
        var from = toAbsoluteIndex(start4, len);
        var end2 = arguments.length > 2 ? arguments[2] : void 0;
        var count = min2((end2 === void 0 ? len : toAbsoluteIndex(end2, len)) - from, len - to);
        var inc = 1;
        if (from < to && to < from + count) {
          inc = -1;
          from += count - 1;
          to += count - 1;
        }
        while (count-- > 0) {
          if (from in O)
            O[to] = O[from];
          else
            delete O[to];
          to += inc;
          from += inc;
        }
        return O;
      };
    }
  });

  // node_modules/core-js/modules/es.array.copy-within.js
  var require_es_array_copy_within = __commonJS({
    "node_modules/core-js/modules/es.array.copy-within.js"() {
      var $2 = require_export();
      var copyWithin = require_array_copy_within();
      var addToUnscopables = require_add_to_unscopables();
      $2({ target: "Array", proto: true }, {
        copyWithin
      });
      addToUnscopables("copyWithin");
    }
  });

  // node_modules/core-js/internals/array-method-is-strict.js
  var require_array_method_is_strict = __commonJS({
    "node_modules/core-js/internals/array-method-is-strict.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      module.exports = function(METHOD_NAME, argument) {
        var method = [][METHOD_NAME];
        return !!method && fails(function() {
          method.call(null, argument || function() {
            throw 1;
          }, 1);
        });
      };
    }
  });

  // node_modules/core-js/modules/es.array.every.js
  var require_es_array_every = __commonJS({
    "node_modules/core-js/modules/es.array.every.js"() {
      "use strict";
      var $2 = require_export();
      var $every = require_array_iteration().every;
      var arrayMethodIsStrict = require_array_method_is_strict();
      var STRICT_METHOD = arrayMethodIsStrict("every");
      $2({ target: "Array", proto: true, forced: !STRICT_METHOD }, {
        every: function every(callbackfn) {
          return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/internals/array-fill.js
  var require_array_fill = __commonJS({
    "node_modules/core-js/internals/array-fill.js"(exports, module) {
      "use strict";
      var toObject = require_to_object();
      var toAbsoluteIndex = require_to_absolute_index();
      var lengthOfArrayLike = require_length_of_array_like();
      module.exports = function fill(value) {
        var O = toObject(this);
        var length = lengthOfArrayLike(O);
        var argumentsLength = arguments.length;
        var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : void 0, length);
        var end2 = argumentsLength > 2 ? arguments[2] : void 0;
        var endPos = end2 === void 0 ? length : toAbsoluteIndex(end2, length);
        while (endPos > index)
          O[index++] = value;
        return O;
      };
    }
  });

  // node_modules/core-js/modules/es.array.fill.js
  var require_es_array_fill = __commonJS({
    "node_modules/core-js/modules/es.array.fill.js"() {
      var $2 = require_export();
      var fill = require_array_fill();
      var addToUnscopables = require_add_to_unscopables();
      $2({ target: "Array", proto: true }, {
        fill
      });
      addToUnscopables("fill");
    }
  });

  // node_modules/core-js/modules/es.array.filter.js
  var require_es_array_filter = __commonJS({
    "node_modules/core-js/modules/es.array.filter.js"() {
      "use strict";
      var $2 = require_export();
      var $filter = require_array_iteration().filter;
      var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
      var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
      $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
        filter: function filter2(callbackfn) {
          return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.find.js
  var require_es_array_find = __commonJS({
    "node_modules/core-js/modules/es.array.find.js"() {
      "use strict";
      var $2 = require_export();
      var $find = require_array_iteration().find;
      var addToUnscopables = require_add_to_unscopables();
      var FIND = "find";
      var SKIPS_HOLES = true;
      if (FIND in [])
        Array(1)[FIND](function() {
          SKIPS_HOLES = false;
        });
      $2({ target: "Array", proto: true, forced: SKIPS_HOLES }, {
        find: function find(callbackfn) {
          return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
      addToUnscopables(FIND);
    }
  });

  // node_modules/core-js/modules/es.array.find-index.js
  var require_es_array_find_index = __commonJS({
    "node_modules/core-js/modules/es.array.find-index.js"() {
      "use strict";
      var $2 = require_export();
      var $findIndex = require_array_iteration().findIndex;
      var addToUnscopables = require_add_to_unscopables();
      var FIND_INDEX = "findIndex";
      var SKIPS_HOLES = true;
      if (FIND_INDEX in [])
        Array(1)[FIND_INDEX](function() {
          SKIPS_HOLES = false;
        });
      $2({ target: "Array", proto: true, forced: SKIPS_HOLES }, {
        findIndex: function findIndex(callbackfn) {
          return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
      addToUnscopables(FIND_INDEX);
    }
  });

  // node_modules/core-js/internals/flatten-into-array.js
  var require_flatten_into_array = __commonJS({
    "node_modules/core-js/internals/flatten-into-array.js"(exports, module) {
      "use strict";
      var global2 = require_global();
      var isArray = require_is_array();
      var lengthOfArrayLike = require_length_of_array_like();
      var bind3 = require_function_bind_context();
      var TypeError2 = global2.TypeError;
      var flattenIntoArray = function(target, original, source, sourceLen, start4, depth, mapper, thisArg) {
        var targetIndex = start4;
        var sourceIndex = 0;
        var mapFn = mapper ? bind3(mapper, thisArg) : false;
        var element, elementLen;
        while (sourceIndex < sourceLen) {
          if (sourceIndex in source) {
            element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
            if (depth > 0 && isArray(element)) {
              elementLen = lengthOfArrayLike(element);
              targetIndex = flattenIntoArray(target, original, element, elementLen, targetIndex, depth - 1) - 1;
            } else {
              if (targetIndex >= 9007199254740991)
                throw TypeError2("Exceed the acceptable array length");
              target[targetIndex] = element;
            }
            targetIndex++;
          }
          sourceIndex++;
        }
        return targetIndex;
      };
      module.exports = flattenIntoArray;
    }
  });

  // node_modules/core-js/modules/es.array.flat.js
  var require_es_array_flat = __commonJS({
    "node_modules/core-js/modules/es.array.flat.js"() {
      "use strict";
      var $2 = require_export();
      var flattenIntoArray = require_flatten_into_array();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var arraySpeciesCreate = require_array_species_create();
      $2({ target: "Array", proto: true }, {
        flat: function flat() {
          var depthArg = arguments.length ? arguments[0] : void 0;
          var O = toObject(this);
          var sourceLen = lengthOfArrayLike(O);
          var A2 = arraySpeciesCreate(O, 0);
          A2.length = flattenIntoArray(A2, O, O, sourceLen, 0, depthArg === void 0 ? 1 : toIntegerOrInfinity(depthArg));
          return A2;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.flat-map.js
  var require_es_array_flat_map = __commonJS({
    "node_modules/core-js/modules/es.array.flat-map.js"() {
      "use strict";
      var $2 = require_export();
      var flattenIntoArray = require_flatten_into_array();
      var aCallable = require_a_callable();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var arraySpeciesCreate = require_array_species_create();
      $2({ target: "Array", proto: true }, {
        flatMap: function flatMap(callbackfn) {
          var O = toObject(this);
          var sourceLen = lengthOfArrayLike(O);
          var A2;
          aCallable(callbackfn);
          A2 = arraySpeciesCreate(O, 0);
          A2.length = flattenIntoArray(A2, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
          return A2;
        }
      });
    }
  });

  // node_modules/core-js/internals/array-for-each.js
  var require_array_for_each = __commonJS({
    "node_modules/core-js/internals/array-for-each.js"(exports, module) {
      "use strict";
      var $forEach = require_array_iteration().forEach;
      var arrayMethodIsStrict = require_array_method_is_strict();
      var STRICT_METHOD = arrayMethodIsStrict("forEach");
      module.exports = !STRICT_METHOD ? function forEach(callbackfn) {
        return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      } : [].forEach;
    }
  });

  // node_modules/core-js/modules/es.array.for-each.js
  var require_es_array_for_each = __commonJS({
    "node_modules/core-js/modules/es.array.for-each.js"() {
      "use strict";
      var $2 = require_export();
      var forEach = require_array_for_each();
      $2({ target: "Array", proto: true, forced: [].forEach != forEach }, {
        forEach
      });
    }
  });

  // node_modules/core-js/internals/call-with-safe-iteration-closing.js
  var require_call_with_safe_iteration_closing = __commonJS({
    "node_modules/core-js/internals/call-with-safe-iteration-closing.js"(exports, module) {
      var anObject = require_an_object();
      var iteratorClose = require_iterator_close();
      module.exports = function(iterator, fn2, value, ENTRIES) {
        try {
          return ENTRIES ? fn2(anObject(value)[0], value[1]) : fn2(value);
        } catch (error2) {
          iteratorClose(iterator, "throw", error2);
        }
      };
    }
  });

  // node_modules/core-js/internals/array-from.js
  var require_array_from = __commonJS({
    "node_modules/core-js/internals/array-from.js"(exports, module) {
      "use strict";
      var global2 = require_global();
      var bind3 = require_function_bind_context();
      var call = require_function_call();
      var toObject = require_to_object();
      var callWithSafeIterationClosing = require_call_with_safe_iteration_closing();
      var isArrayIteratorMethod = require_is_array_iterator_method();
      var isConstructor = require_is_constructor();
      var lengthOfArrayLike = require_length_of_array_like();
      var createProperty = require_create_property();
      var getIterator = require_get_iterator();
      var getIteratorMethod = require_get_iterator_method();
      var Array2 = global2.Array;
      module.exports = function from(arrayLike) {
        var O = toObject(arrayLike);
        var IS_CONSTRUCTOR = isConstructor(this);
        var argumentsLength = arguments.length;
        var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
        var mapping = mapfn !== void 0;
        if (mapping)
          mapfn = bind3(mapfn, argumentsLength > 2 ? arguments[2] : void 0);
        var iteratorMethod = getIteratorMethod(O);
        var index = 0;
        var length, result, step, iterator, next, value;
        if (iteratorMethod && !(this == Array2 && isArrayIteratorMethod(iteratorMethod))) {
          iterator = getIterator(O, iteratorMethod);
          next = iterator.next;
          result = IS_CONSTRUCTOR ? new this() : [];
          for (; !(step = call(next, iterator)).done; index++) {
            value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
            createProperty(result, index, value);
          }
        } else {
          length = lengthOfArrayLike(O);
          result = IS_CONSTRUCTOR ? new this(length) : Array2(length);
          for (; length > index; index++) {
            value = mapping ? mapfn(O[index], index) : O[index];
            createProperty(result, index, value);
          }
        }
        result.length = index;
        return result;
      };
    }
  });

  // node_modules/core-js/internals/check-correctness-of-iteration.js
  var require_check_correctness_of_iteration = __commonJS({
    "node_modules/core-js/internals/check-correctness-of-iteration.js"(exports, module) {
      var wellKnownSymbol = require_well_known_symbol();
      var ITERATOR = wellKnownSymbol("iterator");
      var SAFE_CLOSING = false;
      try {
        called = 0;
        iteratorWithReturn = {
          next: function() {
            return { done: !!called++ };
          },
          "return": function() {
            SAFE_CLOSING = true;
          }
        };
        iteratorWithReturn[ITERATOR] = function() {
          return this;
        };
        Array.from(iteratorWithReturn, function() {
          throw 2;
        });
      } catch (error2) {
      }
      var called;
      var iteratorWithReturn;
      module.exports = function(exec, SKIP_CLOSING) {
        if (!SKIP_CLOSING && !SAFE_CLOSING)
          return false;
        var ITERATION_SUPPORT = false;
        try {
          var object = {};
          object[ITERATOR] = function() {
            return {
              next: function() {
                return { done: ITERATION_SUPPORT = true };
              }
            };
          };
          exec(object);
        } catch (error2) {
        }
        return ITERATION_SUPPORT;
      };
    }
  });

  // node_modules/core-js/modules/es.array.from.js
  var require_es_array_from = __commonJS({
    "node_modules/core-js/modules/es.array.from.js"() {
      var $2 = require_export();
      var from = require_array_from();
      var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
      var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
        Array.from(iterable);
      });
      $2({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
        from
      });
    }
  });

  // node_modules/core-js/modules/es.array.includes.js
  var require_es_array_includes = __commonJS({
    "node_modules/core-js/modules/es.array.includes.js"() {
      "use strict";
      var $2 = require_export();
      var $includes = require_array_includes().includes;
      var addToUnscopables = require_add_to_unscopables();
      $2({ target: "Array", proto: true }, {
        includes: function includes(el) {
          return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
      addToUnscopables("includes");
    }
  });

  // node_modules/core-js/modules/es.array.index-of.js
  var require_es_array_index_of = __commonJS({
    "node_modules/core-js/modules/es.array.index-of.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var $IndexOf = require_array_includes().indexOf;
      var arrayMethodIsStrict = require_array_method_is_strict();
      var un$IndexOf = uncurryThis([].indexOf);
      var NEGATIVE_ZERO = !!un$IndexOf && 1 / un$IndexOf([1], 1, -0) < 0;
      var STRICT_METHOD = arrayMethodIsStrict("indexOf");
      $2({ target: "Array", proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD }, {
        indexOf: function indexOf2(searchElement) {
          var fromIndex = arguments.length > 1 ? arguments[1] : void 0;
          return NEGATIVE_ZERO ? un$IndexOf(this, searchElement, fromIndex) || 0 : $IndexOf(this, searchElement, fromIndex);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.is-array.js
  var require_es_array_is_array = __commonJS({
    "node_modules/core-js/modules/es.array.is-array.js"() {
      var $2 = require_export();
      var isArray = require_is_array();
      $2({ target: "Array", stat: true }, {
        isArray
      });
    }
  });

  // node_modules/core-js/internals/iterators-core.js
  var require_iterators_core = __commonJS({
    "node_modules/core-js/internals/iterators-core.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      var isCallable = require_is_callable();
      var create = require_object_create();
      var getPrototypeOf = require_object_get_prototype_of();
      var redefine = require_redefine();
      var wellKnownSymbol = require_well_known_symbol();
      var IS_PURE = require_is_pure();
      var ITERATOR = wellKnownSymbol("iterator");
      var BUGGY_SAFARI_ITERATORS = false;
      var IteratorPrototype;
      var PrototypeOfArrayIteratorPrototype;
      var arrayIterator;
      if ([].keys) {
        arrayIterator = [].keys();
        if (!("next" in arrayIterator))
          BUGGY_SAFARI_ITERATORS = true;
        else {
          PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
          if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
            IteratorPrototype = PrototypeOfArrayIteratorPrototype;
        }
      }
      var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == void 0 || fails(function() {
        var test = {};
        return IteratorPrototype[ITERATOR].call(test) !== test;
      });
      if (NEW_ITERATOR_PROTOTYPE)
        IteratorPrototype = {};
      else if (IS_PURE)
        IteratorPrototype = create(IteratorPrototype);
      if (!isCallable(IteratorPrototype[ITERATOR])) {
        redefine(IteratorPrototype, ITERATOR, function() {
          return this;
        });
      }
      module.exports = {
        IteratorPrototype,
        BUGGY_SAFARI_ITERATORS
      };
    }
  });

  // node_modules/core-js/internals/create-iterator-constructor.js
  var require_create_iterator_constructor = __commonJS({
    "node_modules/core-js/internals/create-iterator-constructor.js"(exports, module) {
      "use strict";
      var IteratorPrototype = require_iterators_core().IteratorPrototype;
      var create = require_object_create();
      var createPropertyDescriptor = require_create_property_descriptor();
      var setToStringTag = require_set_to_string_tag();
      var Iterators = require_iterators();
      var returnThis = function() {
        return this;
      };
      module.exports = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
        var TO_STRING_TAG = NAME + " Iterator";
        IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
        setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
        Iterators[TO_STRING_TAG] = returnThis;
        return IteratorConstructor;
      };
    }
  });

  // node_modules/core-js/internals/define-iterator.js
  var require_define_iterator = __commonJS({
    "node_modules/core-js/internals/define-iterator.js"(exports, module) {
      "use strict";
      var $2 = require_export();
      var call = require_function_call();
      var IS_PURE = require_is_pure();
      var FunctionName = require_function_name();
      var isCallable = require_is_callable();
      var createIteratorConstructor = require_create_iterator_constructor();
      var getPrototypeOf = require_object_get_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var setToStringTag = require_set_to_string_tag();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var redefine = require_redefine();
      var wellKnownSymbol = require_well_known_symbol();
      var Iterators = require_iterators();
      var IteratorsCore = require_iterators_core();
      var PROPER_FUNCTION_NAME = FunctionName.PROPER;
      var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
      var IteratorPrototype = IteratorsCore.IteratorPrototype;
      var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
      var ITERATOR = wellKnownSymbol("iterator");
      var KEYS = "keys";
      var VALUES = "values";
      var ENTRIES = "entries";
      var returnThis = function() {
        return this;
      };
      module.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
        createIteratorConstructor(IteratorConstructor, NAME, next);
        var getIterationMethod = function(KIND) {
          if (KIND === DEFAULT && defaultIterator)
            return defaultIterator;
          if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
            return IterablePrototype[KIND];
          switch (KIND) {
            case KEYS:
              return function keys() {
                return new IteratorConstructor(this, KIND);
              };
            case VALUES:
              return function values() {
                return new IteratorConstructor(this, KIND);
              };
            case ENTRIES:
              return function entries() {
                return new IteratorConstructor(this, KIND);
              };
          }
          return function() {
            return new IteratorConstructor(this);
          };
        };
        var TO_STRING_TAG = NAME + " Iterator";
        var INCORRECT_VALUES_NAME = false;
        var IterablePrototype = Iterable.prototype;
        var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
        var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
        var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
        var CurrentIteratorPrototype, methods, KEY;
        if (anyNativeIterator) {
          CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
          if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
            if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
              if (setPrototypeOf) {
                setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
              } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
                redefine(CurrentIteratorPrototype, ITERATOR, returnThis);
              }
            }
            setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
            if (IS_PURE)
              Iterators[TO_STRING_TAG] = returnThis;
          }
        }
        if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
          if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
            createNonEnumerableProperty(IterablePrototype, "name", VALUES);
          } else {
            INCORRECT_VALUES_NAME = true;
            defaultIterator = function values() {
              return call(nativeIterator, this);
            };
          }
        }
        if (DEFAULT) {
          methods = {
            values: getIterationMethod(VALUES),
            keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
            entries: getIterationMethod(ENTRIES)
          };
          if (FORCED)
            for (KEY in methods) {
              if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                redefine(IterablePrototype, KEY, methods[KEY]);
              }
            }
          else
            $2({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
        }
        if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
          redefine(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
        }
        Iterators[NAME] = defaultIterator;
        return methods;
      };
    }
  });

  // node_modules/core-js/modules/es.array.iterator.js
  var require_es_array_iterator = __commonJS({
    "node_modules/core-js/modules/es.array.iterator.js"(exports, module) {
      "use strict";
      var toIndexedObject = require_to_indexed_object();
      var addToUnscopables = require_add_to_unscopables();
      var Iterators = require_iterators();
      var InternalStateModule = require_internal_state();
      var defineProperty = require_object_define_property().f;
      var defineIterator = require_define_iterator();
      var IS_PURE = require_is_pure();
      var DESCRIPTORS = require_descriptors();
      var ARRAY_ITERATOR = "Array Iterator";
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
      module.exports = defineIterator(Array, "Array", function(iterated, kind) {
        setInternalState(this, {
          type: ARRAY_ITERATOR,
          target: toIndexedObject(iterated),
          index: 0,
          kind
        });
      }, function() {
        var state = getInternalState(this);
        var target = state.target;
        var kind = state.kind;
        var index = state.index++;
        if (!target || index >= target.length) {
          state.target = void 0;
          return { value: void 0, done: true };
        }
        if (kind == "keys")
          return { value: index, done: false };
        if (kind == "values")
          return { value: target[index], done: false };
        return { value: [index, target[index]], done: false };
      }, "values");
      var values = Iterators.Arguments = Iterators.Array;
      addToUnscopables("keys");
      addToUnscopables("values");
      addToUnscopables("entries");
      if (!IS_PURE && DESCRIPTORS && values.name !== "values")
        try {
          defineProperty(values, "name", { value: "values" });
        } catch (error2) {
        }
    }
  });

  // node_modules/core-js/modules/es.array.join.js
  var require_es_array_join = __commonJS({
    "node_modules/core-js/modules/es.array.join.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var IndexedObject = require_indexed_object();
      var toIndexedObject = require_to_indexed_object();
      var arrayMethodIsStrict = require_array_method_is_strict();
      var un$Join = uncurryThis([].join);
      var ES3_STRINGS = IndexedObject != Object;
      var STRICT_METHOD = arrayMethodIsStrict("join", ",");
      $2({ target: "Array", proto: true, forced: ES3_STRINGS || !STRICT_METHOD }, {
        join: function join(separator) {
          return un$Join(toIndexedObject(this), separator === void 0 ? "," : separator);
        }
      });
    }
  });

  // node_modules/core-js/internals/array-last-index-of.js
  var require_array_last_index_of = __commonJS({
    "node_modules/core-js/internals/array-last-index-of.js"(exports, module) {
      "use strict";
      var apply = require_function_apply();
      var toIndexedObject = require_to_indexed_object();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var lengthOfArrayLike = require_length_of_array_like();
      var arrayMethodIsStrict = require_array_method_is_strict();
      var min2 = Math.min;
      var $lastIndexOf = [].lastIndexOf;
      var NEGATIVE_ZERO = !!$lastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
      var STRICT_METHOD = arrayMethodIsStrict("lastIndexOf");
      var FORCED = NEGATIVE_ZERO || !STRICT_METHOD;
      module.exports = FORCED ? function lastIndexOf(searchElement) {
        if (NEGATIVE_ZERO)
          return apply($lastIndexOf, this, arguments) || 0;
        var O = toIndexedObject(this);
        var length = lengthOfArrayLike(O);
        var index = length - 1;
        if (arguments.length > 1)
          index = min2(index, toIntegerOrInfinity(arguments[1]));
        if (index < 0)
          index = length + index;
        for (; index >= 0; index--)
          if (index in O && O[index] === searchElement)
            return index || 0;
        return -1;
      } : $lastIndexOf;
    }
  });

  // node_modules/core-js/modules/es.array.last-index-of.js
  var require_es_array_last_index_of = __commonJS({
    "node_modules/core-js/modules/es.array.last-index-of.js"() {
      var $2 = require_export();
      var lastIndexOf = require_array_last_index_of();
      $2({ target: "Array", proto: true, forced: lastIndexOf !== [].lastIndexOf }, {
        lastIndexOf
      });
    }
  });

  // node_modules/core-js/modules/es.array.map.js
  var require_es_array_map = __commonJS({
    "node_modules/core-js/modules/es.array.map.js"() {
      "use strict";
      var $2 = require_export();
      var $map = require_array_iteration().map;
      var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
      var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
      $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
        map: function map(callbackfn) {
          return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.of.js
  var require_es_array_of = __commonJS({
    "node_modules/core-js/modules/es.array.of.js"() {
      "use strict";
      var $2 = require_export();
      var global2 = require_global();
      var fails = require_fails();
      var isConstructor = require_is_constructor();
      var createProperty = require_create_property();
      var Array2 = global2.Array;
      var ISNT_GENERIC = fails(function() {
        function F() {
        }
        return !(Array2.of.call(F) instanceof F);
      });
      $2({ target: "Array", stat: true, forced: ISNT_GENERIC }, {
        of: function of() {
          var index = 0;
          var argumentsLength = arguments.length;
          var result = new (isConstructor(this) ? this : Array2)(argumentsLength);
          while (argumentsLength > index)
            createProperty(result, index, arguments[index++]);
          result.length = argumentsLength;
          return result;
        }
      });
    }
  });

  // node_modules/core-js/internals/array-reduce.js
  var require_array_reduce = __commonJS({
    "node_modules/core-js/internals/array-reduce.js"(exports, module) {
      var global2 = require_global();
      var aCallable = require_a_callable();
      var toObject = require_to_object();
      var IndexedObject = require_indexed_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var TypeError2 = global2.TypeError;
      var createMethod = function(IS_RIGHT) {
        return function(that, callbackfn, argumentsLength, memo) {
          aCallable(callbackfn);
          var O = toObject(that);
          var self2 = IndexedObject(O);
          var length = lengthOfArrayLike(O);
          var index = IS_RIGHT ? length - 1 : 0;
          var i2 = IS_RIGHT ? -1 : 1;
          if (argumentsLength < 2)
            while (true) {
              if (index in self2) {
                memo = self2[index];
                index += i2;
                break;
              }
              index += i2;
              if (IS_RIGHT ? index < 0 : length <= index) {
                throw TypeError2("Reduce of empty array with no initial value");
              }
            }
          for (; IS_RIGHT ? index >= 0 : length > index; index += i2)
            if (index in self2) {
              memo = callbackfn(memo, self2[index], index, O);
            }
          return memo;
        };
      };
      module.exports = {
        left: createMethod(false),
        right: createMethod(true)
      };
    }
  });

  // node_modules/core-js/internals/engine-is-node.js
  var require_engine_is_node = __commonJS({
    "node_modules/core-js/internals/engine-is-node.js"(exports, module) {
      var classof = require_classof_raw();
      var global2 = require_global();
      module.exports = classof(global2.process) == "process";
    }
  });

  // node_modules/core-js/modules/es.array.reduce.js
  var require_es_array_reduce = __commonJS({
    "node_modules/core-js/modules/es.array.reduce.js"() {
      "use strict";
      var $2 = require_export();
      var $reduce = require_array_reduce().left;
      var arrayMethodIsStrict = require_array_method_is_strict();
      var CHROME_VERSION = require_engine_v8_version();
      var IS_NODE = require_engine_is_node();
      var STRICT_METHOD = arrayMethodIsStrict("reduce");
      var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
      $2({ target: "Array", proto: true, forced: !STRICT_METHOD || CHROME_BUG }, {
        reduce: function reduce(callbackfn) {
          var length = arguments.length;
          return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.reduce-right.js
  var require_es_array_reduce_right = __commonJS({
    "node_modules/core-js/modules/es.array.reduce-right.js"() {
      "use strict";
      var $2 = require_export();
      var $reduceRight = require_array_reduce().right;
      var arrayMethodIsStrict = require_array_method_is_strict();
      var CHROME_VERSION = require_engine_v8_version();
      var IS_NODE = require_engine_is_node();
      var STRICT_METHOD = arrayMethodIsStrict("reduceRight");
      var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
      $2({ target: "Array", proto: true, forced: !STRICT_METHOD || CHROME_BUG }, {
        reduceRight: function reduceRight(callbackfn) {
          return $reduceRight(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.reverse.js
  var require_es_array_reverse = __commonJS({
    "node_modules/core-js/modules/es.array.reverse.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var isArray = require_is_array();
      var un$Reverse = uncurryThis([].reverse);
      var test = [1, 2];
      $2({ target: "Array", proto: true, forced: String(test) === String(test.reverse()) }, {
        reverse: function reverse() {
          if (isArray(this))
            this.length = this.length;
          return un$Reverse(this);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.slice.js
  var require_es_array_slice = __commonJS({
    "node_modules/core-js/modules/es.array.slice.js"() {
      "use strict";
      var $2 = require_export();
      var global2 = require_global();
      var isArray = require_is_array();
      var isConstructor = require_is_constructor();
      var isObject3 = require_is_object();
      var toAbsoluteIndex = require_to_absolute_index();
      var lengthOfArrayLike = require_length_of_array_like();
      var toIndexedObject = require_to_indexed_object();
      var createProperty = require_create_property();
      var wellKnownSymbol = require_well_known_symbol();
      var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
      var un$Slice = require_array_slice();
      var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("slice");
      var SPECIES = wellKnownSymbol("species");
      var Array2 = global2.Array;
      var max2 = Math.max;
      $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
        slice: function slice(start4, end2) {
          var O = toIndexedObject(this);
          var length = lengthOfArrayLike(O);
          var k2 = toAbsoluteIndex(start4, length);
          var fin = toAbsoluteIndex(end2 === void 0 ? length : end2, length);
          var Constructor, result, n2;
          if (isArray(O)) {
            Constructor = O.constructor;
            if (isConstructor(Constructor) && (Constructor === Array2 || isArray(Constructor.prototype))) {
              Constructor = void 0;
            } else if (isObject3(Constructor)) {
              Constructor = Constructor[SPECIES];
              if (Constructor === null)
                Constructor = void 0;
            }
            if (Constructor === Array2 || Constructor === void 0) {
              return un$Slice(O, k2, fin);
            }
          }
          result = new (Constructor === void 0 ? Array2 : Constructor)(max2(fin - k2, 0));
          for (n2 = 0; k2 < fin; k2++, n2++)
            if (k2 in O)
              createProperty(result, n2, O[k2]);
          result.length = n2;
          return result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.some.js
  var require_es_array_some = __commonJS({
    "node_modules/core-js/modules/es.array.some.js"() {
      "use strict";
      var $2 = require_export();
      var $some = require_array_iteration().some;
      var arrayMethodIsStrict = require_array_method_is_strict();
      var STRICT_METHOD = arrayMethodIsStrict("some");
      $2({ target: "Array", proto: true, forced: !STRICT_METHOD }, {
        some: function some(callbackfn) {
          return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/internals/array-sort.js
  var require_array_sort = __commonJS({
    "node_modules/core-js/internals/array-sort.js"(exports, module) {
      var arraySlice = require_array_slice_simple();
      var floor = Math.floor;
      var mergeSort = function(array, comparefn) {
        var length = array.length;
        var middle = floor(length / 2);
        return length < 8 ? insertionSort(array, comparefn) : merge(array, mergeSort(arraySlice(array, 0, middle), comparefn), mergeSort(arraySlice(array, middle), comparefn), comparefn);
      };
      var insertionSort = function(array, comparefn) {
        var length = array.length;
        var i2 = 1;
        var element, j2;
        while (i2 < length) {
          j2 = i2;
          element = array[i2];
          while (j2 && comparefn(array[j2 - 1], element) > 0) {
            array[j2] = array[--j2];
          }
          if (j2 !== i2++)
            array[j2] = element;
        }
        return array;
      };
      var merge = function(array, left2, right2, comparefn) {
        var llength = left2.length;
        var rlength = right2.length;
        var lindex = 0;
        var rindex = 0;
        while (lindex < llength || rindex < rlength) {
          array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left2[lindex], right2[rindex]) <= 0 ? left2[lindex++] : right2[rindex++] : lindex < llength ? left2[lindex++] : right2[rindex++];
        }
        return array;
      };
      module.exports = mergeSort;
    }
  });

  // node_modules/core-js/internals/engine-ff-version.js
  var require_engine_ff_version = __commonJS({
    "node_modules/core-js/internals/engine-ff-version.js"(exports, module) {
      var userAgent = require_engine_user_agent();
      var firefox = userAgent.match(/firefox\/(\d+)/i);
      module.exports = !!firefox && +firefox[1];
    }
  });

  // node_modules/core-js/internals/engine-is-ie-or-edge.js
  var require_engine_is_ie_or_edge = __commonJS({
    "node_modules/core-js/internals/engine-is-ie-or-edge.js"(exports, module) {
      var UA = require_engine_user_agent();
      module.exports = /MSIE|Trident/.test(UA);
    }
  });

  // node_modules/core-js/internals/engine-webkit-version.js
  var require_engine_webkit_version = __commonJS({
    "node_modules/core-js/internals/engine-webkit-version.js"(exports, module) {
      var userAgent = require_engine_user_agent();
      var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
      module.exports = !!webkit && +webkit[1];
    }
  });

  // node_modules/core-js/modules/es.array.sort.js
  var require_es_array_sort = __commonJS({
    "node_modules/core-js/modules/es.array.sort.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var aCallable = require_a_callable();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var toString = require_to_string();
      var fails = require_fails();
      var internalSort = require_array_sort();
      var arrayMethodIsStrict = require_array_method_is_strict();
      var FF = require_engine_ff_version();
      var IE_OR_EDGE = require_engine_is_ie_or_edge();
      var V8 = require_engine_v8_version();
      var WEBKIT = require_engine_webkit_version();
      var test = [];
      var un$Sort = uncurryThis(test.sort);
      var push = uncurryThis(test.push);
      var FAILS_ON_UNDEFINED = fails(function() {
        test.sort(void 0);
      });
      var FAILS_ON_NULL = fails(function() {
        test.sort(null);
      });
      var STRICT_METHOD = arrayMethodIsStrict("sort");
      var STABLE_SORT = !fails(function() {
        if (V8)
          return V8 < 70;
        if (FF && FF > 3)
          return;
        if (IE_OR_EDGE)
          return true;
        if (WEBKIT)
          return WEBKIT < 603;
        var result = "";
        var code3, chr, value, index;
        for (code3 = 65; code3 < 76; code3++) {
          chr = String.fromCharCode(code3);
          switch (code3) {
            case 66:
            case 69:
            case 70:
            case 72:
              value = 3;
              break;
            case 68:
            case 71:
              value = 4;
              break;
            default:
              value = 2;
          }
          for (index = 0; index < 47; index++) {
            test.push({ k: chr + index, v: value });
          }
        }
        test.sort(function(a2, b2) {
          return b2.v - a2.v;
        });
        for (index = 0; index < test.length; index++) {
          chr = test[index].k.charAt(0);
          if (result.charAt(result.length - 1) !== chr)
            result += chr;
        }
        return result !== "DGBEFHACIJK";
      });
      var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;
      var getSortCompare = function(comparefn) {
        return function(x2, y2) {
          if (y2 === void 0)
            return -1;
          if (x2 === void 0)
            return 1;
          if (comparefn !== void 0)
            return +comparefn(x2, y2) || 0;
          return toString(x2) > toString(y2) ? 1 : -1;
        };
      };
      $2({ target: "Array", proto: true, forced: FORCED }, {
        sort: function sort(comparefn) {
          if (comparefn !== void 0)
            aCallable(comparefn);
          var array = toObject(this);
          if (STABLE_SORT)
            return comparefn === void 0 ? un$Sort(array) : un$Sort(array, comparefn);
          var items = [];
          var arrayLength = lengthOfArrayLike(array);
          var itemsLength, index;
          for (index = 0; index < arrayLength; index++) {
            if (index in array)
              push(items, array[index]);
          }
          internalSort(items, getSortCompare(comparefn));
          itemsLength = items.length;
          index = 0;
          while (index < itemsLength)
            array[index] = items[index++];
          while (index < arrayLength)
            delete array[index++];
          return array;
        }
      });
    }
  });

  // node_modules/core-js/internals/set-species.js
  var require_set_species = __commonJS({
    "node_modules/core-js/internals/set-species.js"(exports, module) {
      "use strict";
      var getBuiltIn = require_get_built_in();
      var definePropertyModule = require_object_define_property();
      var wellKnownSymbol = require_well_known_symbol();
      var DESCRIPTORS = require_descriptors();
      var SPECIES = wellKnownSymbol("species");
      module.exports = function(CONSTRUCTOR_NAME) {
        var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
        var defineProperty = definePropertyModule.f;
        if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
          defineProperty(Constructor, SPECIES, {
            configurable: true,
            get: function() {
              return this;
            }
          });
        }
      };
    }
  });

  // node_modules/core-js/modules/es.array.species.js
  var require_es_array_species = __commonJS({
    "node_modules/core-js/modules/es.array.species.js"() {
      var setSpecies = require_set_species();
      setSpecies("Array");
    }
  });

  // node_modules/core-js/modules/es.array.splice.js
  var require_es_array_splice = __commonJS({
    "node_modules/core-js/modules/es.array.splice.js"() {
      "use strict";
      var $2 = require_export();
      var global2 = require_global();
      var toAbsoluteIndex = require_to_absolute_index();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var lengthOfArrayLike = require_length_of_array_like();
      var toObject = require_to_object();
      var arraySpeciesCreate = require_array_species_create();
      var createProperty = require_create_property();
      var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
      var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
      var TypeError2 = global2.TypeError;
      var max2 = Math.max;
      var min2 = Math.min;
      var MAX_SAFE_INTEGER = 9007199254740991;
      var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = "Maximum allowed length exceeded";
      $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
        splice: function splice(start4, deleteCount) {
          var O = toObject(this);
          var len = lengthOfArrayLike(O);
          var actualStart = toAbsoluteIndex(start4, len);
          var argumentsLength = arguments.length;
          var insertCount, actualDeleteCount, A2, k2, from, to;
          if (argumentsLength === 0) {
            insertCount = actualDeleteCount = 0;
          } else if (argumentsLength === 1) {
            insertCount = 0;
            actualDeleteCount = len - actualStart;
          } else {
            insertCount = argumentsLength - 2;
            actualDeleteCount = min2(max2(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
          }
          if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
            throw TypeError2(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
          }
          A2 = arraySpeciesCreate(O, actualDeleteCount);
          for (k2 = 0; k2 < actualDeleteCount; k2++) {
            from = actualStart + k2;
            if (from in O)
              createProperty(A2, k2, O[from]);
          }
          A2.length = actualDeleteCount;
          if (insertCount < actualDeleteCount) {
            for (k2 = actualStart; k2 < len - actualDeleteCount; k2++) {
              from = k2 + actualDeleteCount;
              to = k2 + insertCount;
              if (from in O)
                O[to] = O[from];
              else
                delete O[to];
            }
            for (k2 = len; k2 > len - actualDeleteCount + insertCount; k2--)
              delete O[k2 - 1];
          } else if (insertCount > actualDeleteCount) {
            for (k2 = len - actualDeleteCount; k2 > actualStart; k2--) {
              from = k2 + actualDeleteCount - 1;
              to = k2 + insertCount - 1;
              if (from in O)
                O[to] = O[from];
              else
                delete O[to];
            }
          }
          for (k2 = 0; k2 < insertCount; k2++) {
            O[k2 + actualStart] = arguments[k2 + 2];
          }
          O.length = len - actualDeleteCount + insertCount;
          return A2;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.unscopables.flat.js
  var require_es_array_unscopables_flat = __commonJS({
    "node_modules/core-js/modules/es.array.unscopables.flat.js"() {
      var addToUnscopables = require_add_to_unscopables();
      addToUnscopables("flat");
    }
  });

  // node_modules/core-js/modules/es.array.unscopables.flat-map.js
  var require_es_array_unscopables_flat_map = __commonJS({
    "node_modules/core-js/modules/es.array.unscopables.flat-map.js"() {
      var addToUnscopables = require_add_to_unscopables();
      addToUnscopables("flatMap");
    }
  });

  // node_modules/core-js/internals/array-buffer-native.js
  var require_array_buffer_native = __commonJS({
    "node_modules/core-js/internals/array-buffer-native.js"(exports, module) {
      module.exports = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined";
    }
  });

  // node_modules/core-js/internals/redefine-all.js
  var require_redefine_all = __commonJS({
    "node_modules/core-js/internals/redefine-all.js"(exports, module) {
      var redefine = require_redefine();
      module.exports = function(target, src, options) {
        for (var key in src)
          redefine(target, key, src[key], options);
        return target;
      };
    }
  });

  // node_modules/core-js/internals/an-instance.js
  var require_an_instance = __commonJS({
    "node_modules/core-js/internals/an-instance.js"(exports, module) {
      var global2 = require_global();
      var isPrototypeOf = require_object_is_prototype_of();
      var TypeError2 = global2.TypeError;
      module.exports = function(it, Prototype) {
        if (isPrototypeOf(Prototype, it))
          return it;
        throw TypeError2("Incorrect invocation");
      };
    }
  });

  // node_modules/core-js/internals/to-index.js
  var require_to_index = __commonJS({
    "node_modules/core-js/internals/to-index.js"(exports, module) {
      var global2 = require_global();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toLength = require_to_length();
      var RangeError2 = global2.RangeError;
      module.exports = function(it) {
        if (it === void 0)
          return 0;
        var number = toIntegerOrInfinity(it);
        var length = toLength(number);
        if (number !== length)
          throw RangeError2("Wrong length or index");
        return length;
      };
    }
  });

  // node_modules/core-js/internals/ieee754.js
  var require_ieee754 = __commonJS({
    "node_modules/core-js/internals/ieee754.js"(exports, module) {
      var global2 = require_global();
      var Array2 = global2.Array;
      var abs = Math.abs;
      var pow = Math.pow;
      var floor = Math.floor;
      var log = Math.log;
      var LN2 = Math.LN2;
      var pack = function(number, mantissaLength, bytes) {
        var buffer = Array2(bytes);
        var exponentLength = bytes * 8 - mantissaLength - 1;
        var eMax = (1 << exponentLength) - 1;
        var eBias = eMax >> 1;
        var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
        var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
        var index = 0;
        var exponent, mantissa, c2;
        number = abs(number);
        if (number != number || number === Infinity) {
          mantissa = number != number ? 1 : 0;
          exponent = eMax;
        } else {
          exponent = floor(log(number) / LN2);
          c2 = pow(2, -exponent);
          if (number * c2 < 1) {
            exponent--;
            c2 *= 2;
          }
          if (exponent + eBias >= 1) {
            number += rt / c2;
          } else {
            number += rt * pow(2, 1 - eBias);
          }
          if (number * c2 >= 2) {
            exponent++;
            c2 /= 2;
          }
          if (exponent + eBias >= eMax) {
            mantissa = 0;
            exponent = eMax;
          } else if (exponent + eBias >= 1) {
            mantissa = (number * c2 - 1) * pow(2, mantissaLength);
            exponent = exponent + eBias;
          } else {
            mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
            exponent = 0;
          }
        }
        while (mantissaLength >= 8) {
          buffer[index++] = mantissa & 255;
          mantissa /= 256;
          mantissaLength -= 8;
        }
        exponent = exponent << mantissaLength | mantissa;
        exponentLength += mantissaLength;
        while (exponentLength > 0) {
          buffer[index++] = exponent & 255;
          exponent /= 256;
          exponentLength -= 8;
        }
        buffer[--index] |= sign * 128;
        return buffer;
      };
      var unpack = function(buffer, mantissaLength) {
        var bytes = buffer.length;
        var exponentLength = bytes * 8 - mantissaLength - 1;
        var eMax = (1 << exponentLength) - 1;
        var eBias = eMax >> 1;
        var nBits = exponentLength - 7;
        var index = bytes - 1;
        var sign = buffer[index--];
        var exponent = sign & 127;
        var mantissa;
        sign >>= 7;
        while (nBits > 0) {
          exponent = exponent * 256 + buffer[index--];
          nBits -= 8;
        }
        mantissa = exponent & (1 << -nBits) - 1;
        exponent >>= -nBits;
        nBits += mantissaLength;
        while (nBits > 0) {
          mantissa = mantissa * 256 + buffer[index--];
          nBits -= 8;
        }
        if (exponent === 0) {
          exponent = 1 - eBias;
        } else if (exponent === eMax) {
          return mantissa ? NaN : sign ? -Infinity : Infinity;
        } else {
          mantissa = mantissa + pow(2, mantissaLength);
          exponent = exponent - eBias;
        }
        return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
      };
      module.exports = {
        pack,
        unpack
      };
    }
  });

  // node_modules/core-js/internals/array-buffer.js
  var require_array_buffer = __commonJS({
    "node_modules/core-js/internals/array-buffer.js"(exports, module) {
      "use strict";
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this();
      var DESCRIPTORS = require_descriptors();
      var NATIVE_ARRAY_BUFFER = require_array_buffer_native();
      var FunctionName = require_function_name();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var redefineAll = require_redefine_all();
      var fails = require_fails();
      var anInstance = require_an_instance();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toLength = require_to_length();
      var toIndex = require_to_index();
      var IEEE754 = require_ieee754();
      var getPrototypeOf = require_object_get_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var getOwnPropertyNames = require_object_get_own_property_names().f;
      var defineProperty = require_object_define_property().f;
      var arrayFill = require_array_fill();
      var arraySlice = require_array_slice_simple();
      var setToStringTag = require_set_to_string_tag();
      var InternalStateModule = require_internal_state();
      var PROPER_FUNCTION_NAME = FunctionName.PROPER;
      var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
      var getInternalState = InternalStateModule.get;
      var setInternalState = InternalStateModule.set;
      var ARRAY_BUFFER = "ArrayBuffer";
      var DATA_VIEW = "DataView";
      var PROTOTYPE = "prototype";
      var WRONG_LENGTH = "Wrong length";
      var WRONG_INDEX = "Wrong index";
      var NativeArrayBuffer = global2[ARRAY_BUFFER];
      var $ArrayBuffer = NativeArrayBuffer;
      var ArrayBufferPrototype = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];
      var $DataView = global2[DATA_VIEW];
      var DataViewPrototype = $DataView && $DataView[PROTOTYPE];
      var ObjectPrototype = Object.prototype;
      var Array2 = global2.Array;
      var RangeError2 = global2.RangeError;
      var fill = uncurryThis(arrayFill);
      var reverse = uncurryThis([].reverse);
      var packIEEE754 = IEEE754.pack;
      var unpackIEEE754 = IEEE754.unpack;
      var packInt8 = function(number) {
        return [number & 255];
      };
      var packInt16 = function(number) {
        return [number & 255, number >> 8 & 255];
      };
      var packInt32 = function(number) {
        return [number & 255, number >> 8 & 255, number >> 16 & 255, number >> 24 & 255];
      };
      var unpackInt32 = function(buffer) {
        return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
      };
      var packFloat32 = function(number) {
        return packIEEE754(number, 23, 4);
      };
      var packFloat64 = function(number) {
        return packIEEE754(number, 52, 8);
      };
      var addGetter = function(Constructor, key2) {
        defineProperty(Constructor[PROTOTYPE], key2, { get: function() {
          return getInternalState(this)[key2];
        } });
      };
      var get = function(view, count, index, isLittleEndian) {
        var intIndex = toIndex(index);
        var store = getInternalState(view);
        if (intIndex + count > store.byteLength)
          throw RangeError2(WRONG_INDEX);
        var bytes = getInternalState(store.buffer).bytes;
        var start4 = intIndex + store.byteOffset;
        var pack = arraySlice(bytes, start4, start4 + count);
        return isLittleEndian ? pack : reverse(pack);
      };
      var set = function(view, count, index, conversion, value, isLittleEndian) {
        var intIndex = toIndex(index);
        var store = getInternalState(view);
        if (intIndex + count > store.byteLength)
          throw RangeError2(WRONG_INDEX);
        var bytes = getInternalState(store.buffer).bytes;
        var start4 = intIndex + store.byteOffset;
        var pack = conversion(+value);
        for (var i2 = 0; i2 < count; i2++)
          bytes[start4 + i2] = pack[isLittleEndian ? i2 : count - i2 - 1];
      };
      if (!NATIVE_ARRAY_BUFFER) {
        $ArrayBuffer = function ArrayBuffer2(length) {
          anInstance(this, ArrayBufferPrototype);
          var byteLength = toIndex(length);
          setInternalState(this, {
            bytes: fill(Array2(byteLength), 0),
            byteLength
          });
          if (!DESCRIPTORS)
            this.byteLength = byteLength;
        };
        ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE];
        $DataView = function DataView2(buffer, byteOffset, byteLength) {
          anInstance(this, DataViewPrototype);
          anInstance(buffer, ArrayBufferPrototype);
          var bufferLength = getInternalState(buffer).byteLength;
          var offset2 = toIntegerOrInfinity(byteOffset);
          if (offset2 < 0 || offset2 > bufferLength)
            throw RangeError2("Wrong offset");
          byteLength = byteLength === void 0 ? bufferLength - offset2 : toLength(byteLength);
          if (offset2 + byteLength > bufferLength)
            throw RangeError2(WRONG_LENGTH);
          setInternalState(this, {
            buffer,
            byteLength,
            byteOffset: offset2
          });
          if (!DESCRIPTORS) {
            this.buffer = buffer;
            this.byteLength = byteLength;
            this.byteOffset = offset2;
          }
        };
        DataViewPrototype = $DataView[PROTOTYPE];
        if (DESCRIPTORS) {
          addGetter($ArrayBuffer, "byteLength");
          addGetter($DataView, "buffer");
          addGetter($DataView, "byteLength");
          addGetter($DataView, "byteOffset");
        }
        redefineAll(DataViewPrototype, {
          getInt8: function getInt8(byteOffset) {
            return get(this, 1, byteOffset)[0] << 24 >> 24;
          },
          getUint8: function getUint8(byteOffset) {
            return get(this, 1, byteOffset)[0];
          },
          getInt16: function getInt16(byteOffset) {
            var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : void 0);
            return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
          },
          getUint16: function getUint16(byteOffset) {
            var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : void 0);
            return bytes[1] << 8 | bytes[0];
          },
          getInt32: function getInt32(byteOffset) {
            return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : void 0));
          },
          getUint32: function getUint32(byteOffset) {
            return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : void 0)) >>> 0;
          },
          getFloat32: function getFloat32(byteOffset) {
            return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : void 0), 23);
          },
          getFloat64: function getFloat64(byteOffset) {
            return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : void 0), 52);
          },
          setInt8: function setInt8(byteOffset, value) {
            set(this, 1, byteOffset, packInt8, value);
          },
          setUint8: function setUint8(byteOffset, value) {
            set(this, 1, byteOffset, packInt8, value);
          },
          setInt16: function setInt16(byteOffset, value) {
            set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : void 0);
          },
          setUint16: function setUint16(byteOffset, value) {
            set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : void 0);
          },
          setInt32: function setInt32(byteOffset, value) {
            set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : void 0);
          },
          setUint32: function setUint32(byteOffset, value) {
            set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : void 0);
          },
          setFloat32: function setFloat32(byteOffset, value) {
            set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : void 0);
          },
          setFloat64: function setFloat64(byteOffset, value) {
            set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : void 0);
          }
        });
      } else {
        INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME && NativeArrayBuffer.name !== ARRAY_BUFFER;
        if (!fails(function() {
          NativeArrayBuffer(1);
        }) || !fails(function() {
          new NativeArrayBuffer(-1);
        }) || fails(function() {
          new NativeArrayBuffer();
          new NativeArrayBuffer(1.5);
          new NativeArrayBuffer(NaN);
          return INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;
        })) {
          $ArrayBuffer = function ArrayBuffer2(length) {
            anInstance(this, ArrayBufferPrototype);
            return new NativeArrayBuffer(toIndex(length));
          };
          $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype;
          for (keys = getOwnPropertyNames(NativeArrayBuffer), j2 = 0; keys.length > j2; ) {
            if (!((key = keys[j2++]) in $ArrayBuffer)) {
              createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
            }
          }
          ArrayBufferPrototype.constructor = $ArrayBuffer;
        } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {
          createNonEnumerableProperty(NativeArrayBuffer, "name", ARRAY_BUFFER);
        }
        if (setPrototypeOf && getPrototypeOf(DataViewPrototype) !== ObjectPrototype) {
          setPrototypeOf(DataViewPrototype, ObjectPrototype);
        }
        testView = new $DataView(new $ArrayBuffer(2));
        $setInt8 = uncurryThis(DataViewPrototype.setInt8);
        testView.setInt8(0, 2147483648);
        testView.setInt8(1, 2147483649);
        if (testView.getInt8(0) || !testView.getInt8(1))
          redefineAll(DataViewPrototype, {
            setInt8: function setInt8(byteOffset, value) {
              $setInt8(this, byteOffset, value << 24 >> 24);
            },
            setUint8: function setUint8(byteOffset, value) {
              $setInt8(this, byteOffset, value << 24 >> 24);
            }
          }, { unsafe: true });
      }
      var INCORRECT_ARRAY_BUFFER_NAME;
      var keys;
      var j2;
      var key;
      var testView;
      var $setInt8;
      setToStringTag($ArrayBuffer, ARRAY_BUFFER);
      setToStringTag($DataView, DATA_VIEW);
      module.exports = {
        ArrayBuffer: $ArrayBuffer,
        DataView: $DataView
      };
    }
  });

  // node_modules/core-js/modules/es.array-buffer.constructor.js
  var require_es_array_buffer_constructor = __commonJS({
    "node_modules/core-js/modules/es.array-buffer.constructor.js"() {
      "use strict";
      var $2 = require_export();
      var global2 = require_global();
      var arrayBufferModule = require_array_buffer();
      var setSpecies = require_set_species();
      var ARRAY_BUFFER = "ArrayBuffer";
      var ArrayBuffer2 = arrayBufferModule[ARRAY_BUFFER];
      var NativeArrayBuffer = global2[ARRAY_BUFFER];
      $2({ global: true, forced: NativeArrayBuffer !== ArrayBuffer2 }, {
        ArrayBuffer: ArrayBuffer2
      });
      setSpecies(ARRAY_BUFFER);
    }
  });

  // node_modules/core-js/internals/array-buffer-view-core.js
  var require_array_buffer_view_core = __commonJS({
    "node_modules/core-js/internals/array-buffer-view-core.js"(exports, module) {
      "use strict";
      var NATIVE_ARRAY_BUFFER = require_array_buffer_native();
      var DESCRIPTORS = require_descriptors();
      var global2 = require_global();
      var isCallable = require_is_callable();
      var isObject3 = require_is_object();
      var hasOwn = require_has_own_property();
      var classof = require_classof();
      var tryToString = require_try_to_string();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var redefine = require_redefine();
      var defineProperty = require_object_define_property().f;
      var isPrototypeOf = require_object_is_prototype_of();
      var getPrototypeOf = require_object_get_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var wellKnownSymbol = require_well_known_symbol();
      var uid = require_uid();
      var Int8Array2 = global2.Int8Array;
      var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
      var Uint8ClampedArray2 = global2.Uint8ClampedArray;
      var Uint8ClampedArrayPrototype = Uint8ClampedArray2 && Uint8ClampedArray2.prototype;
      var TypedArray = Int8Array2 && getPrototypeOf(Int8Array2);
      var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
      var ObjectPrototype = Object.prototype;
      var TypeError2 = global2.TypeError;
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var TYPED_ARRAY_TAG = uid("TYPED_ARRAY_TAG");
      var TYPED_ARRAY_CONSTRUCTOR = uid("TYPED_ARRAY_CONSTRUCTOR");
      var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global2.opera) !== "Opera";
      var TYPED_ARRAY_TAG_REQUIRED = false;
      var NAME;
      var Constructor;
      var Prototype;
      var TypedArrayConstructorsList = {
        Int8Array: 1,
        Uint8Array: 1,
        Uint8ClampedArray: 1,
        Int16Array: 2,
        Uint16Array: 2,
        Int32Array: 4,
        Uint32Array: 4,
        Float32Array: 4,
        Float64Array: 8
      };
      var BigIntArrayConstructorsList = {
        BigInt64Array: 8,
        BigUint64Array: 8
      };
      var isView = function isView2(it) {
        if (!isObject3(it))
          return false;
        var klass = classof(it);
        return klass === "DataView" || hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
      };
      var isTypedArray = function(it) {
        if (!isObject3(it))
          return false;
        var klass = classof(it);
        return hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
      };
      var aTypedArray = function(it) {
        if (isTypedArray(it))
          return it;
        throw TypeError2("Target is not a typed array");
      };
      var aTypedArrayConstructor = function(C2) {
        if (isCallable(C2) && (!setPrototypeOf || isPrototypeOf(TypedArray, C2)))
          return C2;
        throw TypeError2(tryToString(C2) + " is not a typed array constructor");
      };
      var exportTypedArrayMethod = function(KEY, property, forced, options) {
        if (!DESCRIPTORS)
          return;
        if (forced)
          for (var ARRAY in TypedArrayConstructorsList) {
            var TypedArrayConstructor = global2[ARRAY];
            if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY))
              try {
                delete TypedArrayConstructor.prototype[KEY];
              } catch (error2) {
                try {
                  TypedArrayConstructor.prototype[KEY] = property;
                } catch (error22) {
                }
              }
          }
        if (!TypedArrayPrototype[KEY] || forced) {
          redefine(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
        }
      };
      var exportTypedArrayStaticMethod = function(KEY, property, forced) {
        var ARRAY, TypedArrayConstructor;
        if (!DESCRIPTORS)
          return;
        if (setPrototypeOf) {
          if (forced)
            for (ARRAY in TypedArrayConstructorsList) {
              TypedArrayConstructor = global2[ARRAY];
              if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY))
                try {
                  delete TypedArrayConstructor[KEY];
                } catch (error2) {
                }
            }
          if (!TypedArray[KEY] || forced) {
            try {
              return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
            } catch (error2) {
            }
          } else
            return;
        }
        for (ARRAY in TypedArrayConstructorsList) {
          TypedArrayConstructor = global2[ARRAY];
          if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
            redefine(TypedArrayConstructor, KEY, property);
          }
        }
      };
      for (NAME in TypedArrayConstructorsList) {
        Constructor = global2[NAME];
        Prototype = Constructor && Constructor.prototype;
        if (Prototype)
          createNonEnumerableProperty(Prototype, TYPED_ARRAY_CONSTRUCTOR, Constructor);
        else
          NATIVE_ARRAY_BUFFER_VIEWS = false;
      }
      for (NAME in BigIntArrayConstructorsList) {
        Constructor = global2[NAME];
        Prototype = Constructor && Constructor.prototype;
        if (Prototype)
          createNonEnumerableProperty(Prototype, TYPED_ARRAY_CONSTRUCTOR, Constructor);
      }
      if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
        TypedArray = function TypedArray2() {
          throw TypeError2("Incorrect invocation");
        };
        if (NATIVE_ARRAY_BUFFER_VIEWS)
          for (NAME in TypedArrayConstructorsList) {
            if (global2[NAME])
              setPrototypeOf(global2[NAME], TypedArray);
          }
      }
      if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
        TypedArrayPrototype = TypedArray.prototype;
        if (NATIVE_ARRAY_BUFFER_VIEWS)
          for (NAME in TypedArrayConstructorsList) {
            if (global2[NAME])
              setPrototypeOf(global2[NAME].prototype, TypedArrayPrototype);
          }
      }
      if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
        setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
      }
      if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
        TYPED_ARRAY_TAG_REQUIRED = true;
        defineProperty(TypedArrayPrototype, TO_STRING_TAG, { get: function() {
          return isObject3(this) ? this[TYPED_ARRAY_TAG] : void 0;
        } });
        for (NAME in TypedArrayConstructorsList)
          if (global2[NAME]) {
            createNonEnumerableProperty(global2[NAME], TYPED_ARRAY_TAG, NAME);
          }
      }
      module.exports = {
        NATIVE_ARRAY_BUFFER_VIEWS,
        TYPED_ARRAY_CONSTRUCTOR,
        TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
        aTypedArray,
        aTypedArrayConstructor,
        exportTypedArrayMethod,
        exportTypedArrayStaticMethod,
        isView,
        isTypedArray,
        TypedArray,
        TypedArrayPrototype
      };
    }
  });

  // node_modules/core-js/modules/es.array-buffer.is-view.js
  var require_es_array_buffer_is_view = __commonJS({
    "node_modules/core-js/modules/es.array-buffer.is-view.js"() {
      var $2 = require_export();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
      $2({ target: "ArrayBuffer", stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
        isView: ArrayBufferViewCore.isView
      });
    }
  });

  // node_modules/core-js/internals/a-constructor.js
  var require_a_constructor = __commonJS({
    "node_modules/core-js/internals/a-constructor.js"(exports, module) {
      var global2 = require_global();
      var isConstructor = require_is_constructor();
      var tryToString = require_try_to_string();
      var TypeError2 = global2.TypeError;
      module.exports = function(argument) {
        if (isConstructor(argument))
          return argument;
        throw TypeError2(tryToString(argument) + " is not a constructor");
      };
    }
  });

  // node_modules/core-js/internals/species-constructor.js
  var require_species_constructor = __commonJS({
    "node_modules/core-js/internals/species-constructor.js"(exports, module) {
      var anObject = require_an_object();
      var aConstructor = require_a_constructor();
      var wellKnownSymbol = require_well_known_symbol();
      var SPECIES = wellKnownSymbol("species");
      module.exports = function(O, defaultConstructor) {
        var C2 = anObject(O).constructor;
        var S;
        return C2 === void 0 || (S = anObject(C2)[SPECIES]) == void 0 ? defaultConstructor : aConstructor(S);
      };
    }
  });

  // node_modules/core-js/modules/es.array-buffer.slice.js
  var require_es_array_buffer_slice = __commonJS({
    "node_modules/core-js/modules/es.array-buffer.slice.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var ArrayBufferModule = require_array_buffer();
      var anObject = require_an_object();
      var toAbsoluteIndex = require_to_absolute_index();
      var toLength = require_to_length();
      var speciesConstructor = require_species_constructor();
      var ArrayBuffer2 = ArrayBufferModule.ArrayBuffer;
      var DataView2 = ArrayBufferModule.DataView;
      var DataViewPrototype = DataView2.prototype;
      var un$ArrayBufferSlice = uncurryThis(ArrayBuffer2.prototype.slice);
      var getUint8 = uncurryThis(DataViewPrototype.getUint8);
      var setUint8 = uncurryThis(DataViewPrototype.setUint8);
      var INCORRECT_SLICE = fails(function() {
        return !new ArrayBuffer2(2).slice(1, void 0).byteLength;
      });
      $2({ target: "ArrayBuffer", proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
        slice: function slice(start4, end2) {
          if (un$ArrayBufferSlice && end2 === void 0) {
            return un$ArrayBufferSlice(anObject(this), start4);
          }
          var length = anObject(this).byteLength;
          var first = toAbsoluteIndex(start4, length);
          var fin = toAbsoluteIndex(end2 === void 0 ? length : end2, length);
          var result = new (speciesConstructor(this, ArrayBuffer2))(toLength(fin - first));
          var viewSource = new DataView2(this);
          var viewTarget = new DataView2(result);
          var index = 0;
          while (first < fin) {
            setUint8(viewTarget, index++, getUint8(viewSource, first++));
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.data-view.js
  var require_es_data_view = __commonJS({
    "node_modules/core-js/modules/es.data-view.js"() {
      var $2 = require_export();
      var ArrayBufferModule = require_array_buffer();
      var NATIVE_ARRAY_BUFFER = require_array_buffer_native();
      $2({ global: true, forced: !NATIVE_ARRAY_BUFFER }, {
        DataView: ArrayBufferModule.DataView
      });
    }
  });

  // node_modules/core-js/modules/es.date.get-year.js
  var require_es_date_get_year = __commonJS({
    "node_modules/core-js/modules/es.date.get-year.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var FORCED = fails(function() {
        return new Date(16e11).getYear() !== 120;
      });
      var getFullYear = uncurryThis(Date.prototype.getFullYear);
      $2({ target: "Date", proto: true, forced: FORCED }, {
        getYear: function getYear() {
          return getFullYear(this) - 1900;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.date.now.js
  var require_es_date_now = __commonJS({
    "node_modules/core-js/modules/es.date.now.js"() {
      var $2 = require_export();
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this();
      var Date2 = global2.Date;
      var getTime = uncurryThis(Date2.prototype.getTime);
      $2({ target: "Date", stat: true }, {
        now: function now2() {
          return getTime(new Date2());
        }
      });
    }
  });

  // node_modules/core-js/modules/es.date.set-year.js
  var require_es_date_set_year = __commonJS({
    "node_modules/core-js/modules/es.date.set-year.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var DatePrototype = Date.prototype;
      var getTime = uncurryThis(DatePrototype.getTime);
      var setFullYear = uncurryThis(DatePrototype.setFullYear);
      $2({ target: "Date", proto: true }, {
        setYear: function setYear(year) {
          getTime(this);
          var yi = toIntegerOrInfinity(year);
          var yyyy = 0 <= yi && yi <= 99 ? yi + 1900 : yi;
          return setFullYear(this, yyyy);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.date.to-gmt-string.js
  var require_es_date_to_gmt_string = __commonJS({
    "node_modules/core-js/modules/es.date.to-gmt-string.js"() {
      var $2 = require_export();
      $2({ target: "Date", proto: true }, {
        toGMTString: Date.prototype.toUTCString
      });
    }
  });

  // node_modules/core-js/internals/string-repeat.js
  var require_string_repeat = __commonJS({
    "node_modules/core-js/internals/string-repeat.js"(exports, module) {
      "use strict";
      var global2 = require_global();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toString = require_to_string();
      var requireObjectCoercible = require_require_object_coercible();
      var RangeError2 = global2.RangeError;
      module.exports = function repeat(count) {
        var str = toString(requireObjectCoercible(this));
        var result = "";
        var n2 = toIntegerOrInfinity(count);
        if (n2 < 0 || n2 == Infinity)
          throw RangeError2("Wrong number of repetitions");
        for (; n2 > 0; (n2 >>>= 1) && (str += str))
          if (n2 & 1)
            result += str;
        return result;
      };
    }
  });

  // node_modules/core-js/internals/string-pad.js
  var require_string_pad = __commonJS({
    "node_modules/core-js/internals/string-pad.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      var toLength = require_to_length();
      var toString = require_to_string();
      var $repeat = require_string_repeat();
      var requireObjectCoercible = require_require_object_coercible();
      var repeat = uncurryThis($repeat);
      var stringSlice = uncurryThis("".slice);
      var ceil = Math.ceil;
      var createMethod = function(IS_END) {
        return function($this, maxLength, fillString) {
          var S = toString(requireObjectCoercible($this));
          var intMaxLength = toLength(maxLength);
          var stringLength = S.length;
          var fillStr = fillString === void 0 ? " " : toString(fillString);
          var fillLen, stringFiller;
          if (intMaxLength <= stringLength || fillStr == "")
            return S;
          fillLen = intMaxLength - stringLength;
          stringFiller = repeat(fillStr, ceil(fillLen / fillStr.length));
          if (stringFiller.length > fillLen)
            stringFiller = stringSlice(stringFiller, 0, fillLen);
          return IS_END ? S + stringFiller : stringFiller + S;
        };
      };
      module.exports = {
        start: createMethod(false),
        end: createMethod(true)
      };
    }
  });

  // node_modules/core-js/internals/date-to-iso-string.js
  var require_date_to_iso_string = __commonJS({
    "node_modules/core-js/internals/date-to-iso-string.js"(exports, module) {
      "use strict";
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var padStart = require_string_pad().start;
      var RangeError2 = global2.RangeError;
      var abs = Math.abs;
      var DatePrototype = Date.prototype;
      var n$DateToISOString = DatePrototype.toISOString;
      var getTime = uncurryThis(DatePrototype.getTime);
      var getUTCDate = uncurryThis(DatePrototype.getUTCDate);
      var getUTCFullYear = uncurryThis(DatePrototype.getUTCFullYear);
      var getUTCHours = uncurryThis(DatePrototype.getUTCHours);
      var getUTCMilliseconds = uncurryThis(DatePrototype.getUTCMilliseconds);
      var getUTCMinutes = uncurryThis(DatePrototype.getUTCMinutes);
      var getUTCMonth = uncurryThis(DatePrototype.getUTCMonth);
      var getUTCSeconds = uncurryThis(DatePrototype.getUTCSeconds);
      module.exports = fails(function() {
        return n$DateToISOString.call(new Date(-5e13 - 1)) != "0385-07-25T07:06:39.999Z";
      }) || !fails(function() {
        n$DateToISOString.call(new Date(NaN));
      }) ? function toISOString() {
        if (!isFinite(getTime(this)))
          throw RangeError2("Invalid time value");
        var date = this;
        var year = getUTCFullYear(date);
        var milliseconds = getUTCMilliseconds(date);
        var sign = year < 0 ? "-" : year > 9999 ? "+" : "";
        return sign + padStart(abs(year), sign ? 6 : 4, 0) + "-" + padStart(getUTCMonth(date) + 1, 2, 0) + "-" + padStart(getUTCDate(date), 2, 0) + "T" + padStart(getUTCHours(date), 2, 0) + ":" + padStart(getUTCMinutes(date), 2, 0) + ":" + padStart(getUTCSeconds(date), 2, 0) + "." + padStart(milliseconds, 3, 0) + "Z";
      } : n$DateToISOString;
    }
  });

  // node_modules/core-js/modules/es.date.to-iso-string.js
  var require_es_date_to_iso_string = __commonJS({
    "node_modules/core-js/modules/es.date.to-iso-string.js"() {
      var $2 = require_export();
      var toISOString = require_date_to_iso_string();
      $2({ target: "Date", proto: true, forced: Date.prototype.toISOString !== toISOString }, {
        toISOString
      });
    }
  });

  // node_modules/core-js/modules/es.date.to-json.js
  var require_es_date_to_json = __commonJS({
    "node_modules/core-js/modules/es.date.to-json.js"() {
      "use strict";
      var $2 = require_export();
      var fails = require_fails();
      var toObject = require_to_object();
      var toPrimitive = require_to_primitive();
      var FORCED = fails(function() {
        return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({ toISOString: function() {
          return 1;
        } }) !== 1;
      });
      $2({ target: "Date", proto: true, forced: FORCED }, {
        toJSON: function toJSON(key) {
          var O = toObject(this);
          var pv = toPrimitive(O, "number");
          return typeof pv == "number" && !isFinite(pv) ? null : O.toISOString();
        }
      });
    }
  });

  // node_modules/core-js/internals/date-to-primitive.js
  var require_date_to_primitive = __commonJS({
    "node_modules/core-js/internals/date-to-primitive.js"(exports, module) {
      "use strict";
      var global2 = require_global();
      var anObject = require_an_object();
      var ordinaryToPrimitive = require_ordinary_to_primitive();
      var TypeError2 = global2.TypeError;
      module.exports = function(hint) {
        anObject(this);
        if (hint === "string" || hint === "default")
          hint = "string";
        else if (hint !== "number")
          throw TypeError2("Incorrect hint");
        return ordinaryToPrimitive(this, hint);
      };
    }
  });

  // node_modules/core-js/modules/es.date.to-primitive.js
  var require_es_date_to_primitive = __commonJS({
    "node_modules/core-js/modules/es.date.to-primitive.js"() {
      var hasOwn = require_has_own_property();
      var redefine = require_redefine();
      var dateToPrimitive = require_date_to_primitive();
      var wellKnownSymbol = require_well_known_symbol();
      var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
      var DatePrototype = Date.prototype;
      if (!hasOwn(DatePrototype, TO_PRIMITIVE)) {
        redefine(DatePrototype, TO_PRIMITIVE, dateToPrimitive);
      }
    }
  });

  // node_modules/core-js/modules/es.date.to-string.js
  var require_es_date_to_string = __commonJS({
    "node_modules/core-js/modules/es.date.to-string.js"() {
      var uncurryThis = require_function_uncurry_this();
      var redefine = require_redefine();
      var DatePrototype = Date.prototype;
      var INVALID_DATE = "Invalid Date";
      var TO_STRING = "toString";
      var un$DateToString = uncurryThis(DatePrototype[TO_STRING]);
      var getTime = uncurryThis(DatePrototype.getTime);
      if (String(new Date(NaN)) != INVALID_DATE) {
        redefine(DatePrototype, TO_STRING, function toString() {
          var value = getTime(this);
          return value === value ? un$DateToString(this) : INVALID_DATE;
        });
      }
    }
  });

  // node_modules/core-js/modules/es.escape.js
  var require_es_escape = __commonJS({
    "node_modules/core-js/modules/es.escape.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toString = require_to_string();
      var charAt = uncurryThis("".charAt);
      var charCodeAt = uncurryThis("".charCodeAt);
      var exec = uncurryThis(/./.exec);
      var numberToString = uncurryThis(1 .toString);
      var toUpperCase = uncurryThis("".toUpperCase);
      var raw = /[\w*+\-./@]/;
      var hex = function(code3, length) {
        var result = numberToString(code3, 16);
        while (result.length < length)
          result = "0" + result;
        return result;
      };
      $2({ global: true }, {
        escape: function escape2(string) {
          var str = toString(string);
          var result = "";
          var length = str.length;
          var index = 0;
          var chr, code3;
          while (index < length) {
            chr = charAt(str, index++);
            if (exec(raw, chr)) {
              result += chr;
            } else {
              code3 = charCodeAt(chr, 0);
              if (code3 < 256) {
                result += "%" + hex(code3, 2);
              } else {
                result += "%u" + toUpperCase(hex(code3, 4));
              }
            }
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/internals/function-bind.js
  var require_function_bind = __commonJS({
    "node_modules/core-js/internals/function-bind.js"(exports, module) {
      "use strict";
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this();
      var aCallable = require_a_callable();
      var isObject3 = require_is_object();
      var hasOwn = require_has_own_property();
      var arraySlice = require_array_slice();
      var NATIVE_BIND = require_function_bind_native();
      var Function2 = global2.Function;
      var concat = uncurryThis([].concat);
      var join = uncurryThis([].join);
      var factories = {};
      var construct = function(C2, argsLength, args) {
        if (!hasOwn(factories, argsLength)) {
          for (var list = [], i2 = 0; i2 < argsLength; i2++)
            list[i2] = "a[" + i2 + "]";
          factories[argsLength] = Function2("C,a", "return new C(" + join(list, ",") + ")");
        }
        return factories[argsLength](C2, args);
      };
      module.exports = NATIVE_BIND ? Function2.bind : function bind3(that) {
        var F = aCallable(this);
        var Prototype = F.prototype;
        var partArgs = arraySlice(arguments, 1);
        var boundFunction = function bound() {
          var args = concat(partArgs, arraySlice(arguments));
          return this instanceof boundFunction ? construct(F, args.length, args) : F.apply(that, args);
        };
        if (isObject3(Prototype))
          boundFunction.prototype = Prototype;
        return boundFunction;
      };
    }
  });

  // node_modules/core-js/modules/es.function.bind.js
  var require_es_function_bind = __commonJS({
    "node_modules/core-js/modules/es.function.bind.js"() {
      var $2 = require_export();
      var bind3 = require_function_bind();
      $2({ target: "Function", proto: true, forced: Function.bind !== bind3 }, {
        bind: bind3
      });
    }
  });

  // node_modules/core-js/modules/es.function.has-instance.js
  var require_es_function_has_instance = __commonJS({
    "node_modules/core-js/modules/es.function.has-instance.js"() {
      "use strict";
      var isCallable = require_is_callable();
      var isObject3 = require_is_object();
      var definePropertyModule = require_object_define_property();
      var getPrototypeOf = require_object_get_prototype_of();
      var wellKnownSymbol = require_well_known_symbol();
      var HAS_INSTANCE = wellKnownSymbol("hasInstance");
      var FunctionPrototype = Function.prototype;
      if (!(HAS_INSTANCE in FunctionPrototype)) {
        definePropertyModule.f(FunctionPrototype, HAS_INSTANCE, { value: function(O) {
          if (!isCallable(this) || !isObject3(O))
            return false;
          var P2 = this.prototype;
          if (!isObject3(P2))
            return O instanceof this;
          while (O = getPrototypeOf(O))
            if (P2 === O)
              return true;
          return false;
        } });
      }
    }
  });

  // node_modules/core-js/modules/es.function.name.js
  var require_es_function_name = __commonJS({
    "node_modules/core-js/modules/es.function.name.js"() {
      var DESCRIPTORS = require_descriptors();
      var FUNCTION_NAME_EXISTS = require_function_name().EXISTS;
      var uncurryThis = require_function_uncurry_this();
      var defineProperty = require_object_define_property().f;
      var FunctionPrototype = Function.prototype;
      var functionToString = uncurryThis(FunctionPrototype.toString);
      var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
      var regExpExec = uncurryThis(nameRE.exec);
      var NAME = "name";
      if (DESCRIPTORS && !FUNCTION_NAME_EXISTS) {
        defineProperty(FunctionPrototype, NAME, {
          configurable: true,
          get: function() {
            try {
              return regExpExec(nameRE, functionToString(this))[1];
            } catch (error2) {
              return "";
            }
          }
        });
      }
    }
  });

  // node_modules/core-js/modules/es.global-this.js
  var require_es_global_this = __commonJS({
    "node_modules/core-js/modules/es.global-this.js"() {
      var $2 = require_export();
      var global2 = require_global();
      $2({ global: true }, {
        globalThis: global2
      });
    }
  });

  // node_modules/core-js/modules/es.json.stringify.js
  var require_es_json_stringify = __commonJS({
    "node_modules/core-js/modules/es.json.stringify.js"() {
      var $2 = require_export();
      var global2 = require_global();
      var getBuiltIn = require_get_built_in();
      var apply = require_function_apply();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var Array2 = global2.Array;
      var $stringify = getBuiltIn("JSON", "stringify");
      var exec = uncurryThis(/./.exec);
      var charAt = uncurryThis("".charAt);
      var charCodeAt = uncurryThis("".charCodeAt);
      var replace = uncurryThis("".replace);
      var numberToString = uncurryThis(1 .toString);
      var tester = /[\uD800-\uDFFF]/g;
      var low = /^[\uD800-\uDBFF]$/;
      var hi = /^[\uDC00-\uDFFF]$/;
      var fix = function(match, offset2, string) {
        var prev = charAt(string, offset2 - 1);
        var next = charAt(string, offset2 + 1);
        if (exec(low, match) && !exec(hi, next) || exec(hi, match) && !exec(low, prev)) {
          return "\\u" + numberToString(charCodeAt(match, 0), 16);
        }
        return match;
      };
      var FORCED = fails(function() {
        return $stringify("\uDF06\uD834") !== '"\\udf06\\ud834"' || $stringify("\uDEAD") !== '"\\udead"';
      });
      if ($stringify) {
        $2({ target: "JSON", stat: true, forced: FORCED }, {
          stringify: function stringify(it, replacer, space) {
            for (var i2 = 0, l2 = arguments.length, args = Array2(l2); i2 < l2; i2++)
              args[i2] = arguments[i2];
            var result = apply($stringify, null, args);
            return typeof result == "string" ? replace(result, tester, fix) : result;
          }
        });
      }
    }
  });

  // node_modules/core-js/modules/es.json.to-string-tag.js
  var require_es_json_to_string_tag = __commonJS({
    "node_modules/core-js/modules/es.json.to-string-tag.js"() {
      var global2 = require_global();
      var setToStringTag = require_set_to_string_tag();
      setToStringTag(global2.JSON, "JSON", true);
    }
  });

  // node_modules/core-js/internals/array-buffer-non-extensible.js
  var require_array_buffer_non_extensible = __commonJS({
    "node_modules/core-js/internals/array-buffer-non-extensible.js"(exports, module) {
      var fails = require_fails();
      module.exports = fails(function() {
        if (typeof ArrayBuffer == "function") {
          var buffer = new ArrayBuffer(8);
          if (Object.isExtensible(buffer))
            Object.defineProperty(buffer, "a", { value: 8 });
        }
      });
    }
  });

  // node_modules/core-js/internals/object-is-extensible.js
  var require_object_is_extensible = __commonJS({
    "node_modules/core-js/internals/object-is-extensible.js"(exports, module) {
      var fails = require_fails();
      var isObject3 = require_is_object();
      var classof = require_classof_raw();
      var ARRAY_BUFFER_NON_EXTENSIBLE = require_array_buffer_non_extensible();
      var $isExtensible = Object.isExtensible;
      var FAILS_ON_PRIMITIVES = fails(function() {
        $isExtensible(1);
      });
      module.exports = FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it) {
        if (!isObject3(it))
          return false;
        if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) == "ArrayBuffer")
          return false;
        return $isExtensible ? $isExtensible(it) : true;
      } : $isExtensible;
    }
  });

  // node_modules/core-js/internals/freezing.js
  var require_freezing = __commonJS({
    "node_modules/core-js/internals/freezing.js"(exports, module) {
      var fails = require_fails();
      module.exports = !fails(function() {
        return Object.isExtensible(Object.preventExtensions({}));
      });
    }
  });

  // node_modules/core-js/internals/internal-metadata.js
  var require_internal_metadata = __commonJS({
    "node_modules/core-js/internals/internal-metadata.js"(exports, module) {
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var hiddenKeys = require_hidden_keys();
      var isObject3 = require_is_object();
      var hasOwn = require_has_own_property();
      var defineProperty = require_object_define_property().f;
      var getOwnPropertyNamesModule = require_object_get_own_property_names();
      var getOwnPropertyNamesExternalModule = require_object_get_own_property_names_external();
      var isExtensible = require_object_is_extensible();
      var uid = require_uid();
      var FREEZING = require_freezing();
      var REQUIRED = false;
      var METADATA = uid("meta");
      var id = 0;
      var setMetadata = function(it) {
        defineProperty(it, METADATA, { value: {
          objectID: "O" + id++,
          weakData: {}
        } });
      };
      var fastKey = function(it, create) {
        if (!isObject3(it))
          return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
        if (!hasOwn(it, METADATA)) {
          if (!isExtensible(it))
            return "F";
          if (!create)
            return "E";
          setMetadata(it);
        }
        return it[METADATA].objectID;
      };
      var getWeakData = function(it, create) {
        if (!hasOwn(it, METADATA)) {
          if (!isExtensible(it))
            return true;
          if (!create)
            return false;
          setMetadata(it);
        }
        return it[METADATA].weakData;
      };
      var onFreeze = function(it) {
        if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA))
          setMetadata(it);
        return it;
      };
      var enable = function() {
        meta.enable = function() {
        };
        REQUIRED = true;
        var getOwnPropertyNames = getOwnPropertyNamesModule.f;
        var splice = uncurryThis([].splice);
        var test = {};
        test[METADATA] = 1;
        if (getOwnPropertyNames(test).length) {
          getOwnPropertyNamesModule.f = function(it) {
            var result = getOwnPropertyNames(it);
            for (var i2 = 0, length = result.length; i2 < length; i2++) {
              if (result[i2] === METADATA) {
                splice(result, i2, 1);
                break;
              }
            }
            return result;
          };
          $2({ target: "Object", stat: true, forced: true }, {
            getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
          });
        }
      };
      var meta = module.exports = {
        enable,
        fastKey,
        getWeakData,
        onFreeze
      };
      hiddenKeys[METADATA] = true;
    }
  });

  // node_modules/core-js/internals/collection.js
  var require_collection = __commonJS({
    "node_modules/core-js/internals/collection.js"(exports, module) {
      "use strict";
      var $2 = require_export();
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this();
      var isForced = require_is_forced();
      var redefine = require_redefine();
      var InternalMetadataModule = require_internal_metadata();
      var iterate = require_iterate();
      var anInstance = require_an_instance();
      var isCallable = require_is_callable();
      var isObject3 = require_is_object();
      var fails = require_fails();
      var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
      var setToStringTag = require_set_to_string_tag();
      var inheritIfRequired = require_inherit_if_required();
      module.exports = function(CONSTRUCTOR_NAME, wrapper, common) {
        var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
        var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
        var ADDER = IS_MAP ? "set" : "add";
        var NativeConstructor = global2[CONSTRUCTOR_NAME];
        var NativePrototype = NativeConstructor && NativeConstructor.prototype;
        var Constructor = NativeConstructor;
        var exported = {};
        var fixMethod = function(KEY) {
          var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);
          redefine(NativePrototype, KEY, KEY == "add" ? function add3(value) {
            uncurriedNativeMethod(this, value === 0 ? 0 : value);
            return this;
          } : KEY == "delete" ? function(key) {
            return IS_WEAK && !isObject3(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
          } : KEY == "get" ? function get(key) {
            return IS_WEAK && !isObject3(key) ? void 0 : uncurriedNativeMethod(this, key === 0 ? 0 : key);
          } : KEY == "has" ? function has(key) {
            return IS_WEAK && !isObject3(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
          } : function set(key, value) {
            uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
            return this;
          });
        };
        var REPLACE = isForced(CONSTRUCTOR_NAME, !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function() {
          new NativeConstructor().entries().next();
        })));
        if (REPLACE) {
          Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
          InternalMetadataModule.enable();
        } else if (isForced(CONSTRUCTOR_NAME, true)) {
          var instance = new Constructor();
          var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
          var THROWS_ON_PRIMITIVES = fails(function() {
            instance.has(1);
          });
          var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function(iterable) {
            new NativeConstructor(iterable);
          });
          var BUGGY_ZERO = !IS_WEAK && fails(function() {
            var $instance = new NativeConstructor();
            var index = 5;
            while (index--)
              $instance[ADDER](index, index);
            return !$instance.has(-0);
          });
          if (!ACCEPT_ITERABLES) {
            Constructor = wrapper(function(dummy, iterable) {
              anInstance(dummy, NativePrototype);
              var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
              if (iterable != void 0)
                iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
              return that;
            });
            Constructor.prototype = NativePrototype;
            NativePrototype.constructor = Constructor;
          }
          if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
            fixMethod("delete");
            fixMethod("has");
            IS_MAP && fixMethod("get");
          }
          if (BUGGY_ZERO || HASNT_CHAINING)
            fixMethod(ADDER);
          if (IS_WEAK && NativePrototype.clear)
            delete NativePrototype.clear;
        }
        exported[CONSTRUCTOR_NAME] = Constructor;
        $2({ global: true, forced: Constructor != NativeConstructor }, exported);
        setToStringTag(Constructor, CONSTRUCTOR_NAME);
        if (!IS_WEAK)
          common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
        return Constructor;
      };
    }
  });

  // node_modules/core-js/internals/collection-strong.js
  var require_collection_strong = __commonJS({
    "node_modules/core-js/internals/collection-strong.js"(exports, module) {
      "use strict";
      var defineProperty = require_object_define_property().f;
      var create = require_object_create();
      var redefineAll = require_redefine_all();
      var bind3 = require_function_bind_context();
      var anInstance = require_an_instance();
      var iterate = require_iterate();
      var defineIterator = require_define_iterator();
      var setSpecies = require_set_species();
      var DESCRIPTORS = require_descriptors();
      var fastKey = require_internal_metadata().fastKey;
      var InternalStateModule = require_internal_state();
      var setInternalState = InternalStateModule.set;
      var internalStateGetterFor = InternalStateModule.getterFor;
      module.exports = {
        getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
          var Constructor = wrapper(function(that, iterable) {
            anInstance(that, Prototype);
            setInternalState(that, {
              type: CONSTRUCTOR_NAME,
              index: create(null),
              first: void 0,
              last: void 0,
              size: 0
            });
            if (!DESCRIPTORS)
              that.size = 0;
            if (iterable != void 0)
              iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
          });
          var Prototype = Constructor.prototype;
          var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
          var define2 = function(that, key, value) {
            var state = getInternalState(that);
            var entry = getEntry(that, key);
            var previous, index;
            if (entry) {
              entry.value = value;
            } else {
              state.last = entry = {
                index: index = fastKey(key, true),
                key,
                value,
                previous: previous = state.last,
                next: void 0,
                removed: false
              };
              if (!state.first)
                state.first = entry;
              if (previous)
                previous.next = entry;
              if (DESCRIPTORS)
                state.size++;
              else
                that.size++;
              if (index !== "F")
                state.index[index] = entry;
            }
            return that;
          };
          var getEntry = function(that, key) {
            var state = getInternalState(that);
            var index = fastKey(key);
            var entry;
            if (index !== "F")
              return state.index[index];
            for (entry = state.first; entry; entry = entry.next) {
              if (entry.key == key)
                return entry;
            }
          };
          redefineAll(Prototype, {
            clear: function clear() {
              var that = this;
              var state = getInternalState(that);
              var data = state.index;
              var entry = state.first;
              while (entry) {
                entry.removed = true;
                if (entry.previous)
                  entry.previous = entry.previous.next = void 0;
                delete data[entry.index];
                entry = entry.next;
              }
              state.first = state.last = void 0;
              if (DESCRIPTORS)
                state.size = 0;
              else
                that.size = 0;
            },
            "delete": function(key) {
              var that = this;
              var state = getInternalState(that);
              var entry = getEntry(that, key);
              if (entry) {
                var next = entry.next;
                var prev = entry.previous;
                delete state.index[entry.index];
                entry.removed = true;
                if (prev)
                  prev.next = next;
                if (next)
                  next.previous = prev;
                if (state.first == entry)
                  state.first = next;
                if (state.last == entry)
                  state.last = prev;
                if (DESCRIPTORS)
                  state.size--;
                else
                  that.size--;
              }
              return !!entry;
            },
            forEach: function forEach(callbackfn) {
              var state = getInternalState(this);
              var boundFunction = bind3(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
              var entry;
              while (entry = entry ? entry.next : state.first) {
                boundFunction(entry.value, entry.key, this);
                while (entry && entry.removed)
                  entry = entry.previous;
              }
            },
            has: function has(key) {
              return !!getEntry(this, key);
            }
          });
          redefineAll(Prototype, IS_MAP ? {
            get: function get(key) {
              var entry = getEntry(this, key);
              return entry && entry.value;
            },
            set: function set(key, value) {
              return define2(this, key === 0 ? 0 : key, value);
            }
          } : {
            add: function add3(value) {
              return define2(this, value = value === 0 ? 0 : value, value);
            }
          });
          if (DESCRIPTORS)
            defineProperty(Prototype, "size", {
              get: function() {
                return getInternalState(this).size;
              }
            });
          return Constructor;
        },
        setStrong: function(Constructor, CONSTRUCTOR_NAME, IS_MAP) {
          var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
          var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
          var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
          defineIterator(Constructor, CONSTRUCTOR_NAME, function(iterated, kind) {
            setInternalState(this, {
              type: ITERATOR_NAME,
              target: iterated,
              state: getInternalCollectionState(iterated),
              kind,
              last: void 0
            });
          }, function() {
            var state = getInternalIteratorState(this);
            var kind = state.kind;
            var entry = state.last;
            while (entry && entry.removed)
              entry = entry.previous;
            if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
              state.target = void 0;
              return { value: void 0, done: true };
            }
            if (kind == "keys")
              return { value: entry.key, done: false };
            if (kind == "values")
              return { value: entry.value, done: false };
            return { value: [entry.key, entry.value], done: false };
          }, IS_MAP ? "entries" : "values", !IS_MAP, true);
          setSpecies(CONSTRUCTOR_NAME);
        }
      };
    }
  });

  // node_modules/core-js/modules/es.map.js
  var require_es_map = __commonJS({
    "node_modules/core-js/modules/es.map.js"() {
      "use strict";
      var collection = require_collection();
      var collectionStrong = require_collection_strong();
      collection("Map", function(init) {
        return function Map2() {
          return init(this, arguments.length ? arguments[0] : void 0);
        };
      }, collectionStrong);
    }
  });

  // node_modules/core-js/internals/math-log1p.js
  var require_math_log1p = __commonJS({
    "node_modules/core-js/internals/math-log1p.js"(exports, module) {
      var log = Math.log;
      module.exports = Math.log1p || function log1p(x2) {
        return (x2 = +x2) > -1e-8 && x2 < 1e-8 ? x2 - x2 * x2 / 2 : log(1 + x2);
      };
    }
  });

  // node_modules/core-js/modules/es.math.acosh.js
  var require_es_math_acosh = __commonJS({
    "node_modules/core-js/modules/es.math.acosh.js"() {
      var $2 = require_export();
      var log1p = require_math_log1p();
      var $acosh = Math.acosh;
      var log = Math.log;
      var sqrt = Math.sqrt;
      var LN2 = Math.LN2;
      var FORCED = !$acosh || Math.floor($acosh(Number.MAX_VALUE)) != 710 || $acosh(Infinity) != Infinity;
      $2({ target: "Math", stat: true, forced: FORCED }, {
        acosh: function acosh(x2) {
          return (x2 = +x2) < 1 ? NaN : x2 > 9490626562425156e-8 ? log(x2) + LN2 : log1p(x2 - 1 + sqrt(x2 - 1) * sqrt(x2 + 1));
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.asinh.js
  var require_es_math_asinh = __commonJS({
    "node_modules/core-js/modules/es.math.asinh.js"() {
      var $2 = require_export();
      var $asinh = Math.asinh;
      var log = Math.log;
      var sqrt = Math.sqrt;
      function asinh(x2) {
        return !isFinite(x2 = +x2) || x2 == 0 ? x2 : x2 < 0 ? -asinh(-x2) : log(x2 + sqrt(x2 * x2 + 1));
      }
      $2({ target: "Math", stat: true, forced: !($asinh && 1 / $asinh(0) > 0) }, {
        asinh
      });
    }
  });

  // node_modules/core-js/modules/es.math.atanh.js
  var require_es_math_atanh = __commonJS({
    "node_modules/core-js/modules/es.math.atanh.js"() {
      var $2 = require_export();
      var $atanh = Math.atanh;
      var log = Math.log;
      $2({ target: "Math", stat: true, forced: !($atanh && 1 / $atanh(-0) < 0) }, {
        atanh: function atanh(x2) {
          return (x2 = +x2) == 0 ? x2 : log((1 + x2) / (1 - x2)) / 2;
        }
      });
    }
  });

  // node_modules/core-js/internals/math-sign.js
  var require_math_sign = __commonJS({
    "node_modules/core-js/internals/math-sign.js"(exports, module) {
      module.exports = Math.sign || function sign(x2) {
        return (x2 = +x2) == 0 || x2 != x2 ? x2 : x2 < 0 ? -1 : 1;
      };
    }
  });

  // node_modules/core-js/modules/es.math.cbrt.js
  var require_es_math_cbrt = __commonJS({
    "node_modules/core-js/modules/es.math.cbrt.js"() {
      var $2 = require_export();
      var sign = require_math_sign();
      var abs = Math.abs;
      var pow = Math.pow;
      $2({ target: "Math", stat: true }, {
        cbrt: function cbrt(x2) {
          return sign(x2 = +x2) * pow(abs(x2), 1 / 3);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.clz32.js
  var require_es_math_clz32 = __commonJS({
    "node_modules/core-js/modules/es.math.clz32.js"() {
      var $2 = require_export();
      var floor = Math.floor;
      var log = Math.log;
      var LOG2E = Math.LOG2E;
      $2({ target: "Math", stat: true }, {
        clz32: function clz32(x2) {
          return (x2 >>>= 0) ? 31 - floor(log(x2 + 0.5) * LOG2E) : 32;
        }
      });
    }
  });

  // node_modules/core-js/internals/math-expm1.js
  var require_math_expm1 = __commonJS({
    "node_modules/core-js/internals/math-expm1.js"(exports, module) {
      var $expm1 = Math.expm1;
      var exp = Math.exp;
      module.exports = !$expm1 || $expm1(10) > 22025.465794806718 || $expm1(10) < 22025.465794806718 || $expm1(-2e-17) != -2e-17 ? function expm1(x2) {
        return (x2 = +x2) == 0 ? x2 : x2 > -1e-6 && x2 < 1e-6 ? x2 + x2 * x2 / 2 : exp(x2) - 1;
      } : $expm1;
    }
  });

  // node_modules/core-js/modules/es.math.cosh.js
  var require_es_math_cosh = __commonJS({
    "node_modules/core-js/modules/es.math.cosh.js"() {
      var $2 = require_export();
      var expm1 = require_math_expm1();
      var $cosh = Math.cosh;
      var abs = Math.abs;
      var E = Math.E;
      $2({ target: "Math", stat: true, forced: !$cosh || $cosh(710) === Infinity }, {
        cosh: function cosh(x2) {
          var t2 = expm1(abs(x2) - 1) + 1;
          return (t2 + 1 / (t2 * E * E)) * (E / 2);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.expm1.js
  var require_es_math_expm1 = __commonJS({
    "node_modules/core-js/modules/es.math.expm1.js"() {
      var $2 = require_export();
      var expm1 = require_math_expm1();
      $2({ target: "Math", stat: true, forced: expm1 != Math.expm1 }, { expm1 });
    }
  });

  // node_modules/core-js/internals/math-fround.js
  var require_math_fround = __commonJS({
    "node_modules/core-js/internals/math-fround.js"(exports, module) {
      var sign = require_math_sign();
      var abs = Math.abs;
      var pow = Math.pow;
      var EPSILON = pow(2, -52);
      var EPSILON32 = pow(2, -23);
      var MAX32 = pow(2, 127) * (2 - EPSILON32);
      var MIN32 = pow(2, -126);
      var roundTiesToEven = function(n2) {
        return n2 + 1 / EPSILON - 1 / EPSILON;
      };
      module.exports = Math.fround || function fround(x2) {
        var $abs = abs(x2);
        var $sign = sign(x2);
        var a2, result;
        if ($abs < MIN32)
          return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
        a2 = (1 + EPSILON32 / EPSILON) * $abs;
        result = a2 - (a2 - $abs);
        if (result > MAX32 || result != result)
          return $sign * Infinity;
        return $sign * result;
      };
    }
  });

  // node_modules/core-js/modules/es.math.fround.js
  var require_es_math_fround = __commonJS({
    "node_modules/core-js/modules/es.math.fround.js"() {
      var $2 = require_export();
      var fround = require_math_fround();
      $2({ target: "Math", stat: true }, { fround });
    }
  });

  // node_modules/core-js/modules/es.math.hypot.js
  var require_es_math_hypot = __commonJS({
    "node_modules/core-js/modules/es.math.hypot.js"() {
      var $2 = require_export();
      var $hypot = Math.hypot;
      var abs = Math.abs;
      var sqrt = Math.sqrt;
      var BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity;
      $2({ target: "Math", stat: true, forced: BUGGY }, {
        hypot: function hypot(value1, value2) {
          var sum = 0;
          var i2 = 0;
          var aLen = arguments.length;
          var larg = 0;
          var arg, div2;
          while (i2 < aLen) {
            arg = abs(arguments[i2++]);
            if (larg < arg) {
              div2 = larg / arg;
              sum = sum * div2 * div2 + 1;
              larg = arg;
            } else if (arg > 0) {
              div2 = arg / larg;
              sum += div2 * div2;
            } else
              sum += arg;
          }
          return larg === Infinity ? Infinity : larg * sqrt(sum);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.imul.js
  var require_es_math_imul = __commonJS({
    "node_modules/core-js/modules/es.math.imul.js"() {
      var $2 = require_export();
      var fails = require_fails();
      var $imul = Math.imul;
      var FORCED = fails(function() {
        return $imul(4294967295, 5) != -5 || $imul.length != 2;
      });
      $2({ target: "Math", stat: true, forced: FORCED }, {
        imul: function imul(x2, y2) {
          var UINT16 = 65535;
          var xn = +x2;
          var yn = +y2;
          var xl = UINT16 & xn;
          var yl = UINT16 & yn;
          return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
        }
      });
    }
  });

  // node_modules/core-js/internals/math-log10.js
  var require_math_log10 = __commonJS({
    "node_modules/core-js/internals/math-log10.js"(exports, module) {
      var log = Math.log;
      var LOG10E = Math.LOG10E;
      module.exports = Math.log10 || function log10(x2) {
        return log(x2) * LOG10E;
      };
    }
  });

  // node_modules/core-js/modules/es.math.log10.js
  var require_es_math_log10 = __commonJS({
    "node_modules/core-js/modules/es.math.log10.js"() {
      var $2 = require_export();
      var log10 = require_math_log10();
      $2({ target: "Math", stat: true }, {
        log10
      });
    }
  });

  // node_modules/core-js/modules/es.math.log1p.js
  var require_es_math_log1p = __commonJS({
    "node_modules/core-js/modules/es.math.log1p.js"() {
      var $2 = require_export();
      var log1p = require_math_log1p();
      $2({ target: "Math", stat: true }, { log1p });
    }
  });

  // node_modules/core-js/modules/es.math.log2.js
  var require_es_math_log2 = __commonJS({
    "node_modules/core-js/modules/es.math.log2.js"() {
      var $2 = require_export();
      var log = Math.log;
      var LN2 = Math.LN2;
      $2({ target: "Math", stat: true }, {
        log2: function log2(x2) {
          return log(x2) / LN2;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.sign.js
  var require_es_math_sign = __commonJS({
    "node_modules/core-js/modules/es.math.sign.js"() {
      var $2 = require_export();
      var sign = require_math_sign();
      $2({ target: "Math", stat: true }, {
        sign
      });
    }
  });

  // node_modules/core-js/modules/es.math.sinh.js
  var require_es_math_sinh = __commonJS({
    "node_modules/core-js/modules/es.math.sinh.js"() {
      var $2 = require_export();
      var fails = require_fails();
      var expm1 = require_math_expm1();
      var abs = Math.abs;
      var exp = Math.exp;
      var E = Math.E;
      var FORCED = fails(function() {
        return Math.sinh(-2e-17) != -2e-17;
      });
      $2({ target: "Math", stat: true, forced: FORCED }, {
        sinh: function sinh(x2) {
          return abs(x2 = +x2) < 1 ? (expm1(x2) - expm1(-x2)) / 2 : (exp(x2 - 1) - exp(-x2 - 1)) * (E / 2);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.tanh.js
  var require_es_math_tanh = __commonJS({
    "node_modules/core-js/modules/es.math.tanh.js"() {
      var $2 = require_export();
      var expm1 = require_math_expm1();
      var exp = Math.exp;
      $2({ target: "Math", stat: true }, {
        tanh: function tanh(x2) {
          var a2 = expm1(x2 = +x2);
          var b2 = expm1(-x2);
          return a2 == Infinity ? 1 : b2 == Infinity ? -1 : (a2 - b2) / (exp(x2) + exp(-x2));
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.to-string-tag.js
  var require_es_math_to_string_tag = __commonJS({
    "node_modules/core-js/modules/es.math.to-string-tag.js"() {
      var setToStringTag = require_set_to_string_tag();
      setToStringTag(Math, "Math", true);
    }
  });

  // node_modules/core-js/modules/es.math.trunc.js
  var require_es_math_trunc = __commonJS({
    "node_modules/core-js/modules/es.math.trunc.js"() {
      var $2 = require_export();
      var ceil = Math.ceil;
      var floor = Math.floor;
      $2({ target: "Math", stat: true }, {
        trunc: function trunc(it) {
          return (it > 0 ? floor : ceil)(it);
        }
      });
    }
  });

  // node_modules/core-js/internals/this-number-value.js
  var require_this_number_value = __commonJS({
    "node_modules/core-js/internals/this-number-value.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      module.exports = uncurryThis(1 .valueOf);
    }
  });

  // node_modules/core-js/internals/whitespaces.js
  var require_whitespaces = __commonJS({
    "node_modules/core-js/internals/whitespaces.js"(exports, module) {
      module.exports = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
    }
  });

  // node_modules/core-js/internals/string-trim.js
  var require_string_trim = __commonJS({
    "node_modules/core-js/internals/string-trim.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var toString = require_to_string();
      var whitespaces = require_whitespaces();
      var replace = uncurryThis("".replace);
      var whitespace = "[" + whitespaces + "]";
      var ltrim = RegExp("^" + whitespace + whitespace + "*");
      var rtrim = RegExp(whitespace + whitespace + "*$");
      var createMethod = function(TYPE) {
        return function($this) {
          var string = toString(requireObjectCoercible($this));
          if (TYPE & 1)
            string = replace(string, ltrim, "");
          if (TYPE & 2)
            string = replace(string, rtrim, "");
          return string;
        };
      };
      module.exports = {
        start: createMethod(1),
        end: createMethod(2),
        trim: createMethod(3)
      };
    }
  });

  // node_modules/core-js/modules/es.number.constructor.js
  var require_es_number_constructor = __commonJS({
    "node_modules/core-js/modules/es.number.constructor.js"() {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this();
      var isForced = require_is_forced();
      var redefine = require_redefine();
      var hasOwn = require_has_own_property();
      var inheritIfRequired = require_inherit_if_required();
      var isPrototypeOf = require_object_is_prototype_of();
      var isSymbol = require_is_symbol();
      var toPrimitive = require_to_primitive();
      var fails = require_fails();
      var getOwnPropertyNames = require_object_get_own_property_names().f;
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      var defineProperty = require_object_define_property().f;
      var thisNumberValue = require_this_number_value();
      var trim = require_string_trim().trim;
      var NUMBER = "Number";
      var NativeNumber = global2[NUMBER];
      var NumberPrototype = NativeNumber.prototype;
      var TypeError2 = global2.TypeError;
      var arraySlice = uncurryThis("".slice);
      var charCodeAt = uncurryThis("".charCodeAt);
      var toNumeric = function(value) {
        var primValue = toPrimitive(value, "number");
        return typeof primValue == "bigint" ? primValue : toNumber(primValue);
      };
      var toNumber = function(argument) {
        var it = toPrimitive(argument, "number");
        var first, third, radix, maxCode, digits, length, index, code3;
        if (isSymbol(it))
          throw TypeError2("Cannot convert a Symbol value to a number");
        if (typeof it == "string" && it.length > 2) {
          it = trim(it);
          first = charCodeAt(it, 0);
          if (first === 43 || first === 45) {
            third = charCodeAt(it, 2);
            if (third === 88 || third === 120)
              return NaN;
          } else if (first === 48) {
            switch (charCodeAt(it, 1)) {
              case 66:
              case 98:
                radix = 2;
                maxCode = 49;
                break;
              case 79:
              case 111:
                radix = 8;
                maxCode = 55;
                break;
              default:
                return +it;
            }
            digits = arraySlice(it, 2);
            length = digits.length;
            for (index = 0; index < length; index++) {
              code3 = charCodeAt(digits, index);
              if (code3 < 48 || code3 > maxCode)
                return NaN;
            }
            return parseInt(digits, radix);
          }
        }
        return +it;
      };
      if (isForced(NUMBER, !NativeNumber(" 0o1") || !NativeNumber("0b1") || NativeNumber("+0x1"))) {
        NumberWrapper = function Number2(value) {
          var n2 = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
          var dummy = this;
          return isPrototypeOf(NumberPrototype, dummy) && fails(function() {
            thisNumberValue(dummy);
          }) ? inheritIfRequired(Object(n2), dummy, NumberWrapper) : n2;
        };
        for (keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","), j2 = 0; keys.length > j2; j2++) {
          if (hasOwn(NativeNumber, key = keys[j2]) && !hasOwn(NumberWrapper, key)) {
            defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
          }
        }
        NumberWrapper.prototype = NumberPrototype;
        NumberPrototype.constructor = NumberWrapper;
        redefine(global2, NUMBER, NumberWrapper);
      }
      var NumberWrapper;
      var keys;
      var j2;
      var key;
    }
  });

  // node_modules/core-js/modules/es.number.epsilon.js
  var require_es_number_epsilon = __commonJS({
    "node_modules/core-js/modules/es.number.epsilon.js"() {
      var $2 = require_export();
      $2({ target: "Number", stat: true }, {
        EPSILON: Math.pow(2, -52)
      });
    }
  });

  // node_modules/core-js/internals/number-is-finite.js
  var require_number_is_finite = __commonJS({
    "node_modules/core-js/internals/number-is-finite.js"(exports, module) {
      var global2 = require_global();
      var globalIsFinite = global2.isFinite;
      module.exports = Number.isFinite || function isFinite2(it) {
        return typeof it == "number" && globalIsFinite(it);
      };
    }
  });

  // node_modules/core-js/modules/es.number.is-finite.js
  var require_es_number_is_finite = __commonJS({
    "node_modules/core-js/modules/es.number.is-finite.js"() {
      var $2 = require_export();
      var numberIsFinite = require_number_is_finite();
      $2({ target: "Number", stat: true }, { isFinite: numberIsFinite });
    }
  });

  // node_modules/core-js/internals/is-integral-number.js
  var require_is_integral_number = __commonJS({
    "node_modules/core-js/internals/is-integral-number.js"(exports, module) {
      var isObject3 = require_is_object();
      var floor = Math.floor;
      module.exports = Number.isInteger || function isInteger(it) {
        return !isObject3(it) && isFinite(it) && floor(it) === it;
      };
    }
  });

  // node_modules/core-js/modules/es.number.is-integer.js
  var require_es_number_is_integer = __commonJS({
    "node_modules/core-js/modules/es.number.is-integer.js"() {
      var $2 = require_export();
      var isIntegralNumber = require_is_integral_number();
      $2({ target: "Number", stat: true }, {
        isInteger: isIntegralNumber
      });
    }
  });

  // node_modules/core-js/modules/es.number.is-nan.js
  var require_es_number_is_nan = __commonJS({
    "node_modules/core-js/modules/es.number.is-nan.js"() {
      var $2 = require_export();
      $2({ target: "Number", stat: true }, {
        isNaN: function isNaN2(number) {
          return number != number;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.number.is-safe-integer.js
  var require_es_number_is_safe_integer = __commonJS({
    "node_modules/core-js/modules/es.number.is-safe-integer.js"() {
      var $2 = require_export();
      var isIntegralNumber = require_is_integral_number();
      var abs = Math.abs;
      $2({ target: "Number", stat: true }, {
        isSafeInteger: function isSafeInteger(number) {
          return isIntegralNumber(number) && abs(number) <= 9007199254740991;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.number.max-safe-integer.js
  var require_es_number_max_safe_integer = __commonJS({
    "node_modules/core-js/modules/es.number.max-safe-integer.js"() {
      var $2 = require_export();
      $2({ target: "Number", stat: true }, {
        MAX_SAFE_INTEGER: 9007199254740991
      });
    }
  });

  // node_modules/core-js/modules/es.number.min-safe-integer.js
  var require_es_number_min_safe_integer = __commonJS({
    "node_modules/core-js/modules/es.number.min-safe-integer.js"() {
      var $2 = require_export();
      $2({ target: "Number", stat: true }, {
        MIN_SAFE_INTEGER: -9007199254740991
      });
    }
  });

  // node_modules/core-js/internals/number-parse-float.js
  var require_number_parse_float = __commonJS({
    "node_modules/core-js/internals/number-parse-float.js"(exports, module) {
      var global2 = require_global();
      var fails = require_fails();
      var uncurryThis = require_function_uncurry_this();
      var toString = require_to_string();
      var trim = require_string_trim().trim;
      var whitespaces = require_whitespaces();
      var charAt = uncurryThis("".charAt);
      var n$ParseFloat = global2.parseFloat;
      var Symbol2 = global2.Symbol;
      var ITERATOR = Symbol2 && Symbol2.iterator;
      var FORCED = 1 / n$ParseFloat(whitespaces + "-0") !== -Infinity || ITERATOR && !fails(function() {
        n$ParseFloat(Object(ITERATOR));
      });
      module.exports = FORCED ? function parseFloat2(string) {
        var trimmedString = trim(toString(string));
        var result = n$ParseFloat(trimmedString);
        return result === 0 && charAt(trimmedString, 0) == "-" ? -0 : result;
      } : n$ParseFloat;
    }
  });

  // node_modules/core-js/modules/es.number.parse-float.js
  var require_es_number_parse_float = __commonJS({
    "node_modules/core-js/modules/es.number.parse-float.js"() {
      var $2 = require_export();
      var parseFloat2 = require_number_parse_float();
      $2({ target: "Number", stat: true, forced: Number.parseFloat != parseFloat2 }, {
        parseFloat: parseFloat2
      });
    }
  });

  // node_modules/core-js/internals/number-parse-int.js
  var require_number_parse_int = __commonJS({
    "node_modules/core-js/internals/number-parse-int.js"(exports, module) {
      var global2 = require_global();
      var fails = require_fails();
      var uncurryThis = require_function_uncurry_this();
      var toString = require_to_string();
      var trim = require_string_trim().trim;
      var whitespaces = require_whitespaces();
      var $parseInt = global2.parseInt;
      var Symbol2 = global2.Symbol;
      var ITERATOR = Symbol2 && Symbol2.iterator;
      var hex = /^[+-]?0x/i;
      var exec = uncurryThis(hex.exec);
      var FORCED = $parseInt(whitespaces + "08") !== 8 || $parseInt(whitespaces + "0x16") !== 22 || ITERATOR && !fails(function() {
        $parseInt(Object(ITERATOR));
      });
      module.exports = FORCED ? function parseInt2(string, radix) {
        var S = trim(toString(string));
        return $parseInt(S, radix >>> 0 || (exec(hex, S) ? 16 : 10));
      } : $parseInt;
    }
  });

  // node_modules/core-js/modules/es.number.parse-int.js
  var require_es_number_parse_int = __commonJS({
    "node_modules/core-js/modules/es.number.parse-int.js"() {
      var $2 = require_export();
      var parseInt2 = require_number_parse_int();
      $2({ target: "Number", stat: true, forced: Number.parseInt != parseInt2 }, {
        parseInt: parseInt2
      });
    }
  });

  // node_modules/core-js/modules/es.number.to-exponential.js
  var require_es_number_to_exponential = __commonJS({
    "node_modules/core-js/modules/es.number.to-exponential.js"() {
      "use strict";
      var $2 = require_export();
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var thisNumberValue = require_this_number_value();
      var $repeat = require_string_repeat();
      var log10 = require_math_log10();
      var fails = require_fails();
      var RangeError2 = global2.RangeError;
      var String2 = global2.String;
      var isFinite2 = global2.isFinite;
      var abs = Math.abs;
      var floor = Math.floor;
      var pow = Math.pow;
      var round2 = Math.round;
      var un$ToExponential = uncurryThis(1 .toExponential);
      var repeat = uncurryThis($repeat);
      var stringSlice = uncurryThis("".slice);
      var ROUNDS_PROPERLY = un$ToExponential(-69e-12, 4) === "-6.9000e-11" && un$ToExponential(1.255, 2) === "1.25e+0" && un$ToExponential(12345, 3) === "1.235e+4" && un$ToExponential(25, 0) === "3e+1";
      var THROWS_ON_INFINITY_FRACTION = fails(function() {
        un$ToExponential(1, Infinity);
      }) && fails(function() {
        un$ToExponential(1, -Infinity);
      });
      var PROPER_NON_FINITE_THIS_CHECK = !fails(function() {
        un$ToExponential(Infinity, Infinity);
      }) && !fails(function() {
        un$ToExponential(NaN, Infinity);
      });
      var FORCED = !ROUNDS_PROPERLY || !THROWS_ON_INFINITY_FRACTION || !PROPER_NON_FINITE_THIS_CHECK;
      $2({ target: "Number", proto: true, forced: FORCED }, {
        toExponential: function toExponential(fractionDigits) {
          var x2 = thisNumberValue(this);
          if (fractionDigits === void 0)
            return un$ToExponential(x2);
          var f2 = toIntegerOrInfinity(fractionDigits);
          if (!isFinite2(x2))
            return String2(x2);
          if (f2 < 0 || f2 > 20)
            throw RangeError2("Incorrect fraction digits");
          if (ROUNDS_PROPERLY)
            return un$ToExponential(x2, f2);
          var s2 = "";
          var m2 = "";
          var e2 = 0;
          var c2 = "";
          var d2 = "";
          if (x2 < 0) {
            s2 = "-";
            x2 = -x2;
          }
          if (x2 === 0) {
            e2 = 0;
            m2 = repeat("0", f2 + 1);
          } else {
            var l2 = log10(x2);
            e2 = floor(l2);
            var n2 = 0;
            var w = pow(10, e2 - f2);
            n2 = round2(x2 / w);
            if (2 * x2 >= (2 * n2 + 1) * w) {
              n2 += 1;
            }
            if (n2 >= pow(10, f2 + 1)) {
              n2 /= 10;
              e2 += 1;
            }
            m2 = String2(n2);
          }
          if (f2 !== 0) {
            m2 = stringSlice(m2, 0, 1) + "." + stringSlice(m2, 1);
          }
          if (e2 === 0) {
            c2 = "+";
            d2 = "0";
          } else {
            c2 = e2 > 0 ? "+" : "-";
            d2 = String2(abs(e2));
          }
          m2 += "e" + c2 + d2;
          return s2 + m2;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.number.to-fixed.js
  var require_es_number_to_fixed = __commonJS({
    "node_modules/core-js/modules/es.number.to-fixed.js"() {
      "use strict";
      var $2 = require_export();
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var thisNumberValue = require_this_number_value();
      var $repeat = require_string_repeat();
      var fails = require_fails();
      var RangeError2 = global2.RangeError;
      var String2 = global2.String;
      var floor = Math.floor;
      var repeat = uncurryThis($repeat);
      var stringSlice = uncurryThis("".slice);
      var un$ToFixed = uncurryThis(1 .toFixed);
      var pow = function(x2, n2, acc) {
        return n2 === 0 ? acc : n2 % 2 === 1 ? pow(x2, n2 - 1, acc * x2) : pow(x2 * x2, n2 / 2, acc);
      };
      var log = function(x2) {
        var n2 = 0;
        var x22 = x2;
        while (x22 >= 4096) {
          n2 += 12;
          x22 /= 4096;
        }
        while (x22 >= 2) {
          n2 += 1;
          x22 /= 2;
        }
        return n2;
      };
      var multiply = function(data, n2, c2) {
        var index = -1;
        var c22 = c2;
        while (++index < 6) {
          c22 += n2 * data[index];
          data[index] = c22 % 1e7;
          c22 = floor(c22 / 1e7);
        }
      };
      var divide = function(data, n2) {
        var index = 6;
        var c2 = 0;
        while (--index >= 0) {
          c2 += data[index];
          data[index] = floor(c2 / n2);
          c2 = c2 % n2 * 1e7;
        }
      };
      var dataToString = function(data) {
        var index = 6;
        var s2 = "";
        while (--index >= 0) {
          if (s2 !== "" || index === 0 || data[index] !== 0) {
            var t2 = String2(data[index]);
            s2 = s2 === "" ? t2 : s2 + repeat("0", 7 - t2.length) + t2;
          }
        }
        return s2;
      };
      var FORCED = fails(function() {
        return un$ToFixed(8e-5, 3) !== "0.000" || un$ToFixed(0.9, 0) !== "1" || un$ToFixed(1.255, 2) !== "1.25" || un$ToFixed(1000000000000000100, 0) !== "1000000000000000128";
      }) || !fails(function() {
        un$ToFixed({});
      });
      $2({ target: "Number", proto: true, forced: FORCED }, {
        toFixed: function toFixed(fractionDigits) {
          var number = thisNumberValue(this);
          var fractDigits = toIntegerOrInfinity(fractionDigits);
          var data = [0, 0, 0, 0, 0, 0];
          var sign = "";
          var result = "0";
          var e2, z2, j2, k2;
          if (fractDigits < 0 || fractDigits > 20)
            throw RangeError2("Incorrect fraction digits");
          if (number != number)
            return "NaN";
          if (number <= -1e21 || number >= 1e21)
            return String2(number);
          if (number < 0) {
            sign = "-";
            number = -number;
          }
          if (number > 1e-21) {
            e2 = log(number * pow(2, 69, 1)) - 69;
            z2 = e2 < 0 ? number * pow(2, -e2, 1) : number / pow(2, e2, 1);
            z2 *= 4503599627370496;
            e2 = 52 - e2;
            if (e2 > 0) {
              multiply(data, 0, z2);
              j2 = fractDigits;
              while (j2 >= 7) {
                multiply(data, 1e7, 0);
                j2 -= 7;
              }
              multiply(data, pow(10, j2, 1), 0);
              j2 = e2 - 1;
              while (j2 >= 23) {
                divide(data, 1 << 23);
                j2 -= 23;
              }
              divide(data, 1 << j2);
              multiply(data, 1, 1);
              divide(data, 2);
              result = dataToString(data);
            } else {
              multiply(data, 0, z2);
              multiply(data, 1 << -e2, 0);
              result = dataToString(data) + repeat("0", fractDigits);
            }
          }
          if (fractDigits > 0) {
            k2 = result.length;
            result = sign + (k2 <= fractDigits ? "0." + repeat("0", fractDigits - k2) + result : stringSlice(result, 0, k2 - fractDigits) + "." + stringSlice(result, k2 - fractDigits));
          } else {
            result = sign + result;
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.number.to-precision.js
  var require_es_number_to_precision = __commonJS({
    "node_modules/core-js/modules/es.number.to-precision.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var thisNumberValue = require_this_number_value();
      var un$ToPrecision = uncurryThis(1 .toPrecision);
      var FORCED = fails(function() {
        return un$ToPrecision(1, void 0) !== "1";
      }) || !fails(function() {
        un$ToPrecision({});
      });
      $2({ target: "Number", proto: true, forced: FORCED }, {
        toPrecision: function toPrecision(precision) {
          return precision === void 0 ? un$ToPrecision(thisNumberValue(this)) : un$ToPrecision(thisNumberValue(this), precision);
        }
      });
    }
  });

  // node_modules/core-js/internals/object-assign.js
  var require_object_assign = __commonJS({
    "node_modules/core-js/internals/object-assign.js"(exports, module) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var uncurryThis = require_function_uncurry_this();
      var call = require_function_call();
      var fails = require_fails();
      var objectKeys = require_object_keys();
      var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
      var propertyIsEnumerableModule = require_object_property_is_enumerable();
      var toObject = require_to_object();
      var IndexedObject = require_indexed_object();
      var $assign = Object.assign;
      var defineProperty = Object.defineProperty;
      var concat = uncurryThis([].concat);
      module.exports = !$assign || fails(function() {
        if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, "a", {
          enumerable: true,
          get: function() {
            defineProperty(this, "b", {
              value: 3,
              enumerable: false
            });
          }
        }), { b: 2 })).b !== 1)
          return true;
        var A2 = {};
        var B = {};
        var symbol = Symbol();
        var alphabet = "abcdefghijklmnopqrst";
        A2[symbol] = 7;
        alphabet.split("").forEach(function(chr) {
          B[chr] = chr;
        });
        return $assign({}, A2)[symbol] != 7 || objectKeys($assign({}, B)).join("") != alphabet;
      }) ? function assign(target, source) {
        var T2 = toObject(target);
        var argumentsLength = arguments.length;
        var index = 1;
        var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
        var propertyIsEnumerable = propertyIsEnumerableModule.f;
        while (argumentsLength > index) {
          var S = IndexedObject(arguments[index++]);
          var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);
          var length = keys.length;
          var j2 = 0;
          var key;
          while (length > j2) {
            key = keys[j2++];
            if (!DESCRIPTORS || call(propertyIsEnumerable, S, key))
              T2[key] = S[key];
          }
        }
        return T2;
      } : $assign;
    }
  });

  // node_modules/core-js/modules/es.object.assign.js
  var require_es_object_assign = __commonJS({
    "node_modules/core-js/modules/es.object.assign.js"() {
      var $2 = require_export();
      var assign = require_object_assign();
      $2({ target: "Object", stat: true, forced: Object.assign !== assign }, {
        assign
      });
    }
  });

  // node_modules/core-js/modules/es.object.create.js
  var require_es_object_create = __commonJS({
    "node_modules/core-js/modules/es.object.create.js"() {
      var $2 = require_export();
      var DESCRIPTORS = require_descriptors();
      var create = require_object_create();
      $2({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
        create
      });
    }
  });

  // node_modules/core-js/internals/object-prototype-accessors-forced.js
  var require_object_prototype_accessors_forced = __commonJS({
    "node_modules/core-js/internals/object-prototype-accessors-forced.js"(exports, module) {
      "use strict";
      var IS_PURE = require_is_pure();
      var global2 = require_global();
      var fails = require_fails();
      var WEBKIT = require_engine_webkit_version();
      module.exports = IS_PURE || !fails(function() {
        if (WEBKIT && WEBKIT < 535)
          return;
        var key = Math.random();
        __defineSetter__.call(null, key, function() {
        });
        delete global2[key];
      });
    }
  });

  // node_modules/core-js/modules/es.object.define-getter.js
  var require_es_object_define_getter = __commonJS({
    "node_modules/core-js/modules/es.object.define-getter.js"() {
      "use strict";
      var $2 = require_export();
      var DESCRIPTORS = require_descriptors();
      var FORCED = require_object_prototype_accessors_forced();
      var aCallable = require_a_callable();
      var toObject = require_to_object();
      var definePropertyModule = require_object_define_property();
      if (DESCRIPTORS) {
        $2({ target: "Object", proto: true, forced: FORCED }, {
          __defineGetter__: function __defineGetter__(P2, getter) {
            definePropertyModule.f(toObject(this), P2, { get: aCallable(getter), enumerable: true, configurable: true });
          }
        });
      }
    }
  });

  // node_modules/core-js/modules/es.object.define-properties.js
  var require_es_object_define_properties = __commonJS({
    "node_modules/core-js/modules/es.object.define-properties.js"() {
      var $2 = require_export();
      var DESCRIPTORS = require_descriptors();
      var defineProperties = require_object_define_properties().f;
      $2({ target: "Object", stat: true, forced: Object.defineProperties !== defineProperties, sham: !DESCRIPTORS }, {
        defineProperties
      });
    }
  });

  // node_modules/core-js/modules/es.object.define-property.js
  var require_es_object_define_property = __commonJS({
    "node_modules/core-js/modules/es.object.define-property.js"() {
      var $2 = require_export();
      var DESCRIPTORS = require_descriptors();
      var defineProperty = require_object_define_property().f;
      $2({ target: "Object", stat: true, forced: Object.defineProperty !== defineProperty, sham: !DESCRIPTORS }, {
        defineProperty
      });
    }
  });

  // node_modules/core-js/modules/es.object.define-setter.js
  var require_es_object_define_setter = __commonJS({
    "node_modules/core-js/modules/es.object.define-setter.js"() {
      "use strict";
      var $2 = require_export();
      var DESCRIPTORS = require_descriptors();
      var FORCED = require_object_prototype_accessors_forced();
      var aCallable = require_a_callable();
      var toObject = require_to_object();
      var definePropertyModule = require_object_define_property();
      if (DESCRIPTORS) {
        $2({ target: "Object", proto: true, forced: FORCED }, {
          __defineSetter__: function __defineSetter__2(P2, setter) {
            definePropertyModule.f(toObject(this), P2, { set: aCallable(setter), enumerable: true, configurable: true });
          }
        });
      }
    }
  });

  // node_modules/core-js/internals/object-to-array.js
  var require_object_to_array = __commonJS({
    "node_modules/core-js/internals/object-to-array.js"(exports, module) {
      var DESCRIPTORS = require_descriptors();
      var uncurryThis = require_function_uncurry_this();
      var objectKeys = require_object_keys();
      var toIndexedObject = require_to_indexed_object();
      var $propertyIsEnumerable = require_object_property_is_enumerable().f;
      var propertyIsEnumerable = uncurryThis($propertyIsEnumerable);
      var push = uncurryThis([].push);
      var createMethod = function(TO_ENTRIES) {
        return function(it) {
          var O = toIndexedObject(it);
          var keys = objectKeys(O);
          var length = keys.length;
          var i2 = 0;
          var result = [];
          var key;
          while (length > i2) {
            key = keys[i2++];
            if (!DESCRIPTORS || propertyIsEnumerable(O, key)) {
              push(result, TO_ENTRIES ? [key, O[key]] : O[key]);
            }
          }
          return result;
        };
      };
      module.exports = {
        entries: createMethod(true),
        values: createMethod(false)
      };
    }
  });

  // node_modules/core-js/modules/es.object.entries.js
  var require_es_object_entries = __commonJS({
    "node_modules/core-js/modules/es.object.entries.js"() {
      var $2 = require_export();
      var $entries = require_object_to_array().entries;
      $2({ target: "Object", stat: true }, {
        entries: function entries(O) {
          return $entries(O);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.freeze.js
  var require_es_object_freeze = __commonJS({
    "node_modules/core-js/modules/es.object.freeze.js"() {
      var $2 = require_export();
      var FREEZING = require_freezing();
      var fails = require_fails();
      var isObject3 = require_is_object();
      var onFreeze = require_internal_metadata().onFreeze;
      var $freeze = Object.freeze;
      var FAILS_ON_PRIMITIVES = fails(function() {
        $freeze(1);
      });
      $2({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
        freeze: function freeze(it) {
          return $freeze && isObject3(it) ? $freeze(onFreeze(it)) : it;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.from-entries.js
  var require_es_object_from_entries = __commonJS({
    "node_modules/core-js/modules/es.object.from-entries.js"() {
      var $2 = require_export();
      var iterate = require_iterate();
      var createProperty = require_create_property();
      $2({ target: "Object", stat: true }, {
        fromEntries: function fromEntries(iterable) {
          var obj = {};
          iterate(iterable, function(k2, v2) {
            createProperty(obj, k2, v2);
          }, { AS_ENTRIES: true });
          return obj;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.get-own-property-descriptor.js
  var require_es_object_get_own_property_descriptor = __commonJS({
    "node_modules/core-js/modules/es.object.get-own-property-descriptor.js"() {
      var $2 = require_export();
      var fails = require_fails();
      var toIndexedObject = require_to_indexed_object();
      var nativeGetOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      var DESCRIPTORS = require_descriptors();
      var FAILS_ON_PRIMITIVES = fails(function() {
        nativeGetOwnPropertyDescriptor(1);
      });
      var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;
      $2({ target: "Object", stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
        getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
          return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.get-own-property-descriptors.js
  var require_es_object_get_own_property_descriptors = __commonJS({
    "node_modules/core-js/modules/es.object.get-own-property-descriptors.js"() {
      var $2 = require_export();
      var DESCRIPTORS = require_descriptors();
      var ownKeys17 = require_own_keys();
      var toIndexedObject = require_to_indexed_object();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var createProperty = require_create_property();
      $2({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
        getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
          var O = toIndexedObject(object);
          var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
          var keys = ownKeys17(O);
          var result = {};
          var index = 0;
          var key, descriptor;
          while (keys.length > index) {
            descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
            if (descriptor !== void 0)
              createProperty(result, key, descriptor);
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.get-own-property-names.js
  var require_es_object_get_own_property_names = __commonJS({
    "node_modules/core-js/modules/es.object.get-own-property-names.js"() {
      var $2 = require_export();
      var fails = require_fails();
      var getOwnPropertyNames = require_object_get_own_property_names_external().f;
      var FAILS_ON_PRIMITIVES = fails(function() {
        return !Object.getOwnPropertyNames(1);
      });
      $2({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
        getOwnPropertyNames
      });
    }
  });

  // node_modules/core-js/modules/es.object.get-prototype-of.js
  var require_es_object_get_prototype_of = __commonJS({
    "node_modules/core-js/modules/es.object.get-prototype-of.js"() {
      var $2 = require_export();
      var fails = require_fails();
      var toObject = require_to_object();
      var nativeGetPrototypeOf = require_object_get_prototype_of();
      var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
      var FAILS_ON_PRIMITIVES = fails(function() {
        nativeGetPrototypeOf(1);
      });
      $2({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
        getPrototypeOf: function getPrototypeOf(it) {
          return nativeGetPrototypeOf(toObject(it));
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.has-own.js
  var require_es_object_has_own = __commonJS({
    "node_modules/core-js/modules/es.object.has-own.js"() {
      var $2 = require_export();
      var hasOwn = require_has_own_property();
      $2({ target: "Object", stat: true }, {
        hasOwn
      });
    }
  });

  // node_modules/core-js/internals/same-value.js
  var require_same_value = __commonJS({
    "node_modules/core-js/internals/same-value.js"(exports, module) {
      module.exports = Object.is || function is(x2, y2) {
        return x2 === y2 ? x2 !== 0 || 1 / x2 === 1 / y2 : x2 != x2 && y2 != y2;
      };
    }
  });

  // node_modules/core-js/modules/es.object.is.js
  var require_es_object_is = __commonJS({
    "node_modules/core-js/modules/es.object.is.js"() {
      var $2 = require_export();
      var is = require_same_value();
      $2({ target: "Object", stat: true }, {
        is
      });
    }
  });

  // node_modules/core-js/modules/es.object.is-extensible.js
  var require_es_object_is_extensible = __commonJS({
    "node_modules/core-js/modules/es.object.is-extensible.js"() {
      var $2 = require_export();
      var $isExtensible = require_object_is_extensible();
      $2({ target: "Object", stat: true, forced: Object.isExtensible !== $isExtensible }, {
        isExtensible: $isExtensible
      });
    }
  });

  // node_modules/core-js/modules/es.object.is-frozen.js
  var require_es_object_is_frozen = __commonJS({
    "node_modules/core-js/modules/es.object.is-frozen.js"() {
      var $2 = require_export();
      var fails = require_fails();
      var isObject3 = require_is_object();
      var classof = require_classof_raw();
      var ARRAY_BUFFER_NON_EXTENSIBLE = require_array_buffer_non_extensible();
      var $isFrozen = Object.isFrozen;
      var FAILS_ON_PRIMITIVES = fails(function() {
        $isFrozen(1);
      });
      $2({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE }, {
        isFrozen: function isFrozen(it) {
          if (!isObject3(it))
            return true;
          if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) == "ArrayBuffer")
            return true;
          return $isFrozen ? $isFrozen(it) : false;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.is-sealed.js
  var require_es_object_is_sealed = __commonJS({
    "node_modules/core-js/modules/es.object.is-sealed.js"() {
      var $2 = require_export();
      var fails = require_fails();
      var isObject3 = require_is_object();
      var classof = require_classof_raw();
      var ARRAY_BUFFER_NON_EXTENSIBLE = require_array_buffer_non_extensible();
      var $isSealed = Object.isSealed;
      var FAILS_ON_PRIMITIVES = fails(function() {
        $isSealed(1);
      });
      $2({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE }, {
        isSealed: function isSealed(it) {
          if (!isObject3(it))
            return true;
          if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) == "ArrayBuffer")
            return true;
          return $isSealed ? $isSealed(it) : false;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.keys.js
  var require_es_object_keys = __commonJS({
    "node_modules/core-js/modules/es.object.keys.js"() {
      var $2 = require_export();
      var toObject = require_to_object();
      var nativeKeys = require_object_keys();
      var fails = require_fails();
      var FAILS_ON_PRIMITIVES = fails(function() {
        nativeKeys(1);
      });
      $2({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
        keys: function keys(it) {
          return nativeKeys(toObject(it));
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.lookup-getter.js
  var require_es_object_lookup_getter = __commonJS({
    "node_modules/core-js/modules/es.object.lookup-getter.js"() {
      "use strict";
      var $2 = require_export();
      var DESCRIPTORS = require_descriptors();
      var FORCED = require_object_prototype_accessors_forced();
      var toObject = require_to_object();
      var toPropertyKey = require_to_property_key();
      var getPrototypeOf = require_object_get_prototype_of();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      if (DESCRIPTORS) {
        $2({ target: "Object", proto: true, forced: FORCED }, {
          __lookupGetter__: function __lookupGetter__(P2) {
            var O = toObject(this);
            var key = toPropertyKey(P2);
            var desc;
            do {
              if (desc = getOwnPropertyDescriptor(O, key))
                return desc.get;
            } while (O = getPrototypeOf(O));
          }
        });
      }
    }
  });

  // node_modules/core-js/modules/es.object.lookup-setter.js
  var require_es_object_lookup_setter = __commonJS({
    "node_modules/core-js/modules/es.object.lookup-setter.js"() {
      "use strict";
      var $2 = require_export();
      var DESCRIPTORS = require_descriptors();
      var FORCED = require_object_prototype_accessors_forced();
      var toObject = require_to_object();
      var toPropertyKey = require_to_property_key();
      var getPrototypeOf = require_object_get_prototype_of();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      if (DESCRIPTORS) {
        $2({ target: "Object", proto: true, forced: FORCED }, {
          __lookupSetter__: function __lookupSetter__(P2) {
            var O = toObject(this);
            var key = toPropertyKey(P2);
            var desc;
            do {
              if (desc = getOwnPropertyDescriptor(O, key))
                return desc.set;
            } while (O = getPrototypeOf(O));
          }
        });
      }
    }
  });

  // node_modules/core-js/modules/es.object.prevent-extensions.js
  var require_es_object_prevent_extensions = __commonJS({
    "node_modules/core-js/modules/es.object.prevent-extensions.js"() {
      var $2 = require_export();
      var isObject3 = require_is_object();
      var onFreeze = require_internal_metadata().onFreeze;
      var FREEZING = require_freezing();
      var fails = require_fails();
      var $preventExtensions = Object.preventExtensions;
      var FAILS_ON_PRIMITIVES = fails(function() {
        $preventExtensions(1);
      });
      $2({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
        preventExtensions: function preventExtensions(it) {
          return $preventExtensions && isObject3(it) ? $preventExtensions(onFreeze(it)) : it;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.seal.js
  var require_es_object_seal = __commonJS({
    "node_modules/core-js/modules/es.object.seal.js"() {
      var $2 = require_export();
      var isObject3 = require_is_object();
      var onFreeze = require_internal_metadata().onFreeze;
      var FREEZING = require_freezing();
      var fails = require_fails();
      var $seal = Object.seal;
      var FAILS_ON_PRIMITIVES = fails(function() {
        $seal(1);
      });
      $2({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
        seal: function seal(it) {
          return $seal && isObject3(it) ? $seal(onFreeze(it)) : it;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.set-prototype-of.js
  var require_es_object_set_prototype_of = __commonJS({
    "node_modules/core-js/modules/es.object.set-prototype-of.js"() {
      var $2 = require_export();
      var setPrototypeOf = require_object_set_prototype_of();
      $2({ target: "Object", stat: true }, {
        setPrototypeOf
      });
    }
  });

  // node_modules/core-js/internals/object-to-string.js
  var require_object_to_string = __commonJS({
    "node_modules/core-js/internals/object-to-string.js"(exports, module) {
      "use strict";
      var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
      var classof = require_classof();
      module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
        return "[object " + classof(this) + "]";
      };
    }
  });

  // node_modules/core-js/modules/es.object.to-string.js
  var require_es_object_to_string = __commonJS({
    "node_modules/core-js/modules/es.object.to-string.js"() {
      var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
      var redefine = require_redefine();
      var toString = require_object_to_string();
      if (!TO_STRING_TAG_SUPPORT) {
        redefine(Object.prototype, "toString", toString, { unsafe: true });
      }
    }
  });

  // node_modules/core-js/modules/es.object.values.js
  var require_es_object_values = __commonJS({
    "node_modules/core-js/modules/es.object.values.js"() {
      var $2 = require_export();
      var $values = require_object_to_array().values;
      $2({ target: "Object", stat: true }, {
        values: function values(O) {
          return $values(O);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.parse-float.js
  var require_es_parse_float = __commonJS({
    "node_modules/core-js/modules/es.parse-float.js"() {
      var $2 = require_export();
      var $parseFloat = require_number_parse_float();
      $2({ global: true, forced: parseFloat != $parseFloat }, {
        parseFloat: $parseFloat
      });
    }
  });

  // node_modules/core-js/modules/es.parse-int.js
  var require_es_parse_int = __commonJS({
    "node_modules/core-js/modules/es.parse-int.js"() {
      var $2 = require_export();
      var $parseInt = require_number_parse_int();
      $2({ global: true, forced: parseInt != $parseInt }, {
        parseInt: $parseInt
      });
    }
  });

  // node_modules/core-js/internals/native-promise-constructor.js
  var require_native_promise_constructor = __commonJS({
    "node_modules/core-js/internals/native-promise-constructor.js"(exports, module) {
      var global2 = require_global();
      module.exports = global2.Promise;
    }
  });

  // node_modules/core-js/internals/validate-arguments-length.js
  var require_validate_arguments_length = __commonJS({
    "node_modules/core-js/internals/validate-arguments-length.js"(exports, module) {
      var global2 = require_global();
      var TypeError2 = global2.TypeError;
      module.exports = function(passed, required) {
        if (passed < required)
          throw TypeError2("Not enough arguments");
        return passed;
      };
    }
  });

  // node_modules/core-js/internals/engine-is-ios.js
  var require_engine_is_ios = __commonJS({
    "node_modules/core-js/internals/engine-is-ios.js"(exports, module) {
      var userAgent = require_engine_user_agent();
      module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
    }
  });

  // node_modules/core-js/internals/task.js
  var require_task = __commonJS({
    "node_modules/core-js/internals/task.js"(exports, module) {
      var global2 = require_global();
      var apply = require_function_apply();
      var bind3 = require_function_bind_context();
      var isCallable = require_is_callable();
      var hasOwn = require_has_own_property();
      var fails = require_fails();
      var html = require_html();
      var arraySlice = require_array_slice();
      var createElement2 = require_document_create_element();
      var validateArgumentsLength = require_validate_arguments_length();
      var IS_IOS = require_engine_is_ios();
      var IS_NODE = require_engine_is_node();
      var set = global2.setImmediate;
      var clear = global2.clearImmediate;
      var process2 = global2.process;
      var Dispatch = global2.Dispatch;
      var Function2 = global2.Function;
      var MessageChannel = global2.MessageChannel;
      var String2 = global2.String;
      var counter = 0;
      var queue = {};
      var ONREADYSTATECHANGE = "onreadystatechange";
      var location2;
      var defer;
      var channel;
      var port;
      try {
        location2 = global2.location;
      } catch (error2) {
      }
      var run = function(id) {
        if (hasOwn(queue, id)) {
          var fn2 = queue[id];
          delete queue[id];
          fn2();
        }
      };
      var runner = function(id) {
        return function() {
          run(id);
        };
      };
      var listener = function(event) {
        run(event.data);
      };
      var post = function(id) {
        global2.postMessage(String2(id), location2.protocol + "//" + location2.host);
      };
      if (!set || !clear) {
        set = function setImmediate2(handler) {
          validateArgumentsLength(arguments.length, 1);
          var fn2 = isCallable(handler) ? handler : Function2(handler);
          var args = arraySlice(arguments, 1);
          queue[++counter] = function() {
            apply(fn2, void 0, args);
          };
          defer(counter);
          return counter;
        };
        clear = function clearImmediate(id) {
          delete queue[id];
        };
        if (IS_NODE) {
          defer = function(id) {
            process2.nextTick(runner(id));
          };
        } else if (Dispatch && Dispatch.now) {
          defer = function(id) {
            Dispatch.now(runner(id));
          };
        } else if (MessageChannel && !IS_IOS) {
          channel = new MessageChannel();
          port = channel.port2;
          channel.port1.onmessage = listener;
          defer = bind3(port.postMessage, port);
        } else if (global2.addEventListener && isCallable(global2.postMessage) && !global2.importScripts && location2 && location2.protocol !== "file:" && !fails(post)) {
          defer = post;
          global2.addEventListener("message", listener, false);
        } else if (ONREADYSTATECHANGE in createElement2("script")) {
          defer = function(id) {
            html.appendChild(createElement2("script"))[ONREADYSTATECHANGE] = function() {
              html.removeChild(this);
              run(id);
            };
          };
        } else {
          defer = function(id) {
            setTimeout(runner(id), 0);
          };
        }
      }
      module.exports = {
        set,
        clear
      };
    }
  });

  // node_modules/core-js/internals/engine-is-ios-pebble.js
  var require_engine_is_ios_pebble = __commonJS({
    "node_modules/core-js/internals/engine-is-ios-pebble.js"(exports, module) {
      var userAgent = require_engine_user_agent();
      var global2 = require_global();
      module.exports = /ipad|iphone|ipod/i.test(userAgent) && global2.Pebble !== void 0;
    }
  });

  // node_modules/core-js/internals/engine-is-webos-webkit.js
  var require_engine_is_webos_webkit = __commonJS({
    "node_modules/core-js/internals/engine-is-webos-webkit.js"(exports, module) {
      var userAgent = require_engine_user_agent();
      module.exports = /web0s(?!.*chrome)/i.test(userAgent);
    }
  });

  // node_modules/core-js/internals/microtask.js
  var require_microtask = __commonJS({
    "node_modules/core-js/internals/microtask.js"(exports, module) {
      var global2 = require_global();
      var bind3 = require_function_bind_context();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      var macrotask = require_task().set;
      var IS_IOS = require_engine_is_ios();
      var IS_IOS_PEBBLE = require_engine_is_ios_pebble();
      var IS_WEBOS_WEBKIT = require_engine_is_webos_webkit();
      var IS_NODE = require_engine_is_node();
      var MutationObserver2 = global2.MutationObserver || global2.WebKitMutationObserver;
      var document2 = global2.document;
      var process2 = global2.process;
      var Promise2 = global2.Promise;
      var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global2, "queueMicrotask");
      var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
      var flush;
      var head;
      var last;
      var notify;
      var toggle;
      var node;
      var promise;
      var then;
      if (!queueMicrotask) {
        flush = function() {
          var parent, fn2;
          if (IS_NODE && (parent = process2.domain))
            parent.exit();
          while (head) {
            fn2 = head.fn;
            head = head.next;
            try {
              fn2();
            } catch (error2) {
              if (head)
                notify();
              else
                last = void 0;
              throw error2;
            }
          }
          last = void 0;
          if (parent)
            parent.enter();
        };
        if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver2 && document2) {
          toggle = true;
          node = document2.createTextNode("");
          new MutationObserver2(flush).observe(node, { characterData: true });
          notify = function() {
            node.data = toggle = !toggle;
          };
        } else if (!IS_IOS_PEBBLE && Promise2 && Promise2.resolve) {
          promise = Promise2.resolve(void 0);
          promise.constructor = Promise2;
          then = bind3(promise.then, promise);
          notify = function() {
            then(flush);
          };
        } else if (IS_NODE) {
          notify = function() {
            process2.nextTick(flush);
          };
        } else {
          macrotask = bind3(macrotask, global2);
          notify = function() {
            macrotask(flush);
          };
        }
      }
      module.exports = queueMicrotask || function(fn2) {
        var task = { fn: fn2, next: void 0 };
        if (last)
          last.next = task;
        if (!head) {
          head = task;
          notify();
        }
        last = task;
      };
    }
  });

  // node_modules/core-js/internals/new-promise-capability.js
  var require_new_promise_capability = __commonJS({
    "node_modules/core-js/internals/new-promise-capability.js"(exports, module) {
      "use strict";
      var aCallable = require_a_callable();
      var PromiseCapability = function(C2) {
        var resolve2, reject;
        this.promise = new C2(function($$resolve, $$reject) {
          if (resolve2 !== void 0 || reject !== void 0)
            throw TypeError("Bad Promise constructor");
          resolve2 = $$resolve;
          reject = $$reject;
        });
        this.resolve = aCallable(resolve2);
        this.reject = aCallable(reject);
      };
      module.exports.f = function(C2) {
        return new PromiseCapability(C2);
      };
    }
  });

  // node_modules/core-js/internals/promise-resolve.js
  var require_promise_resolve = __commonJS({
    "node_modules/core-js/internals/promise-resolve.js"(exports, module) {
      var anObject = require_an_object();
      var isObject3 = require_is_object();
      var newPromiseCapability = require_new_promise_capability();
      module.exports = function(C2, x2) {
        anObject(C2);
        if (isObject3(x2) && x2.constructor === C2)
          return x2;
        var promiseCapability = newPromiseCapability.f(C2);
        var resolve2 = promiseCapability.resolve;
        resolve2(x2);
        return promiseCapability.promise;
      };
    }
  });

  // node_modules/core-js/internals/host-report-errors.js
  var require_host_report_errors = __commonJS({
    "node_modules/core-js/internals/host-report-errors.js"(exports, module) {
      var global2 = require_global();
      module.exports = function(a2, b2) {
        var console2 = global2.console;
        if (console2 && console2.error) {
          arguments.length == 1 ? console2.error(a2) : console2.error(a2, b2);
        }
      };
    }
  });

  // node_modules/core-js/internals/perform.js
  var require_perform = __commonJS({
    "node_modules/core-js/internals/perform.js"(exports, module) {
      module.exports = function(exec) {
        try {
          return { error: false, value: exec() };
        } catch (error2) {
          return { error: true, value: error2 };
        }
      };
    }
  });

  // node_modules/core-js/internals/queue.js
  var require_queue = __commonJS({
    "node_modules/core-js/internals/queue.js"(exports, module) {
      var Queue = function() {
        this.head = null;
        this.tail = null;
      };
      Queue.prototype = {
        add: function(item) {
          var entry = { item, next: null };
          if (this.head)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
        },
        get: function() {
          var entry = this.head;
          if (entry) {
            this.head = entry.next;
            if (this.tail === entry)
              this.tail = null;
            return entry.item;
          }
        }
      };
      module.exports = Queue;
    }
  });

  // node_modules/core-js/internals/engine-is-browser.js
  var require_engine_is_browser = __commonJS({
    "node_modules/core-js/internals/engine-is-browser.js"(exports, module) {
      module.exports = typeof window == "object";
    }
  });

  // node_modules/core-js/modules/es.promise.js
  var require_es_promise = __commonJS({
    "node_modules/core-js/modules/es.promise.js"() {
      "use strict";
      var $2 = require_export();
      var IS_PURE = require_is_pure();
      var global2 = require_global();
      var getBuiltIn = require_get_built_in();
      var call = require_function_call();
      var NativePromise = require_native_promise_constructor();
      var redefine = require_redefine();
      var redefineAll = require_redefine_all();
      var setPrototypeOf = require_object_set_prototype_of();
      var setToStringTag = require_set_to_string_tag();
      var setSpecies = require_set_species();
      var aCallable = require_a_callable();
      var isCallable = require_is_callable();
      var isObject3 = require_is_object();
      var anInstance = require_an_instance();
      var inspectSource = require_inspect_source();
      var iterate = require_iterate();
      var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
      var speciesConstructor = require_species_constructor();
      var task = require_task().set;
      var microtask = require_microtask();
      var promiseResolve = require_promise_resolve();
      var hostReportErrors = require_host_report_errors();
      var newPromiseCapabilityModule = require_new_promise_capability();
      var perform = require_perform();
      var Queue = require_queue();
      var InternalStateModule = require_internal_state();
      var isForced = require_is_forced();
      var wellKnownSymbol = require_well_known_symbol();
      var IS_BROWSER = require_engine_is_browser();
      var IS_NODE = require_engine_is_node();
      var V8_VERSION = require_engine_v8_version();
      var SPECIES = wellKnownSymbol("species");
      var PROMISE = "Promise";
      var getInternalState = InternalStateModule.getterFor(PROMISE);
      var setInternalState = InternalStateModule.set;
      var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
      var NativePromisePrototype = NativePromise && NativePromise.prototype;
      var PromiseConstructor = NativePromise;
      var PromisePrototype = NativePromisePrototype;
      var TypeError2 = global2.TypeError;
      var document2 = global2.document;
      var process2 = global2.process;
      var newPromiseCapability = newPromiseCapabilityModule.f;
      var newGenericPromiseCapability = newPromiseCapability;
      var DISPATCH_EVENT = !!(document2 && document2.createEvent && global2.dispatchEvent);
      var NATIVE_REJECTION_EVENT = isCallable(global2.PromiseRejectionEvent);
      var UNHANDLED_REJECTION = "unhandledrejection";
      var REJECTION_HANDLED = "rejectionhandled";
      var PENDING = 0;
      var FULFILLED = 1;
      var REJECTED = 2;
      var HANDLED = 1;
      var UNHANDLED = 2;
      var SUBCLASSING = false;
      var Internal;
      var OwnPromiseCapability;
      var PromiseWrapper;
      var nativeThen;
      var FORCED = isForced(PROMISE, function() {
        var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(PromiseConstructor);
        var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(PromiseConstructor);
        if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66)
          return true;
        if (IS_PURE && !PromisePrototype["finally"])
          return true;
        if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE))
          return false;
        var promise = new PromiseConstructor(function(resolve2) {
          resolve2(1);
        });
        var FakePromise = function(exec) {
          exec(function() {
          }, function() {
          });
        };
        var constructor = promise.constructor = {};
        constructor[SPECIES] = FakePromise;
        SUBCLASSING = promise.then(function() {
        }) instanceof FakePromise;
        if (!SUBCLASSING)
          return true;
        return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_REJECTION_EVENT;
      });
      var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function(iterable) {
        PromiseConstructor.all(iterable)["catch"](function() {
        });
      });
      var isThenable = function(it) {
        var then;
        return isObject3(it) && isCallable(then = it.then) ? then : false;
      };
      var callReaction = function(reaction, state) {
        var value = state.value;
        var ok = state.state == FULFILLED;
        var handler = ok ? reaction.ok : reaction.fail;
        var resolve2 = reaction.resolve;
        var reject = reaction.reject;
        var domain = reaction.domain;
        var result, then, exited;
        try {
          if (handler) {
            if (!ok) {
              if (state.rejection === UNHANDLED)
                onHandleUnhandled(state);
              state.rejection = HANDLED;
            }
            if (handler === true)
              result = value;
            else {
              if (domain)
                domain.enter();
              result = handler(value);
              if (domain) {
                domain.exit();
                exited = true;
              }
            }
            if (result === reaction.promise) {
              reject(TypeError2("Promise-chain cycle"));
            } else if (then = isThenable(result)) {
              call(then, result, resolve2, reject);
            } else
              resolve2(result);
          } else
            reject(value);
        } catch (error2) {
          if (domain && !exited)
            domain.exit();
          reject(error2);
        }
      };
      var notify = function(state, isReject) {
        if (state.notified)
          return;
        state.notified = true;
        microtask(function() {
          var reactions = state.reactions;
          var reaction;
          while (reaction = reactions.get()) {
            callReaction(reaction, state);
          }
          state.notified = false;
          if (isReject && !state.rejection)
            onUnhandled(state);
        });
      };
      var dispatchEvent2 = function(name, promise, reason) {
        var event, handler;
        if (DISPATCH_EVENT) {
          event = document2.createEvent("Event");
          event.promise = promise;
          event.reason = reason;
          event.initEvent(name, false, true);
          global2.dispatchEvent(event);
        } else
          event = { promise, reason };
        if (!NATIVE_REJECTION_EVENT && (handler = global2["on" + name]))
          handler(event);
        else if (name === UNHANDLED_REJECTION)
          hostReportErrors("Unhandled promise rejection", reason);
      };
      var onUnhandled = function(state) {
        call(task, global2, function() {
          var promise = state.facade;
          var value = state.value;
          var IS_UNHANDLED = isUnhandled(state);
          var result;
          if (IS_UNHANDLED) {
            result = perform(function() {
              if (IS_NODE) {
                process2.emit("unhandledRejection", value, promise);
              } else
                dispatchEvent2(UNHANDLED_REJECTION, promise, value);
            });
            state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
            if (result.error)
              throw result.value;
          }
        });
      };
      var isUnhandled = function(state) {
        return state.rejection !== HANDLED && !state.parent;
      };
      var onHandleUnhandled = function(state) {
        call(task, global2, function() {
          var promise = state.facade;
          if (IS_NODE) {
            process2.emit("rejectionHandled", promise);
          } else
            dispatchEvent2(REJECTION_HANDLED, promise, state.value);
        });
      };
      var bind3 = function(fn2, state, unwrap) {
        return function(value) {
          fn2(state, value, unwrap);
        };
      };
      var internalReject = function(state, value, unwrap) {
        if (state.done)
          return;
        state.done = true;
        if (unwrap)
          state = unwrap;
        state.value = value;
        state.state = REJECTED;
        notify(state, true);
      };
      var internalResolve = function(state, value, unwrap) {
        if (state.done)
          return;
        state.done = true;
        if (unwrap)
          state = unwrap;
        try {
          if (state.facade === value)
            throw TypeError2("Promise can't be resolved itself");
          var then = isThenable(value);
          if (then) {
            microtask(function() {
              var wrapper = { done: false };
              try {
                call(then, value, bind3(internalResolve, wrapper, state), bind3(internalReject, wrapper, state));
              } catch (error2) {
                internalReject(wrapper, error2, state);
              }
            });
          } else {
            state.value = value;
            state.state = FULFILLED;
            notify(state, false);
          }
        } catch (error2) {
          internalReject({ done: false }, error2, state);
        }
      };
      if (FORCED) {
        PromiseConstructor = function Promise2(executor) {
          anInstance(this, PromisePrototype);
          aCallable(executor);
          call(Internal, this);
          var state = getInternalState(this);
          try {
            executor(bind3(internalResolve, state), bind3(internalReject, state));
          } catch (error2) {
            internalReject(state, error2);
          }
        };
        PromisePrototype = PromiseConstructor.prototype;
        Internal = function Promise2(executor) {
          setInternalState(this, {
            type: PROMISE,
            done: false,
            notified: false,
            parent: false,
            reactions: new Queue(),
            rejection: false,
            state: PENDING,
            value: void 0
          });
        };
        Internal.prototype = redefineAll(PromisePrototype, {
          then: function then(onFulfilled, onRejected) {
            var state = getInternalPromiseState(this);
            var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
            state.parent = true;
            reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
            reaction.fail = isCallable(onRejected) && onRejected;
            reaction.domain = IS_NODE ? process2.domain : void 0;
            if (state.state == PENDING)
              state.reactions.add(reaction);
            else
              microtask(function() {
                callReaction(reaction, state);
              });
            return reaction.promise;
          },
          "catch": function(onRejected) {
            return this.then(void 0, onRejected);
          }
        });
        OwnPromiseCapability = function() {
          var promise = new Internal();
          var state = getInternalState(promise);
          this.promise = promise;
          this.resolve = bind3(internalResolve, state);
          this.reject = bind3(internalReject, state);
        };
        newPromiseCapabilityModule.f = newPromiseCapability = function(C2) {
          return C2 === PromiseConstructor || C2 === PromiseWrapper ? new OwnPromiseCapability(C2) : newGenericPromiseCapability(C2);
        };
        if (!IS_PURE && isCallable(NativePromise) && NativePromisePrototype !== Object.prototype) {
          nativeThen = NativePromisePrototype.then;
          if (!SUBCLASSING) {
            redefine(NativePromisePrototype, "then", function then(onFulfilled, onRejected) {
              var that = this;
              return new PromiseConstructor(function(resolve2, reject) {
                call(nativeThen, that, resolve2, reject);
              }).then(onFulfilled, onRejected);
            }, { unsafe: true });
            redefine(NativePromisePrototype, "catch", PromisePrototype["catch"], { unsafe: true });
          }
          try {
            delete NativePromisePrototype.constructor;
          } catch (error2) {
          }
          if (setPrototypeOf) {
            setPrototypeOf(NativePromisePrototype, PromisePrototype);
          }
        }
      }
      $2({ global: true, wrap: true, forced: FORCED }, {
        Promise: PromiseConstructor
      });
      setToStringTag(PromiseConstructor, PROMISE, false, true);
      setSpecies(PROMISE);
      PromiseWrapper = getBuiltIn(PROMISE);
      $2({ target: PROMISE, stat: true, forced: FORCED }, {
        reject: function reject(r2) {
          var capability = newPromiseCapability(this);
          call(capability.reject, void 0, r2);
          return capability.promise;
        }
      });
      $2({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, {
        resolve: function resolve2(x2) {
          return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x2);
        }
      });
      $2({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
        all: function all(iterable) {
          var C2 = this;
          var capability = newPromiseCapability(C2);
          var resolve2 = capability.resolve;
          var reject = capability.reject;
          var result = perform(function() {
            var $promiseResolve = aCallable(C2.resolve);
            var values = [];
            var counter = 0;
            var remaining = 1;
            iterate(iterable, function(promise) {
              var index = counter++;
              var alreadyCalled = false;
              remaining++;
              call($promiseResolve, C2, promise).then(function(value) {
                if (alreadyCalled)
                  return;
                alreadyCalled = true;
                values[index] = value;
                --remaining || resolve2(values);
              }, reject);
            });
            --remaining || resolve2(values);
          });
          if (result.error)
            reject(result.value);
          return capability.promise;
        },
        race: function race(iterable) {
          var C2 = this;
          var capability = newPromiseCapability(C2);
          var reject = capability.reject;
          var result = perform(function() {
            var $promiseResolve = aCallable(C2.resolve);
            iterate(iterable, function(promise) {
              call($promiseResolve, C2, promise).then(capability.resolve, reject);
            });
          });
          if (result.error)
            reject(result.value);
          return capability.promise;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.promise.all-settled.js
  var require_es_promise_all_settled = __commonJS({
    "node_modules/core-js/modules/es.promise.all-settled.js"() {
      "use strict";
      var $2 = require_export();
      var call = require_function_call();
      var aCallable = require_a_callable();
      var newPromiseCapabilityModule = require_new_promise_capability();
      var perform = require_perform();
      var iterate = require_iterate();
      $2({ target: "Promise", stat: true }, {
        allSettled: function allSettled(iterable) {
          var C2 = this;
          var capability = newPromiseCapabilityModule.f(C2);
          var resolve2 = capability.resolve;
          var reject = capability.reject;
          var result = perform(function() {
            var promiseResolve = aCallable(C2.resolve);
            var values = [];
            var counter = 0;
            var remaining = 1;
            iterate(iterable, function(promise) {
              var index = counter++;
              var alreadyCalled = false;
              remaining++;
              call(promiseResolve, C2, promise).then(function(value) {
                if (alreadyCalled)
                  return;
                alreadyCalled = true;
                values[index] = { status: "fulfilled", value };
                --remaining || resolve2(values);
              }, function(error2) {
                if (alreadyCalled)
                  return;
                alreadyCalled = true;
                values[index] = { status: "rejected", reason: error2 };
                --remaining || resolve2(values);
              });
            });
            --remaining || resolve2(values);
          });
          if (result.error)
            reject(result.value);
          return capability.promise;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.promise.any.js
  var require_es_promise_any = __commonJS({
    "node_modules/core-js/modules/es.promise.any.js"() {
      "use strict";
      var $2 = require_export();
      var aCallable = require_a_callable();
      var getBuiltIn = require_get_built_in();
      var call = require_function_call();
      var newPromiseCapabilityModule = require_new_promise_capability();
      var perform = require_perform();
      var iterate = require_iterate();
      var PROMISE_ANY_ERROR = "No one promise resolved";
      $2({ target: "Promise", stat: true }, {
        any: function any(iterable) {
          var C2 = this;
          var AggregateError = getBuiltIn("AggregateError");
          var capability = newPromiseCapabilityModule.f(C2);
          var resolve2 = capability.resolve;
          var reject = capability.reject;
          var result = perform(function() {
            var promiseResolve = aCallable(C2.resolve);
            var errors = [];
            var counter = 0;
            var remaining = 1;
            var alreadyResolved = false;
            iterate(iterable, function(promise) {
              var index = counter++;
              var alreadyRejected = false;
              remaining++;
              call(promiseResolve, C2, promise).then(function(value) {
                if (alreadyRejected || alreadyResolved)
                  return;
                alreadyResolved = true;
                resolve2(value);
              }, function(error2) {
                if (alreadyRejected || alreadyResolved)
                  return;
                alreadyRejected = true;
                errors[index] = error2;
                --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
              });
            });
            --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
          });
          if (result.error)
            reject(result.value);
          return capability.promise;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.promise.finally.js
  var require_es_promise_finally = __commonJS({
    "node_modules/core-js/modules/es.promise.finally.js"() {
      "use strict";
      var $2 = require_export();
      var IS_PURE = require_is_pure();
      var NativePromise = require_native_promise_constructor();
      var fails = require_fails();
      var getBuiltIn = require_get_built_in();
      var isCallable = require_is_callable();
      var speciesConstructor = require_species_constructor();
      var promiseResolve = require_promise_resolve();
      var redefine = require_redefine();
      var NON_GENERIC = !!NativePromise && fails(function() {
        NativePromise.prototype["finally"].call({ then: function() {
        } }, function() {
        });
      });
      $2({ target: "Promise", proto: true, real: true, forced: NON_GENERIC }, {
        "finally": function(onFinally) {
          var C2 = speciesConstructor(this, getBuiltIn("Promise"));
          var isFunction = isCallable(onFinally);
          return this.then(isFunction ? function(x2) {
            return promiseResolve(C2, onFinally()).then(function() {
              return x2;
            });
          } : onFinally, isFunction ? function(e2) {
            return promiseResolve(C2, onFinally()).then(function() {
              throw e2;
            });
          } : onFinally);
        }
      });
      if (!IS_PURE && isCallable(NativePromise)) {
        method = getBuiltIn("Promise").prototype["finally"];
        if (NativePromise.prototype["finally"] !== method) {
          redefine(NativePromise.prototype, "finally", method, { unsafe: true });
        }
      }
      var method;
    }
  });

  // node_modules/core-js/modules/es.reflect.apply.js
  var require_es_reflect_apply = __commonJS({
    "node_modules/core-js/modules/es.reflect.apply.js"() {
      var $2 = require_export();
      var functionApply = require_function_apply();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var fails = require_fails();
      var OPTIONAL_ARGUMENTS_LIST = !fails(function() {
        Reflect.apply(function() {
        });
      });
      $2({ target: "Reflect", stat: true, forced: OPTIONAL_ARGUMENTS_LIST }, {
        apply: function apply(target, thisArgument, argumentsList) {
          return functionApply(aCallable(target), thisArgument, anObject(argumentsList));
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.construct.js
  var require_es_reflect_construct = __commonJS({
    "node_modules/core-js/modules/es.reflect.construct.js"() {
      var $2 = require_export();
      var getBuiltIn = require_get_built_in();
      var apply = require_function_apply();
      var bind3 = require_function_bind();
      var aConstructor = require_a_constructor();
      var anObject = require_an_object();
      var isObject3 = require_is_object();
      var create = require_object_create();
      var fails = require_fails();
      var nativeConstruct = getBuiltIn("Reflect", "construct");
      var ObjectPrototype = Object.prototype;
      var push = [].push;
      var NEW_TARGET_BUG = fails(function() {
        function F() {
        }
        return !(nativeConstruct(function() {
        }, [], F) instanceof F);
      });
      var ARGS_BUG = !fails(function() {
        nativeConstruct(function() {
        });
      });
      var FORCED = NEW_TARGET_BUG || ARGS_BUG;
      $2({ target: "Reflect", stat: true, forced: FORCED, sham: FORCED }, {
        construct: function construct(Target, args) {
          aConstructor(Target);
          anObject(args);
          var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
          if (ARGS_BUG && !NEW_TARGET_BUG)
            return nativeConstruct(Target, args, newTarget);
          if (Target == newTarget) {
            switch (args.length) {
              case 0:
                return new Target();
              case 1:
                return new Target(args[0]);
              case 2:
                return new Target(args[0], args[1]);
              case 3:
                return new Target(args[0], args[1], args[2]);
              case 4:
                return new Target(args[0], args[1], args[2], args[3]);
            }
            var $args = [null];
            apply(push, $args, args);
            return new (apply(bind3, Target, $args))();
          }
          var proto = newTarget.prototype;
          var instance = create(isObject3(proto) ? proto : ObjectPrototype);
          var result = apply(Target, instance, args);
          return isObject3(result) ? result : instance;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.define-property.js
  var require_es_reflect_define_property = __commonJS({
    "node_modules/core-js/modules/es.reflect.define-property.js"() {
      var $2 = require_export();
      var DESCRIPTORS = require_descriptors();
      var anObject = require_an_object();
      var toPropertyKey = require_to_property_key();
      var definePropertyModule = require_object_define_property();
      var fails = require_fails();
      var ERROR_INSTEAD_OF_FALSE = fails(function() {
        Reflect.defineProperty(definePropertyModule.f({}, 1, { value: 1 }), 1, { value: 2 });
      });
      $2({ target: "Reflect", stat: true, forced: ERROR_INSTEAD_OF_FALSE, sham: !DESCRIPTORS }, {
        defineProperty: function defineProperty(target, propertyKey, attributes) {
          anObject(target);
          var key = toPropertyKey(propertyKey);
          anObject(attributes);
          try {
            definePropertyModule.f(target, key, attributes);
            return true;
          } catch (error2) {
            return false;
          }
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.delete-property.js
  var require_es_reflect_delete_property = __commonJS({
    "node_modules/core-js/modules/es.reflect.delete-property.js"() {
      var $2 = require_export();
      var anObject = require_an_object();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      $2({ target: "Reflect", stat: true }, {
        deleteProperty: function deleteProperty(target, propertyKey) {
          var descriptor = getOwnPropertyDescriptor(anObject(target), propertyKey);
          return descriptor && !descriptor.configurable ? false : delete target[propertyKey];
        }
      });
    }
  });

  // node_modules/core-js/internals/is-data-descriptor.js
  var require_is_data_descriptor = __commonJS({
    "node_modules/core-js/internals/is-data-descriptor.js"(exports, module) {
      var hasOwn = require_has_own_property();
      module.exports = function(descriptor) {
        return descriptor !== void 0 && (hasOwn(descriptor, "value") || hasOwn(descriptor, "writable"));
      };
    }
  });

  // node_modules/core-js/modules/es.reflect.get.js
  var require_es_reflect_get = __commonJS({
    "node_modules/core-js/modules/es.reflect.get.js"() {
      var $2 = require_export();
      var call = require_function_call();
      var isObject3 = require_is_object();
      var anObject = require_an_object();
      var isDataDescriptor = require_is_data_descriptor();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var getPrototypeOf = require_object_get_prototype_of();
      function get(target, propertyKey) {
        var receiver = arguments.length < 3 ? target : arguments[2];
        var descriptor, prototype;
        if (anObject(target) === receiver)
          return target[propertyKey];
        descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey);
        if (descriptor)
          return isDataDescriptor(descriptor) ? descriptor.value : descriptor.get === void 0 ? void 0 : call(descriptor.get, receiver);
        if (isObject3(prototype = getPrototypeOf(target)))
          return get(prototype, propertyKey, receiver);
      }
      $2({ target: "Reflect", stat: true }, {
        get
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.get-own-property-descriptor.js
  var require_es_reflect_get_own_property_descriptor = __commonJS({
    "node_modules/core-js/modules/es.reflect.get-own-property-descriptor.js"() {
      var $2 = require_export();
      var DESCRIPTORS = require_descriptors();
      var anObject = require_an_object();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      $2({ target: "Reflect", stat: true, sham: !DESCRIPTORS }, {
        getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
          return getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.get-prototype-of.js
  var require_es_reflect_get_prototype_of = __commonJS({
    "node_modules/core-js/modules/es.reflect.get-prototype-of.js"() {
      var $2 = require_export();
      var anObject = require_an_object();
      var objectGetPrototypeOf = require_object_get_prototype_of();
      var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
      $2({ target: "Reflect", stat: true, sham: !CORRECT_PROTOTYPE_GETTER }, {
        getPrototypeOf: function getPrototypeOf(target) {
          return objectGetPrototypeOf(anObject(target));
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.has.js
  var require_es_reflect_has = __commonJS({
    "node_modules/core-js/modules/es.reflect.has.js"() {
      var $2 = require_export();
      $2({ target: "Reflect", stat: true }, {
        has: function has(target, propertyKey) {
          return propertyKey in target;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.is-extensible.js
  var require_es_reflect_is_extensible = __commonJS({
    "node_modules/core-js/modules/es.reflect.is-extensible.js"() {
      var $2 = require_export();
      var anObject = require_an_object();
      var $isExtensible = require_object_is_extensible();
      $2({ target: "Reflect", stat: true }, {
        isExtensible: function isExtensible(target) {
          anObject(target);
          return $isExtensible(target);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.own-keys.js
  var require_es_reflect_own_keys = __commonJS({
    "node_modules/core-js/modules/es.reflect.own-keys.js"() {
      var $2 = require_export();
      var ownKeys17 = require_own_keys();
      $2({ target: "Reflect", stat: true }, {
        ownKeys: ownKeys17
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.prevent-extensions.js
  var require_es_reflect_prevent_extensions = __commonJS({
    "node_modules/core-js/modules/es.reflect.prevent-extensions.js"() {
      var $2 = require_export();
      var getBuiltIn = require_get_built_in();
      var anObject = require_an_object();
      var FREEZING = require_freezing();
      $2({ target: "Reflect", stat: true, sham: !FREEZING }, {
        preventExtensions: function preventExtensions(target) {
          anObject(target);
          try {
            var objectPreventExtensions = getBuiltIn("Object", "preventExtensions");
            if (objectPreventExtensions)
              objectPreventExtensions(target);
            return true;
          } catch (error2) {
            return false;
          }
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.set.js
  var require_es_reflect_set = __commonJS({
    "node_modules/core-js/modules/es.reflect.set.js"() {
      var $2 = require_export();
      var call = require_function_call();
      var anObject = require_an_object();
      var isObject3 = require_is_object();
      var isDataDescriptor = require_is_data_descriptor();
      var fails = require_fails();
      var definePropertyModule = require_object_define_property();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var getPrototypeOf = require_object_get_prototype_of();
      var createPropertyDescriptor = require_create_property_descriptor();
      function set(target, propertyKey, V) {
        var receiver = arguments.length < 4 ? target : arguments[3];
        var ownDescriptor = getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
        var existingDescriptor, prototype, setter;
        if (!ownDescriptor) {
          if (isObject3(prototype = getPrototypeOf(target))) {
            return set(prototype, propertyKey, V, receiver);
          }
          ownDescriptor = createPropertyDescriptor(0);
        }
        if (isDataDescriptor(ownDescriptor)) {
          if (ownDescriptor.writable === false || !isObject3(receiver))
            return false;
          if (existingDescriptor = getOwnPropertyDescriptorModule.f(receiver, propertyKey)) {
            if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false)
              return false;
            existingDescriptor.value = V;
            definePropertyModule.f(receiver, propertyKey, existingDescriptor);
          } else
            definePropertyModule.f(receiver, propertyKey, createPropertyDescriptor(0, V));
        } else {
          setter = ownDescriptor.set;
          if (setter === void 0)
            return false;
          call(setter, receiver, V);
        }
        return true;
      }
      var MS_EDGE_BUG = fails(function() {
        var Constructor = function() {
        };
        var object = definePropertyModule.f(new Constructor(), "a", { configurable: true });
        return Reflect.set(Constructor.prototype, "a", 1, object) !== false;
      });
      $2({ target: "Reflect", stat: true, forced: MS_EDGE_BUG }, {
        set
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.set-prototype-of.js
  var require_es_reflect_set_prototype_of = __commonJS({
    "node_modules/core-js/modules/es.reflect.set-prototype-of.js"() {
      var $2 = require_export();
      var anObject = require_an_object();
      var aPossiblePrototype = require_a_possible_prototype();
      var objectSetPrototypeOf = require_object_set_prototype_of();
      if (objectSetPrototypeOf)
        $2({ target: "Reflect", stat: true }, {
          setPrototypeOf: function setPrototypeOf(target, proto) {
            anObject(target);
            aPossiblePrototype(proto);
            try {
              objectSetPrototypeOf(target, proto);
              return true;
            } catch (error2) {
              return false;
            }
          }
        });
    }
  });

  // node_modules/core-js/modules/es.reflect.to-string-tag.js
  var require_es_reflect_to_string_tag = __commonJS({
    "node_modules/core-js/modules/es.reflect.to-string-tag.js"() {
      var $2 = require_export();
      var global2 = require_global();
      var setToStringTag = require_set_to_string_tag();
      $2({ global: true }, { Reflect: {} });
      setToStringTag(global2.Reflect, "Reflect", true);
    }
  });

  // node_modules/core-js/internals/is-regexp.js
  var require_is_regexp = __commonJS({
    "node_modules/core-js/internals/is-regexp.js"(exports, module) {
      var isObject3 = require_is_object();
      var classof = require_classof_raw();
      var wellKnownSymbol = require_well_known_symbol();
      var MATCH = wellKnownSymbol("match");
      module.exports = function(it) {
        var isRegExp;
        return isObject3(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : classof(it) == "RegExp");
      };
    }
  });

  // node_modules/core-js/internals/regexp-flags.js
  var require_regexp_flags = __commonJS({
    "node_modules/core-js/internals/regexp-flags.js"(exports, module) {
      "use strict";
      var anObject = require_an_object();
      module.exports = function() {
        var that = anObject(this);
        var result = "";
        if (that.global)
          result += "g";
        if (that.ignoreCase)
          result += "i";
        if (that.multiline)
          result += "m";
        if (that.dotAll)
          result += "s";
        if (that.unicode)
          result += "u";
        if (that.sticky)
          result += "y";
        return result;
      };
    }
  });

  // node_modules/core-js/internals/regexp-sticky-helpers.js
  var require_regexp_sticky_helpers = __commonJS({
    "node_modules/core-js/internals/regexp-sticky-helpers.js"(exports, module) {
      var fails = require_fails();
      var global2 = require_global();
      var $RegExp = global2.RegExp;
      var UNSUPPORTED_Y = fails(function() {
        var re = $RegExp("a", "y");
        re.lastIndex = 2;
        return re.exec("abcd") != null;
      });
      var MISSED_STICKY = UNSUPPORTED_Y || fails(function() {
        return !$RegExp("a", "y").sticky;
      });
      var BROKEN_CARET = UNSUPPORTED_Y || fails(function() {
        var re = $RegExp("^r", "gy");
        re.lastIndex = 2;
        return re.exec("str") != null;
      });
      module.exports = {
        BROKEN_CARET,
        MISSED_STICKY,
        UNSUPPORTED_Y
      };
    }
  });

  // node_modules/core-js/internals/regexp-unsupported-dot-all.js
  var require_regexp_unsupported_dot_all = __commonJS({
    "node_modules/core-js/internals/regexp-unsupported-dot-all.js"(exports, module) {
      var fails = require_fails();
      var global2 = require_global();
      var $RegExp = global2.RegExp;
      module.exports = fails(function() {
        var re = $RegExp(".", "s");
        return !(re.dotAll && re.exec("\n") && re.flags === "s");
      });
    }
  });

  // node_modules/core-js/internals/regexp-unsupported-ncg.js
  var require_regexp_unsupported_ncg = __commonJS({
    "node_modules/core-js/internals/regexp-unsupported-ncg.js"(exports, module) {
      var fails = require_fails();
      var global2 = require_global();
      var $RegExp = global2.RegExp;
      module.exports = fails(function() {
        var re = $RegExp("(?<a>b)", "g");
        return re.exec("b").groups.a !== "b" || "b".replace(re, "$<a>c") !== "bc";
      });
    }
  });

  // node_modules/core-js/modules/es.regexp.constructor.js
  var require_es_regexp_constructor = __commonJS({
    "node_modules/core-js/modules/es.regexp.constructor.js"() {
      var DESCRIPTORS = require_descriptors();
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this();
      var isForced = require_is_forced();
      var inheritIfRequired = require_inherit_if_required();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var defineProperty = require_object_define_property().f;
      var getOwnPropertyNames = require_object_get_own_property_names().f;
      var isPrototypeOf = require_object_is_prototype_of();
      var isRegExp = require_is_regexp();
      var toString = require_to_string();
      var regExpFlags = require_regexp_flags();
      var stickyHelpers = require_regexp_sticky_helpers();
      var redefine = require_redefine();
      var fails = require_fails();
      var hasOwn = require_has_own_property();
      var enforceInternalState = require_internal_state().enforce;
      var setSpecies = require_set_species();
      var wellKnownSymbol = require_well_known_symbol();
      var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
      var UNSUPPORTED_NCG = require_regexp_unsupported_ncg();
      var MATCH = wellKnownSymbol("match");
      var NativeRegExp = global2.RegExp;
      var RegExpPrototype = NativeRegExp.prototype;
      var SyntaxError2 = global2.SyntaxError;
      var getFlags = uncurryThis(regExpFlags);
      var exec = uncurryThis(RegExpPrototype.exec);
      var charAt = uncurryThis("".charAt);
      var replace = uncurryThis("".replace);
      var stringIndexOf = uncurryThis("".indexOf);
      var stringSlice = uncurryThis("".slice);
      var IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
      var re1 = /a/g;
      var re2 = /a/g;
      var CORRECT_NEW = new NativeRegExp(re1) !== re1;
      var MISSED_STICKY = stickyHelpers.MISSED_STICKY;
      var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
      var BASE_FORCED = DESCRIPTORS && (!CORRECT_NEW || MISSED_STICKY || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG || fails(function() {
        re2[MATCH] = false;
        return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, "i") != "/a/i";
      }));
      var handleDotAll = function(string) {
        var length = string.length;
        var index2 = 0;
        var result = "";
        var brackets = false;
        var chr;
        for (; index2 <= length; index2++) {
          chr = charAt(string, index2);
          if (chr === "\\") {
            result += chr + charAt(string, ++index2);
            continue;
          }
          if (!brackets && chr === ".") {
            result += "[\\s\\S]";
          } else {
            if (chr === "[") {
              brackets = true;
            } else if (chr === "]") {
              brackets = false;
            }
            result += chr;
          }
        }
        return result;
      };
      var handleNCG = function(string) {
        var length = string.length;
        var index2 = 0;
        var result = "";
        var named = [];
        var names = {};
        var brackets = false;
        var ncg = false;
        var groupid = 0;
        var groupname = "";
        var chr;
        for (; index2 <= length; index2++) {
          chr = charAt(string, index2);
          if (chr === "\\") {
            chr = chr + charAt(string, ++index2);
          } else if (chr === "]") {
            brackets = false;
          } else if (!brackets)
            switch (true) {
              case chr === "[":
                brackets = true;
                break;
              case chr === "(":
                if (exec(IS_NCG, stringSlice(string, index2 + 1))) {
                  index2 += 2;
                  ncg = true;
                }
                result += chr;
                groupid++;
                continue;
              case (chr === ">" && ncg):
                if (groupname === "" || hasOwn(names, groupname)) {
                  throw new SyntaxError2("Invalid capture group name");
                }
                names[groupname] = true;
                named[named.length] = [groupname, groupid];
                ncg = false;
                groupname = "";
                continue;
            }
          if (ncg)
            groupname += chr;
          else
            result += chr;
        }
        return [result, named];
      };
      if (isForced("RegExp", BASE_FORCED)) {
        RegExpWrapper = function RegExp2(pattern, flags) {
          var thisIsRegExp = isPrototypeOf(RegExpPrototype, this);
          var patternIsRegExp = isRegExp(pattern);
          var flagsAreUndefined = flags === void 0;
          var groups = [];
          var rawPattern = pattern;
          var rawFlags, dotAll, sticky, handled, result, state;
          if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {
            return pattern;
          }
          if (patternIsRegExp || isPrototypeOf(RegExpPrototype, pattern)) {
            pattern = pattern.source;
            if (flagsAreUndefined)
              flags = "flags" in rawPattern ? rawPattern.flags : getFlags(rawPattern);
          }
          pattern = pattern === void 0 ? "" : toString(pattern);
          flags = flags === void 0 ? "" : toString(flags);
          rawPattern = pattern;
          if (UNSUPPORTED_DOT_ALL && "dotAll" in re1) {
            dotAll = !!flags && stringIndexOf(flags, "s") > -1;
            if (dotAll)
              flags = replace(flags, /s/g, "");
          }
          rawFlags = flags;
          if (MISSED_STICKY && "sticky" in re1) {
            sticky = !!flags && stringIndexOf(flags, "y") > -1;
            if (sticky && UNSUPPORTED_Y)
              flags = replace(flags, /y/g, "");
          }
          if (UNSUPPORTED_NCG) {
            handled = handleNCG(pattern);
            pattern = handled[0];
            groups = handled[1];
          }
          result = inheritIfRequired(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);
          if (dotAll || sticky || groups.length) {
            state = enforceInternalState(result);
            if (dotAll) {
              state.dotAll = true;
              state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
            }
            if (sticky)
              state.sticky = true;
            if (groups.length)
              state.groups = groups;
          }
          if (pattern !== rawPattern)
            try {
              createNonEnumerableProperty(result, "source", rawPattern === "" ? "(?:)" : rawPattern);
            } catch (error2) {
            }
          return result;
        };
        proxy = function(key) {
          key in RegExpWrapper || defineProperty(RegExpWrapper, key, {
            configurable: true,
            get: function() {
              return NativeRegExp[key];
            },
            set: function(it) {
              NativeRegExp[key] = it;
            }
          });
        };
        for (keys = getOwnPropertyNames(NativeRegExp), index = 0; keys.length > index; ) {
          proxy(keys[index++]);
        }
        RegExpPrototype.constructor = RegExpWrapper;
        RegExpWrapper.prototype = RegExpPrototype;
        redefine(global2, "RegExp", RegExpWrapper);
      }
      var RegExpWrapper;
      var proxy;
      var keys;
      var index;
      setSpecies("RegExp");
    }
  });

  // node_modules/core-js/modules/es.regexp.dot-all.js
  var require_es_regexp_dot_all = __commonJS({
    "node_modules/core-js/modules/es.regexp.dot-all.js"() {
      var global2 = require_global();
      var DESCRIPTORS = require_descriptors();
      var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
      var classof = require_classof_raw();
      var defineProperty = require_object_define_property().f;
      var getInternalState = require_internal_state().get;
      var RegExpPrototype = RegExp.prototype;
      var TypeError2 = global2.TypeError;
      if (DESCRIPTORS && UNSUPPORTED_DOT_ALL) {
        defineProperty(RegExpPrototype, "dotAll", {
          configurable: true,
          get: function() {
            if (this === RegExpPrototype)
              return void 0;
            if (classof(this) === "RegExp") {
              return !!getInternalState(this).dotAll;
            }
            throw TypeError2("Incompatible receiver, RegExp required");
          }
        });
      }
    }
  });

  // node_modules/core-js/internals/regexp-exec.js
  var require_regexp_exec = __commonJS({
    "node_modules/core-js/internals/regexp-exec.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var toString = require_to_string();
      var regexpFlags = require_regexp_flags();
      var stickyHelpers = require_regexp_sticky_helpers();
      var shared = require_shared();
      var create = require_object_create();
      var getInternalState = require_internal_state().get;
      var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
      var UNSUPPORTED_NCG = require_regexp_unsupported_ncg();
      var nativeReplace = shared("native-string-replace", String.prototype.replace);
      var nativeExec = RegExp.prototype.exec;
      var patchedExec = nativeExec;
      var charAt = uncurryThis("".charAt);
      var indexOf2 = uncurryThis("".indexOf);
      var replace = uncurryThis("".replace);
      var stringSlice = uncurryThis("".slice);
      var UPDATES_LAST_INDEX_WRONG = function() {
        var re1 = /a/;
        var re2 = /b*/g;
        call(nativeExec, re1, "a");
        call(nativeExec, re2, "a");
        return re1.lastIndex !== 0 || re2.lastIndex !== 0;
      }();
      var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;
      var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
      var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
      if (PATCH) {
        patchedExec = function exec(string) {
          var re = this;
          var state = getInternalState(re);
          var str = toString(string);
          var raw = state.raw;
          var result, reCopy, lastIndex, match, i2, object, group;
          if (raw) {
            raw.lastIndex = re.lastIndex;
            result = call(patchedExec, raw, str);
            re.lastIndex = raw.lastIndex;
            return result;
          }
          var groups = state.groups;
          var sticky = UNSUPPORTED_Y && re.sticky;
          var flags = call(regexpFlags, re);
          var source = re.source;
          var charsAdded = 0;
          var strCopy = str;
          if (sticky) {
            flags = replace(flags, "y", "");
            if (indexOf2(flags, "g") === -1) {
              flags += "g";
            }
            strCopy = stringSlice(str, re.lastIndex);
            if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== "\n")) {
              source = "(?: " + source + ")";
              strCopy = " " + strCopy;
              charsAdded++;
            }
            reCopy = new RegExp("^(?:" + source + ")", flags);
          }
          if (NPCG_INCLUDED) {
            reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
          }
          if (UPDATES_LAST_INDEX_WRONG)
            lastIndex = re.lastIndex;
          match = call(nativeExec, sticky ? reCopy : re, strCopy);
          if (sticky) {
            if (match) {
              match.input = stringSlice(match.input, charsAdded);
              match[0] = stringSlice(match[0], charsAdded);
              match.index = re.lastIndex;
              re.lastIndex += match[0].length;
            } else
              re.lastIndex = 0;
          } else if (UPDATES_LAST_INDEX_WRONG && match) {
            re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
          }
          if (NPCG_INCLUDED && match && match.length > 1) {
            call(nativeReplace, match[0], reCopy, function() {
              for (i2 = 1; i2 < arguments.length - 2; i2++) {
                if (arguments[i2] === void 0)
                  match[i2] = void 0;
              }
            });
          }
          if (match && groups) {
            match.groups = object = create(null);
            for (i2 = 0; i2 < groups.length; i2++) {
              group = groups[i2];
              object[group[0]] = match[group[1]];
            }
          }
          return match;
        };
      }
      module.exports = patchedExec;
    }
  });

  // node_modules/core-js/modules/es.regexp.exec.js
  var require_es_regexp_exec = __commonJS({
    "node_modules/core-js/modules/es.regexp.exec.js"() {
      "use strict";
      var $2 = require_export();
      var exec = require_regexp_exec();
      $2({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
        exec
      });
    }
  });

  // node_modules/core-js/modules/es.regexp.flags.js
  var require_es_regexp_flags = __commonJS({
    "node_modules/core-js/modules/es.regexp.flags.js"() {
      var DESCRIPTORS = require_descriptors();
      var objectDefinePropertyModule = require_object_define_property();
      var regExpFlags = require_regexp_flags();
      var fails = require_fails();
      var RegExpPrototype = RegExp.prototype;
      var FORCED = DESCRIPTORS && fails(function() {
        return Object.getOwnPropertyDescriptor(RegExpPrototype, "flags").get.call({ dotAll: true, sticky: true }) !== "sy";
      });
      if (FORCED)
        objectDefinePropertyModule.f(RegExpPrototype, "flags", {
          configurable: true,
          get: regExpFlags
        });
    }
  });

  // node_modules/core-js/modules/es.regexp.sticky.js
  var require_es_regexp_sticky = __commonJS({
    "node_modules/core-js/modules/es.regexp.sticky.js"() {
      var global2 = require_global();
      var DESCRIPTORS = require_descriptors();
      var MISSED_STICKY = require_regexp_sticky_helpers().MISSED_STICKY;
      var classof = require_classof_raw();
      var defineProperty = require_object_define_property().f;
      var getInternalState = require_internal_state().get;
      var RegExpPrototype = RegExp.prototype;
      var TypeError2 = global2.TypeError;
      if (DESCRIPTORS && MISSED_STICKY) {
        defineProperty(RegExpPrototype, "sticky", {
          configurable: true,
          get: function() {
            if (this === RegExpPrototype)
              return void 0;
            if (classof(this) === "RegExp") {
              return !!getInternalState(this).sticky;
            }
            throw TypeError2("Incompatible receiver, RegExp required");
          }
        });
      }
    }
  });

  // node_modules/core-js/modules/es.regexp.test.js
  var require_es_regexp_test = __commonJS({
    "node_modules/core-js/modules/es.regexp.test.js"() {
      "use strict";
      require_es_regexp_exec();
      var $2 = require_export();
      var global2 = require_global();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var isCallable = require_is_callable();
      var isObject3 = require_is_object();
      var DELEGATES_TO_EXEC = function() {
        var execCalled = false;
        var re = /[ac]/;
        re.exec = function() {
          execCalled = true;
          return /./.exec.apply(this, arguments);
        };
        return re.test("abc") === true && execCalled;
      }();
      var Error2 = global2.Error;
      var un$Test = uncurryThis(/./.test);
      $2({ target: "RegExp", proto: true, forced: !DELEGATES_TO_EXEC }, {
        test: function(str) {
          var exec = this.exec;
          if (!isCallable(exec))
            return un$Test(this, str);
          var result = call(exec, this, str);
          if (result !== null && !isObject3(result)) {
            throw new Error2("RegExp exec method returned something other than an Object or null");
          }
          return !!result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.regexp.to-string.js
  var require_es_regexp_to_string = __commonJS({
    "node_modules/core-js/modules/es.regexp.to-string.js"() {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var PROPER_FUNCTION_NAME = require_function_name().PROPER;
      var redefine = require_redefine();
      var anObject = require_an_object();
      var isPrototypeOf = require_object_is_prototype_of();
      var $toString = require_to_string();
      var fails = require_fails();
      var regExpFlags = require_regexp_flags();
      var TO_STRING = "toString";
      var RegExpPrototype = RegExp.prototype;
      var n$ToString = RegExpPrototype[TO_STRING];
      var getFlags = uncurryThis(regExpFlags);
      var NOT_GENERIC = fails(function() {
        return n$ToString.call({ source: "a", flags: "b" }) != "/a/b";
      });
      var INCORRECT_NAME = PROPER_FUNCTION_NAME && n$ToString.name != TO_STRING;
      if (NOT_GENERIC || INCORRECT_NAME) {
        redefine(RegExp.prototype, TO_STRING, function toString() {
          var R = anObject(this);
          var p2 = $toString(R.source);
          var rf = R.flags;
          var f2 = $toString(rf === void 0 && isPrototypeOf(RegExpPrototype, R) && !("flags" in RegExpPrototype) ? getFlags(R) : rf);
          return "/" + p2 + "/" + f2;
        }, { unsafe: true });
      }
    }
  });

  // node_modules/core-js/modules/es.set.js
  var require_es_set = __commonJS({
    "node_modules/core-js/modules/es.set.js"() {
      "use strict";
      var collection = require_collection();
      var collectionStrong = require_collection_strong();
      collection("Set", function(init) {
        return function Set2() {
          return init(this, arguments.length ? arguments[0] : void 0);
        };
      }, collectionStrong);
    }
  });

  // node_modules/core-js/modules/es.string.at-alternative.js
  var require_es_string_at_alternative = __commonJS({
    "node_modules/core-js/modules/es.string.at-alternative.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toString = require_to_string();
      var fails = require_fails();
      var charAt = uncurryThis("".charAt);
      var FORCED = fails(function() {
        return "\u{20BB7}".at(-2) !== "\uD842";
      });
      $2({ target: "String", proto: true, forced: FORCED }, {
        at: function at(index) {
          var S = toString(requireObjectCoercible(this));
          var len = S.length;
          var relativeIndex = toIntegerOrInfinity(index);
          var k2 = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
          return k2 < 0 || k2 >= len ? void 0 : charAt(S, k2);
        }
      });
    }
  });

  // node_modules/core-js/internals/string-multibyte.js
  var require_string_multibyte = __commonJS({
    "node_modules/core-js/internals/string-multibyte.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toString = require_to_string();
      var requireObjectCoercible = require_require_object_coercible();
      var charAt = uncurryThis("".charAt);
      var charCodeAt = uncurryThis("".charCodeAt);
      var stringSlice = uncurryThis("".slice);
      var createMethod = function(CONVERT_TO_STRING) {
        return function($this, pos) {
          var S = toString(requireObjectCoercible($this));
          var position = toIntegerOrInfinity(pos);
          var size = S.length;
          var first, second;
          if (position < 0 || position >= size)
            return CONVERT_TO_STRING ? "" : void 0;
          first = charCodeAt(S, position);
          return first < 55296 || first > 56319 || position + 1 === size || (second = charCodeAt(S, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S, position) : first : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
        };
      };
      module.exports = {
        codeAt: createMethod(false),
        charAt: createMethod(true)
      };
    }
  });

  // node_modules/core-js/modules/es.string.code-point-at.js
  var require_es_string_code_point_at = __commonJS({
    "node_modules/core-js/modules/es.string.code-point-at.js"() {
      "use strict";
      var $2 = require_export();
      var codeAt = require_string_multibyte().codeAt;
      $2({ target: "String", proto: true }, {
        codePointAt: function codePointAt(pos) {
          return codeAt(this, pos);
        }
      });
    }
  });

  // node_modules/core-js/internals/not-a-regexp.js
  var require_not_a_regexp = __commonJS({
    "node_modules/core-js/internals/not-a-regexp.js"(exports, module) {
      var global2 = require_global();
      var isRegExp = require_is_regexp();
      var TypeError2 = global2.TypeError;
      module.exports = function(it) {
        if (isRegExp(it)) {
          throw TypeError2("The method doesn't accept regular expressions");
        }
        return it;
      };
    }
  });

  // node_modules/core-js/internals/correct-is-regexp-logic.js
  var require_correct_is_regexp_logic = __commonJS({
    "node_modules/core-js/internals/correct-is-regexp-logic.js"(exports, module) {
      var wellKnownSymbol = require_well_known_symbol();
      var MATCH = wellKnownSymbol("match");
      module.exports = function(METHOD_NAME) {
        var regexp = /./;
        try {
          "/./"[METHOD_NAME](regexp);
        } catch (error1) {
          try {
            regexp[MATCH] = false;
            return "/./"[METHOD_NAME](regexp);
          } catch (error2) {
          }
        }
        return false;
      };
    }
  });

  // node_modules/core-js/modules/es.string.ends-with.js
  var require_es_string_ends_with = __commonJS({
    "node_modules/core-js/modules/es.string.ends-with.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      var toLength = require_to_length();
      var toString = require_to_string();
      var notARegExp = require_not_a_regexp();
      var requireObjectCoercible = require_require_object_coercible();
      var correctIsRegExpLogic = require_correct_is_regexp_logic();
      var IS_PURE = require_is_pure();
      var un$EndsWith = uncurryThis("".endsWith);
      var slice = uncurryThis("".slice);
      var min2 = Math.min;
      var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("endsWith");
      var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
        var descriptor = getOwnPropertyDescriptor(String.prototype, "endsWith");
        return descriptor && !descriptor.writable;
      }();
      $2({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
        endsWith: function endsWith(searchString) {
          var that = toString(requireObjectCoercible(this));
          notARegExp(searchString);
          var endPosition = arguments.length > 1 ? arguments[1] : void 0;
          var len = that.length;
          var end2 = endPosition === void 0 ? len : min2(toLength(endPosition), len);
          var search = toString(searchString);
          return un$EndsWith ? un$EndsWith(that, search, end2) : slice(that, end2 - search.length, end2) === search;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.from-code-point.js
  var require_es_string_from_code_point = __commonJS({
    "node_modules/core-js/modules/es.string.from-code-point.js"() {
      var $2 = require_export();
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this();
      var toAbsoluteIndex = require_to_absolute_index();
      var RangeError2 = global2.RangeError;
      var fromCharCode = String.fromCharCode;
      var $fromCodePoint = String.fromCodePoint;
      var join = uncurryThis([].join);
      var INCORRECT_LENGTH = !!$fromCodePoint && $fromCodePoint.length != 1;
      $2({ target: "String", stat: true, forced: INCORRECT_LENGTH }, {
        fromCodePoint: function fromCodePoint(x2) {
          var elements = [];
          var length = arguments.length;
          var i2 = 0;
          var code3;
          while (length > i2) {
            code3 = +arguments[i2++];
            if (toAbsoluteIndex(code3, 1114111) !== code3)
              throw RangeError2(code3 + " is not a valid code point");
            elements[i2] = code3 < 65536 ? fromCharCode(code3) : fromCharCode(((code3 -= 65536) >> 10) + 55296, code3 % 1024 + 56320);
          }
          return join(elements, "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.includes.js
  var require_es_string_includes = __commonJS({
    "node_modules/core-js/modules/es.string.includes.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var notARegExp = require_not_a_regexp();
      var requireObjectCoercible = require_require_object_coercible();
      var toString = require_to_string();
      var correctIsRegExpLogic = require_correct_is_regexp_logic();
      var stringIndexOf = uncurryThis("".indexOf);
      $2({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
        includes: function includes(searchString) {
          return !!~stringIndexOf(toString(requireObjectCoercible(this)), toString(notARegExp(searchString)), arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.iterator.js
  var require_es_string_iterator = __commonJS({
    "node_modules/core-js/modules/es.string.iterator.js"() {
      "use strict";
      var charAt = require_string_multibyte().charAt;
      var toString = require_to_string();
      var InternalStateModule = require_internal_state();
      var defineIterator = require_define_iterator();
      var STRING_ITERATOR = "String Iterator";
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
      defineIterator(String, "String", function(iterated) {
        setInternalState(this, {
          type: STRING_ITERATOR,
          string: toString(iterated),
          index: 0
        });
      }, function next() {
        var state = getInternalState(this);
        var string = state.string;
        var index = state.index;
        var point;
        if (index >= string.length)
          return { value: void 0, done: true };
        point = charAt(string, index);
        state.index += point.length;
        return { value: point, done: false };
      });
    }
  });

  // node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js
  var require_fix_regexp_well_known_symbol_logic = __commonJS({
    "node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js"(exports, module) {
      "use strict";
      require_es_regexp_exec();
      var uncurryThis = require_function_uncurry_this();
      var redefine = require_redefine();
      var regexpExec = require_regexp_exec();
      var fails = require_fails();
      var wellKnownSymbol = require_well_known_symbol();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var SPECIES = wellKnownSymbol("species");
      var RegExpPrototype = RegExp.prototype;
      module.exports = function(KEY, exec, FORCED, SHAM) {
        var SYMBOL = wellKnownSymbol(KEY);
        var DELEGATES_TO_SYMBOL = !fails(function() {
          var O = {};
          O[SYMBOL] = function() {
            return 7;
          };
          return ""[KEY](O) != 7;
        });
        var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
          var execCalled = false;
          var re = /a/;
          if (KEY === "split") {
            re = {};
            re.constructor = {};
            re.constructor[SPECIES] = function() {
              return re;
            };
            re.flags = "";
            re[SYMBOL] = /./[SYMBOL];
          }
          re.exec = function() {
            execCalled = true;
            return null;
          };
          re[SYMBOL]("");
          return !execCalled;
        });
        if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
          var uncurriedNativeRegExpMethod = uncurryThis(/./[SYMBOL]);
          var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
            var uncurriedNativeMethod = uncurryThis(nativeMethod);
            var $exec = regexp.exec;
            if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
              if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
              }
              return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
            }
            return { done: false };
          });
          redefine(String.prototype, KEY, methods[0]);
          redefine(RegExpPrototype, SYMBOL, methods[1]);
        }
        if (SHAM)
          createNonEnumerableProperty(RegExpPrototype[SYMBOL], "sham", true);
      };
    }
  });

  // node_modules/core-js/internals/advance-string-index.js
  var require_advance_string_index = __commonJS({
    "node_modules/core-js/internals/advance-string-index.js"(exports, module) {
      "use strict";
      var charAt = require_string_multibyte().charAt;
      module.exports = function(S, index, unicode) {
        return index + (unicode ? charAt(S, index).length : 1);
      };
    }
  });

  // node_modules/core-js/internals/regexp-exec-abstract.js
  var require_regexp_exec_abstract = __commonJS({
    "node_modules/core-js/internals/regexp-exec-abstract.js"(exports, module) {
      var global2 = require_global();
      var call = require_function_call();
      var anObject = require_an_object();
      var isCallable = require_is_callable();
      var classof = require_classof_raw();
      var regexpExec = require_regexp_exec();
      var TypeError2 = global2.TypeError;
      module.exports = function(R, S) {
        var exec = R.exec;
        if (isCallable(exec)) {
          var result = call(exec, R, S);
          if (result !== null)
            anObject(result);
          return result;
        }
        if (classof(R) === "RegExp")
          return call(regexpExec, R, S);
        throw TypeError2("RegExp#exec called on incompatible receiver");
      };
    }
  });

  // node_modules/core-js/modules/es.string.match.js
  var require_es_string_match = __commonJS({
    "node_modules/core-js/modules/es.string.match.js"() {
      "use strict";
      var call = require_function_call();
      var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
      var anObject = require_an_object();
      var toLength = require_to_length();
      var toString = require_to_string();
      var requireObjectCoercible = require_require_object_coercible();
      var getMethod = require_get_method();
      var advanceStringIndex = require_advance_string_index();
      var regExpExec = require_regexp_exec_abstract();
      fixRegExpWellKnownSymbolLogic("match", function(MATCH, nativeMatch, maybeCallNative) {
        return [
          function match(regexp) {
            var O = requireObjectCoercible(this);
            var matcher = regexp == void 0 ? void 0 : getMethod(regexp, MATCH);
            return matcher ? call(matcher, regexp, O) : new RegExp(regexp)[MATCH](toString(O));
          },
          function(string) {
            var rx = anObject(this);
            var S = toString(string);
            var res = maybeCallNative(nativeMatch, rx, S);
            if (res.done)
              return res.value;
            if (!rx.global)
              return regExpExec(rx, S);
            var fullUnicode = rx.unicode;
            rx.lastIndex = 0;
            var A2 = [];
            var n2 = 0;
            var result;
            while ((result = regExpExec(rx, S)) !== null) {
              var matchStr = toString(result[0]);
              A2[n2] = matchStr;
              if (matchStr === "")
                rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
              n2++;
            }
            return n2 === 0 ? null : A2;
          }
        ];
      });
    }
  });

  // node_modules/core-js/modules/es.string.match-all.js
  var require_es_string_match_all = __commonJS({
    "node_modules/core-js/modules/es.string.match-all.js"() {
      "use strict";
      var $2 = require_export();
      var global2 = require_global();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var createIteratorConstructor = require_create_iterator_constructor();
      var requireObjectCoercible = require_require_object_coercible();
      var toLength = require_to_length();
      var toString = require_to_string();
      var anObject = require_an_object();
      var classof = require_classof_raw();
      var isPrototypeOf = require_object_is_prototype_of();
      var isRegExp = require_is_regexp();
      var regExpFlags = require_regexp_flags();
      var getMethod = require_get_method();
      var redefine = require_redefine();
      var fails = require_fails();
      var wellKnownSymbol = require_well_known_symbol();
      var speciesConstructor = require_species_constructor();
      var advanceStringIndex = require_advance_string_index();
      var regExpExec = require_regexp_exec_abstract();
      var InternalStateModule = require_internal_state();
      var IS_PURE = require_is_pure();
      var MATCH_ALL = wellKnownSymbol("matchAll");
      var REGEXP_STRING = "RegExp String";
      var REGEXP_STRING_ITERATOR = REGEXP_STRING + " Iterator";
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(REGEXP_STRING_ITERATOR);
      var RegExpPrototype = RegExp.prototype;
      var TypeError2 = global2.TypeError;
      var getFlags = uncurryThis(regExpFlags);
      var stringIndexOf = uncurryThis("".indexOf);
      var un$MatchAll = uncurryThis("".matchAll);
      var WORKS_WITH_NON_GLOBAL_REGEX = !!un$MatchAll && !fails(function() {
        un$MatchAll("a", /./);
      });
      var $RegExpStringIterator = createIteratorConstructor(function RegExpStringIterator(regexp, string, $global, fullUnicode) {
        setInternalState(this, {
          type: REGEXP_STRING_ITERATOR,
          regexp,
          string,
          global: $global,
          unicode: fullUnicode,
          done: false
        });
      }, REGEXP_STRING, function next() {
        var state = getInternalState(this);
        if (state.done)
          return { value: void 0, done: true };
        var R = state.regexp;
        var S = state.string;
        var match = regExpExec(R, S);
        if (match === null)
          return { value: void 0, done: state.done = true };
        if (state.global) {
          if (toString(match[0]) === "")
            R.lastIndex = advanceStringIndex(S, toLength(R.lastIndex), state.unicode);
          return { value: match, done: false };
        }
        state.done = true;
        return { value: match, done: false };
      });
      var $matchAll = function(string) {
        var R = anObject(this);
        var S = toString(string);
        var C2, flagsValue, flags, matcher, $global, fullUnicode;
        C2 = speciesConstructor(R, RegExp);
        flagsValue = R.flags;
        if (flagsValue === void 0 && isPrototypeOf(RegExpPrototype, R) && !("flags" in RegExpPrototype)) {
          flagsValue = getFlags(R);
        }
        flags = flagsValue === void 0 ? "" : toString(flagsValue);
        matcher = new C2(C2 === RegExp ? R.source : R, flags);
        $global = !!~stringIndexOf(flags, "g");
        fullUnicode = !!~stringIndexOf(flags, "u");
        matcher.lastIndex = toLength(R.lastIndex);
        return new $RegExpStringIterator(matcher, S, $global, fullUnicode);
      };
      $2({ target: "String", proto: true, forced: WORKS_WITH_NON_GLOBAL_REGEX }, {
        matchAll: function matchAll(regexp) {
          var O = requireObjectCoercible(this);
          var flags, S, matcher, rx;
          if (regexp != null) {
            if (isRegExp(regexp)) {
              flags = toString(requireObjectCoercible("flags" in RegExpPrototype ? regexp.flags : getFlags(regexp)));
              if (!~stringIndexOf(flags, "g"))
                throw TypeError2("`.matchAll` does not allow non-global regexes");
            }
            if (WORKS_WITH_NON_GLOBAL_REGEX)
              return un$MatchAll(O, regexp);
            matcher = getMethod(regexp, MATCH_ALL);
            if (matcher === void 0 && IS_PURE && classof(regexp) == "RegExp")
              matcher = $matchAll;
            if (matcher)
              return call(matcher, regexp, O);
          } else if (WORKS_WITH_NON_GLOBAL_REGEX)
            return un$MatchAll(O, regexp);
          S = toString(O);
          rx = new RegExp(regexp, "g");
          return IS_PURE ? call($matchAll, rx, S) : rx[MATCH_ALL](S);
        }
      });
      IS_PURE || MATCH_ALL in RegExpPrototype || redefine(RegExpPrototype, MATCH_ALL, $matchAll);
    }
  });

  // node_modules/core-js/internals/string-pad-webkit-bug.js
  var require_string_pad_webkit_bug = __commonJS({
    "node_modules/core-js/internals/string-pad-webkit-bug.js"(exports, module) {
      var userAgent = require_engine_user_agent();
      module.exports = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(userAgent);
    }
  });

  // node_modules/core-js/modules/es.string.pad-end.js
  var require_es_string_pad_end = __commonJS({
    "node_modules/core-js/modules/es.string.pad-end.js"() {
      "use strict";
      var $2 = require_export();
      var $padEnd = require_string_pad().end;
      var WEBKIT_BUG = require_string_pad_webkit_bug();
      $2({ target: "String", proto: true, forced: WEBKIT_BUG }, {
        padEnd: function padEnd(maxLength) {
          return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.pad-start.js
  var require_es_string_pad_start = __commonJS({
    "node_modules/core-js/modules/es.string.pad-start.js"() {
      "use strict";
      var $2 = require_export();
      var $padStart = require_string_pad().start;
      var WEBKIT_BUG = require_string_pad_webkit_bug();
      $2({ target: "String", proto: true, forced: WEBKIT_BUG }, {
        padStart: function padStart(maxLength) {
          return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.raw.js
  var require_es_string_raw = __commonJS({
    "node_modules/core-js/modules/es.string.raw.js"() {
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toIndexedObject = require_to_indexed_object();
      var toObject = require_to_object();
      var toString = require_to_string();
      var lengthOfArrayLike = require_length_of_array_like();
      var push = uncurryThis([].push);
      var join = uncurryThis([].join);
      $2({ target: "String", stat: true }, {
        raw: function raw(template) {
          var rawTemplate = toIndexedObject(toObject(template).raw);
          var literalSegments = lengthOfArrayLike(rawTemplate);
          var argumentsLength = arguments.length;
          var elements = [];
          var i2 = 0;
          while (literalSegments > i2) {
            push(elements, toString(rawTemplate[i2++]));
            if (i2 === literalSegments)
              return join(elements, "");
            if (i2 < argumentsLength)
              push(elements, toString(arguments[i2]));
          }
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.repeat.js
  var require_es_string_repeat = __commonJS({
    "node_modules/core-js/modules/es.string.repeat.js"() {
      var $2 = require_export();
      var repeat = require_string_repeat();
      $2({ target: "String", proto: true }, {
        repeat
      });
    }
  });

  // node_modules/core-js/internals/get-substitution.js
  var require_get_substitution = __commonJS({
    "node_modules/core-js/internals/get-substitution.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      var toObject = require_to_object();
      var floor = Math.floor;
      var charAt = uncurryThis("".charAt);
      var replace = uncurryThis("".replace);
      var stringSlice = uncurryThis("".slice);
      var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
      var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
      module.exports = function(matched, str, position, captures, namedCaptures, replacement) {
        var tailPos = position + matched.length;
        var m2 = captures.length;
        var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
        if (namedCaptures !== void 0) {
          namedCaptures = toObject(namedCaptures);
          symbols = SUBSTITUTION_SYMBOLS;
        }
        return replace(replacement, symbols, function(match, ch) {
          var capture;
          switch (charAt(ch, 0)) {
            case "$":
              return "$";
            case "&":
              return matched;
            case "`":
              return stringSlice(str, 0, position);
            case "'":
              return stringSlice(str, tailPos);
            case "<":
              capture = namedCaptures[stringSlice(ch, 1, -1)];
              break;
            default:
              var n2 = +ch;
              if (n2 === 0)
                return match;
              if (n2 > m2) {
                var f2 = floor(n2 / 10);
                if (f2 === 0)
                  return match;
                if (f2 <= m2)
                  return captures[f2 - 1] === void 0 ? charAt(ch, 1) : captures[f2 - 1] + charAt(ch, 1);
                return match;
              }
              capture = captures[n2 - 1];
          }
          return capture === void 0 ? "" : capture;
        });
      };
    }
  });

  // node_modules/core-js/modules/es.string.replace.js
  var require_es_string_replace = __commonJS({
    "node_modules/core-js/modules/es.string.replace.js"() {
      "use strict";
      var apply = require_function_apply();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
      var fails = require_fails();
      var anObject = require_an_object();
      var isCallable = require_is_callable();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toLength = require_to_length();
      var toString = require_to_string();
      var requireObjectCoercible = require_require_object_coercible();
      var advanceStringIndex = require_advance_string_index();
      var getMethod = require_get_method();
      var getSubstitution = require_get_substitution();
      var regExpExec = require_regexp_exec_abstract();
      var wellKnownSymbol = require_well_known_symbol();
      var REPLACE = wellKnownSymbol("replace");
      var max2 = Math.max;
      var min2 = Math.min;
      var concat = uncurryThis([].concat);
      var push = uncurryThis([].push);
      var stringIndexOf = uncurryThis("".indexOf);
      var stringSlice = uncurryThis("".slice);
      var maybeToString = function(it) {
        return it === void 0 ? it : String(it);
      };
      var REPLACE_KEEPS_$0 = function() {
        return "a".replace(/./, "$0") === "$0";
      }();
      var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
        if (/./[REPLACE]) {
          return /./[REPLACE]("a", "$0") === "";
        }
        return false;
      }();
      var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
        var re = /./;
        re.exec = function() {
          var result = [];
          result.groups = { a: "7" };
          return result;
        };
        return "".replace(re, "$<a>") !== "7";
      });
      fixRegExpWellKnownSymbolLogic("replace", function(_2, nativeReplace, maybeCallNative) {
        var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
        return [
          function replace(searchValue, replaceValue) {
            var O = requireObjectCoercible(this);
            var replacer = searchValue == void 0 ? void 0 : getMethod(searchValue, REPLACE);
            return replacer ? call(replacer, searchValue, O, replaceValue) : call(nativeReplace, toString(O), searchValue, replaceValue);
          },
          function(string, replaceValue) {
            var rx = anObject(this);
            var S = toString(string);
            if (typeof replaceValue == "string" && stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf(replaceValue, "$<") === -1) {
              var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
              if (res.done)
                return res.value;
            }
            var functionalReplace = isCallable(replaceValue);
            if (!functionalReplace)
              replaceValue = toString(replaceValue);
            var global2 = rx.global;
            if (global2) {
              var fullUnicode = rx.unicode;
              rx.lastIndex = 0;
            }
            var results = [];
            while (true) {
              var result = regExpExec(rx, S);
              if (result === null)
                break;
              push(results, result);
              if (!global2)
                break;
              var matchStr = toString(result[0]);
              if (matchStr === "")
                rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
            }
            var accumulatedResult = "";
            var nextSourcePosition = 0;
            for (var i2 = 0; i2 < results.length; i2++) {
              result = results[i2];
              var matched = toString(result[0]);
              var position = max2(min2(toIntegerOrInfinity(result.index), S.length), 0);
              var captures = [];
              for (var j2 = 1; j2 < result.length; j2++)
                push(captures, maybeToString(result[j2]));
              var namedCaptures = result.groups;
              if (functionalReplace) {
                var replacerArgs = concat([matched], captures, position, S);
                if (namedCaptures !== void 0)
                  push(replacerArgs, namedCaptures);
                var replacement = toString(apply(replaceValue, void 0, replacerArgs));
              } else {
                replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
              }
              if (position >= nextSourcePosition) {
                accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
                nextSourcePosition = position + matched.length;
              }
            }
            return accumulatedResult + stringSlice(S, nextSourcePosition);
          }
        ];
      }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
    }
  });

  // node_modules/core-js/modules/es.string.replace-all.js
  var require_es_string_replace_all = __commonJS({
    "node_modules/core-js/modules/es.string.replace-all.js"() {
      "use strict";
      var $2 = require_export();
      var global2 = require_global();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var isCallable = require_is_callable();
      var isRegExp = require_is_regexp();
      var toString = require_to_string();
      var getMethod = require_get_method();
      var regExpFlags = require_regexp_flags();
      var getSubstitution = require_get_substitution();
      var wellKnownSymbol = require_well_known_symbol();
      var IS_PURE = require_is_pure();
      var REPLACE = wellKnownSymbol("replace");
      var RegExpPrototype = RegExp.prototype;
      var TypeError2 = global2.TypeError;
      var getFlags = uncurryThis(regExpFlags);
      var indexOf2 = uncurryThis("".indexOf);
      var replace = uncurryThis("".replace);
      var stringSlice = uncurryThis("".slice);
      var max2 = Math.max;
      var stringIndexOf = function(string, searchValue, fromIndex) {
        if (fromIndex > string.length)
          return -1;
        if (searchValue === "")
          return fromIndex;
        return indexOf2(string, searchValue, fromIndex);
      };
      $2({ target: "String", proto: true }, {
        replaceAll: function replaceAll(searchValue, replaceValue) {
          var O = requireObjectCoercible(this);
          var IS_REG_EXP, flags, replacer, string, searchString, functionalReplace, searchLength, advanceBy, replacement;
          var position = 0;
          var endOfLastMatch = 0;
          var result = "";
          if (searchValue != null) {
            IS_REG_EXP = isRegExp(searchValue);
            if (IS_REG_EXP) {
              flags = toString(requireObjectCoercible("flags" in RegExpPrototype ? searchValue.flags : getFlags(searchValue)));
              if (!~indexOf2(flags, "g"))
                throw TypeError2("`.replaceAll` does not allow non-global regexes");
            }
            replacer = getMethod(searchValue, REPLACE);
            if (replacer) {
              return call(replacer, searchValue, O, replaceValue);
            } else if (IS_PURE && IS_REG_EXP) {
              return replace(toString(O), searchValue, replaceValue);
            }
          }
          string = toString(O);
          searchString = toString(searchValue);
          functionalReplace = isCallable(replaceValue);
          if (!functionalReplace)
            replaceValue = toString(replaceValue);
          searchLength = searchString.length;
          advanceBy = max2(1, searchLength);
          position = stringIndexOf(string, searchString, 0);
          while (position !== -1) {
            replacement = functionalReplace ? toString(replaceValue(searchString, position, string)) : getSubstitution(searchString, string, position, [], void 0, replaceValue);
            result += stringSlice(string, endOfLastMatch, position) + replacement;
            endOfLastMatch = position + searchLength;
            position = stringIndexOf(string, searchString, position + advanceBy);
          }
          if (endOfLastMatch < string.length) {
            result += stringSlice(string, endOfLastMatch);
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.search.js
  var require_es_string_search = __commonJS({
    "node_modules/core-js/modules/es.string.search.js"() {
      "use strict";
      var call = require_function_call();
      var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
      var anObject = require_an_object();
      var requireObjectCoercible = require_require_object_coercible();
      var sameValue = require_same_value();
      var toString = require_to_string();
      var getMethod = require_get_method();
      var regExpExec = require_regexp_exec_abstract();
      fixRegExpWellKnownSymbolLogic("search", function(SEARCH, nativeSearch, maybeCallNative) {
        return [
          function search(regexp) {
            var O = requireObjectCoercible(this);
            var searcher = regexp == void 0 ? void 0 : getMethod(regexp, SEARCH);
            return searcher ? call(searcher, regexp, O) : new RegExp(regexp)[SEARCH](toString(O));
          },
          function(string) {
            var rx = anObject(this);
            var S = toString(string);
            var res = maybeCallNative(nativeSearch, rx, S);
            if (res.done)
              return res.value;
            var previousLastIndex = rx.lastIndex;
            if (!sameValue(previousLastIndex, 0))
              rx.lastIndex = 0;
            var result = regExpExec(rx, S);
            if (!sameValue(rx.lastIndex, previousLastIndex))
              rx.lastIndex = previousLastIndex;
            return result === null ? -1 : result.index;
          }
        ];
      });
    }
  });

  // node_modules/core-js/modules/es.string.split.js
  var require_es_string_split = __commonJS({
    "node_modules/core-js/modules/es.string.split.js"() {
      "use strict";
      var apply = require_function_apply();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
      var isRegExp = require_is_regexp();
      var anObject = require_an_object();
      var requireObjectCoercible = require_require_object_coercible();
      var speciesConstructor = require_species_constructor();
      var advanceStringIndex = require_advance_string_index();
      var toLength = require_to_length();
      var toString = require_to_string();
      var getMethod = require_get_method();
      var arraySlice = require_array_slice_simple();
      var callRegExpExec = require_regexp_exec_abstract();
      var regexpExec = require_regexp_exec();
      var stickyHelpers = require_regexp_sticky_helpers();
      var fails = require_fails();
      var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
      var MAX_UINT32 = 4294967295;
      var min2 = Math.min;
      var $push = [].push;
      var exec = uncurryThis(/./.exec);
      var push = uncurryThis($push);
      var stringSlice = uncurryThis("".slice);
      var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
        var re = /(?:)/;
        var originalExec = re.exec;
        re.exec = function() {
          return originalExec.apply(this, arguments);
        };
        var result = "ab".split(re);
        return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
      });
      fixRegExpWellKnownSymbolLogic("split", function(SPLIT, nativeSplit, maybeCallNative) {
        var internalSplit;
        if ("abbc".split(/(b)*/)[1] == "c" || "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || ".".split(/()()/).length > 1 || "".split(/.?/).length) {
          internalSplit = function(separator, limit) {
            var string = toString(requireObjectCoercible(this));
            var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
            if (lim === 0)
              return [];
            if (separator === void 0)
              return [string];
            if (!isRegExp(separator)) {
              return call(nativeSplit, string, separator, lim);
            }
            var output = [];
            var flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.unicode ? "u" : "") + (separator.sticky ? "y" : "");
            var lastLastIndex = 0;
            var separatorCopy = new RegExp(separator.source, flags + "g");
            var match, lastIndex, lastLength;
            while (match = call(regexpExec, separatorCopy, string)) {
              lastIndex = separatorCopy.lastIndex;
              if (lastIndex > lastLastIndex) {
                push(output, stringSlice(string, lastLastIndex, match.index));
                if (match.length > 1 && match.index < string.length)
                  apply($push, output, arraySlice(match, 1));
                lastLength = match[0].length;
                lastLastIndex = lastIndex;
                if (output.length >= lim)
                  break;
              }
              if (separatorCopy.lastIndex === match.index)
                separatorCopy.lastIndex++;
            }
            if (lastLastIndex === string.length) {
              if (lastLength || !exec(separatorCopy, ""))
                push(output, "");
            } else
              push(output, stringSlice(string, lastLastIndex));
            return output.length > lim ? arraySlice(output, 0, lim) : output;
          };
        } else if ("0".split(void 0, 0).length) {
          internalSplit = function(separator, limit) {
            return separator === void 0 && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
          };
        } else
          internalSplit = nativeSplit;
        return [
          function split(separator, limit) {
            var O = requireObjectCoercible(this);
            var splitter = separator == void 0 ? void 0 : getMethod(separator, SPLIT);
            return splitter ? call(splitter, separator, O, limit) : call(internalSplit, toString(O), separator, limit);
          },
          function(string, limit) {
            var rx = anObject(this);
            var S = toString(string);
            var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);
            if (res.done)
              return res.value;
            var C2 = speciesConstructor(rx, RegExp);
            var unicodeMatching = rx.unicode;
            var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
            var splitter = new C2(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
            var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
            if (lim === 0)
              return [];
            if (S.length === 0)
              return callRegExpExec(splitter, S) === null ? [S] : [];
            var p2 = 0;
            var q = 0;
            var A2 = [];
            while (q < S.length) {
              splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
              var z2 = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);
              var e2;
              if (z2 === null || (e2 = min2(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p2) {
                q = advanceStringIndex(S, q, unicodeMatching);
              } else {
                push(A2, stringSlice(S, p2, q));
                if (A2.length === lim)
                  return A2;
                for (var i2 = 1; i2 <= z2.length - 1; i2++) {
                  push(A2, z2[i2]);
                  if (A2.length === lim)
                    return A2;
                }
                q = p2 = e2;
              }
            }
            push(A2, stringSlice(S, p2));
            return A2;
          }
        ];
      }, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
    }
  });

  // node_modules/core-js/modules/es.string.starts-with.js
  var require_es_string_starts_with = __commonJS({
    "node_modules/core-js/modules/es.string.starts-with.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      var toLength = require_to_length();
      var toString = require_to_string();
      var notARegExp = require_not_a_regexp();
      var requireObjectCoercible = require_require_object_coercible();
      var correctIsRegExpLogic = require_correct_is_regexp_logic();
      var IS_PURE = require_is_pure();
      var un$StartsWith = uncurryThis("".startsWith);
      var stringSlice = uncurryThis("".slice);
      var min2 = Math.min;
      var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
      var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
        var descriptor = getOwnPropertyDescriptor(String.prototype, "startsWith");
        return descriptor && !descriptor.writable;
      }();
      $2({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
        startsWith: function startsWith(searchString) {
          var that = toString(requireObjectCoercible(this));
          notARegExp(searchString);
          var index = toLength(min2(arguments.length > 1 ? arguments[1] : void 0, that.length));
          var search = toString(searchString);
          return un$StartsWith ? un$StartsWith(that, search, index) : stringSlice(that, index, index + search.length) === search;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.substr.js
  var require_es_string_substr = __commonJS({
    "node_modules/core-js/modules/es.string.substr.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toString = require_to_string();
      var stringSlice = uncurryThis("".slice);
      var max2 = Math.max;
      var min2 = Math.min;
      var FORCED = !"".substr || "ab".substr(-1) !== "b";
      $2({ target: "String", proto: true, forced: FORCED }, {
        substr: function substr(start4, length) {
          var that = toString(requireObjectCoercible(this));
          var size = that.length;
          var intStart = toIntegerOrInfinity(start4);
          var intLength, intEnd;
          if (intStart === Infinity)
            intStart = 0;
          if (intStart < 0)
            intStart = max2(size + intStart, 0);
          intLength = length === void 0 ? size : toIntegerOrInfinity(length);
          if (intLength <= 0 || intLength === Infinity)
            return "";
          intEnd = min2(intStart + intLength, size);
          return intStart >= intEnd ? "" : stringSlice(that, intStart, intEnd);
        }
      });
    }
  });

  // node_modules/core-js/internals/string-trim-forced.js
  var require_string_trim_forced = __commonJS({
    "node_modules/core-js/internals/string-trim-forced.js"(exports, module) {
      var PROPER_FUNCTION_NAME = require_function_name().PROPER;
      var fails = require_fails();
      var whitespaces = require_whitespaces();
      var non = "\u200B\x85\u180E";
      module.exports = function(METHOD_NAME) {
        return fails(function() {
          return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
        });
      };
    }
  });

  // node_modules/core-js/modules/es.string.trim.js
  var require_es_string_trim = __commonJS({
    "node_modules/core-js/modules/es.string.trim.js"() {
      "use strict";
      var $2 = require_export();
      var $trim = require_string_trim().trim;
      var forcedStringTrimMethod = require_string_trim_forced();
      $2({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
        trim: function trim() {
          return $trim(this);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.trim-end.js
  var require_es_string_trim_end = __commonJS({
    "node_modules/core-js/modules/es.string.trim-end.js"() {
      "use strict";
      var $2 = require_export();
      var $trimEnd = require_string_trim().end;
      var forcedStringTrimMethod = require_string_trim_forced();
      var FORCED = forcedStringTrimMethod("trimEnd");
      var trimEnd = FORCED ? function trimEnd2() {
        return $trimEnd(this);
      } : "".trimEnd;
      $2({ target: "String", proto: true, name: "trimEnd", forced: FORCED }, {
        trimEnd,
        trimRight: trimEnd
      });
    }
  });

  // node_modules/core-js/modules/es.string.trim-start.js
  var require_es_string_trim_start = __commonJS({
    "node_modules/core-js/modules/es.string.trim-start.js"() {
      "use strict";
      var $2 = require_export();
      var $trimStart = require_string_trim().start;
      var forcedStringTrimMethod = require_string_trim_forced();
      var FORCED = forcedStringTrimMethod("trimStart");
      var trimStart = FORCED ? function trimStart2() {
        return $trimStart(this);
      } : "".trimStart;
      $2({ target: "String", proto: true, name: "trimStart", forced: FORCED }, {
        trimStart,
        trimLeft: trimStart
      });
    }
  });

  // node_modules/core-js/internals/create-html.js
  var require_create_html = __commonJS({
    "node_modules/core-js/internals/create-html.js"(exports, module) {
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var toString = require_to_string();
      var quot = /"/g;
      var replace = uncurryThis("".replace);
      module.exports = function(string, tag, attribute, value) {
        var S = toString(requireObjectCoercible(string));
        var p1 = "<" + tag;
        if (attribute !== "")
          p1 += " " + attribute + '="' + replace(toString(value), quot, "&quot;") + '"';
        return p1 + ">" + S + "</" + tag + ">";
      };
    }
  });

  // node_modules/core-js/internals/string-html-forced.js
  var require_string_html_forced = __commonJS({
    "node_modules/core-js/internals/string-html-forced.js"(exports, module) {
      var fails = require_fails();
      module.exports = function(METHOD_NAME) {
        return fails(function() {
          var test = ""[METHOD_NAME]('"');
          return test !== test.toLowerCase() || test.split('"').length > 3;
        });
      };
    }
  });

  // node_modules/core-js/modules/es.string.anchor.js
  var require_es_string_anchor = __commonJS({
    "node_modules/core-js/modules/es.string.anchor.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("anchor") }, {
        anchor: function anchor(name) {
          return createHTML(this, "a", "name", name);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.big.js
  var require_es_string_big = __commonJS({
    "node_modules/core-js/modules/es.string.big.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("big") }, {
        big: function big() {
          return createHTML(this, "big", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.blink.js
  var require_es_string_blink = __commonJS({
    "node_modules/core-js/modules/es.string.blink.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("blink") }, {
        blink: function blink() {
          return createHTML(this, "blink", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.bold.js
  var require_es_string_bold = __commonJS({
    "node_modules/core-js/modules/es.string.bold.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("bold") }, {
        bold: function bold() {
          return createHTML(this, "b", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.fixed.js
  var require_es_string_fixed = __commonJS({
    "node_modules/core-js/modules/es.string.fixed.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("fixed") }, {
        fixed: function fixed() {
          return createHTML(this, "tt", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.fontcolor.js
  var require_es_string_fontcolor = __commonJS({
    "node_modules/core-js/modules/es.string.fontcolor.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("fontcolor") }, {
        fontcolor: function fontcolor(color) {
          return createHTML(this, "font", "color", color);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.fontsize.js
  var require_es_string_fontsize = __commonJS({
    "node_modules/core-js/modules/es.string.fontsize.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("fontsize") }, {
        fontsize: function fontsize(size) {
          return createHTML(this, "font", "size", size);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.italics.js
  var require_es_string_italics = __commonJS({
    "node_modules/core-js/modules/es.string.italics.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("italics") }, {
        italics: function italics() {
          return createHTML(this, "i", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.link.js
  var require_es_string_link = __commonJS({
    "node_modules/core-js/modules/es.string.link.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("link") }, {
        link: function link(url) {
          return createHTML(this, "a", "href", url);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.small.js
  var require_es_string_small = __commonJS({
    "node_modules/core-js/modules/es.string.small.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("small") }, {
        small: function small() {
          return createHTML(this, "small", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.strike.js
  var require_es_string_strike = __commonJS({
    "node_modules/core-js/modules/es.string.strike.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("strike") }, {
        strike: function strike() {
          return createHTML(this, "strike", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.sub.js
  var require_es_string_sub = __commonJS({
    "node_modules/core-js/modules/es.string.sub.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("sub") }, {
        sub: function sub() {
          return createHTML(this, "sub", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.sup.js
  var require_es_string_sup = __commonJS({
    "node_modules/core-js/modules/es.string.sup.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("sup") }, {
        sup: function sup() {
          return createHTML(this, "sup", "", "");
        }
      });
    }
  });

  // node_modules/core-js/internals/typed-array-constructors-require-wrappers.js
  var require_typed_array_constructors_require_wrappers = __commonJS({
    "node_modules/core-js/internals/typed-array-constructors-require-wrappers.js"(exports, module) {
      var global2 = require_global();
      var fails = require_fails();
      var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
      var NATIVE_ARRAY_BUFFER_VIEWS = require_array_buffer_view_core().NATIVE_ARRAY_BUFFER_VIEWS;
      var ArrayBuffer2 = global2.ArrayBuffer;
      var Int8Array2 = global2.Int8Array;
      module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function() {
        Int8Array2(1);
      }) || !fails(function() {
        new Int8Array2(-1);
      }) || !checkCorrectnessOfIteration(function(iterable) {
        new Int8Array2();
        new Int8Array2(null);
        new Int8Array2(1.5);
        new Int8Array2(iterable);
      }, true) || fails(function() {
        return new Int8Array2(new ArrayBuffer2(2), 1, void 0).length !== 1;
      });
    }
  });

  // node_modules/core-js/internals/to-positive-integer.js
  var require_to_positive_integer = __commonJS({
    "node_modules/core-js/internals/to-positive-integer.js"(exports, module) {
      var global2 = require_global();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var RangeError2 = global2.RangeError;
      module.exports = function(it) {
        var result = toIntegerOrInfinity(it);
        if (result < 0)
          throw RangeError2("The argument can't be less than 0");
        return result;
      };
    }
  });

  // node_modules/core-js/internals/to-offset.js
  var require_to_offset = __commonJS({
    "node_modules/core-js/internals/to-offset.js"(exports, module) {
      var global2 = require_global();
      var toPositiveInteger = require_to_positive_integer();
      var RangeError2 = global2.RangeError;
      module.exports = function(it, BYTES) {
        var offset2 = toPositiveInteger(it);
        if (offset2 % BYTES)
          throw RangeError2("Wrong offset");
        return offset2;
      };
    }
  });

  // node_modules/core-js/internals/typed-array-from.js
  var require_typed_array_from = __commonJS({
    "node_modules/core-js/internals/typed-array-from.js"(exports, module) {
      var bind3 = require_function_bind_context();
      var call = require_function_call();
      var aConstructor = require_a_constructor();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var getIterator = require_get_iterator();
      var getIteratorMethod = require_get_iterator_method();
      var isArrayIteratorMethod = require_is_array_iterator_method();
      var aTypedArrayConstructor = require_array_buffer_view_core().aTypedArrayConstructor;
      module.exports = function from(source) {
        var C2 = aConstructor(this);
        var O = toObject(source);
        var argumentsLength = arguments.length;
        var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
        var mapping = mapfn !== void 0;
        var iteratorMethod = getIteratorMethod(O);
        var i2, length, result, step, iterator, next;
        if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {
          iterator = getIterator(O, iteratorMethod);
          next = iterator.next;
          O = [];
          while (!(step = call(next, iterator)).done) {
            O.push(step.value);
          }
        }
        if (mapping && argumentsLength > 2) {
          mapfn = bind3(mapfn, arguments[2]);
        }
        length = lengthOfArrayLike(O);
        result = new (aTypedArrayConstructor(C2))(length);
        for (i2 = 0; length > i2; i2++) {
          result[i2] = mapping ? mapfn(O[i2], i2) : O[i2];
        }
        return result;
      };
    }
  });

  // node_modules/core-js/internals/typed-array-constructor.js
  var require_typed_array_constructor = __commonJS({
    "node_modules/core-js/internals/typed-array-constructor.js"(exports, module) {
      "use strict";
      var $2 = require_export();
      var global2 = require_global();
      var call = require_function_call();
      var DESCRIPTORS = require_descriptors();
      var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require_typed_array_constructors_require_wrappers();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var ArrayBufferModule = require_array_buffer();
      var anInstance = require_an_instance();
      var createPropertyDescriptor = require_create_property_descriptor();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var isIntegralNumber = require_is_integral_number();
      var toLength = require_to_length();
      var toIndex = require_to_index();
      var toOffset = require_to_offset();
      var toPropertyKey = require_to_property_key();
      var hasOwn = require_has_own_property();
      var classof = require_classof();
      var isObject3 = require_is_object();
      var isSymbol = require_is_symbol();
      var create = require_object_create();
      var isPrototypeOf = require_object_is_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var getOwnPropertyNames = require_object_get_own_property_names().f;
      var typedArrayFrom = require_typed_array_from();
      var forEach = require_array_iteration().forEach;
      var setSpecies = require_set_species();
      var definePropertyModule = require_object_define_property();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var InternalStateModule = require_internal_state();
      var inheritIfRequired = require_inherit_if_required();
      var getInternalState = InternalStateModule.get;
      var setInternalState = InternalStateModule.set;
      var nativeDefineProperty = definePropertyModule.f;
      var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      var round2 = Math.round;
      var RangeError2 = global2.RangeError;
      var ArrayBuffer2 = ArrayBufferModule.ArrayBuffer;
      var ArrayBufferPrototype = ArrayBuffer2.prototype;
      var DataView2 = ArrayBufferModule.DataView;
      var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
      var TYPED_ARRAY_CONSTRUCTOR = ArrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
      var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
      var TypedArray = ArrayBufferViewCore.TypedArray;
      var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
      var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
      var isTypedArray = ArrayBufferViewCore.isTypedArray;
      var BYTES_PER_ELEMENT = "BYTES_PER_ELEMENT";
      var WRONG_LENGTH = "Wrong length";
      var fromList = function(C2, list) {
        aTypedArrayConstructor(C2);
        var index = 0;
        var length = list.length;
        var result = new C2(length);
        while (length > index)
          result[index] = list[index++];
        return result;
      };
      var addGetter = function(it, key) {
        nativeDefineProperty(it, key, { get: function() {
          return getInternalState(this)[key];
        } });
      };
      var isArrayBuffer = function(it) {
        var klass;
        return isPrototypeOf(ArrayBufferPrototype, it) || (klass = classof(it)) == "ArrayBuffer" || klass == "SharedArrayBuffer";
      };
      var isTypedArrayIndex = function(target, key) {
        return isTypedArray(target) && !isSymbol(key) && key in target && isIntegralNumber(+key) && key >= 0;
      };
      var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
        key = toPropertyKey(key);
        return isTypedArrayIndex(target, key) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
      };
      var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
        key = toPropertyKey(key);
        if (isTypedArrayIndex(target, key) && isObject3(descriptor) && hasOwn(descriptor, "value") && !hasOwn(descriptor, "get") && !hasOwn(descriptor, "set") && !descriptor.configurable && (!hasOwn(descriptor, "writable") || descriptor.writable) && (!hasOwn(descriptor, "enumerable") || descriptor.enumerable)) {
          target[key] = descriptor.value;
          return target;
        }
        return nativeDefineProperty(target, key, descriptor);
      };
      if (DESCRIPTORS) {
        if (!NATIVE_ARRAY_BUFFER_VIEWS) {
          getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
          definePropertyModule.f = wrappedDefineProperty;
          addGetter(TypedArrayPrototype, "buffer");
          addGetter(TypedArrayPrototype, "byteOffset");
          addGetter(TypedArrayPrototype, "byteLength");
          addGetter(TypedArrayPrototype, "length");
        }
        $2({ target: "Object", stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
          getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
          defineProperty: wrappedDefineProperty
        });
        module.exports = function(TYPE, wrapper, CLAMPED) {
          var BYTES = TYPE.match(/\d+$/)[0] / 8;
          var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? "Clamped" : "") + "Array";
          var GETTER = "get" + TYPE;
          var SETTER = "set" + TYPE;
          var NativeTypedArrayConstructor = global2[CONSTRUCTOR_NAME];
          var TypedArrayConstructor = NativeTypedArrayConstructor;
          var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
          var exported = {};
          var getter = function(that, index) {
            var data = getInternalState(that);
            return data.view[GETTER](index * BYTES + data.byteOffset, true);
          };
          var setter = function(that, index, value) {
            var data = getInternalState(that);
            if (CLAMPED)
              value = (value = round2(value)) < 0 ? 0 : value > 255 ? 255 : value & 255;
            data.view[SETTER](index * BYTES + data.byteOffset, value, true);
          };
          var addElement = function(that, index) {
            nativeDefineProperty(that, index, {
              get: function() {
                return getter(this, index);
              },
              set: function(value) {
                return setter(this, index, value);
              },
              enumerable: true
            });
          };
          if (!NATIVE_ARRAY_BUFFER_VIEWS) {
            TypedArrayConstructor = wrapper(function(that, data, offset2, $length) {
              anInstance(that, TypedArrayConstructorPrototype);
              var index = 0;
              var byteOffset = 0;
              var buffer, byteLength, length;
              if (!isObject3(data)) {
                length = toIndex(data);
                byteLength = length * BYTES;
                buffer = new ArrayBuffer2(byteLength);
              } else if (isArrayBuffer(data)) {
                buffer = data;
                byteOffset = toOffset(offset2, BYTES);
                var $len = data.byteLength;
                if ($length === void 0) {
                  if ($len % BYTES)
                    throw RangeError2(WRONG_LENGTH);
                  byteLength = $len - byteOffset;
                  if (byteLength < 0)
                    throw RangeError2(WRONG_LENGTH);
                } else {
                  byteLength = toLength($length) * BYTES;
                  if (byteLength + byteOffset > $len)
                    throw RangeError2(WRONG_LENGTH);
                }
                length = byteLength / BYTES;
              } else if (isTypedArray(data)) {
                return fromList(TypedArrayConstructor, data);
              } else {
                return call(typedArrayFrom, TypedArrayConstructor, data);
              }
              setInternalState(that, {
                buffer,
                byteOffset,
                byteLength,
                length,
                view: new DataView2(buffer)
              });
              while (index < length)
                addElement(that, index++);
            });
            if (setPrototypeOf)
              setPrototypeOf(TypedArrayConstructor, TypedArray);
            TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
          } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
            TypedArrayConstructor = wrapper(function(dummy, data, typedArrayOffset, $length) {
              anInstance(dummy, TypedArrayConstructorPrototype);
              return inheritIfRequired(function() {
                if (!isObject3(data))
                  return new NativeTypedArrayConstructor(toIndex(data));
                if (isArrayBuffer(data))
                  return $length !== void 0 ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== void 0 ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);
                if (isTypedArray(data))
                  return fromList(TypedArrayConstructor, data);
                return call(typedArrayFrom, TypedArrayConstructor, data);
              }(), dummy, TypedArrayConstructor);
            });
            if (setPrototypeOf)
              setPrototypeOf(TypedArrayConstructor, TypedArray);
            forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function(key) {
              if (!(key in TypedArrayConstructor)) {
                createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
              }
            });
            TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
          }
          if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
            createNonEnumerableProperty(TypedArrayConstructorPrototype, "constructor", TypedArrayConstructor);
          }
          createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_CONSTRUCTOR, TypedArrayConstructor);
          if (TYPED_ARRAY_TAG) {
            createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
          }
          exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
          $2({
            global: true,
            forced: TypedArrayConstructor != NativeTypedArrayConstructor,
            sham: !NATIVE_ARRAY_BUFFER_VIEWS
          }, exported);
          if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
            createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
          }
          if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
            createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
          }
          setSpecies(CONSTRUCTOR_NAME);
        };
      } else
        module.exports = function() {
        };
    }
  });

  // node_modules/core-js/modules/es.typed-array.float32-array.js
  var require_es_typed_array_float32_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.float32-array.js"() {
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Float32", function(init) {
        return function Float32Array(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.float64-array.js
  var require_es_typed_array_float64_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.float64-array.js"() {
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Float64", function(init) {
        return function Float64Array(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.int8-array.js
  var require_es_typed_array_int8_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.int8-array.js"() {
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Int8", function(init) {
        return function Int8Array2(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.int16-array.js
  var require_es_typed_array_int16_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.int16-array.js"() {
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Int16", function(init) {
        return function Int16Array(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.int32-array.js
  var require_es_typed_array_int32_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.int32-array.js"() {
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Int32", function(init) {
        return function Int32Array(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.uint8-array.js
  var require_es_typed_array_uint8_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.uint8-array.js"() {
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Uint8", function(init) {
        return function Uint8Array2(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.uint8-clamped-array.js
  var require_es_typed_array_uint8_clamped_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.uint8-clamped-array.js"() {
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Uint8", function(init) {
        return function Uint8ClampedArray2(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      }, true);
    }
  });

  // node_modules/core-js/modules/es.typed-array.uint16-array.js
  var require_es_typed_array_uint16_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.uint16-array.js"() {
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Uint16", function(init) {
        return function Uint16Array(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.uint32-array.js
  var require_es_typed_array_uint32_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.uint32-array.js"() {
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Uint32", function(init) {
        return function Uint32Array(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.at.js
  var require_es_typed_array_at = __commonJS({
    "node_modules/core-js/modules/es.typed-array.at.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var lengthOfArrayLike = require_length_of_array_like();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("at", function at(index) {
        var O = aTypedArray(this);
        var len = lengthOfArrayLike(O);
        var relativeIndex = toIntegerOrInfinity(index);
        var k2 = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
        return k2 < 0 || k2 >= len ? void 0 : O[k2];
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.copy-within.js
  var require_es_typed_array_copy_within = __commonJS({
    "node_modules/core-js/modules/es.typed-array.copy-within.js"() {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $ArrayCopyWithin = require_array_copy_within();
      var u$ArrayCopyWithin = uncurryThis($ArrayCopyWithin);
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("copyWithin", function copyWithin(target, start4) {
        return u$ArrayCopyWithin(aTypedArray(this), target, start4, arguments.length > 2 ? arguments[2] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.every.js
  var require_es_typed_array_every = __commonJS({
    "node_modules/core-js/modules/es.typed-array.every.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $every = require_array_iteration().every;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("every", function every(callbackfn) {
        return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.fill.js
  var require_es_typed_array_fill = __commonJS({
    "node_modules/core-js/modules/es.typed-array.fill.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var call = require_function_call();
      var $fill = require_array_fill();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("fill", function fill(value) {
        var length = arguments.length;
        return call($fill, aTypedArray(this), value, length > 1 ? arguments[1] : void 0, length > 2 ? arguments[2] : void 0);
      });
    }
  });

  // node_modules/core-js/internals/array-from-constructor-and-list.js
  var require_array_from_constructor_and_list = __commonJS({
    "node_modules/core-js/internals/array-from-constructor-and-list.js"(exports, module) {
      var lengthOfArrayLike = require_length_of_array_like();
      module.exports = function(Constructor, list) {
        var index = 0;
        var length = lengthOfArrayLike(list);
        var result = new Constructor(length);
        while (length > index)
          result[index] = list[index++];
        return result;
      };
    }
  });

  // node_modules/core-js/internals/typed-array-species-constructor.js
  var require_typed_array_species_constructor = __commonJS({
    "node_modules/core-js/internals/typed-array-species-constructor.js"(exports, module) {
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var speciesConstructor = require_species_constructor();
      var TYPED_ARRAY_CONSTRUCTOR = ArrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
      var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
      module.exports = function(originalArray) {
        return aTypedArrayConstructor(speciesConstructor(originalArray, originalArray[TYPED_ARRAY_CONSTRUCTOR]));
      };
    }
  });

  // node_modules/core-js/internals/typed-array-from-species-and-list.js
  var require_typed_array_from_species_and_list = __commonJS({
    "node_modules/core-js/internals/typed-array-from-species-and-list.js"(exports, module) {
      var arrayFromConstructorAndList = require_array_from_constructor_and_list();
      var typedArraySpeciesConstructor = require_typed_array_species_constructor();
      module.exports = function(instance, list) {
        return arrayFromConstructorAndList(typedArraySpeciesConstructor(instance), list);
      };
    }
  });

  // node_modules/core-js/modules/es.typed-array.filter.js
  var require_es_typed_array_filter = __commonJS({
    "node_modules/core-js/modules/es.typed-array.filter.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $filter = require_array_iteration().filter;
      var fromSpeciesAndList = require_typed_array_from_species_and_list();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("filter", function filter2(callbackfn) {
        var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        return fromSpeciesAndList(this, list);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.find.js
  var require_es_typed_array_find = __commonJS({
    "node_modules/core-js/modules/es.typed-array.find.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $find = require_array_iteration().find;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("find", function find(predicate) {
        return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.find-index.js
  var require_es_typed_array_find_index = __commonJS({
    "node_modules/core-js/modules/es.typed-array.find-index.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $findIndex = require_array_iteration().findIndex;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("findIndex", function findIndex(predicate) {
        return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.for-each.js
  var require_es_typed_array_for_each = __commonJS({
    "node_modules/core-js/modules/es.typed-array.for-each.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $forEach = require_array_iteration().forEach;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("forEach", function forEach(callbackfn) {
        $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.from.js
  var require_es_typed_array_from = __commonJS({
    "node_modules/core-js/modules/es.typed-array.from.js"() {
      "use strict";
      var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require_typed_array_constructors_require_wrappers();
      var exportTypedArrayStaticMethod = require_array_buffer_view_core().exportTypedArrayStaticMethod;
      var typedArrayFrom = require_typed_array_from();
      exportTypedArrayStaticMethod("from", typedArrayFrom, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);
    }
  });

  // node_modules/core-js/modules/es.typed-array.includes.js
  var require_es_typed_array_includes = __commonJS({
    "node_modules/core-js/modules/es.typed-array.includes.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $includes = require_array_includes().includes;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("includes", function includes(searchElement) {
        return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.index-of.js
  var require_es_typed_array_index_of = __commonJS({
    "node_modules/core-js/modules/es.typed-array.index-of.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $indexOf = require_array_includes().indexOf;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("indexOf", function indexOf2(searchElement) {
        return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.iterator.js
  var require_es_typed_array_iterator = __commonJS({
    "node_modules/core-js/modules/es.typed-array.iterator.js"() {
      "use strict";
      var global2 = require_global();
      var fails = require_fails();
      var uncurryThis = require_function_uncurry_this();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var ArrayIterators = require_es_array_iterator();
      var wellKnownSymbol = require_well_known_symbol();
      var ITERATOR = wellKnownSymbol("iterator");
      var Uint8Array2 = global2.Uint8Array;
      var arrayValues = uncurryThis(ArrayIterators.values);
      var arrayKeys = uncurryThis(ArrayIterators.keys);
      var arrayEntries = uncurryThis(ArrayIterators.entries);
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var TypedArrayPrototype = Uint8Array2 && Uint8Array2.prototype;
      var GENERIC = !fails(function() {
        TypedArrayPrototype[ITERATOR].call([1]);
      });
      var ITERATOR_IS_VALUES = !!TypedArrayPrototype && TypedArrayPrototype.values && TypedArrayPrototype[ITERATOR] === TypedArrayPrototype.values && TypedArrayPrototype.values.name === "values";
      var typedArrayValues = function values() {
        return arrayValues(aTypedArray(this));
      };
      exportTypedArrayMethod("entries", function entries() {
        return arrayEntries(aTypedArray(this));
      }, GENERIC);
      exportTypedArrayMethod("keys", function keys() {
        return arrayKeys(aTypedArray(this));
      }, GENERIC);
      exportTypedArrayMethod("values", typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: "values" });
      exportTypedArrayMethod(ITERATOR, typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: "values" });
    }
  });

  // node_modules/core-js/modules/es.typed-array.join.js
  var require_es_typed_array_join = __commonJS({
    "node_modules/core-js/modules/es.typed-array.join.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var uncurryThis = require_function_uncurry_this();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var $join = uncurryThis([].join);
      exportTypedArrayMethod("join", function join(separator) {
        return $join(aTypedArray(this), separator);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.last-index-of.js
  var require_es_typed_array_last_index_of = __commonJS({
    "node_modules/core-js/modules/es.typed-array.last-index-of.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var apply = require_function_apply();
      var $lastIndexOf = require_array_last_index_of();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("lastIndexOf", function lastIndexOf(searchElement) {
        var length = arguments.length;
        return apply($lastIndexOf, aTypedArray(this), length > 1 ? [searchElement, arguments[1]] : [searchElement]);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.map.js
  var require_es_typed_array_map = __commonJS({
    "node_modules/core-js/modules/es.typed-array.map.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $map = require_array_iteration().map;
      var typedArraySpeciesConstructor = require_typed_array_species_constructor();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("map", function map(mapfn) {
        return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : void 0, function(O, length) {
          return new (typedArraySpeciesConstructor(O))(length);
        });
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.of.js
  var require_es_typed_array_of = __commonJS({
    "node_modules/core-js/modules/es.typed-array.of.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require_typed_array_constructors_require_wrappers();
      var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
      var exportTypedArrayStaticMethod = ArrayBufferViewCore.exportTypedArrayStaticMethod;
      exportTypedArrayStaticMethod("of", function of() {
        var index = 0;
        var length = arguments.length;
        var result = new (aTypedArrayConstructor(this))(length);
        while (length > index)
          result[index] = arguments[index++];
        return result;
      }, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);
    }
  });

  // node_modules/core-js/modules/es.typed-array.reduce.js
  var require_es_typed_array_reduce = __commonJS({
    "node_modules/core-js/modules/es.typed-array.reduce.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $reduce = require_array_reduce().left;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("reduce", function reduce(callbackfn) {
        var length = arguments.length;
        return $reduce(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.reduce-right.js
  var require_es_typed_array_reduce_right = __commonJS({
    "node_modules/core-js/modules/es.typed-array.reduce-right.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $reduceRight = require_array_reduce().right;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("reduceRight", function reduceRight(callbackfn) {
        var length = arguments.length;
        return $reduceRight(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.reverse.js
  var require_es_typed_array_reverse = __commonJS({
    "node_modules/core-js/modules/es.typed-array.reverse.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var floor = Math.floor;
      exportTypedArrayMethod("reverse", function reverse() {
        var that = this;
        var length = aTypedArray(that).length;
        var middle = floor(length / 2);
        var index = 0;
        var value;
        while (index < middle) {
          value = that[index];
          that[index++] = that[--length];
          that[length] = value;
        }
        return that;
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.set.js
  var require_es_typed_array_set = __commonJS({
    "node_modules/core-js/modules/es.typed-array.set.js"() {
      "use strict";
      var global2 = require_global();
      var call = require_function_call();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var lengthOfArrayLike = require_length_of_array_like();
      var toOffset = require_to_offset();
      var toIndexedObject = require_to_object();
      var fails = require_fails();
      var RangeError2 = global2.RangeError;
      var Int8Array2 = global2.Int8Array;
      var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
      var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS = !fails(function() {
        var array = new Uint8ClampedArray(2);
        call($set, array, { length: 1, 0: 3 }, 1);
        return array[1] !== 3;
      });
      var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS && fails(function() {
        var array = new Int8Array2(2);
        array.set(1);
        array.set("2", 1);
        return array[0] !== 0 || array[1] !== 2;
      });
      exportTypedArrayMethod("set", function set(arrayLike) {
        aTypedArray(this);
        var offset2 = toOffset(arguments.length > 1 ? arguments[1] : void 0, 1);
        var src = toIndexedObject(arrayLike);
        if (WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS)
          return call($set, this, src, offset2);
        var length = this.length;
        var len = lengthOfArrayLike(src);
        var index = 0;
        if (len + offset2 > length)
          throw RangeError2("Wrong length");
        while (index < len)
          this[offset2 + index] = src[index++];
      }, !WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);
    }
  });

  // node_modules/core-js/modules/es.typed-array.slice.js
  var require_es_typed_array_slice = __commonJS({
    "node_modules/core-js/modules/es.typed-array.slice.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var typedArraySpeciesConstructor = require_typed_array_species_constructor();
      var fails = require_fails();
      var arraySlice = require_array_slice();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var FORCED = fails(function() {
        new Int8Array(1).slice();
      });
      exportTypedArrayMethod("slice", function slice(start4, end2) {
        var list = arraySlice(aTypedArray(this), start4, end2);
        var C2 = typedArraySpeciesConstructor(this);
        var index = 0;
        var length = list.length;
        var result = new C2(length);
        while (length > index)
          result[index] = list[index++];
        return result;
      }, FORCED);
    }
  });

  // node_modules/core-js/modules/es.typed-array.some.js
  var require_es_typed_array_some = __commonJS({
    "node_modules/core-js/modules/es.typed-array.some.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $some = require_array_iteration().some;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("some", function some(callbackfn) {
        return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.sort.js
  var require_es_typed_array_sort = __commonJS({
    "node_modules/core-js/modules/es.typed-array.sort.js"() {
      "use strict";
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var aCallable = require_a_callable();
      var internalSort = require_array_sort();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var FF = require_engine_ff_version();
      var IE_OR_EDGE = require_engine_is_ie_or_edge();
      var V8 = require_engine_v8_version();
      var WEBKIT = require_engine_webkit_version();
      var Array2 = global2.Array;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var Uint16Array = global2.Uint16Array;
      var un$Sort = Uint16Array && uncurryThis(Uint16Array.prototype.sort);
      var ACCEPT_INCORRECT_ARGUMENTS = !!un$Sort && !(fails(function() {
        un$Sort(new Uint16Array(2), null);
      }) && fails(function() {
        un$Sort(new Uint16Array(2), {});
      }));
      var STABLE_SORT = !!un$Sort && !fails(function() {
        if (V8)
          return V8 < 74;
        if (FF)
          return FF < 67;
        if (IE_OR_EDGE)
          return true;
        if (WEBKIT)
          return WEBKIT < 602;
        var array = new Uint16Array(516);
        var expected = Array2(516);
        var index, mod;
        for (index = 0; index < 516; index++) {
          mod = index % 4;
          array[index] = 515 - index;
          expected[index] = index - 2 * mod + 3;
        }
        un$Sort(array, function(a2, b2) {
          return (a2 / 4 | 0) - (b2 / 4 | 0);
        });
        for (index = 0; index < 516; index++) {
          if (array[index] !== expected[index])
            return true;
        }
      });
      var getSortCompare = function(comparefn) {
        return function(x2, y2) {
          if (comparefn !== void 0)
            return +comparefn(x2, y2) || 0;
          if (y2 !== y2)
            return -1;
          if (x2 !== x2)
            return 1;
          if (x2 === 0 && y2 === 0)
            return 1 / x2 > 0 && 1 / y2 < 0 ? 1 : -1;
          return x2 > y2;
        };
      };
      exportTypedArrayMethod("sort", function sort(comparefn) {
        if (comparefn !== void 0)
          aCallable(comparefn);
        if (STABLE_SORT)
          return un$Sort(this, comparefn);
        return internalSort(aTypedArray(this), getSortCompare(comparefn));
      }, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);
    }
  });

  // node_modules/core-js/modules/es.typed-array.subarray.js
  var require_es_typed_array_subarray = __commonJS({
    "node_modules/core-js/modules/es.typed-array.subarray.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var toLength = require_to_length();
      var toAbsoluteIndex = require_to_absolute_index();
      var typedArraySpeciesConstructor = require_typed_array_species_constructor();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("subarray", function subarray(begin, end2) {
        var O = aTypedArray(this);
        var length = O.length;
        var beginIndex = toAbsoluteIndex(begin, length);
        var C2 = typedArraySpeciesConstructor(O);
        return new C2(O.buffer, O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT, toLength((end2 === void 0 ? length : toAbsoluteIndex(end2, length)) - beginIndex));
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.to-locale-string.js
  var require_es_typed_array_to_locale_string = __commonJS({
    "node_modules/core-js/modules/es.typed-array.to-locale-string.js"() {
      "use strict";
      var global2 = require_global();
      var apply = require_function_apply();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var fails = require_fails();
      var arraySlice = require_array_slice();
      var Int8Array2 = global2.Int8Array;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var $toLocaleString = [].toLocaleString;
      var TO_LOCALE_STRING_BUG = !!Int8Array2 && fails(function() {
        $toLocaleString.call(new Int8Array2(1));
      });
      var FORCED = fails(function() {
        return [1, 2].toLocaleString() != new Int8Array2([1, 2]).toLocaleString();
      }) || !fails(function() {
        Int8Array2.prototype.toLocaleString.call([1, 2]);
      });
      exportTypedArrayMethod("toLocaleString", function toLocaleString() {
        return apply($toLocaleString, TO_LOCALE_STRING_BUG ? arraySlice(aTypedArray(this)) : aTypedArray(this), arraySlice(arguments));
      }, FORCED);
    }
  });

  // node_modules/core-js/modules/es.typed-array.to-string.js
  var require_es_typed_array_to_string = __commonJS({
    "node_modules/core-js/modules/es.typed-array.to-string.js"() {
      "use strict";
      var exportTypedArrayMethod = require_array_buffer_view_core().exportTypedArrayMethod;
      var fails = require_fails();
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this();
      var Uint8Array2 = global2.Uint8Array;
      var Uint8ArrayPrototype = Uint8Array2 && Uint8Array2.prototype || {};
      var arrayToString = [].toString;
      var join = uncurryThis([].join);
      if (fails(function() {
        arrayToString.call({});
      })) {
        arrayToString = function toString() {
          return join(this);
        };
      }
      var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;
      exportTypedArrayMethod("toString", arrayToString, IS_NOT_ARRAY_METHOD);
    }
  });

  // node_modules/core-js/modules/es.unescape.js
  var require_es_unescape = __commonJS({
    "node_modules/core-js/modules/es.unescape.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toString = require_to_string();
      var fromCharCode = String.fromCharCode;
      var charAt = uncurryThis("".charAt);
      var exec = uncurryThis(/./.exec);
      var stringSlice = uncurryThis("".slice);
      var hex2 = /^[\da-f]{2}$/i;
      var hex4 = /^[\da-f]{4}$/i;
      $2({ global: true }, {
        unescape: function unescape3(string) {
          var str = toString(string);
          var result = "";
          var length = str.length;
          var index = 0;
          var chr, part;
          while (index < length) {
            chr = charAt(str, index++);
            if (chr === "%") {
              if (charAt(str, index) === "u") {
                part = stringSlice(str, index + 1, index + 5);
                if (exec(hex4, part)) {
                  result += fromCharCode(parseInt(part, 16));
                  index += 5;
                  continue;
                }
              } else {
                part = stringSlice(str, index, index + 2);
                if (exec(hex2, part)) {
                  result += fromCharCode(parseInt(part, 16));
                  index += 2;
                  continue;
                }
              }
            }
            result += chr;
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/internals/collection-weak.js
  var require_collection_weak = __commonJS({
    "node_modules/core-js/internals/collection-weak.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var redefineAll = require_redefine_all();
      var getWeakData = require_internal_metadata().getWeakData;
      var anObject = require_an_object();
      var isObject3 = require_is_object();
      var anInstance = require_an_instance();
      var iterate = require_iterate();
      var ArrayIterationModule = require_array_iteration();
      var hasOwn = require_has_own_property();
      var InternalStateModule = require_internal_state();
      var setInternalState = InternalStateModule.set;
      var internalStateGetterFor = InternalStateModule.getterFor;
      var find = ArrayIterationModule.find;
      var findIndex = ArrayIterationModule.findIndex;
      var splice = uncurryThis([].splice);
      var id = 0;
      var uncaughtFrozenStore = function(store) {
        return store.frozen || (store.frozen = new UncaughtFrozenStore());
      };
      var UncaughtFrozenStore = function() {
        this.entries = [];
      };
      var findUncaughtFrozen = function(store, key) {
        return find(store.entries, function(it) {
          return it[0] === key;
        });
      };
      UncaughtFrozenStore.prototype = {
        get: function(key) {
          var entry = findUncaughtFrozen(this, key);
          if (entry)
            return entry[1];
        },
        has: function(key) {
          return !!findUncaughtFrozen(this, key);
        },
        set: function(key, value) {
          var entry = findUncaughtFrozen(this, key);
          if (entry)
            entry[1] = value;
          else
            this.entries.push([key, value]);
        },
        "delete": function(key) {
          var index = findIndex(this.entries, function(it) {
            return it[0] === key;
          });
          if (~index)
            splice(this.entries, index, 1);
          return !!~index;
        }
      };
      module.exports = {
        getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
          var Constructor = wrapper(function(that, iterable) {
            anInstance(that, Prototype);
            setInternalState(that, {
              type: CONSTRUCTOR_NAME,
              id: id++,
              frozen: void 0
            });
            if (iterable != void 0)
              iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
          });
          var Prototype = Constructor.prototype;
          var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
          var define2 = function(that, key, value) {
            var state = getInternalState(that);
            var data = getWeakData(anObject(key), true);
            if (data === true)
              uncaughtFrozenStore(state).set(key, value);
            else
              data[state.id] = value;
            return that;
          };
          redefineAll(Prototype, {
            "delete": function(key) {
              var state = getInternalState(this);
              if (!isObject3(key))
                return false;
              var data = getWeakData(key);
              if (data === true)
                return uncaughtFrozenStore(state)["delete"](key);
              return data && hasOwn(data, state.id) && delete data[state.id];
            },
            has: function has(key) {
              var state = getInternalState(this);
              if (!isObject3(key))
                return false;
              var data = getWeakData(key);
              if (data === true)
                return uncaughtFrozenStore(state).has(key);
              return data && hasOwn(data, state.id);
            }
          });
          redefineAll(Prototype, IS_MAP ? {
            get: function get(key) {
              var state = getInternalState(this);
              if (isObject3(key)) {
                var data = getWeakData(key);
                if (data === true)
                  return uncaughtFrozenStore(state).get(key);
                return data ? data[state.id] : void 0;
              }
            },
            set: function set(key, value) {
              return define2(this, key, value);
            }
          } : {
            add: function add3(value) {
              return define2(this, value, true);
            }
          });
          return Constructor;
        }
      };
    }
  });

  // node_modules/core-js/modules/es.weak-map.js
  var require_es_weak_map = __commonJS({
    "node_modules/core-js/modules/es.weak-map.js"() {
      "use strict";
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this();
      var redefineAll = require_redefine_all();
      var InternalMetadataModule = require_internal_metadata();
      var collection = require_collection();
      var collectionWeak = require_collection_weak();
      var isObject3 = require_is_object();
      var isExtensible = require_object_is_extensible();
      var enforceInternalState = require_internal_state().enforce;
      var NATIVE_WEAK_MAP = require_native_weak_map();
      var IS_IE11 = !global2.ActiveXObject && "ActiveXObject" in global2;
      var InternalWeakMap;
      var wrapper = function(init) {
        return function WeakMap2() {
          return init(this, arguments.length ? arguments[0] : void 0);
        };
      };
      var $WeakMap = collection("WeakMap", wrapper, collectionWeak);
      if (NATIVE_WEAK_MAP && IS_IE11) {
        InternalWeakMap = collectionWeak.getConstructor(wrapper, "WeakMap", true);
        InternalMetadataModule.enable();
        WeakMapPrototype = $WeakMap.prototype;
        nativeDelete = uncurryThis(WeakMapPrototype["delete"]);
        nativeHas = uncurryThis(WeakMapPrototype.has);
        nativeGet = uncurryThis(WeakMapPrototype.get);
        nativeSet = uncurryThis(WeakMapPrototype.set);
        redefineAll(WeakMapPrototype, {
          "delete": function(key) {
            if (isObject3(key) && !isExtensible(key)) {
              var state = enforceInternalState(this);
              if (!state.frozen)
                state.frozen = new InternalWeakMap();
              return nativeDelete(this, key) || state.frozen["delete"](key);
            }
            return nativeDelete(this, key);
          },
          has: function has(key) {
            if (isObject3(key) && !isExtensible(key)) {
              var state = enforceInternalState(this);
              if (!state.frozen)
                state.frozen = new InternalWeakMap();
              return nativeHas(this, key) || state.frozen.has(key);
            }
            return nativeHas(this, key);
          },
          get: function get(key) {
            if (isObject3(key) && !isExtensible(key)) {
              var state = enforceInternalState(this);
              if (!state.frozen)
                state.frozen = new InternalWeakMap();
              return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);
            }
            return nativeGet(this, key);
          },
          set: function set(key, value) {
            if (isObject3(key) && !isExtensible(key)) {
              var state = enforceInternalState(this);
              if (!state.frozen)
                state.frozen = new InternalWeakMap();
              nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);
            } else
              nativeSet(this, key, value);
            return this;
          }
        });
      }
      var WeakMapPrototype;
      var nativeDelete;
      var nativeHas;
      var nativeGet;
      var nativeSet;
    }
  });

  // node_modules/core-js/modules/es.weak-set.js
  var require_es_weak_set = __commonJS({
    "node_modules/core-js/modules/es.weak-set.js"() {
      "use strict";
      var collection = require_collection();
      var collectionWeak = require_collection_weak();
      collection("WeakSet", function(init) {
        return function WeakSet2() {
          return init(this, arguments.length ? arguments[0] : void 0);
        };
      }, collectionWeak);
    }
  });

  // node_modules/core-js/internals/base64-map.js
  var require_base64_map = __commonJS({
    "node_modules/core-js/internals/base64-map.js"(exports, module) {
      var itoc = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var ctoi = {};
      for (index = 0; index < 66; index++)
        ctoi[itoc.charAt(index)] = index;
      var index;
      module.exports = {
        itoc,
        ctoi
      };
    }
  });

  // node_modules/core-js/modules/web.atob.js
  var require_web_atob = __commonJS({
    "node_modules/core-js/modules/web.atob.js"() {
      var $2 = require_export();
      var getBuiltIn = require_get_built_in();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var toString = require_to_string();
      var hasOwn = require_has_own_property();
      var validateArgumentsLength = require_validate_arguments_length();
      var ctoi = require_base64_map().ctoi;
      var disallowed = /[^\d+/a-z]/i;
      var whitespaces = /[\t\n\f\r ]+/g;
      var finalEq = /[=]+$/;
      var $atob = getBuiltIn("atob");
      var fromCharCode = String.fromCharCode;
      var charAt = uncurryThis("".charAt);
      var replace = uncurryThis("".replace);
      var exec = uncurryThis(disallowed.exec);
      var NO_SPACES_IGNORE = fails(function() {
        return atob(" ") !== "";
      });
      var NO_ARG_RECEIVING_CHECK = !NO_SPACES_IGNORE && !fails(function() {
        $atob();
      });
      $2({ global: true, enumerable: true, forced: NO_SPACES_IGNORE || NO_ARG_RECEIVING_CHECK }, {
        atob: function atob2(data) {
          validateArgumentsLength(arguments.length, 1);
          if (NO_ARG_RECEIVING_CHECK)
            return $atob(data);
          var string = replace(toString(data), whitespaces, "");
          var output = "";
          var position = 0;
          var bc = 0;
          var chr, bs;
          if (string.length % 4 == 0) {
            string = replace(string, finalEq, "");
          }
          if (string.length % 4 == 1 || exec(disallowed, string)) {
            throw new (getBuiltIn("DOMException"))("The string is not correctly encoded", "InvalidCharacterError");
          }
          while (chr = charAt(string, position++)) {
            if (hasOwn(ctoi, chr)) {
              bs = bc % 4 ? bs * 64 + ctoi[chr] : ctoi[chr];
              if (bc++ % 4)
                output += fromCharCode(255 & bs >> (-2 * bc & 6));
            }
          }
          return output;
        }
      });
    }
  });

  // node_modules/core-js/modules/web.btoa.js
  var require_web_btoa = __commonJS({
    "node_modules/core-js/modules/web.btoa.js"() {
      var $2 = require_export();
      var getBuiltIn = require_get_built_in();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var toString = require_to_string();
      var validateArgumentsLength = require_validate_arguments_length();
      var itoc = require_base64_map().itoc;
      var $btoa = getBuiltIn("btoa");
      var charAt = uncurryThis("".charAt);
      var charCodeAt = uncurryThis("".charCodeAt);
      var NO_ARG_RECEIVING_CHECK = !!$btoa && !fails(function() {
        $btoa();
      });
      $2({ global: true, enumerable: true, forced: NO_ARG_RECEIVING_CHECK }, {
        btoa: function btoa2(data) {
          validateArgumentsLength(arguments.length, 1);
          if (NO_ARG_RECEIVING_CHECK)
            return $btoa(data);
          var string = toString(data);
          var output = "";
          var position = 0;
          var map = itoc;
          var block, charCode;
          while (charAt(string, position) || (map = "=", position % 1)) {
            charCode = charCodeAt(string, position += 3 / 4);
            if (charCode > 255) {
              throw new (getBuiltIn("DOMException"))("The string contains characters outside of the Latin1 range", "InvalidCharacterError");
            }
            block = block << 8 | charCode;
            output += charAt(map, 63 & block >> 8 - position % 1 * 8);
          }
          return output;
        }
      });
    }
  });

  // node_modules/core-js/internals/dom-iterables.js
  var require_dom_iterables = __commonJS({
    "node_modules/core-js/internals/dom-iterables.js"(exports, module) {
      module.exports = {
        CSSRuleList: 0,
        CSSStyleDeclaration: 0,
        CSSValueList: 0,
        ClientRectList: 0,
        DOMRectList: 0,
        DOMStringList: 0,
        DOMTokenList: 1,
        DataTransferItemList: 0,
        FileList: 0,
        HTMLAllCollection: 0,
        HTMLCollection: 0,
        HTMLFormElement: 0,
        HTMLSelectElement: 0,
        MediaList: 0,
        MimeTypeArray: 0,
        NamedNodeMap: 0,
        NodeList: 1,
        PaintRequestList: 0,
        Plugin: 0,
        PluginArray: 0,
        SVGLengthList: 0,
        SVGNumberList: 0,
        SVGPathSegList: 0,
        SVGPointList: 0,
        SVGStringList: 0,
        SVGTransformList: 0,
        SourceBufferList: 0,
        StyleSheetList: 0,
        TextTrackCueList: 0,
        TextTrackList: 0,
        TouchList: 0
      };
    }
  });

  // node_modules/core-js/internals/dom-token-list-prototype.js
  var require_dom_token_list_prototype = __commonJS({
    "node_modules/core-js/internals/dom-token-list-prototype.js"(exports, module) {
      var documentCreateElement = require_document_create_element();
      var classList = documentCreateElement("span").classList;
      var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;
      module.exports = DOMTokenListPrototype === Object.prototype ? void 0 : DOMTokenListPrototype;
    }
  });

  // node_modules/core-js/modules/web.dom-collections.for-each.js
  var require_web_dom_collections_for_each = __commonJS({
    "node_modules/core-js/modules/web.dom-collections.for-each.js"() {
      var global2 = require_global();
      var DOMIterables = require_dom_iterables();
      var DOMTokenListPrototype = require_dom_token_list_prototype();
      var forEach = require_array_for_each();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var handlePrototype = function(CollectionPrototype) {
        if (CollectionPrototype && CollectionPrototype.forEach !== forEach)
          try {
            createNonEnumerableProperty(CollectionPrototype, "forEach", forEach);
          } catch (error2) {
            CollectionPrototype.forEach = forEach;
          }
      };
      for (COLLECTION_NAME in DOMIterables) {
        if (DOMIterables[COLLECTION_NAME]) {
          handlePrototype(global2[COLLECTION_NAME] && global2[COLLECTION_NAME].prototype);
        }
      }
      var COLLECTION_NAME;
      handlePrototype(DOMTokenListPrototype);
    }
  });

  // node_modules/core-js/modules/web.dom-collections.iterator.js
  var require_web_dom_collections_iterator = __commonJS({
    "node_modules/core-js/modules/web.dom-collections.iterator.js"() {
      var global2 = require_global();
      var DOMIterables = require_dom_iterables();
      var DOMTokenListPrototype = require_dom_token_list_prototype();
      var ArrayIteratorMethods = require_es_array_iterator();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var wellKnownSymbol = require_well_known_symbol();
      var ITERATOR = wellKnownSymbol("iterator");
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var ArrayValues = ArrayIteratorMethods.values;
      var handlePrototype = function(CollectionPrototype, COLLECTION_NAME2) {
        if (CollectionPrototype) {
          if (CollectionPrototype[ITERATOR] !== ArrayValues)
            try {
              createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
            } catch (error2) {
              CollectionPrototype[ITERATOR] = ArrayValues;
            }
          if (!CollectionPrototype[TO_STRING_TAG]) {
            createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME2);
          }
          if (DOMIterables[COLLECTION_NAME2])
            for (var METHOD_NAME in ArrayIteratorMethods) {
              if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
                try {
                  createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
                } catch (error2) {
                  CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
                }
            }
        }
      };
      for (COLLECTION_NAME in DOMIterables) {
        handlePrototype(global2[COLLECTION_NAME] && global2[COLLECTION_NAME].prototype, COLLECTION_NAME);
      }
      var COLLECTION_NAME;
      handlePrototype(DOMTokenListPrototype, "DOMTokenList");
    }
  });

  // node_modules/core-js/internals/try-node-require.js
  var require_try_node_require = __commonJS({
    "node_modules/core-js/internals/try-node-require.js"(exports, module) {
      var IS_NODE = require_engine_is_node();
      module.exports = function(name) {
        try {
          if (IS_NODE)
            return Function('return require("' + name + '")')();
        } catch (error2) {
        }
      };
    }
  });

  // node_modules/core-js/internals/dom-exception-constants.js
  var require_dom_exception_constants = __commonJS({
    "node_modules/core-js/internals/dom-exception-constants.js"(exports, module) {
      module.exports = {
        IndexSizeError: { s: "INDEX_SIZE_ERR", c: 1, m: 1 },
        DOMStringSizeError: { s: "DOMSTRING_SIZE_ERR", c: 2, m: 0 },
        HierarchyRequestError: { s: "HIERARCHY_REQUEST_ERR", c: 3, m: 1 },
        WrongDocumentError: { s: "WRONG_DOCUMENT_ERR", c: 4, m: 1 },
        InvalidCharacterError: { s: "INVALID_CHARACTER_ERR", c: 5, m: 1 },
        NoDataAllowedError: { s: "NO_DATA_ALLOWED_ERR", c: 6, m: 0 },
        NoModificationAllowedError: { s: "NO_MODIFICATION_ALLOWED_ERR", c: 7, m: 1 },
        NotFoundError: { s: "NOT_FOUND_ERR", c: 8, m: 1 },
        NotSupportedError: { s: "NOT_SUPPORTED_ERR", c: 9, m: 1 },
        InUseAttributeError: { s: "INUSE_ATTRIBUTE_ERR", c: 10, m: 1 },
        InvalidStateError: { s: "INVALID_STATE_ERR", c: 11, m: 1 },
        SyntaxError: { s: "SYNTAX_ERR", c: 12, m: 1 },
        InvalidModificationError: { s: "INVALID_MODIFICATION_ERR", c: 13, m: 1 },
        NamespaceError: { s: "NAMESPACE_ERR", c: 14, m: 1 },
        InvalidAccessError: { s: "INVALID_ACCESS_ERR", c: 15, m: 1 },
        ValidationError: { s: "VALIDATION_ERR", c: 16, m: 0 },
        TypeMismatchError: { s: "TYPE_MISMATCH_ERR", c: 17, m: 1 },
        SecurityError: { s: "SECURITY_ERR", c: 18, m: 1 },
        NetworkError: { s: "NETWORK_ERR", c: 19, m: 1 },
        AbortError: { s: "ABORT_ERR", c: 20, m: 1 },
        URLMismatchError: { s: "URL_MISMATCH_ERR", c: 21, m: 1 },
        QuotaExceededError: { s: "QUOTA_EXCEEDED_ERR", c: 22, m: 1 },
        TimeoutError: { s: "TIMEOUT_ERR", c: 23, m: 1 },
        InvalidNodeTypeError: { s: "INVALID_NODE_TYPE_ERR", c: 24, m: 1 },
        DataCloneError: { s: "DATA_CLONE_ERR", c: 25, m: 1 }
      };
    }
  });

  // node_modules/core-js/modules/web.dom-exception.constructor.js
  var require_web_dom_exception_constructor = __commonJS({
    "node_modules/core-js/modules/web.dom-exception.constructor.js"() {
      "use strict";
      var $2 = require_export();
      var tryNodeRequire = require_try_node_require();
      var getBuiltIn = require_get_built_in();
      var fails = require_fails();
      var create = require_object_create();
      var createPropertyDescriptor = require_create_property_descriptor();
      var defineProperty = require_object_define_property().f;
      var defineProperties = require_object_define_properties().f;
      var redefine = require_redefine();
      var hasOwn = require_has_own_property();
      var anInstance = require_an_instance();
      var anObject = require_an_object();
      var errorToString = require_error_to_string();
      var normalizeStringArgument = require_normalize_string_argument();
      var DOMExceptionConstants = require_dom_exception_constants();
      var clearErrorStack = require_clear_error_stack();
      var InternalStateModule = require_internal_state();
      var DESCRIPTORS = require_descriptors();
      var IS_PURE = require_is_pure();
      var DOM_EXCEPTION = "DOMException";
      var DATA_CLONE_ERR = "DATA_CLONE_ERR";
      var Error2 = getBuiltIn("Error");
      var NativeDOMException = getBuiltIn(DOM_EXCEPTION) || function() {
        try {
          var MessageChannel = getBuiltIn("MessageChannel") || tryNodeRequire("worker_threads").MessageChannel;
          new MessageChannel().port1.postMessage(/* @__PURE__ */ new WeakMap());
        } catch (error2) {
          if (error2.name == DATA_CLONE_ERR && error2.code == 25)
            return error2.constructor;
        }
      }();
      var NativeDOMExceptionPrototype = NativeDOMException && NativeDOMException.prototype;
      var ErrorPrototype = Error2.prototype;
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(DOM_EXCEPTION);
      var HAS_STACK = "stack" in Error2(DOM_EXCEPTION);
      var codeFor = function(name) {
        return hasOwn(DOMExceptionConstants, name) && DOMExceptionConstants[name].m ? DOMExceptionConstants[name].c : 0;
      };
      var $DOMException = function DOMException2() {
        anInstance(this, DOMExceptionPrototype);
        var argumentsLength = arguments.length;
        var message = normalizeStringArgument(argumentsLength < 1 ? void 0 : arguments[0]);
        var name = normalizeStringArgument(argumentsLength < 2 ? void 0 : arguments[1], "Error");
        var code3 = codeFor(name);
        setInternalState(this, {
          type: DOM_EXCEPTION,
          name,
          message,
          code: code3
        });
        if (!DESCRIPTORS) {
          this.name = name;
          this.message = message;
          this.code = code3;
        }
        if (HAS_STACK) {
          var error2 = Error2(message);
          error2.name = DOM_EXCEPTION;
          defineProperty(this, "stack", createPropertyDescriptor(1, clearErrorStack(error2.stack, 1)));
        }
      };
      var DOMExceptionPrototype = $DOMException.prototype = create(ErrorPrototype);
      var createGetterDescriptor = function(get) {
        return { enumerable: true, configurable: true, get };
      };
      var getterFor = function(key2) {
        return createGetterDescriptor(function() {
          return getInternalState(this)[key2];
        });
      };
      if (DESCRIPTORS)
        defineProperties(DOMExceptionPrototype, {
          name: getterFor("name"),
          message: getterFor("message"),
          code: getterFor("code")
        });
      defineProperty(DOMExceptionPrototype, "constructor", createPropertyDescriptor(1, $DOMException));
      var INCORRECT_CONSTRUCTOR = fails(function() {
        return !(new NativeDOMException() instanceof Error2);
      });
      var INCORRECT_TO_STRING = INCORRECT_CONSTRUCTOR || fails(function() {
        return ErrorPrototype.toString !== errorToString || String(new NativeDOMException(1, 2)) !== "2: 1";
      });
      var INCORRECT_CODE = INCORRECT_CONSTRUCTOR || fails(function() {
        return new NativeDOMException(1, "DataCloneError").code !== 25;
      });
      var MISSED_CONSTANTS = INCORRECT_CONSTRUCTOR || NativeDOMException[DATA_CLONE_ERR] !== 25 || NativeDOMExceptionPrototype[DATA_CLONE_ERR] !== 25;
      var FORCED_CONSTRUCTOR = IS_PURE ? INCORRECT_TO_STRING || INCORRECT_CODE || MISSED_CONSTANTS : INCORRECT_CONSTRUCTOR;
      $2({ global: true, forced: FORCED_CONSTRUCTOR }, {
        DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException
      });
      var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);
      var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;
      if (INCORRECT_TO_STRING && (IS_PURE || NativeDOMException === PolyfilledDOMException)) {
        redefine(PolyfilledDOMExceptionPrototype, "toString", errorToString);
      }
      if (INCORRECT_CODE && DESCRIPTORS && NativeDOMException === PolyfilledDOMException) {
        defineProperty(PolyfilledDOMExceptionPrototype, "code", createGetterDescriptor(function() {
          return codeFor(anObject(this).name);
        }));
      }
      for (key in DOMExceptionConstants)
        if (hasOwn(DOMExceptionConstants, key)) {
          constant = DOMExceptionConstants[key];
          constantName = constant.s;
          descriptor = createPropertyDescriptor(6, constant.c);
          if (!hasOwn(PolyfilledDOMException, constantName)) {
            defineProperty(PolyfilledDOMException, constantName, descriptor);
          }
          if (!hasOwn(PolyfilledDOMExceptionPrototype, constantName)) {
            defineProperty(PolyfilledDOMExceptionPrototype, constantName, descriptor);
          }
        }
      var constant;
      var constantName;
      var descriptor;
      var key;
    }
  });

  // node_modules/core-js/modules/web.dom-exception.stack.js
  var require_web_dom_exception_stack = __commonJS({
    "node_modules/core-js/modules/web.dom-exception.stack.js"() {
      "use strict";
      var $2 = require_export();
      var getBuiltIn = require_get_built_in();
      var createPropertyDescriptor = require_create_property_descriptor();
      var defineProperty = require_object_define_property().f;
      var hasOwn = require_has_own_property();
      var anInstance = require_an_instance();
      var inheritIfRequired = require_inherit_if_required();
      var normalizeStringArgument = require_normalize_string_argument();
      var DOMExceptionConstants = require_dom_exception_constants();
      var clearErrorStack = require_clear_error_stack();
      var IS_PURE = require_is_pure();
      var DOM_EXCEPTION = "DOMException";
      var Error2 = getBuiltIn("Error");
      var NativeDOMException = getBuiltIn(DOM_EXCEPTION);
      var $DOMException = function DOMException2() {
        anInstance(this, DOMExceptionPrototype);
        var argumentsLength = arguments.length;
        var message = normalizeStringArgument(argumentsLength < 1 ? void 0 : arguments[0]);
        var name = normalizeStringArgument(argumentsLength < 2 ? void 0 : arguments[1], "Error");
        var that = new NativeDOMException(message, name);
        var error2 = Error2(message);
        error2.name = DOM_EXCEPTION;
        defineProperty(that, "stack", createPropertyDescriptor(1, clearErrorStack(error2.stack, 1)));
        inheritIfRequired(that, this, $DOMException);
        return that;
      };
      var DOMExceptionPrototype = $DOMException.prototype = NativeDOMException.prototype;
      var ERROR_HAS_STACK = "stack" in Error2(DOM_EXCEPTION);
      var DOM_EXCEPTION_HAS_STACK = "stack" in new NativeDOMException(1, 2);
      var FORCED_CONSTRUCTOR = ERROR_HAS_STACK && !DOM_EXCEPTION_HAS_STACK;
      $2({ global: true, forced: IS_PURE || FORCED_CONSTRUCTOR }, {
        DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException
      });
      var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);
      var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;
      if (PolyfilledDOMExceptionPrototype.constructor !== PolyfilledDOMException) {
        if (!IS_PURE) {
          defineProperty(PolyfilledDOMExceptionPrototype, "constructor", createPropertyDescriptor(1, PolyfilledDOMException));
        }
        for (key in DOMExceptionConstants)
          if (hasOwn(DOMExceptionConstants, key)) {
            constant = DOMExceptionConstants[key];
            constantName = constant.s;
            if (!hasOwn(PolyfilledDOMException, constantName)) {
              defineProperty(PolyfilledDOMException, constantName, createPropertyDescriptor(6, constant.c));
            }
          }
      }
      var constant;
      var constantName;
      var key;
    }
  });

  // node_modules/core-js/modules/web.dom-exception.to-string-tag.js
  var require_web_dom_exception_to_string_tag = __commonJS({
    "node_modules/core-js/modules/web.dom-exception.to-string-tag.js"() {
      var getBuiltIn = require_get_built_in();
      var setToStringTag = require_set_to_string_tag();
      var DOM_EXCEPTION = "DOMException";
      setToStringTag(getBuiltIn(DOM_EXCEPTION), DOM_EXCEPTION);
    }
  });

  // node_modules/core-js/modules/web.immediate.js
  var require_web_immediate = __commonJS({
    "node_modules/core-js/modules/web.immediate.js"() {
      var $2 = require_export();
      var global2 = require_global();
      var task = require_task();
      var FORCED = !global2.setImmediate || !global2.clearImmediate;
      $2({ global: true, bind: true, enumerable: true, forced: FORCED }, {
        setImmediate: task.set,
        clearImmediate: task.clear
      });
    }
  });

  // node_modules/core-js/modules/web.queue-microtask.js
  var require_web_queue_microtask = __commonJS({
    "node_modules/core-js/modules/web.queue-microtask.js"() {
      var $2 = require_export();
      var global2 = require_global();
      var microtask = require_microtask();
      var aCallable = require_a_callable();
      var validateArgumentsLength = require_validate_arguments_length();
      var IS_NODE = require_engine_is_node();
      var process2 = global2.process;
      $2({ global: true, enumerable: true, noTargetGet: true }, {
        queueMicrotask: function queueMicrotask(fn2) {
          validateArgumentsLength(arguments.length, 1);
          aCallable(fn2);
          var domain = IS_NODE && process2.domain;
          microtask(domain ? domain.bind(fn2) : fn2);
        }
      });
    }
  });

  // node_modules/core-js/modules/web.structured-clone.js
  var require_web_structured_clone = __commonJS({
    "node_modules/core-js/modules/web.structured-clone.js"() {
      var IS_PURE = require_is_pure();
      var $2 = require_export();
      var global2 = require_global();
      var getBuiltin = require_get_built_in();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var uid = require_uid();
      var isCallable = require_is_callable();
      var isConstructor = require_is_constructor();
      var isObject3 = require_is_object();
      var isSymbol = require_is_symbol();
      var iterate = require_iterate();
      var anObject = require_an_object();
      var classof = require_classof();
      var hasOwn = require_has_own_property();
      var createProperty = require_create_property();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var lengthOfArrayLike = require_length_of_array_like();
      var validateArgumentsLength = require_validate_arguments_length();
      var regExpFlags = require_regexp_flags();
      var ERROR_STACK_INSTALLABLE = require_error_stack_installable();
      var Object2 = global2.Object;
      var Date2 = global2.Date;
      var Error2 = global2.Error;
      var EvalError = global2.EvalError;
      var RangeError2 = global2.RangeError;
      var ReferenceError2 = global2.ReferenceError;
      var SyntaxError2 = global2.SyntaxError;
      var TypeError2 = global2.TypeError;
      var URIError = global2.URIError;
      var PerformanceMark = global2.PerformanceMark;
      var WebAssembly = global2.WebAssembly;
      var CompileError = WebAssembly && WebAssembly.CompileError || Error2;
      var LinkError = WebAssembly && WebAssembly.LinkError || Error2;
      var RuntimeError = WebAssembly && WebAssembly.RuntimeError || Error2;
      var DOMException2 = getBuiltin("DOMException");
      var Set2 = getBuiltin("Set");
      var Map2 = getBuiltin("Map");
      var MapPrototype = Map2.prototype;
      var mapHas = uncurryThis(MapPrototype.has);
      var mapGet = uncurryThis(MapPrototype.get);
      var mapSet = uncurryThis(MapPrototype.set);
      var setAdd = uncurryThis(Set2.prototype.add);
      var objectKeys = getBuiltin("Object", "keys");
      var push = uncurryThis([].push);
      var booleanValueOf = uncurryThis(true.valueOf);
      var numberValueOf = uncurryThis(1 .valueOf);
      var stringValueOf = uncurryThis("".valueOf);
      var getFlags = uncurryThis(regExpFlags);
      var getTime = uncurryThis(Date2.prototype.getTime);
      var PERFORMANCE_MARK = uid("structuredClone");
      var DATA_CLONE_ERROR = "DataCloneError";
      var TRANSFERRING = "Transferring";
      var checkBasicSemantic = function(structuredCloneImplementation) {
        return !fails(function() {
          var set1 = new global2.Set([7]);
          var set2 = structuredCloneImplementation(set1);
          var number = structuredCloneImplementation(Object2(7));
          return set2 == set1 || !set2.has(7) || typeof number != "object" || number != 7;
        }) && structuredCloneImplementation;
      };
      var checkNewErrorsSemantic = function(structuredCloneImplementation) {
        return !fails(function() {
          var test = structuredCloneImplementation(new global2.AggregateError([1], PERFORMANCE_MARK, { cause: 3 }));
          return test.name != "AggregateError" || test.errors[0] != 1 || test.message != PERFORMANCE_MARK || test.cause != 3;
        }) && structuredCloneImplementation;
      };
      var nativeStructuredClone = global2.structuredClone;
      var FORCED_REPLACEMENT = IS_PURE || !checkNewErrorsSemantic(nativeStructuredClone);
      var structuredCloneFromMark = !nativeStructuredClone && checkBasicSemantic(function(value) {
        return new PerformanceMark(PERFORMANCE_MARK, { detail: value }).detail;
      });
      var nativeRestrictedStructuredClone = checkBasicSemantic(nativeStructuredClone) || structuredCloneFromMark;
      var throwUncloneable = function(type) {
        throw new DOMException2("Uncloneable type: " + type, DATA_CLONE_ERROR);
      };
      var throwUnpolyfillable = function(type, kind) {
        throw new DOMException2((kind || "Cloning") + " of " + type + " cannot be properly polyfilled in this engine", DATA_CLONE_ERROR);
      };
      var structuredCloneInternal = function(value, map) {
        if (isSymbol(value))
          throwUncloneable("Symbol");
        if (!isObject3(value))
          return value;
        if (map) {
          if (mapHas(map, value))
            return mapGet(map, value);
        } else
          map = new Map2();
        var type = classof(value);
        var deep = false;
        var C2, name, cloned, dataTransfer, i2, length, keys, key, source, target;
        switch (type) {
          case "Array":
            cloned = [];
            deep = true;
            break;
          case "Object":
            cloned = {};
            deep = true;
            break;
          case "Map":
            cloned = new Map2();
            deep = true;
            break;
          case "Set":
            cloned = new Set2();
            deep = true;
            break;
          case "RegExp":
            cloned = new RegExp(value.source, "flags" in value ? value.flags : getFlags(value));
            break;
          case "Error":
            name = value.name;
            switch (name) {
              case "AggregateError":
                cloned = getBuiltin("AggregateError")([]);
                break;
              case "EvalError":
                cloned = EvalError();
                break;
              case "RangeError":
                cloned = RangeError2();
                break;
              case "ReferenceError":
                cloned = ReferenceError2();
                break;
              case "SyntaxError":
                cloned = SyntaxError2();
                break;
              case "TypeError":
                cloned = TypeError2();
                break;
              case "URIError":
                cloned = URIError();
                break;
              case "CompileError":
                cloned = CompileError();
                break;
              case "LinkError":
                cloned = LinkError();
                break;
              case "RuntimeError":
                cloned = RuntimeError();
                break;
              default:
                cloned = Error2();
            }
            deep = true;
            break;
          case "DOMException":
            cloned = new DOMException2(value.message, value.name);
            deep = true;
            break;
          case "DataView":
          case "Int8Array":
          case "Uint8Array":
          case "Uint8ClampedArray":
          case "Int16Array":
          case "Uint16Array":
          case "Int32Array":
          case "Uint32Array":
          case "Float32Array":
          case "Float64Array":
          case "BigInt64Array":
          case "BigUint64Array":
            C2 = global2[type];
            if (!isObject3(C2))
              throwUnpolyfillable(type);
            cloned = new C2(structuredCloneInternal(value.buffer, map), value.byteOffset, type === "DataView" ? value.byteLength : value.length);
            break;
          case "DOMQuad":
            try {
              cloned = new DOMQuad(structuredCloneInternal(value.p1, map), structuredCloneInternal(value.p2, map), structuredCloneInternal(value.p3, map), structuredCloneInternal(value.p4, map));
            } catch (error2) {
              if (nativeRestrictedStructuredClone) {
                cloned = nativeRestrictedStructuredClone(value);
              } else
                throwUnpolyfillable(type);
            }
            break;
          case "FileList":
            C2 = global2.DataTransfer;
            if (isConstructor(C2)) {
              dataTransfer = new C2();
              for (i2 = 0, length = lengthOfArrayLike(value); i2 < length; i2++) {
                dataTransfer.items.add(structuredCloneInternal(value[i2], map));
              }
              cloned = dataTransfer.files;
            } else if (nativeRestrictedStructuredClone) {
              cloned = nativeRestrictedStructuredClone(value);
            } else
              throwUnpolyfillable(type);
            break;
          case "ImageData":
            try {
              cloned = new ImageData(structuredCloneInternal(value.data, map), value.width, value.height, { colorSpace: value.colorSpace });
            } catch (error2) {
              if (nativeRestrictedStructuredClone) {
                cloned = nativeRestrictedStructuredClone(value);
              } else
                throwUnpolyfillable(type);
            }
            break;
          default:
            if (nativeRestrictedStructuredClone) {
              cloned = nativeRestrictedStructuredClone(value);
            } else
              switch (type) {
                case "BigInt":
                  cloned = Object2(value.valueOf());
                  break;
                case "Boolean":
                  cloned = Object2(booleanValueOf(value));
                  break;
                case "Number":
                  cloned = Object2(numberValueOf(value));
                  break;
                case "String":
                  cloned = Object2(stringValueOf(value));
                  break;
                case "Date":
                  cloned = new Date2(getTime(value));
                  break;
                case "ArrayBuffer":
                  C2 = global2.DataView;
                  if (!C2 && typeof value.slice != "function")
                    throwUnpolyfillable(type);
                  try {
                    if (typeof value.slice == "function") {
                      cloned = value.slice(0);
                    } else {
                      length = value.byteLength;
                      cloned = new ArrayBuffer(length);
                      source = new C2(value);
                      target = new C2(cloned);
                      for (i2 = 0; i2 < length; i2++) {
                        target.setUint8(i2, source.getUint8(i2));
                      }
                    }
                  } catch (error2) {
                    throw new DOMException2("ArrayBuffer is detached", DATA_CLONE_ERROR);
                  }
                  break;
                case "SharedArrayBuffer":
                  cloned = value;
                  break;
                case "Blob":
                  try {
                    cloned = value.slice(0, value.size, value.type);
                  } catch (error2) {
                    throwUnpolyfillable(type);
                  }
                  break;
                case "DOMPoint":
                case "DOMPointReadOnly":
                  C2 = global2[type];
                  try {
                    cloned = C2.fromPoint ? C2.fromPoint(value) : new C2(value.x, value.y, value.z, value.w);
                  } catch (error2) {
                    throwUnpolyfillable(type);
                  }
                  break;
                case "DOMRect":
                case "DOMRectReadOnly":
                  C2 = global2[type];
                  try {
                    cloned = C2.fromRect ? C2.fromRect(value) : new C2(value.x, value.y, value.width, value.height);
                  } catch (error2) {
                    throwUnpolyfillable(type);
                  }
                  break;
                case "DOMMatrix":
                case "DOMMatrixReadOnly":
                  C2 = global2[type];
                  try {
                    cloned = C2.fromMatrix ? C2.fromMatrix(value) : new C2(value);
                  } catch (error2) {
                    throwUnpolyfillable(type);
                  }
                  break;
                case "AudioData":
                case "VideoFrame":
                  if (!isCallable(value.clone))
                    throwUnpolyfillable(type);
                  try {
                    cloned = value.clone();
                  } catch (error2) {
                    throwUncloneable(type);
                  }
                  break;
                case "File":
                  try {
                    cloned = new File([value], value.name, value);
                  } catch (error2) {
                    throwUnpolyfillable(type);
                  }
                  break;
                case "CryptoKey":
                case "GPUCompilationMessage":
                case "GPUCompilationInfo":
                case "ImageBitmap":
                case "RTCCertificate":
                case "WebAssembly.Module":
                  throwUnpolyfillable(type);
                default:
                  throwUncloneable(type);
              }
        }
        mapSet(map, value, cloned);
        if (deep)
          switch (type) {
            case "Array":
            case "Object":
              keys = objectKeys(value);
              for (i2 = 0, length = lengthOfArrayLike(keys); i2 < length; i2++) {
                key = keys[i2];
                createProperty(cloned, key, structuredCloneInternal(value[key], map));
              }
              break;
            case "Map":
              value.forEach(function(v2, k2) {
                mapSet(cloned, structuredCloneInternal(k2, map), structuredCloneInternal(v2, map));
              });
              break;
            case "Set":
              value.forEach(function(v2) {
                setAdd(cloned, structuredCloneInternal(v2, map));
              });
              break;
            case "Error":
              createNonEnumerableProperty(cloned, "message", structuredCloneInternal(value.message, map));
              if (hasOwn(value, "cause")) {
                createNonEnumerableProperty(cloned, "cause", structuredCloneInternal(value.cause, map));
              }
              if (name == "AggregateError") {
                cloned.errors = structuredCloneInternal(value.errors, map);
              }
            case "DOMException":
              if (ERROR_STACK_INSTALLABLE) {
                createNonEnumerableProperty(cloned, "stack", structuredCloneInternal(value.stack, map));
              }
          }
        return cloned;
      };
      var PROPER_TRANSFER = nativeStructuredClone && !fails(function() {
        var buffer = new ArrayBuffer(8);
        var clone = nativeStructuredClone(buffer, { transfer: [buffer] });
        return buffer.byteLength != 0 || clone.byteLength != 8;
      });
      var tryToTransfer = function(rawTransfer, map) {
        if (!isObject3(rawTransfer))
          throw TypeError2("Transfer option cannot be converted to a sequence");
        var transfer = [];
        iterate(rawTransfer, function(value2) {
          push(transfer, anObject(value2));
        });
        var i2 = 0;
        var length = lengthOfArrayLike(transfer);
        var value, type, C2, transferredArray, transferred, canvas, context;
        if (PROPER_TRANSFER) {
          transferredArray = nativeStructuredClone(transfer, { transfer });
          while (i2 < length)
            mapSet(map, transfer[i2], transferredArray[i2++]);
        } else
          while (i2 < length) {
            value = transfer[i2++];
            if (mapHas(map, value))
              throw new DOMException2("Duplicate transferable", DATA_CLONE_ERROR);
            type = classof(value);
            switch (type) {
              case "ImageBitmap":
                C2 = global2.OffscreenCanvas;
                if (!isConstructor(C2))
                  throwUnpolyfillable(type, TRANSFERRING);
                try {
                  canvas = new C2(value.width, value.height);
                  context = canvas.getContext("bitmaprenderer");
                  context.transferFromImageBitmap(value);
                  transferred = canvas.transferToImageBitmap();
                } catch (error2) {
                }
                break;
              case "AudioData":
              case "VideoFrame":
                if (!isCallable(value.clone) || !isCallable(value.close))
                  throwUnpolyfillable(type, TRANSFERRING);
                try {
                  transferred = value.clone();
                  value.close();
                } catch (error2) {
                }
                break;
              case "ArrayBuffer":
              case "MessagePort":
              case "OffscreenCanvas":
              case "ReadableStream":
              case "TransformStream":
              case "WritableStream":
                throwUnpolyfillable(type, TRANSFERRING);
            }
            if (transferred === void 0)
              throw new DOMException2("This object cannot be transferred: " + type, DATA_CLONE_ERROR);
            mapSet(map, value, transferred);
          }
      };
      $2({ global: true, enumerable: true, sham: !PROPER_TRANSFER, forced: FORCED_REPLACEMENT }, {
        structuredClone: function structuredClone(value) {
          var options = validateArgumentsLength(arguments.length, 1) > 1 ? anObject(arguments[1]) : void 0;
          var transfer = options ? options.transfer : void 0;
          var map;
          if (transfer !== void 0) {
            map = new Map2();
            tryToTransfer(transfer, map);
          }
          return structuredCloneInternal(value, map);
        }
      });
    }
  });

  // node_modules/core-js/modules/web.timers.js
  var require_web_timers = __commonJS({
    "node_modules/core-js/modules/web.timers.js"() {
      var $2 = require_export();
      var global2 = require_global();
      var apply = require_function_apply();
      var isCallable = require_is_callable();
      var userAgent = require_engine_user_agent();
      var arraySlice = require_array_slice();
      var validateArgumentsLength = require_validate_arguments_length();
      var MSIE = /MSIE .\./.test(userAgent);
      var Function2 = global2.Function;
      var wrap2 = function(scheduler) {
        return function(handler, timeout) {
          var boundArgs = validateArgumentsLength(arguments.length, 1) > 2;
          var fn2 = isCallable(handler) ? handler : Function2(handler);
          var args = boundArgs ? arraySlice(arguments, 2) : void 0;
          return scheduler(boundArgs ? function() {
            apply(fn2, this, args);
          } : fn2, timeout);
        };
      };
      $2({ global: true, bind: true, forced: MSIE }, {
        setTimeout: wrap2(global2.setTimeout),
        setInterval: wrap2(global2.setInterval)
      });
    }
  });

  // node_modules/core-js/internals/native-url.js
  var require_native_url = __commonJS({
    "node_modules/core-js/internals/native-url.js"(exports, module) {
      var fails = require_fails();
      var wellKnownSymbol = require_well_known_symbol();
      var IS_PURE = require_is_pure();
      var ITERATOR = wellKnownSymbol("iterator");
      module.exports = !fails(function() {
        var url = new URL("b?a=1&b=2&c=3", "http://a");
        var searchParams = url.searchParams;
        var result = "";
        url.pathname = "c%20d";
        searchParams.forEach(function(value, key) {
          searchParams["delete"]("b");
          result += key + value;
        });
        return IS_PURE && !url.toJSON || !searchParams.sort || url.href !== "http://a/c%20d?a=1&c=3" || searchParams.get("c") !== "3" || String(new URLSearchParams("?a=1")) !== "a=1" || !searchParams[ITERATOR] || new URL("https://a@b").username !== "a" || new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" || new URL("http://\u0442\u0435\u0441\u0442").host !== "xn--e1aybc" || new URL("http://a#\u0431").hash !== "#%D0%B1" || result !== "a1c3" || new URL("http://x", void 0).host !== "x";
      });
    }
  });

  // node_modules/core-js/internals/string-punycode-to-ascii.js
  var require_string_punycode_to_ascii = __commonJS({
    "node_modules/core-js/internals/string-punycode-to-ascii.js"(exports, module) {
      "use strict";
      var global2 = require_global();
      var uncurryThis = require_function_uncurry_this();
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexNonASCII = /[^\0-\u007E]/;
      var regexSeparators = /[.\u3002\uFF0E\uFF61]/g;
      var OVERFLOW_ERROR = "Overflow: input needs wider integers to process";
      var baseMinusTMin = base - tMin;
      var RangeError2 = global2.RangeError;
      var exec = uncurryThis(regexSeparators.exec);
      var floor = Math.floor;
      var fromCharCode = String.fromCharCode;
      var charCodeAt = uncurryThis("".charCodeAt);
      var join = uncurryThis([].join);
      var push = uncurryThis([].push);
      var replace = uncurryThis("".replace);
      var split = uncurryThis("".split);
      var toLowerCase = uncurryThis("".toLowerCase);
      var ucs2decode = function(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        while (counter < length) {
          var value = charCodeAt(string, counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            var extra = charCodeAt(string, counter++);
            if ((extra & 64512) == 56320) {
              push(output, ((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              push(output, value);
              counter--;
            }
          } else {
            push(output, value);
          }
        }
        return output;
      };
      var digitToBasic = function(digit) {
        return digit + 22 + 75 * (digit < 26);
      };
      var adapt = function(delta, numPoints, firstTime) {
        var k2 = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        while (delta > baseMinusTMin * tMax >> 1) {
          delta = floor(delta / baseMinusTMin);
          k2 += base;
        }
        return floor(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var encode = function(input) {
        var output = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n2 = initialN;
        var delta = 0;
        var bias = initialBias;
        var i2, currentValue;
        for (i2 = 0; i2 < input.length; i2++) {
          currentValue = input[i2];
          if (currentValue < 128) {
            push(output, fromCharCode(currentValue));
          }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          push(output, delimiter);
        }
        while (handledCPCount < inputLength) {
          var m2 = maxInt;
          for (i2 = 0; i2 < input.length; i2++) {
            currentValue = input[i2];
            if (currentValue >= n2 && currentValue < m2) {
              m2 = currentValue;
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m2 - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
            throw RangeError2(OVERFLOW_ERROR);
          }
          delta += (m2 - n2) * handledCPCountPlusOne;
          n2 = m2;
          for (i2 = 0; i2 < input.length; i2++) {
            currentValue = input[i2];
            if (currentValue < n2 && ++delta > maxInt) {
              throw RangeError2(OVERFLOW_ERROR);
            }
            if (currentValue == n2) {
              var q = delta;
              var k2 = base;
              while (true) {
                var t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
                if (q < t2)
                  break;
                var qMinusT = q - t2;
                var baseMinusT = base - t2;
                push(output, fromCharCode(digitToBasic(t2 + qMinusT % baseMinusT)));
                q = floor(qMinusT / baseMinusT);
                k2 += base;
              }
              push(output, fromCharCode(digitToBasic(q)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              handledCPCount++;
            }
          }
          delta++;
          n2++;
        }
        return join(output, "");
      };
      module.exports = function(input) {
        var encoded = [];
        var labels = split(replace(toLowerCase(input), regexSeparators, "."), ".");
        var i2, label;
        for (i2 = 0; i2 < labels.length; i2++) {
          label = labels[i2];
          push(encoded, exec(regexNonASCII, label) ? "xn--" + encode(label) : label);
        }
        return join(encoded, ".");
      };
    }
  });

  // node_modules/core-js/modules/web.url-search-params.js
  var require_web_url_search_params = __commonJS({
    "node_modules/core-js/modules/web.url-search-params.js"(exports, module) {
      "use strict";
      require_es_array_iterator();
      var $2 = require_export();
      var global2 = require_global();
      var getBuiltIn = require_get_built_in();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var USE_NATIVE_URL = require_native_url();
      var redefine = require_redefine();
      var redefineAll = require_redefine_all();
      var setToStringTag = require_set_to_string_tag();
      var createIteratorConstructor = require_create_iterator_constructor();
      var InternalStateModule = require_internal_state();
      var anInstance = require_an_instance();
      var isCallable = require_is_callable();
      var hasOwn = require_has_own_property();
      var bind3 = require_function_bind_context();
      var classof = require_classof();
      var anObject = require_an_object();
      var isObject3 = require_is_object();
      var $toString = require_to_string();
      var create = require_object_create();
      var createPropertyDescriptor = require_create_property_descriptor();
      var getIterator = require_get_iterator();
      var getIteratorMethod = require_get_iterator_method();
      var validateArgumentsLength = require_validate_arguments_length();
      var wellKnownSymbol = require_well_known_symbol();
      var arraySort = require_array_sort();
      var ITERATOR = wellKnownSymbol("iterator");
      var URL_SEARCH_PARAMS = "URLSearchParams";
      var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + "Iterator";
      var setInternalState = InternalStateModule.set;
      var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
      var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);
      var n$Fetch = getBuiltIn("fetch");
      var N$Request = getBuiltIn("Request");
      var Headers = getBuiltIn("Headers");
      var RequestPrototype = N$Request && N$Request.prototype;
      var HeadersPrototype = Headers && Headers.prototype;
      var RegExp2 = global2.RegExp;
      var TypeError2 = global2.TypeError;
      var decodeURIComponent2 = global2.decodeURIComponent;
      var encodeURIComponent2 = global2.encodeURIComponent;
      var charAt = uncurryThis("".charAt);
      var join = uncurryThis([].join);
      var push = uncurryThis([].push);
      var replace = uncurryThis("".replace);
      var shift = uncurryThis([].shift);
      var splice = uncurryThis([].splice);
      var split = uncurryThis("".split);
      var stringSlice = uncurryThis("".slice);
      var plus = /\+/g;
      var sequences = Array(4);
      var percentSequence = function(bytes) {
        return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp2("((?:%[\\da-f]{2}){" + bytes + "})", "gi"));
      };
      var percentDecode = function(sequence) {
        try {
          return decodeURIComponent2(sequence);
        } catch (error2) {
          return sequence;
        }
      };
      var deserialize = function(it) {
        var result = replace(it, plus, " ");
        var bytes = 4;
        try {
          return decodeURIComponent2(result);
        } catch (error2) {
          while (bytes) {
            result = replace(result, percentSequence(bytes--), percentDecode);
          }
          return result;
        }
      };
      var find = /[!'()~]|%20/g;
      var replacements = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+"
      };
      var replacer = function(match) {
        return replacements[match];
      };
      var serialize = function(it) {
        return replace(encodeURIComponent2(it), find, replacer);
      };
      var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
        setInternalState(this, {
          type: URL_SEARCH_PARAMS_ITERATOR,
          iterator: getIterator(getInternalParamsState(params).entries),
          kind
        });
      }, "Iterator", function next() {
        var state = getInternalIteratorState(this);
        var kind = state.kind;
        var step = state.iterator.next();
        var entry = step.value;
        if (!step.done) {
          step.value = kind === "keys" ? entry.key : kind === "values" ? entry.value : [entry.key, entry.value];
        }
        return step;
      }, true);
      var URLSearchParamsState = function(init) {
        this.entries = [];
        this.url = null;
        if (init !== void 0) {
          if (isObject3(init))
            this.parseObject(init);
          else
            this.parseQuery(typeof init == "string" ? charAt(init, 0) === "?" ? stringSlice(init, 1) : init : $toString(init));
        }
      };
      URLSearchParamsState.prototype = {
        type: URL_SEARCH_PARAMS,
        bindURL: function(url) {
          this.url = url;
          this.update();
        },
        parseObject: function(object) {
          var iteratorMethod = getIteratorMethod(object);
          var iterator, next, step, entryIterator, entryNext, first, second;
          if (iteratorMethod) {
            iterator = getIterator(object, iteratorMethod);
            next = iterator.next;
            while (!(step = call(next, iterator)).done) {
              entryIterator = getIterator(anObject(step.value));
              entryNext = entryIterator.next;
              if ((first = call(entryNext, entryIterator)).done || (second = call(entryNext, entryIterator)).done || !call(entryNext, entryIterator).done)
                throw TypeError2("Expected sequence with length 2");
              push(this.entries, { key: $toString(first.value), value: $toString(second.value) });
            }
          } else
            for (var key in object)
              if (hasOwn(object, key)) {
                push(this.entries, { key, value: $toString(object[key]) });
              }
        },
        parseQuery: function(query) {
          if (query) {
            var attributes = split(query, "&");
            var index = 0;
            var attribute, entry;
            while (index < attributes.length) {
              attribute = attributes[index++];
              if (attribute.length) {
                entry = split(attribute, "=");
                push(this.entries, {
                  key: deserialize(shift(entry)),
                  value: deserialize(join(entry, "="))
                });
              }
            }
          }
        },
        serialize: function() {
          var entries = this.entries;
          var result = [];
          var index = 0;
          var entry;
          while (index < entries.length) {
            entry = entries[index++];
            push(result, serialize(entry.key) + "=" + serialize(entry.value));
          }
          return join(result, "&");
        },
        update: function() {
          this.entries.length = 0;
          this.parseQuery(this.url.query);
        },
        updateURL: function() {
          if (this.url)
            this.url.update();
        }
      };
      var URLSearchParamsConstructor = function URLSearchParams2() {
        anInstance(this, URLSearchParamsPrototype);
        var init = arguments.length > 0 ? arguments[0] : void 0;
        setInternalState(this, new URLSearchParamsState(init));
      };
      var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
      redefineAll(URLSearchParamsPrototype, {
        append: function append(name, value) {
          validateArgumentsLength(arguments.length, 2);
          var state = getInternalParamsState(this);
          push(state.entries, { key: $toString(name), value: $toString(value) });
          state.updateURL();
        },
        "delete": function(name) {
          validateArgumentsLength(arguments.length, 1);
          var state = getInternalParamsState(this);
          var entries = state.entries;
          var key = $toString(name);
          var index = 0;
          while (index < entries.length) {
            if (entries[index].key === key)
              splice(entries, index, 1);
            else
              index++;
          }
          state.updateURL();
        },
        get: function get(name) {
          validateArgumentsLength(arguments.length, 1);
          var entries = getInternalParamsState(this).entries;
          var key = $toString(name);
          var index = 0;
          for (; index < entries.length; index++) {
            if (entries[index].key === key)
              return entries[index].value;
          }
          return null;
        },
        getAll: function getAll(name) {
          validateArgumentsLength(arguments.length, 1);
          var entries = getInternalParamsState(this).entries;
          var key = $toString(name);
          var result = [];
          var index = 0;
          for (; index < entries.length; index++) {
            if (entries[index].key === key)
              push(result, entries[index].value);
          }
          return result;
        },
        has: function has(name) {
          validateArgumentsLength(arguments.length, 1);
          var entries = getInternalParamsState(this).entries;
          var key = $toString(name);
          var index = 0;
          while (index < entries.length) {
            if (entries[index++].key === key)
              return true;
          }
          return false;
        },
        set: function set(name, value) {
          validateArgumentsLength(arguments.length, 1);
          var state = getInternalParamsState(this);
          var entries = state.entries;
          var found = false;
          var key = $toString(name);
          var val = $toString(value);
          var index = 0;
          var entry;
          for (; index < entries.length; index++) {
            entry = entries[index];
            if (entry.key === key) {
              if (found)
                splice(entries, index--, 1);
              else {
                found = true;
                entry.value = val;
              }
            }
          }
          if (!found)
            push(entries, { key, value: val });
          state.updateURL();
        },
        sort: function sort() {
          var state = getInternalParamsState(this);
          arraySort(state.entries, function(a2, b2) {
            return a2.key > b2.key ? 1 : -1;
          });
          state.updateURL();
        },
        forEach: function forEach(callback) {
          var entries = getInternalParamsState(this).entries;
          var boundFunction = bind3(callback, arguments.length > 1 ? arguments[1] : void 0);
          var index = 0;
          var entry;
          while (index < entries.length) {
            entry = entries[index++];
            boundFunction(entry.value, entry.key, this);
          }
        },
        keys: function keys() {
          return new URLSearchParamsIterator(this, "keys");
        },
        values: function values() {
          return new URLSearchParamsIterator(this, "values");
        },
        entries: function entries() {
          return new URLSearchParamsIterator(this, "entries");
        }
      }, { enumerable: true });
      redefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries, { name: "entries" });
      redefine(URLSearchParamsPrototype, "toString", function toString() {
        return getInternalParamsState(this).serialize();
      }, { enumerable: true });
      setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
      $2({ global: true, forced: !USE_NATIVE_URL }, {
        URLSearchParams: URLSearchParamsConstructor
      });
      if (!USE_NATIVE_URL && isCallable(Headers)) {
        headersHas = uncurryThis(HeadersPrototype.has);
        headersSet = uncurryThis(HeadersPrototype.set);
        wrapRequestOptions = function(init) {
          if (isObject3(init)) {
            var body = init.body;
            var headers;
            if (classof(body) === URL_SEARCH_PARAMS) {
              headers = init.headers ? new Headers(init.headers) : new Headers();
              if (!headersHas(headers, "content-type")) {
                headersSet(headers, "content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
              return create(init, {
                body: createPropertyDescriptor(0, $toString(body)),
                headers: createPropertyDescriptor(0, headers)
              });
            }
          }
          return init;
        };
        if (isCallable(n$Fetch)) {
          $2({ global: true, enumerable: true, forced: true }, {
            fetch: function fetch4(input) {
              return n$Fetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
            }
          });
        }
        if (isCallable(N$Request)) {
          RequestConstructor = function Request(input) {
            anInstance(this, RequestPrototype);
            return new N$Request(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
          };
          RequestPrototype.constructor = RequestConstructor;
          RequestConstructor.prototype = RequestPrototype;
          $2({ global: true, forced: true }, {
            Request: RequestConstructor
          });
        }
      }
      var headersHas;
      var headersSet;
      var wrapRequestOptions;
      var RequestConstructor;
      module.exports = {
        URLSearchParams: URLSearchParamsConstructor,
        getState: getInternalParamsState
      };
    }
  });

  // node_modules/core-js/modules/web.url.js
  var require_web_url = __commonJS({
    "node_modules/core-js/modules/web.url.js"() {
      "use strict";
      require_es_string_iterator();
      var $2 = require_export();
      var DESCRIPTORS = require_descriptors();
      var USE_NATIVE_URL = require_native_url();
      var global2 = require_global();
      var bind3 = require_function_bind_context();
      var uncurryThis = require_function_uncurry_this();
      var defineProperties = require_object_define_properties().f;
      var redefine = require_redefine();
      var anInstance = require_an_instance();
      var hasOwn = require_has_own_property();
      var assign = require_object_assign();
      var arrayFrom2 = require_array_from();
      var arraySlice = require_array_slice_simple();
      var codeAt = require_string_multibyte().codeAt;
      var toASCII = require_string_punycode_to_ascii();
      var $toString = require_to_string();
      var setToStringTag = require_set_to_string_tag();
      var validateArgumentsLength = require_validate_arguments_length();
      var URLSearchParamsModule = require_web_url_search_params();
      var InternalStateModule = require_internal_state();
      var setInternalState = InternalStateModule.set;
      var getInternalURLState = InternalStateModule.getterFor("URL");
      var URLSearchParams2 = URLSearchParamsModule.URLSearchParams;
      var getInternalSearchParamsState = URLSearchParamsModule.getState;
      var NativeURL = global2.URL;
      var TypeError2 = global2.TypeError;
      var parseInt2 = global2.parseInt;
      var floor = Math.floor;
      var pow = Math.pow;
      var charAt = uncurryThis("".charAt);
      var exec = uncurryThis(/./.exec);
      var join = uncurryThis([].join);
      var numberToString = uncurryThis(1 .toString);
      var pop = uncurryThis([].pop);
      var push = uncurryThis([].push);
      var replace = uncurryThis("".replace);
      var shift = uncurryThis([].shift);
      var split = uncurryThis("".split);
      var stringSlice = uncurryThis("".slice);
      var toLowerCase = uncurryThis("".toLowerCase);
      var unshift = uncurryThis([].unshift);
      var INVALID_AUTHORITY = "Invalid authority";
      var INVALID_SCHEME = "Invalid scheme";
      var INVALID_HOST = "Invalid host";
      var INVALID_PORT = "Invalid port";
      var ALPHA = /[a-z]/i;
      var ALPHANUMERIC = /[\d+-.a-z]/i;
      var DIGIT = /\d/;
      var HEX_START = /^0x/i;
      var OCT = /^[0-7]+$/;
      var DEC = /^\d+$/;
      var HEX = /^[\da-f]+$/i;
      var FORBIDDEN_HOST_CODE_POINT = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
      var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\0\t\n\r #/:<>?@[\\\]^|]/;
      var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u0020]+|[\u0000-\u0020]+$/g;
      var TAB_AND_NEW_LINE = /[\t\n\r]/g;
      var EOF;
      var parseIPv4 = function(input) {
        var parts = split(input, ".");
        var partsLength, numbers, index, part, radix, number, ipv4;
        if (parts.length && parts[parts.length - 1] == "") {
          parts.length--;
        }
        partsLength = parts.length;
        if (partsLength > 4)
          return input;
        numbers = [];
        for (index = 0; index < partsLength; index++) {
          part = parts[index];
          if (part == "")
            return input;
          radix = 10;
          if (part.length > 1 && charAt(part, 0) == "0") {
            radix = exec(HEX_START, part) ? 16 : 8;
            part = stringSlice(part, radix == 8 ? 1 : 2);
          }
          if (part === "") {
            number = 0;
          } else {
            if (!exec(radix == 10 ? DEC : radix == 8 ? OCT : HEX, part))
              return input;
            number = parseInt2(part, radix);
          }
          push(numbers, number);
        }
        for (index = 0; index < partsLength; index++) {
          number = numbers[index];
          if (index == partsLength - 1) {
            if (number >= pow(256, 5 - partsLength))
              return null;
          } else if (number > 255)
            return null;
        }
        ipv4 = pop(numbers);
        for (index = 0; index < numbers.length; index++) {
          ipv4 += numbers[index] * pow(256, 3 - index);
        }
        return ipv4;
      };
      var parseIPv6 = function(input) {
        var address = [0, 0, 0, 0, 0, 0, 0, 0];
        var pieceIndex = 0;
        var compress = null;
        var pointer = 0;
        var value, length, numbersSeen, ipv4Piece, number, swaps, swap;
        var chr = function() {
          return charAt(input, pointer);
        };
        if (chr() == ":") {
          if (charAt(input, 1) != ":")
            return;
          pointer += 2;
          pieceIndex++;
          compress = pieceIndex;
        }
        while (chr()) {
          if (pieceIndex == 8)
            return;
          if (chr() == ":") {
            if (compress !== null)
              return;
            pointer++;
            pieceIndex++;
            compress = pieceIndex;
            continue;
          }
          value = length = 0;
          while (length < 4 && exec(HEX, chr())) {
            value = value * 16 + parseInt2(chr(), 16);
            pointer++;
            length++;
          }
          if (chr() == ".") {
            if (length == 0)
              return;
            pointer -= length;
            if (pieceIndex > 6)
              return;
            numbersSeen = 0;
            while (chr()) {
              ipv4Piece = null;
              if (numbersSeen > 0) {
                if (chr() == "." && numbersSeen < 4)
                  pointer++;
                else
                  return;
              }
              if (!exec(DIGIT, chr()))
                return;
              while (exec(DIGIT, chr())) {
                number = parseInt2(chr(), 10);
                if (ipv4Piece === null)
                  ipv4Piece = number;
                else if (ipv4Piece == 0)
                  return;
                else
                  ipv4Piece = ipv4Piece * 10 + number;
                if (ipv4Piece > 255)
                  return;
                pointer++;
              }
              address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
              numbersSeen++;
              if (numbersSeen == 2 || numbersSeen == 4)
                pieceIndex++;
            }
            if (numbersSeen != 4)
              return;
            break;
          } else if (chr() == ":") {
            pointer++;
            if (!chr())
              return;
          } else if (chr())
            return;
          address[pieceIndex++] = value;
        }
        if (compress !== null) {
          swaps = pieceIndex - compress;
          pieceIndex = 7;
          while (pieceIndex != 0 && swaps > 0) {
            swap = address[pieceIndex];
            address[pieceIndex--] = address[compress + swaps - 1];
            address[compress + --swaps] = swap;
          }
        } else if (pieceIndex != 8)
          return;
        return address;
      };
      var findLongestZeroSequence = function(ipv6) {
        var maxIndex = null;
        var maxLength = 1;
        var currStart = null;
        var currLength = 0;
        var index = 0;
        for (; index < 8; index++) {
          if (ipv6[index] !== 0) {
            if (currLength > maxLength) {
              maxIndex = currStart;
              maxLength = currLength;
            }
            currStart = null;
            currLength = 0;
          } else {
            if (currStart === null)
              currStart = index;
            ++currLength;
          }
        }
        if (currLength > maxLength) {
          maxIndex = currStart;
          maxLength = currLength;
        }
        return maxIndex;
      };
      var serializeHost = function(host) {
        var result, index, compress, ignore0;
        if (typeof host == "number") {
          result = [];
          for (index = 0; index < 4; index++) {
            unshift(result, host % 256);
            host = floor(host / 256);
          }
          return join(result, ".");
        } else if (typeof host == "object") {
          result = "";
          compress = findLongestZeroSequence(host);
          for (index = 0; index < 8; index++) {
            if (ignore0 && host[index] === 0)
              continue;
            if (ignore0)
              ignore0 = false;
            if (compress === index) {
              result += index ? ":" : "::";
              ignore0 = true;
            } else {
              result += numberToString(host[index], 16);
              if (index < 7)
                result += ":";
            }
          }
          return "[" + result + "]";
        }
        return host;
      };
      var C0ControlPercentEncodeSet = {};
      var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
        " ": 1,
        '"': 1,
        "<": 1,
        ">": 1,
        "`": 1
      });
      var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
        "#": 1,
        "?": 1,
        "{": 1,
        "}": 1
      });
      var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
        "/": 1,
        ":": 1,
        ";": 1,
        "=": 1,
        "@": 1,
        "[": 1,
        "\\": 1,
        "]": 1,
        "^": 1,
        "|": 1
      });
      var percentEncode = function(chr, set) {
        var code3 = codeAt(chr, 0);
        return code3 > 32 && code3 < 127 && !hasOwn(set, chr) ? chr : encodeURIComponent(chr);
      };
      var specialSchemes = {
        ftp: 21,
        file: null,
        http: 80,
        https: 443,
        ws: 80,
        wss: 443
      };
      var isWindowsDriveLetter = function(string, normalized) {
        var second;
        return string.length == 2 && exec(ALPHA, charAt(string, 0)) && ((second = charAt(string, 1)) == ":" || !normalized && second == "|");
      };
      var startsWithWindowsDriveLetter = function(string) {
        var third;
        return string.length > 1 && isWindowsDriveLetter(stringSlice(string, 0, 2)) && (string.length == 2 || ((third = charAt(string, 2)) === "/" || third === "\\" || third === "?" || third === "#"));
      };
      var isSingleDot = function(segment) {
        return segment === "." || toLowerCase(segment) === "%2e";
      };
      var isDoubleDot = function(segment) {
        segment = toLowerCase(segment);
        return segment === ".." || segment === "%2e." || segment === ".%2e" || segment === "%2e%2e";
      };
      var SCHEME_START = {};
      var SCHEME = {};
      var NO_SCHEME = {};
      var SPECIAL_RELATIVE_OR_AUTHORITY = {};
      var PATH_OR_AUTHORITY = {};
      var RELATIVE = {};
      var RELATIVE_SLASH = {};
      var SPECIAL_AUTHORITY_SLASHES = {};
      var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
      var AUTHORITY = {};
      var HOST = {};
      var HOSTNAME = {};
      var PORT = {};
      var FILE = {};
      var FILE_SLASH = {};
      var FILE_HOST = {};
      var PATH_START = {};
      var PATH = {};
      var CANNOT_BE_A_BASE_URL_PATH = {};
      var QUERY = {};
      var FRAGMENT = {};
      var URLState = function(url, isBase, base) {
        var urlString = $toString(url);
        var baseState, failure, searchParams;
        if (isBase) {
          failure = this.parse(urlString);
          if (failure)
            throw TypeError2(failure);
          this.searchParams = null;
        } else {
          if (base !== void 0)
            baseState = new URLState(base, true);
          failure = this.parse(urlString, null, baseState);
          if (failure)
            throw TypeError2(failure);
          searchParams = getInternalSearchParamsState(new URLSearchParams2());
          searchParams.bindURL(this);
          this.searchParams = searchParams;
        }
      };
      URLState.prototype = {
        type: "URL",
        parse: function(input, stateOverride, base) {
          var url = this;
          var state = stateOverride || SCHEME_START;
          var pointer = 0;
          var buffer = "";
          var seenAt = false;
          var seenBracket = false;
          var seenPasswordToken = false;
          var codePoints, chr, bufferCodePoints, failure;
          input = $toString(input);
          if (!stateOverride) {
            url.scheme = "";
            url.username = "";
            url.password = "";
            url.host = null;
            url.port = null;
            url.path = [];
            url.query = null;
            url.fragment = null;
            url.cannotBeABaseURL = false;
            input = replace(input, LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, "");
          }
          input = replace(input, TAB_AND_NEW_LINE, "");
          codePoints = arrayFrom2(input);
          while (pointer <= codePoints.length) {
            chr = codePoints[pointer];
            switch (state) {
              case SCHEME_START:
                if (chr && exec(ALPHA, chr)) {
                  buffer += toLowerCase(chr);
                  state = SCHEME;
                } else if (!stateOverride) {
                  state = NO_SCHEME;
                  continue;
                } else
                  return INVALID_SCHEME;
                break;
              case SCHEME:
                if (chr && (exec(ALPHANUMERIC, chr) || chr == "+" || chr == "-" || chr == ".")) {
                  buffer += toLowerCase(chr);
                } else if (chr == ":") {
                  if (stateOverride && (url.isSpecial() != hasOwn(specialSchemes, buffer) || buffer == "file" && (url.includesCredentials() || url.port !== null) || url.scheme == "file" && !url.host))
                    return;
                  url.scheme = buffer;
                  if (stateOverride) {
                    if (url.isSpecial() && specialSchemes[url.scheme] == url.port)
                      url.port = null;
                    return;
                  }
                  buffer = "";
                  if (url.scheme == "file") {
                    state = FILE;
                  } else if (url.isSpecial() && base && base.scheme == url.scheme) {
                    state = SPECIAL_RELATIVE_OR_AUTHORITY;
                  } else if (url.isSpecial()) {
                    state = SPECIAL_AUTHORITY_SLASHES;
                  } else if (codePoints[pointer + 1] == "/") {
                    state = PATH_OR_AUTHORITY;
                    pointer++;
                  } else {
                    url.cannotBeABaseURL = true;
                    push(url.path, "");
                    state = CANNOT_BE_A_BASE_URL_PATH;
                  }
                } else if (!stateOverride) {
                  buffer = "";
                  state = NO_SCHEME;
                  pointer = 0;
                  continue;
                } else
                  return INVALID_SCHEME;
                break;
              case NO_SCHEME:
                if (!base || base.cannotBeABaseURL && chr != "#")
                  return INVALID_SCHEME;
                if (base.cannotBeABaseURL && chr == "#") {
                  url.scheme = base.scheme;
                  url.path = arraySlice(base.path);
                  url.query = base.query;
                  url.fragment = "";
                  url.cannotBeABaseURL = true;
                  state = FRAGMENT;
                  break;
                }
                state = base.scheme == "file" ? FILE : RELATIVE;
                continue;
              case SPECIAL_RELATIVE_OR_AUTHORITY:
                if (chr == "/" && codePoints[pointer + 1] == "/") {
                  state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                  pointer++;
                } else {
                  state = RELATIVE;
                  continue;
                }
                break;
              case PATH_OR_AUTHORITY:
                if (chr == "/") {
                  state = AUTHORITY;
                  break;
                } else {
                  state = PATH;
                  continue;
                }
              case RELATIVE:
                url.scheme = base.scheme;
                if (chr == EOF) {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  url.path = arraySlice(base.path);
                  url.query = base.query;
                } else if (chr == "/" || chr == "\\" && url.isSpecial()) {
                  state = RELATIVE_SLASH;
                } else if (chr == "?") {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  url.path = arraySlice(base.path);
                  url.query = "";
                  state = QUERY;
                } else if (chr == "#") {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  url.path = arraySlice(base.path);
                  url.query = base.query;
                  url.fragment = "";
                  state = FRAGMENT;
                } else {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  url.path = arraySlice(base.path);
                  url.path.length--;
                  state = PATH;
                  continue;
                }
                break;
              case RELATIVE_SLASH:
                if (url.isSpecial() && (chr == "/" || chr == "\\")) {
                  state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                } else if (chr == "/") {
                  state = AUTHORITY;
                } else {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  state = PATH;
                  continue;
                }
                break;
              case SPECIAL_AUTHORITY_SLASHES:
                state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                if (chr != "/" || charAt(buffer, pointer + 1) != "/")
                  continue;
                pointer++;
                break;
              case SPECIAL_AUTHORITY_IGNORE_SLASHES:
                if (chr != "/" && chr != "\\") {
                  state = AUTHORITY;
                  continue;
                }
                break;
              case AUTHORITY:
                if (chr == "@") {
                  if (seenAt)
                    buffer = "%40" + buffer;
                  seenAt = true;
                  bufferCodePoints = arrayFrom2(buffer);
                  for (var i2 = 0; i2 < bufferCodePoints.length; i2++) {
                    var codePoint = bufferCodePoints[i2];
                    if (codePoint == ":" && !seenPasswordToken) {
                      seenPasswordToken = true;
                      continue;
                    }
                    var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
                    if (seenPasswordToken)
                      url.password += encodedCodePoints;
                    else
                      url.username += encodedCodePoints;
                  }
                  buffer = "";
                } else if (chr == EOF || chr == "/" || chr == "?" || chr == "#" || chr == "\\" && url.isSpecial()) {
                  if (seenAt && buffer == "")
                    return INVALID_AUTHORITY;
                  pointer -= arrayFrom2(buffer).length + 1;
                  buffer = "";
                  state = HOST;
                } else
                  buffer += chr;
                break;
              case HOST:
              case HOSTNAME:
                if (stateOverride && url.scheme == "file") {
                  state = FILE_HOST;
                  continue;
                } else if (chr == ":" && !seenBracket) {
                  if (buffer == "")
                    return INVALID_HOST;
                  failure = url.parseHost(buffer);
                  if (failure)
                    return failure;
                  buffer = "";
                  state = PORT;
                  if (stateOverride == HOSTNAME)
                    return;
                } else if (chr == EOF || chr == "/" || chr == "?" || chr == "#" || chr == "\\" && url.isSpecial()) {
                  if (url.isSpecial() && buffer == "")
                    return INVALID_HOST;
                  if (stateOverride && buffer == "" && (url.includesCredentials() || url.port !== null))
                    return;
                  failure = url.parseHost(buffer);
                  if (failure)
                    return failure;
                  buffer = "";
                  state = PATH_START;
                  if (stateOverride)
                    return;
                  continue;
                } else {
                  if (chr == "[")
                    seenBracket = true;
                  else if (chr == "]")
                    seenBracket = false;
                  buffer += chr;
                }
                break;
              case PORT:
                if (exec(DIGIT, chr)) {
                  buffer += chr;
                } else if (chr == EOF || chr == "/" || chr == "?" || chr == "#" || chr == "\\" && url.isSpecial() || stateOverride) {
                  if (buffer != "") {
                    var port = parseInt2(buffer, 10);
                    if (port > 65535)
                      return INVALID_PORT;
                    url.port = url.isSpecial() && port === specialSchemes[url.scheme] ? null : port;
                    buffer = "";
                  }
                  if (stateOverride)
                    return;
                  state = PATH_START;
                  continue;
                } else
                  return INVALID_PORT;
                break;
              case FILE:
                url.scheme = "file";
                if (chr == "/" || chr == "\\")
                  state = FILE_SLASH;
                else if (base && base.scheme == "file") {
                  if (chr == EOF) {
                    url.host = base.host;
                    url.path = arraySlice(base.path);
                    url.query = base.query;
                  } else if (chr == "?") {
                    url.host = base.host;
                    url.path = arraySlice(base.path);
                    url.query = "";
                    state = QUERY;
                  } else if (chr == "#") {
                    url.host = base.host;
                    url.path = arraySlice(base.path);
                    url.query = base.query;
                    url.fragment = "";
                    state = FRAGMENT;
                  } else {
                    if (!startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ""))) {
                      url.host = base.host;
                      url.path = arraySlice(base.path);
                      url.shortenPath();
                    }
                    state = PATH;
                    continue;
                  }
                } else {
                  state = PATH;
                  continue;
                }
                break;
              case FILE_SLASH:
                if (chr == "/" || chr == "\\") {
                  state = FILE_HOST;
                  break;
                }
                if (base && base.scheme == "file" && !startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ""))) {
                  if (isWindowsDriveLetter(base.path[0], true))
                    push(url.path, base.path[0]);
                  else
                    url.host = base.host;
                }
                state = PATH;
                continue;
              case FILE_HOST:
                if (chr == EOF || chr == "/" || chr == "\\" || chr == "?" || chr == "#") {
                  if (!stateOverride && isWindowsDriveLetter(buffer)) {
                    state = PATH;
                  } else if (buffer == "") {
                    url.host = "";
                    if (stateOverride)
                      return;
                    state = PATH_START;
                  } else {
                    failure = url.parseHost(buffer);
                    if (failure)
                      return failure;
                    if (url.host == "localhost")
                      url.host = "";
                    if (stateOverride)
                      return;
                    buffer = "";
                    state = PATH_START;
                  }
                  continue;
                } else
                  buffer += chr;
                break;
              case PATH_START:
                if (url.isSpecial()) {
                  state = PATH;
                  if (chr != "/" && chr != "\\")
                    continue;
                } else if (!stateOverride && chr == "?") {
                  url.query = "";
                  state = QUERY;
                } else if (!stateOverride && chr == "#") {
                  url.fragment = "";
                  state = FRAGMENT;
                } else if (chr != EOF) {
                  state = PATH;
                  if (chr != "/")
                    continue;
                }
                break;
              case PATH:
                if (chr == EOF || chr == "/" || chr == "\\" && url.isSpecial() || !stateOverride && (chr == "?" || chr == "#")) {
                  if (isDoubleDot(buffer)) {
                    url.shortenPath();
                    if (chr != "/" && !(chr == "\\" && url.isSpecial())) {
                      push(url.path, "");
                    }
                  } else if (isSingleDot(buffer)) {
                    if (chr != "/" && !(chr == "\\" && url.isSpecial())) {
                      push(url.path, "");
                    }
                  } else {
                    if (url.scheme == "file" && !url.path.length && isWindowsDriveLetter(buffer)) {
                      if (url.host)
                        url.host = "";
                      buffer = charAt(buffer, 0) + ":";
                    }
                    push(url.path, buffer);
                  }
                  buffer = "";
                  if (url.scheme == "file" && (chr == EOF || chr == "?" || chr == "#")) {
                    while (url.path.length > 1 && url.path[0] === "") {
                      shift(url.path);
                    }
                  }
                  if (chr == "?") {
                    url.query = "";
                    state = QUERY;
                  } else if (chr == "#") {
                    url.fragment = "";
                    state = FRAGMENT;
                  }
                } else {
                  buffer += percentEncode(chr, pathPercentEncodeSet);
                }
                break;
              case CANNOT_BE_A_BASE_URL_PATH:
                if (chr == "?") {
                  url.query = "";
                  state = QUERY;
                } else if (chr == "#") {
                  url.fragment = "";
                  state = FRAGMENT;
                } else if (chr != EOF) {
                  url.path[0] += percentEncode(chr, C0ControlPercentEncodeSet);
                }
                break;
              case QUERY:
                if (!stateOverride && chr == "#") {
                  url.fragment = "";
                  state = FRAGMENT;
                } else if (chr != EOF) {
                  if (chr == "'" && url.isSpecial())
                    url.query += "%27";
                  else if (chr == "#")
                    url.query += "%23";
                  else
                    url.query += percentEncode(chr, C0ControlPercentEncodeSet);
                }
                break;
              case FRAGMENT:
                if (chr != EOF)
                  url.fragment += percentEncode(chr, fragmentPercentEncodeSet);
                break;
            }
            pointer++;
          }
        },
        parseHost: function(input) {
          var result, codePoints, index;
          if (charAt(input, 0) == "[") {
            if (charAt(input, input.length - 1) != "]")
              return INVALID_HOST;
            result = parseIPv6(stringSlice(input, 1, -1));
            if (!result)
              return INVALID_HOST;
            this.host = result;
          } else if (!this.isSpecial()) {
            if (exec(FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT, input))
              return INVALID_HOST;
            result = "";
            codePoints = arrayFrom2(input);
            for (index = 0; index < codePoints.length; index++) {
              result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
            }
            this.host = result;
          } else {
            input = toASCII(input);
            if (exec(FORBIDDEN_HOST_CODE_POINT, input))
              return INVALID_HOST;
            result = parseIPv4(input);
            if (result === null)
              return INVALID_HOST;
            this.host = result;
          }
        },
        cannotHaveUsernamePasswordPort: function() {
          return !this.host || this.cannotBeABaseURL || this.scheme == "file";
        },
        includesCredentials: function() {
          return this.username != "" || this.password != "";
        },
        isSpecial: function() {
          return hasOwn(specialSchemes, this.scheme);
        },
        shortenPath: function() {
          var path = this.path;
          var pathSize = path.length;
          if (pathSize && (this.scheme != "file" || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
            path.length--;
          }
        },
        serialize: function() {
          var url = this;
          var scheme = url.scheme;
          var username = url.username;
          var password = url.password;
          var host = url.host;
          var port = url.port;
          var path = url.path;
          var query = url.query;
          var fragment = url.fragment;
          var output = scheme + ":";
          if (host !== null) {
            output += "//";
            if (url.includesCredentials()) {
              output += username + (password ? ":" + password : "") + "@";
            }
            output += serializeHost(host);
            if (port !== null)
              output += ":" + port;
          } else if (scheme == "file")
            output += "//";
          output += url.cannotBeABaseURL ? path[0] : path.length ? "/" + join(path, "/") : "";
          if (query !== null)
            output += "?" + query;
          if (fragment !== null)
            output += "#" + fragment;
          return output;
        },
        setHref: function(href) {
          var failure = this.parse(href);
          if (failure)
            throw TypeError2(failure);
          this.searchParams.update();
        },
        getOrigin: function() {
          var scheme = this.scheme;
          var port = this.port;
          if (scheme == "blob")
            try {
              return new URLConstructor(scheme.path[0]).origin;
            } catch (error2) {
              return "null";
            }
          if (scheme == "file" || !this.isSpecial())
            return "null";
          return scheme + "://" + serializeHost(this.host) + (port !== null ? ":" + port : "");
        },
        getProtocol: function() {
          return this.scheme + ":";
        },
        setProtocol: function(protocol) {
          this.parse($toString(protocol) + ":", SCHEME_START);
        },
        getUsername: function() {
          return this.username;
        },
        setUsername: function(username) {
          var codePoints = arrayFrom2($toString(username));
          if (this.cannotHaveUsernamePasswordPort())
            return;
          this.username = "";
          for (var i2 = 0; i2 < codePoints.length; i2++) {
            this.username += percentEncode(codePoints[i2], userinfoPercentEncodeSet);
          }
        },
        getPassword: function() {
          return this.password;
        },
        setPassword: function(password) {
          var codePoints = arrayFrom2($toString(password));
          if (this.cannotHaveUsernamePasswordPort())
            return;
          this.password = "";
          for (var i2 = 0; i2 < codePoints.length; i2++) {
            this.password += percentEncode(codePoints[i2], userinfoPercentEncodeSet);
          }
        },
        getHost: function() {
          var host = this.host;
          var port = this.port;
          return host === null ? "" : port === null ? serializeHost(host) : serializeHost(host) + ":" + port;
        },
        setHost: function(host) {
          if (this.cannotBeABaseURL)
            return;
          this.parse(host, HOST);
        },
        getHostname: function() {
          var host = this.host;
          return host === null ? "" : serializeHost(host);
        },
        setHostname: function(hostname) {
          if (this.cannotBeABaseURL)
            return;
          this.parse(hostname, HOSTNAME);
        },
        getPort: function() {
          var port = this.port;
          return port === null ? "" : $toString(port);
        },
        setPort: function(port) {
          if (this.cannotHaveUsernamePasswordPort())
            return;
          port = $toString(port);
          if (port == "")
            this.port = null;
          else
            this.parse(port, PORT);
        },
        getPathname: function() {
          var path = this.path;
          return this.cannotBeABaseURL ? path[0] : path.length ? "/" + join(path, "/") : "";
        },
        setPathname: function(pathname) {
          if (this.cannotBeABaseURL)
            return;
          this.path = [];
          this.parse(pathname, PATH_START);
        },
        getSearch: function() {
          var query = this.query;
          return query ? "?" + query : "";
        },
        setSearch: function(search) {
          search = $toString(search);
          if (search == "") {
            this.query = null;
          } else {
            if (charAt(search, 0) == "?")
              search = stringSlice(search, 1);
            this.query = "";
            this.parse(search, QUERY);
          }
          this.searchParams.update();
        },
        getSearchParams: function() {
          return this.searchParams.facade;
        },
        getHash: function() {
          var fragment = this.fragment;
          return fragment ? "#" + fragment : "";
        },
        setHash: function(hash3) {
          hash3 = $toString(hash3);
          if (hash3 == "") {
            this.fragment = null;
            return;
          }
          if (charAt(hash3, 0) == "#")
            hash3 = stringSlice(hash3, 1);
          this.fragment = "";
          this.parse(hash3, FRAGMENT);
        },
        update: function() {
          this.query = this.searchParams.serialize() || null;
        }
      };
      var URLConstructor = function URL2(url) {
        var that = anInstance(this, URLPrototype);
        var base = validateArgumentsLength(arguments.length, 1) > 1 ? arguments[1] : void 0;
        var state = setInternalState(that, new URLState(url, false, base));
        if (!DESCRIPTORS) {
          that.href = state.serialize();
          that.origin = state.getOrigin();
          that.protocol = state.getProtocol();
          that.username = state.getUsername();
          that.password = state.getPassword();
          that.host = state.getHost();
          that.hostname = state.getHostname();
          that.port = state.getPort();
          that.pathname = state.getPathname();
          that.search = state.getSearch();
          that.searchParams = state.getSearchParams();
          that.hash = state.getHash();
        }
      };
      var URLPrototype = URLConstructor.prototype;
      var accessorDescriptor = function(getter, setter) {
        return {
          get: function() {
            return getInternalURLState(this)[getter]();
          },
          set: setter && function(value) {
            return getInternalURLState(this)[setter](value);
          },
          configurable: true,
          enumerable: true
        };
      };
      if (DESCRIPTORS) {
        defineProperties(URLPrototype, {
          href: accessorDescriptor("serialize", "setHref"),
          origin: accessorDescriptor("getOrigin"),
          protocol: accessorDescriptor("getProtocol", "setProtocol"),
          username: accessorDescriptor("getUsername", "setUsername"),
          password: accessorDescriptor("getPassword", "setPassword"),
          host: accessorDescriptor("getHost", "setHost"),
          hostname: accessorDescriptor("getHostname", "setHostname"),
          port: accessorDescriptor("getPort", "setPort"),
          pathname: accessorDescriptor("getPathname", "setPathname"),
          search: accessorDescriptor("getSearch", "setSearch"),
          searchParams: accessorDescriptor("getSearchParams"),
          hash: accessorDescriptor("getHash", "setHash")
        });
      }
      redefine(URLPrototype, "toJSON", function toJSON() {
        return getInternalURLState(this).serialize();
      }, { enumerable: true });
      redefine(URLPrototype, "toString", function toString() {
        return getInternalURLState(this).serialize();
      }, { enumerable: true });
      if (NativeURL) {
        nativeCreateObjectURL = NativeURL.createObjectURL;
        nativeRevokeObjectURL = NativeURL.revokeObjectURL;
        if (nativeCreateObjectURL)
          redefine(URLConstructor, "createObjectURL", bind3(nativeCreateObjectURL, NativeURL));
        if (nativeRevokeObjectURL)
          redefine(URLConstructor, "revokeObjectURL", bind3(nativeRevokeObjectURL, NativeURL));
      }
      var nativeCreateObjectURL;
      var nativeRevokeObjectURL;
      setToStringTag(URLConstructor, "URL");
      $2({ global: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {
        URL: URLConstructor
      });
    }
  });

  // node_modules/core-js/modules/web.url.to-json.js
  var require_web_url_to_json = __commonJS({
    "node_modules/core-js/modules/web.url.to-json.js"() {
      "use strict";
      var $2 = require_export();
      var call = require_function_call();
      $2({ target: "URL", proto: true, enumerable: true }, {
        toJSON: function toJSON() {
          return call(URL.prototype.toString, this);
        }
      });
    }
  });

  // node_modules/core-js/stable/index.js
  var require_stable = __commonJS({
    "node_modules/core-js/stable/index.js"(exports, module) {
      require_es_symbol();
      require_es_symbol_description();
      require_es_symbol_async_iterator();
      require_es_symbol_has_instance();
      require_es_symbol_is_concat_spreadable();
      require_es_symbol_iterator();
      require_es_symbol_match();
      require_es_symbol_match_all();
      require_es_symbol_replace();
      require_es_symbol_search();
      require_es_symbol_species();
      require_es_symbol_split();
      require_es_symbol_to_primitive();
      require_es_symbol_to_string_tag();
      require_es_symbol_unscopables();
      require_es_error_cause();
      require_es_error_to_string();
      require_es_aggregate_error();
      require_es_aggregate_error_cause();
      require_es_array_at();
      require_es_array_concat();
      require_es_array_copy_within();
      require_es_array_every();
      require_es_array_fill();
      require_es_array_filter();
      require_es_array_find();
      require_es_array_find_index();
      require_es_array_flat();
      require_es_array_flat_map();
      require_es_array_for_each();
      require_es_array_from();
      require_es_array_includes();
      require_es_array_index_of();
      require_es_array_is_array();
      require_es_array_iterator();
      require_es_array_join();
      require_es_array_last_index_of();
      require_es_array_map();
      require_es_array_of();
      require_es_array_reduce();
      require_es_array_reduce_right();
      require_es_array_reverse();
      require_es_array_slice();
      require_es_array_some();
      require_es_array_sort();
      require_es_array_species();
      require_es_array_splice();
      require_es_array_unscopables_flat();
      require_es_array_unscopables_flat_map();
      require_es_array_buffer_constructor();
      require_es_array_buffer_is_view();
      require_es_array_buffer_slice();
      require_es_data_view();
      require_es_date_get_year();
      require_es_date_now();
      require_es_date_set_year();
      require_es_date_to_gmt_string();
      require_es_date_to_iso_string();
      require_es_date_to_json();
      require_es_date_to_primitive();
      require_es_date_to_string();
      require_es_escape();
      require_es_function_bind();
      require_es_function_has_instance();
      require_es_function_name();
      require_es_global_this();
      require_es_json_stringify();
      require_es_json_to_string_tag();
      require_es_map();
      require_es_math_acosh();
      require_es_math_asinh();
      require_es_math_atanh();
      require_es_math_cbrt();
      require_es_math_clz32();
      require_es_math_cosh();
      require_es_math_expm1();
      require_es_math_fround();
      require_es_math_hypot();
      require_es_math_imul();
      require_es_math_log10();
      require_es_math_log1p();
      require_es_math_log2();
      require_es_math_sign();
      require_es_math_sinh();
      require_es_math_tanh();
      require_es_math_to_string_tag();
      require_es_math_trunc();
      require_es_number_constructor();
      require_es_number_epsilon();
      require_es_number_is_finite();
      require_es_number_is_integer();
      require_es_number_is_nan();
      require_es_number_is_safe_integer();
      require_es_number_max_safe_integer();
      require_es_number_min_safe_integer();
      require_es_number_parse_float();
      require_es_number_parse_int();
      require_es_number_to_exponential();
      require_es_number_to_fixed();
      require_es_number_to_precision();
      require_es_object_assign();
      require_es_object_create();
      require_es_object_define_getter();
      require_es_object_define_properties();
      require_es_object_define_property();
      require_es_object_define_setter();
      require_es_object_entries();
      require_es_object_freeze();
      require_es_object_from_entries();
      require_es_object_get_own_property_descriptor();
      require_es_object_get_own_property_descriptors();
      require_es_object_get_own_property_names();
      require_es_object_get_prototype_of();
      require_es_object_has_own();
      require_es_object_is();
      require_es_object_is_extensible();
      require_es_object_is_frozen();
      require_es_object_is_sealed();
      require_es_object_keys();
      require_es_object_lookup_getter();
      require_es_object_lookup_setter();
      require_es_object_prevent_extensions();
      require_es_object_seal();
      require_es_object_set_prototype_of();
      require_es_object_to_string();
      require_es_object_values();
      require_es_parse_float();
      require_es_parse_int();
      require_es_promise();
      require_es_promise_all_settled();
      require_es_promise_any();
      require_es_promise_finally();
      require_es_reflect_apply();
      require_es_reflect_construct();
      require_es_reflect_define_property();
      require_es_reflect_delete_property();
      require_es_reflect_get();
      require_es_reflect_get_own_property_descriptor();
      require_es_reflect_get_prototype_of();
      require_es_reflect_has();
      require_es_reflect_is_extensible();
      require_es_reflect_own_keys();
      require_es_reflect_prevent_extensions();
      require_es_reflect_set();
      require_es_reflect_set_prototype_of();
      require_es_reflect_to_string_tag();
      require_es_regexp_constructor();
      require_es_regexp_dot_all();
      require_es_regexp_exec();
      require_es_regexp_flags();
      require_es_regexp_sticky();
      require_es_regexp_test();
      require_es_regexp_to_string();
      require_es_set();
      require_es_string_at_alternative();
      require_es_string_code_point_at();
      require_es_string_ends_with();
      require_es_string_from_code_point();
      require_es_string_includes();
      require_es_string_iterator();
      require_es_string_match();
      require_es_string_match_all();
      require_es_string_pad_end();
      require_es_string_pad_start();
      require_es_string_raw();
      require_es_string_repeat();
      require_es_string_replace();
      require_es_string_replace_all();
      require_es_string_search();
      require_es_string_split();
      require_es_string_starts_with();
      require_es_string_substr();
      require_es_string_trim();
      require_es_string_trim_end();
      require_es_string_trim_start();
      require_es_string_anchor();
      require_es_string_big();
      require_es_string_blink();
      require_es_string_bold();
      require_es_string_fixed();
      require_es_string_fontcolor();
      require_es_string_fontsize();
      require_es_string_italics();
      require_es_string_link();
      require_es_string_small();
      require_es_string_strike();
      require_es_string_sub();
      require_es_string_sup();
      require_es_typed_array_float32_array();
      require_es_typed_array_float64_array();
      require_es_typed_array_int8_array();
      require_es_typed_array_int16_array();
      require_es_typed_array_int32_array();
      require_es_typed_array_uint8_array();
      require_es_typed_array_uint8_clamped_array();
      require_es_typed_array_uint16_array();
      require_es_typed_array_uint32_array();
      require_es_typed_array_at();
      require_es_typed_array_copy_within();
      require_es_typed_array_every();
      require_es_typed_array_fill();
      require_es_typed_array_filter();
      require_es_typed_array_find();
      require_es_typed_array_find_index();
      require_es_typed_array_for_each();
      require_es_typed_array_from();
      require_es_typed_array_includes();
      require_es_typed_array_index_of();
      require_es_typed_array_iterator();
      require_es_typed_array_join();
      require_es_typed_array_last_index_of();
      require_es_typed_array_map();
      require_es_typed_array_of();
      require_es_typed_array_reduce();
      require_es_typed_array_reduce_right();
      require_es_typed_array_reverse();
      require_es_typed_array_set();
      require_es_typed_array_slice();
      require_es_typed_array_some();
      require_es_typed_array_sort();
      require_es_typed_array_subarray();
      require_es_typed_array_to_locale_string();
      require_es_typed_array_to_string();
      require_es_unescape();
      require_es_weak_map();
      require_es_weak_set();
      require_web_atob();
      require_web_btoa();
      require_web_dom_collections_for_each();
      require_web_dom_collections_iterator();
      require_web_dom_exception_constructor();
      require_web_dom_exception_stack();
      require_web_dom_exception_to_string_tag();
      require_web_immediate();
      require_web_queue_microtask();
      require_web_structured_clone();
      require_web_timers();
      require_web_url();
      require_web_url_to_json();
      require_web_url_search_params();
      module.exports = require_path();
    }
  });

  // node_modules/regenerator-runtime/runtime.js
  var require_runtime = __commonJS({
    "node_modules/regenerator-runtime/runtime.js"(exports, module) {
      var runtime = function(exports2) {
        "use strict";
        var Op = Object.prototype;
        var hasOwn = Op.hasOwnProperty;
        var undefined2;
        var $Symbol = typeof Symbol === "function" ? Symbol : {};
        var iteratorSymbol = $Symbol.iterator || "@@iterator";
        var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
        var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
        function define2(obj, key, value) {
          Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
          return obj[key];
        }
        try {
          define2({}, "");
        } catch (err) {
          define2 = function(obj, key, value) {
            return obj[key] = value;
          };
        }
        function wrap2(innerFn, outerFn, self2, tryLocsList) {
          var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
          var generator = Object.create(protoGenerator.prototype);
          var context = new Context2(tryLocsList || []);
          generator._invoke = makeInvokeMethod(innerFn, self2, context);
          return generator;
        }
        exports2.wrap = wrap2;
        function tryCatch(fn2, obj, arg) {
          try {
            return { type: "normal", arg: fn2.call(obj, arg) };
          } catch (err) {
            return { type: "throw", arg: err };
          }
        }
        var GenStateSuspendedStart = "suspendedStart";
        var GenStateSuspendedYield = "suspendedYield";
        var GenStateExecuting = "executing";
        var GenStateCompleted = "completed";
        var ContinueSentinel = {};
        function Generator() {
        }
        function GeneratorFunction() {
        }
        function GeneratorFunctionPrototype() {
        }
        var IteratorPrototype = {};
        define2(IteratorPrototype, iteratorSymbol, function() {
          return this;
        });
        var getProto = Object.getPrototypeOf;
        var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
        if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
          IteratorPrototype = NativeIteratorPrototype;
        }
        var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
        GeneratorFunction.prototype = GeneratorFunctionPrototype;
        define2(Gp, "constructor", GeneratorFunctionPrototype);
        define2(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
        GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");
        function defineIteratorMethods(prototype) {
          ["next", "throw", "return"].forEach(function(method) {
            define2(prototype, method, function(arg) {
              return this._invoke(method, arg);
            });
          });
        }
        exports2.isGeneratorFunction = function(genFun) {
          var ctor = typeof genFun === "function" && genFun.constructor;
          return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
        };
        exports2.mark = function(genFun) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
          } else {
            genFun.__proto__ = GeneratorFunctionPrototype;
            define2(genFun, toStringTagSymbol, "GeneratorFunction");
          }
          genFun.prototype = Object.create(Gp);
          return genFun;
        };
        exports2.awrap = function(arg) {
          return { __await: arg };
        };
        function AsyncIterator(generator, PromiseImpl) {
          function invoke(method, arg, resolve2, reject) {
            var record = tryCatch(generator[method], generator, arg);
            if (record.type === "throw") {
              reject(record.arg);
            } else {
              var result = record.arg;
              var value = result.value;
              if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
                return PromiseImpl.resolve(value.__await).then(function(value2) {
                  invoke("next", value2, resolve2, reject);
                }, function(err) {
                  invoke("throw", err, resolve2, reject);
                });
              }
              return PromiseImpl.resolve(value).then(function(unwrapped) {
                result.value = unwrapped;
                resolve2(result);
              }, function(error2) {
                return invoke("throw", error2, resolve2, reject);
              });
            }
          }
          var previousPromise;
          function enqueue(method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function(resolve2, reject) {
                invoke(method, arg, resolve2, reject);
              });
            }
            return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
          this._invoke = enqueue;
        }
        defineIteratorMethods(AsyncIterator.prototype);
        define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
          return this;
        });
        exports2.AsyncIterator = AsyncIterator;
        exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
          if (PromiseImpl === void 0)
            PromiseImpl = Promise;
          var iter = new AsyncIterator(wrap2(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
          return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
        };
        function makeInvokeMethod(innerFn, self2, context) {
          var state = GenStateSuspendedStart;
          return function invoke(method, arg) {
            if (state === GenStateExecuting) {
              throw new Error("Generator is already running");
            }
            if (state === GenStateCompleted) {
              if (method === "throw") {
                throw arg;
              }
              return doneResult();
            }
            context.method = method;
            context.arg = arg;
            while (true) {
              var delegate = context.delegate;
              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context);
                if (delegateResult) {
                  if (delegateResult === ContinueSentinel)
                    continue;
                  return delegateResult;
                }
              }
              if (context.method === "next") {
                context.sent = context._sent = context.arg;
              } else if (context.method === "throw") {
                if (state === GenStateSuspendedStart) {
                  state = GenStateCompleted;
                  throw context.arg;
                }
                context.dispatchException(context.arg);
              } else if (context.method === "return") {
                context.abrupt("return", context.arg);
              }
              state = GenStateExecuting;
              var record = tryCatch(innerFn, self2, context);
              if (record.type === "normal") {
                state = context.done ? GenStateCompleted : GenStateSuspendedYield;
                if (record.arg === ContinueSentinel) {
                  continue;
                }
                return {
                  value: record.arg,
                  done: context.done
                };
              } else if (record.type === "throw") {
                state = GenStateCompleted;
                context.method = "throw";
                context.arg = record.arg;
              }
            }
          };
        }
        function maybeInvokeDelegate(delegate, context) {
          var method = delegate.iterator[context.method];
          if (method === undefined2) {
            context.delegate = null;
            if (context.method === "throw") {
              if (delegate.iterator["return"]) {
                context.method = "return";
                context.arg = undefined2;
                maybeInvokeDelegate(delegate, context);
                if (context.method === "throw") {
                  return ContinueSentinel;
                }
              }
              context.method = "throw";
              context.arg = new TypeError("The iterator does not provide a 'throw' method");
            }
            return ContinueSentinel;
          }
          var record = tryCatch(method, delegate.iterator, context.arg);
          if (record.type === "throw") {
            context.method = "throw";
            context.arg = record.arg;
            context.delegate = null;
            return ContinueSentinel;
          }
          var info = record.arg;
          if (!info) {
            context.method = "throw";
            context.arg = new TypeError("iterator result is not an object");
            context.delegate = null;
            return ContinueSentinel;
          }
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
            if (context.method !== "return") {
              context.method = "next";
              context.arg = undefined2;
            }
          } else {
            return info;
          }
          context.delegate = null;
          return ContinueSentinel;
        }
        defineIteratorMethods(Gp);
        define2(Gp, toStringTagSymbol, "Generator");
        define2(Gp, iteratorSymbol, function() {
          return this;
        });
        define2(Gp, "toString", function() {
          return "[object Generator]";
        });
        function pushTryEntry(locs) {
          var entry = { tryLoc: locs[0] };
          if (1 in locs) {
            entry.catchLoc = locs[1];
          }
          if (2 in locs) {
            entry.finallyLoc = locs[2];
            entry.afterLoc = locs[3];
          }
          this.tryEntries.push(entry);
        }
        function resetTryEntry(entry) {
          var record = entry.completion || {};
          record.type = "normal";
          delete record.arg;
          entry.completion = record;
        }
        function Context2(tryLocsList) {
          this.tryEntries = [{ tryLoc: "root" }];
          tryLocsList.forEach(pushTryEntry, this);
          this.reset(true);
        }
        exports2.keys = function(object) {
          var keys = [];
          for (var key in object) {
            keys.push(key);
          }
          keys.reverse();
          return function next() {
            while (keys.length) {
              var key2 = keys.pop();
              if (key2 in object) {
                next.value = key2;
                next.done = false;
                return next;
              }
            }
            next.done = true;
            return next;
          };
        };
        function values(iterable) {
          if (iterable) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod) {
              return iteratorMethod.call(iterable);
            }
            if (typeof iterable.next === "function") {
              return iterable;
            }
            if (!isNaN(iterable.length)) {
              var i2 = -1, next = function next2() {
                while (++i2 < iterable.length) {
                  if (hasOwn.call(iterable, i2)) {
                    next2.value = iterable[i2];
                    next2.done = false;
                    return next2;
                  }
                }
                next2.value = undefined2;
                next2.done = true;
                return next2;
              };
              return next.next = next;
            }
          }
          return { next: doneResult };
        }
        exports2.values = values;
        function doneResult() {
          return { value: undefined2, done: true };
        }
        Context2.prototype = {
          constructor: Context2,
          reset: function(skipTempReset) {
            this.prev = 0;
            this.next = 0;
            this.sent = this._sent = undefined2;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = undefined2;
            this.tryEntries.forEach(resetTryEntry);
            if (!skipTempReset) {
              for (var name in this) {
                if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                  this[name] = undefined2;
                }
              }
            }
          },
          stop: function() {
            this.done = true;
            var rootEntry = this.tryEntries[0];
            var rootRecord = rootEntry.completion;
            if (rootRecord.type === "throw") {
              throw rootRecord.arg;
            }
            return this.rval;
          },
          dispatchException: function(exception) {
            if (this.done) {
              throw exception;
            }
            var context = this;
            function handle(loc, caught) {
              record.type = "throw";
              record.arg = exception;
              context.next = loc;
              if (caught) {
                context.method = "next";
                context.arg = undefined2;
              }
              return !!caught;
            }
            for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
              var entry = this.tryEntries[i2];
              var record = entry.completion;
              if (entry.tryLoc === "root") {
                return handle("end");
              }
              if (entry.tryLoc <= this.prev) {
                var hasCatch = hasOwn.call(entry, "catchLoc");
                var hasFinally = hasOwn.call(entry, "finallyLoc");
                if (hasCatch && hasFinally) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true);
                  } else if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc);
                  }
                } else if (hasCatch) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true);
                  }
                } else if (hasFinally) {
                  if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc);
                  }
                } else {
                  throw new Error("try statement without catch or finally");
                }
              }
            }
          },
          abrupt: function(type, arg) {
            for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
              var entry = this.tryEntries[i2];
              if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                var finallyEntry = entry;
                break;
              }
            }
            if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
              finallyEntry = null;
            }
            var record = finallyEntry ? finallyEntry.completion : {};
            record.type = type;
            record.arg = arg;
            if (finallyEntry) {
              this.method = "next";
              this.next = finallyEntry.finallyLoc;
              return ContinueSentinel;
            }
            return this.complete(record);
          },
          complete: function(record, afterLoc) {
            if (record.type === "throw") {
              throw record.arg;
            }
            if (record.type === "break" || record.type === "continue") {
              this.next = record.arg;
            } else if (record.type === "return") {
              this.rval = this.arg = record.arg;
              this.method = "return";
              this.next = "end";
            } else if (record.type === "normal" && afterLoc) {
              this.next = afterLoc;
            }
            return ContinueSentinel;
          },
          finish: function(finallyLoc) {
            for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
              var entry = this.tryEntries[i2];
              if (entry.finallyLoc === finallyLoc) {
                this.complete(entry.completion, entry.afterLoc);
                resetTryEntry(entry);
                return ContinueSentinel;
              }
            }
          },
          "catch": function(tryLoc) {
            for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
              var entry = this.tryEntries[i2];
              if (entry.tryLoc === tryLoc) {
                var record = entry.completion;
                if (record.type === "throw") {
                  var thrown = record.arg;
                  resetTryEntry(entry);
                }
                return thrown;
              }
            }
            throw new Error("illegal catch attempt");
          },
          delegateYield: function(iterable, resultName, nextLoc) {
            this.delegate = {
              iterator: values(iterable),
              resultName,
              nextLoc
            };
            if (this.method === "next") {
              this.arg = undefined2;
            }
            return ContinueSentinel;
          }
        };
        return exports2;
      }(typeof module === "object" ? module.exports : {});
      try {
        regeneratorRuntime = runtime;
      } catch (accidentalStrictMode) {
        if (typeof globalThis === "object") {
          globalThis.regeneratorRuntime = runtime;
        } else {
          Function("r", "regeneratorRuntime = r")(runtime);
        }
      }
    }
  });

  // node_modules/@rails/activestorage/app/assets/javascripts/activestorage.js
  var require_activestorage = __commonJS({
    "node_modules/@rails/activestorage/app/assets/javascripts/activestorage.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.ActiveStorage = {});
      })(exports, function(exports2) {
        "use strict";
        function createCommonjsModule(fn2, module2) {
          return module2 = {
            exports: {}
          }, fn2(module2, module2.exports), module2.exports;
        }
        var sparkMd5 = createCommonjsModule(function(module2, exports3) {
          (function(factory) {
            {
              module2.exports = factory();
            }
          })(function(undefined2) {
            var hex_chr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
            function md5cycle(x2, k2) {
              var a2 = x2[0], b2 = x2[1], c2 = x2[2], d2 = x2[3];
              a2 += (b2 & c2 | ~b2 & d2) + k2[0] - 680876936 | 0;
              a2 = (a2 << 7 | a2 >>> 25) + b2 | 0;
              d2 += (a2 & b2 | ~a2 & c2) + k2[1] - 389564586 | 0;
              d2 = (d2 << 12 | d2 >>> 20) + a2 | 0;
              c2 += (d2 & a2 | ~d2 & b2) + k2[2] + 606105819 | 0;
              c2 = (c2 << 17 | c2 >>> 15) + d2 | 0;
              b2 += (c2 & d2 | ~c2 & a2) + k2[3] - 1044525330 | 0;
              b2 = (b2 << 22 | b2 >>> 10) + c2 | 0;
              a2 += (b2 & c2 | ~b2 & d2) + k2[4] - 176418897 | 0;
              a2 = (a2 << 7 | a2 >>> 25) + b2 | 0;
              d2 += (a2 & b2 | ~a2 & c2) + k2[5] + 1200080426 | 0;
              d2 = (d2 << 12 | d2 >>> 20) + a2 | 0;
              c2 += (d2 & a2 | ~d2 & b2) + k2[6] - 1473231341 | 0;
              c2 = (c2 << 17 | c2 >>> 15) + d2 | 0;
              b2 += (c2 & d2 | ~c2 & a2) + k2[7] - 45705983 | 0;
              b2 = (b2 << 22 | b2 >>> 10) + c2 | 0;
              a2 += (b2 & c2 | ~b2 & d2) + k2[8] + 1770035416 | 0;
              a2 = (a2 << 7 | a2 >>> 25) + b2 | 0;
              d2 += (a2 & b2 | ~a2 & c2) + k2[9] - 1958414417 | 0;
              d2 = (d2 << 12 | d2 >>> 20) + a2 | 0;
              c2 += (d2 & a2 | ~d2 & b2) + k2[10] - 42063 | 0;
              c2 = (c2 << 17 | c2 >>> 15) + d2 | 0;
              b2 += (c2 & d2 | ~c2 & a2) + k2[11] - 1990404162 | 0;
              b2 = (b2 << 22 | b2 >>> 10) + c2 | 0;
              a2 += (b2 & c2 | ~b2 & d2) + k2[12] + 1804603682 | 0;
              a2 = (a2 << 7 | a2 >>> 25) + b2 | 0;
              d2 += (a2 & b2 | ~a2 & c2) + k2[13] - 40341101 | 0;
              d2 = (d2 << 12 | d2 >>> 20) + a2 | 0;
              c2 += (d2 & a2 | ~d2 & b2) + k2[14] - 1502002290 | 0;
              c2 = (c2 << 17 | c2 >>> 15) + d2 | 0;
              b2 += (c2 & d2 | ~c2 & a2) + k2[15] + 1236535329 | 0;
              b2 = (b2 << 22 | b2 >>> 10) + c2 | 0;
              a2 += (b2 & d2 | c2 & ~d2) + k2[1] - 165796510 | 0;
              a2 = (a2 << 5 | a2 >>> 27) + b2 | 0;
              d2 += (a2 & c2 | b2 & ~c2) + k2[6] - 1069501632 | 0;
              d2 = (d2 << 9 | d2 >>> 23) + a2 | 0;
              c2 += (d2 & b2 | a2 & ~b2) + k2[11] + 643717713 | 0;
              c2 = (c2 << 14 | c2 >>> 18) + d2 | 0;
              b2 += (c2 & a2 | d2 & ~a2) + k2[0] - 373897302 | 0;
              b2 = (b2 << 20 | b2 >>> 12) + c2 | 0;
              a2 += (b2 & d2 | c2 & ~d2) + k2[5] - 701558691 | 0;
              a2 = (a2 << 5 | a2 >>> 27) + b2 | 0;
              d2 += (a2 & c2 | b2 & ~c2) + k2[10] + 38016083 | 0;
              d2 = (d2 << 9 | d2 >>> 23) + a2 | 0;
              c2 += (d2 & b2 | a2 & ~b2) + k2[15] - 660478335 | 0;
              c2 = (c2 << 14 | c2 >>> 18) + d2 | 0;
              b2 += (c2 & a2 | d2 & ~a2) + k2[4] - 405537848 | 0;
              b2 = (b2 << 20 | b2 >>> 12) + c2 | 0;
              a2 += (b2 & d2 | c2 & ~d2) + k2[9] + 568446438 | 0;
              a2 = (a2 << 5 | a2 >>> 27) + b2 | 0;
              d2 += (a2 & c2 | b2 & ~c2) + k2[14] - 1019803690 | 0;
              d2 = (d2 << 9 | d2 >>> 23) + a2 | 0;
              c2 += (d2 & b2 | a2 & ~b2) + k2[3] - 187363961 | 0;
              c2 = (c2 << 14 | c2 >>> 18) + d2 | 0;
              b2 += (c2 & a2 | d2 & ~a2) + k2[8] + 1163531501 | 0;
              b2 = (b2 << 20 | b2 >>> 12) + c2 | 0;
              a2 += (b2 & d2 | c2 & ~d2) + k2[13] - 1444681467 | 0;
              a2 = (a2 << 5 | a2 >>> 27) + b2 | 0;
              d2 += (a2 & c2 | b2 & ~c2) + k2[2] - 51403784 | 0;
              d2 = (d2 << 9 | d2 >>> 23) + a2 | 0;
              c2 += (d2 & b2 | a2 & ~b2) + k2[7] + 1735328473 | 0;
              c2 = (c2 << 14 | c2 >>> 18) + d2 | 0;
              b2 += (c2 & a2 | d2 & ~a2) + k2[12] - 1926607734 | 0;
              b2 = (b2 << 20 | b2 >>> 12) + c2 | 0;
              a2 += (b2 ^ c2 ^ d2) + k2[5] - 378558 | 0;
              a2 = (a2 << 4 | a2 >>> 28) + b2 | 0;
              d2 += (a2 ^ b2 ^ c2) + k2[8] - 2022574463 | 0;
              d2 = (d2 << 11 | d2 >>> 21) + a2 | 0;
              c2 += (d2 ^ a2 ^ b2) + k2[11] + 1839030562 | 0;
              c2 = (c2 << 16 | c2 >>> 16) + d2 | 0;
              b2 += (c2 ^ d2 ^ a2) + k2[14] - 35309556 | 0;
              b2 = (b2 << 23 | b2 >>> 9) + c2 | 0;
              a2 += (b2 ^ c2 ^ d2) + k2[1] - 1530992060 | 0;
              a2 = (a2 << 4 | a2 >>> 28) + b2 | 0;
              d2 += (a2 ^ b2 ^ c2) + k2[4] + 1272893353 | 0;
              d2 = (d2 << 11 | d2 >>> 21) + a2 | 0;
              c2 += (d2 ^ a2 ^ b2) + k2[7] - 155497632 | 0;
              c2 = (c2 << 16 | c2 >>> 16) + d2 | 0;
              b2 += (c2 ^ d2 ^ a2) + k2[10] - 1094730640 | 0;
              b2 = (b2 << 23 | b2 >>> 9) + c2 | 0;
              a2 += (b2 ^ c2 ^ d2) + k2[13] + 681279174 | 0;
              a2 = (a2 << 4 | a2 >>> 28) + b2 | 0;
              d2 += (a2 ^ b2 ^ c2) + k2[0] - 358537222 | 0;
              d2 = (d2 << 11 | d2 >>> 21) + a2 | 0;
              c2 += (d2 ^ a2 ^ b2) + k2[3] - 722521979 | 0;
              c2 = (c2 << 16 | c2 >>> 16) + d2 | 0;
              b2 += (c2 ^ d2 ^ a2) + k2[6] + 76029189 | 0;
              b2 = (b2 << 23 | b2 >>> 9) + c2 | 0;
              a2 += (b2 ^ c2 ^ d2) + k2[9] - 640364487 | 0;
              a2 = (a2 << 4 | a2 >>> 28) + b2 | 0;
              d2 += (a2 ^ b2 ^ c2) + k2[12] - 421815835 | 0;
              d2 = (d2 << 11 | d2 >>> 21) + a2 | 0;
              c2 += (d2 ^ a2 ^ b2) + k2[15] + 530742520 | 0;
              c2 = (c2 << 16 | c2 >>> 16) + d2 | 0;
              b2 += (c2 ^ d2 ^ a2) + k2[2] - 995338651 | 0;
              b2 = (b2 << 23 | b2 >>> 9) + c2 | 0;
              a2 += (c2 ^ (b2 | ~d2)) + k2[0] - 198630844 | 0;
              a2 = (a2 << 6 | a2 >>> 26) + b2 | 0;
              d2 += (b2 ^ (a2 | ~c2)) + k2[7] + 1126891415 | 0;
              d2 = (d2 << 10 | d2 >>> 22) + a2 | 0;
              c2 += (a2 ^ (d2 | ~b2)) + k2[14] - 1416354905 | 0;
              c2 = (c2 << 15 | c2 >>> 17) + d2 | 0;
              b2 += (d2 ^ (c2 | ~a2)) + k2[5] - 57434055 | 0;
              b2 = (b2 << 21 | b2 >>> 11) + c2 | 0;
              a2 += (c2 ^ (b2 | ~d2)) + k2[12] + 1700485571 | 0;
              a2 = (a2 << 6 | a2 >>> 26) + b2 | 0;
              d2 += (b2 ^ (a2 | ~c2)) + k2[3] - 1894986606 | 0;
              d2 = (d2 << 10 | d2 >>> 22) + a2 | 0;
              c2 += (a2 ^ (d2 | ~b2)) + k2[10] - 1051523 | 0;
              c2 = (c2 << 15 | c2 >>> 17) + d2 | 0;
              b2 += (d2 ^ (c2 | ~a2)) + k2[1] - 2054922799 | 0;
              b2 = (b2 << 21 | b2 >>> 11) + c2 | 0;
              a2 += (c2 ^ (b2 | ~d2)) + k2[8] + 1873313359 | 0;
              a2 = (a2 << 6 | a2 >>> 26) + b2 | 0;
              d2 += (b2 ^ (a2 | ~c2)) + k2[15] - 30611744 | 0;
              d2 = (d2 << 10 | d2 >>> 22) + a2 | 0;
              c2 += (a2 ^ (d2 | ~b2)) + k2[6] - 1560198380 | 0;
              c2 = (c2 << 15 | c2 >>> 17) + d2 | 0;
              b2 += (d2 ^ (c2 | ~a2)) + k2[13] + 1309151649 | 0;
              b2 = (b2 << 21 | b2 >>> 11) + c2 | 0;
              a2 += (c2 ^ (b2 | ~d2)) + k2[4] - 145523070 | 0;
              a2 = (a2 << 6 | a2 >>> 26) + b2 | 0;
              d2 += (b2 ^ (a2 | ~c2)) + k2[11] - 1120210379 | 0;
              d2 = (d2 << 10 | d2 >>> 22) + a2 | 0;
              c2 += (a2 ^ (d2 | ~b2)) + k2[2] + 718787259 | 0;
              c2 = (c2 << 15 | c2 >>> 17) + d2 | 0;
              b2 += (d2 ^ (c2 | ~a2)) + k2[9] - 343485551 | 0;
              b2 = (b2 << 21 | b2 >>> 11) + c2 | 0;
              x2[0] = a2 + x2[0] | 0;
              x2[1] = b2 + x2[1] | 0;
              x2[2] = c2 + x2[2] | 0;
              x2[3] = d2 + x2[3] | 0;
            }
            function md5blk(s2) {
              var md5blks = [], i2;
              for (i2 = 0; i2 < 64; i2 += 4) {
                md5blks[i2 >> 2] = s2.charCodeAt(i2) + (s2.charCodeAt(i2 + 1) << 8) + (s2.charCodeAt(i2 + 2) << 16) + (s2.charCodeAt(i2 + 3) << 24);
              }
              return md5blks;
            }
            function md5blk_array(a2) {
              var md5blks = [], i2;
              for (i2 = 0; i2 < 64; i2 += 4) {
                md5blks[i2 >> 2] = a2[i2] + (a2[i2 + 1] << 8) + (a2[i2 + 2] << 16) + (a2[i2 + 3] << 24);
              }
              return md5blks;
            }
            function md51(s2) {
              var n2 = s2.length, state = [1732584193, -271733879, -1732584194, 271733878], i2, length, tail, tmp, lo, hi;
              for (i2 = 64; i2 <= n2; i2 += 64) {
                md5cycle(state, md5blk(s2.substring(i2 - 64, i2)));
              }
              s2 = s2.substring(i2 - 64);
              length = s2.length;
              tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
              for (i2 = 0; i2 < length; i2 += 1) {
                tail[i2 >> 2] |= s2.charCodeAt(i2) << (i2 % 4 << 3);
              }
              tail[i2 >> 2] |= 128 << (i2 % 4 << 3);
              if (i2 > 55) {
                md5cycle(state, tail);
                for (i2 = 0; i2 < 16; i2 += 1) {
                  tail[i2] = 0;
                }
              }
              tmp = n2 * 8;
              tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
              lo = parseInt(tmp[2], 16);
              hi = parseInt(tmp[1], 16) || 0;
              tail[14] = lo;
              tail[15] = hi;
              md5cycle(state, tail);
              return state;
            }
            function md51_array(a2) {
              var n2 = a2.length, state = [1732584193, -271733879, -1732584194, 271733878], i2, length, tail, tmp, lo, hi;
              for (i2 = 64; i2 <= n2; i2 += 64) {
                md5cycle(state, md5blk_array(a2.subarray(i2 - 64, i2)));
              }
              a2 = i2 - 64 < n2 ? a2.subarray(i2 - 64) : new Uint8Array(0);
              length = a2.length;
              tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
              for (i2 = 0; i2 < length; i2 += 1) {
                tail[i2 >> 2] |= a2[i2] << (i2 % 4 << 3);
              }
              tail[i2 >> 2] |= 128 << (i2 % 4 << 3);
              if (i2 > 55) {
                md5cycle(state, tail);
                for (i2 = 0; i2 < 16; i2 += 1) {
                  tail[i2] = 0;
                }
              }
              tmp = n2 * 8;
              tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
              lo = parseInt(tmp[2], 16);
              hi = parseInt(tmp[1], 16) || 0;
              tail[14] = lo;
              tail[15] = hi;
              md5cycle(state, tail);
              return state;
            }
            function rhex(n2) {
              var s2 = "", j2;
              for (j2 = 0; j2 < 4; j2 += 1) {
                s2 += hex_chr[n2 >> j2 * 8 + 4 & 15] + hex_chr[n2 >> j2 * 8 & 15];
              }
              return s2;
            }
            function hex(x2) {
              var i2;
              for (i2 = 0; i2 < x2.length; i2 += 1) {
                x2[i2] = rhex(x2[i2]);
              }
              return x2.join("");
            }
            if (hex(md51("hello")) !== "5d41402abc4b2a76b9719d911017c592")
              ;
            if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice) {
              (function() {
                function clamp(val, length) {
                  val = val | 0 || 0;
                  if (val < 0) {
                    return Math.max(val + length, 0);
                  }
                  return Math.min(val, length);
                }
                ArrayBuffer.prototype.slice = function(from, to) {
                  var length = this.byteLength, begin = clamp(from, length), end2 = length, num, target, targetArray, sourceArray;
                  if (to !== undefined2) {
                    end2 = clamp(to, length);
                  }
                  if (begin > end2) {
                    return new ArrayBuffer(0);
                  }
                  num = end2 - begin;
                  target = new ArrayBuffer(num);
                  targetArray = new Uint8Array(target);
                  sourceArray = new Uint8Array(this, begin, num);
                  targetArray.set(sourceArray);
                  return target;
                };
              })();
            }
            function toUtf8(str) {
              if (/[\u0080-\uFFFF]/.test(str)) {
                str = unescape(encodeURIComponent(str));
              }
              return str;
            }
            function utf8Str2ArrayBuffer(str, returnUInt8Array) {
              var length = str.length, buff = new ArrayBuffer(length), arr = new Uint8Array(buff), i2;
              for (i2 = 0; i2 < length; i2 += 1) {
                arr[i2] = str.charCodeAt(i2);
              }
              return returnUInt8Array ? arr : buff;
            }
            function arrayBuffer2Utf8Str(buff) {
              return String.fromCharCode.apply(null, new Uint8Array(buff));
            }
            function concatenateArrayBuffers(first, second, returnUInt8Array) {
              var result = new Uint8Array(first.byteLength + second.byteLength);
              result.set(new Uint8Array(first));
              result.set(new Uint8Array(second), first.byteLength);
              return returnUInt8Array ? result : result.buffer;
            }
            function hexToBinaryString(hex2) {
              var bytes = [], length = hex2.length, x2;
              for (x2 = 0; x2 < length - 1; x2 += 2) {
                bytes.push(parseInt(hex2.substr(x2, 2), 16));
              }
              return String.fromCharCode.apply(String, bytes);
            }
            function SparkMD5() {
              this.reset();
            }
            SparkMD5.prototype.append = function(str) {
              this.appendBinary(toUtf8(str));
              return this;
            };
            SparkMD5.prototype.appendBinary = function(contents) {
              this._buff += contents;
              this._length += contents.length;
              var length = this._buff.length, i2;
              for (i2 = 64; i2 <= length; i2 += 64) {
                md5cycle(this._hash, md5blk(this._buff.substring(i2 - 64, i2)));
              }
              this._buff = this._buff.substring(i2 - 64);
              return this;
            };
            SparkMD5.prototype.end = function(raw) {
              var buff = this._buff, length = buff.length, i2, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ret;
              for (i2 = 0; i2 < length; i2 += 1) {
                tail[i2 >> 2] |= buff.charCodeAt(i2) << (i2 % 4 << 3);
              }
              this._finish(tail, length);
              ret = hex(this._hash);
              if (raw) {
                ret = hexToBinaryString(ret);
              }
              this.reset();
              return ret;
            };
            SparkMD5.prototype.reset = function() {
              this._buff = "";
              this._length = 0;
              this._hash = [1732584193, -271733879, -1732584194, 271733878];
              return this;
            };
            SparkMD5.prototype.getState = function() {
              return {
                buff: this._buff,
                length: this._length,
                hash: this._hash
              };
            };
            SparkMD5.prototype.setState = function(state) {
              this._buff = state.buff;
              this._length = state.length;
              this._hash = state.hash;
              return this;
            };
            SparkMD5.prototype.destroy = function() {
              delete this._hash;
              delete this._buff;
              delete this._length;
            };
            SparkMD5.prototype._finish = function(tail, length) {
              var i2 = length, tmp, lo, hi;
              tail[i2 >> 2] |= 128 << (i2 % 4 << 3);
              if (i2 > 55) {
                md5cycle(this._hash, tail);
                for (i2 = 0; i2 < 16; i2 += 1) {
                  tail[i2] = 0;
                }
              }
              tmp = this._length * 8;
              tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
              lo = parseInt(tmp[2], 16);
              hi = parseInt(tmp[1], 16) || 0;
              tail[14] = lo;
              tail[15] = hi;
              md5cycle(this._hash, tail);
            };
            SparkMD5.hash = function(str, raw) {
              return SparkMD5.hashBinary(toUtf8(str), raw);
            };
            SparkMD5.hashBinary = function(content, raw) {
              var hash3 = md51(content), ret = hex(hash3);
              return raw ? hexToBinaryString(ret) : ret;
            };
            SparkMD5.ArrayBuffer = function() {
              this.reset();
            };
            SparkMD5.ArrayBuffer.prototype.append = function(arr) {
              var buff = concatenateArrayBuffers(this._buff.buffer, arr, true), length = buff.length, i2;
              this._length += arr.byteLength;
              for (i2 = 64; i2 <= length; i2 += 64) {
                md5cycle(this._hash, md5blk_array(buff.subarray(i2 - 64, i2)));
              }
              this._buff = i2 - 64 < length ? new Uint8Array(buff.buffer.slice(i2 - 64)) : new Uint8Array(0);
              return this;
            };
            SparkMD5.ArrayBuffer.prototype.end = function(raw) {
              var buff = this._buff, length = buff.length, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i2, ret;
              for (i2 = 0; i2 < length; i2 += 1) {
                tail[i2 >> 2] |= buff[i2] << (i2 % 4 << 3);
              }
              this._finish(tail, length);
              ret = hex(this._hash);
              if (raw) {
                ret = hexToBinaryString(ret);
              }
              this.reset();
              return ret;
            };
            SparkMD5.ArrayBuffer.prototype.reset = function() {
              this._buff = new Uint8Array(0);
              this._length = 0;
              this._hash = [1732584193, -271733879, -1732584194, 271733878];
              return this;
            };
            SparkMD5.ArrayBuffer.prototype.getState = function() {
              var state = SparkMD5.prototype.getState.call(this);
              state.buff = arrayBuffer2Utf8Str(state.buff);
              return state;
            };
            SparkMD5.ArrayBuffer.prototype.setState = function(state) {
              state.buff = utf8Str2ArrayBuffer(state.buff, true);
              return SparkMD5.prototype.setState.call(this, state);
            };
            SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;
            SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;
            SparkMD5.ArrayBuffer.hash = function(arr, raw) {
              var hash3 = md51_array(new Uint8Array(arr)), ret = hex(hash3);
              return raw ? hexToBinaryString(ret) : ret;
            };
            return SparkMD5;
          });
        });
        var classCallCheck = function(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        };
        var createClass = function() {
          function defineProperties(target, props) {
            for (var i2 = 0; i2 < props.length; i2++) {
              var descriptor = props[i2];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          return function(Constructor, protoProps, staticProps) {
            if (protoProps)
              defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
        var fileSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;
        var FileChecksum = function() {
          createClass(FileChecksum2, null, [{
            key: "create",
            value: function create(file, callback) {
              var instance = new FileChecksum2(file);
              instance.create(callback);
            }
          }]);
          function FileChecksum2(file) {
            classCallCheck(this, FileChecksum2);
            this.file = file;
            this.chunkSize = 2097152;
            this.chunkCount = Math.ceil(this.file.size / this.chunkSize);
            this.chunkIndex = 0;
          }
          createClass(FileChecksum2, [{
            key: "create",
            value: function create(callback) {
              var _this = this;
              this.callback = callback;
              this.md5Buffer = new sparkMd5.ArrayBuffer();
              this.fileReader = new FileReader();
              this.fileReader.addEventListener("load", function(event) {
                return _this.fileReaderDidLoad(event);
              });
              this.fileReader.addEventListener("error", function(event) {
                return _this.fileReaderDidError(event);
              });
              this.readNextChunk();
            }
          }, {
            key: "fileReaderDidLoad",
            value: function fileReaderDidLoad(event) {
              this.md5Buffer.append(event.target.result);
              if (!this.readNextChunk()) {
                var binaryDigest = this.md5Buffer.end(true);
                var base64digest = btoa(binaryDigest);
                this.callback(null, base64digest);
              }
            }
          }, {
            key: "fileReaderDidError",
            value: function fileReaderDidError(event) {
              this.callback("Error reading " + this.file.name);
            }
          }, {
            key: "readNextChunk",
            value: function readNextChunk() {
              if (this.chunkIndex < this.chunkCount || this.chunkIndex == 0 && this.chunkCount == 0) {
                var start5 = this.chunkIndex * this.chunkSize;
                var end2 = Math.min(start5 + this.chunkSize, this.file.size);
                var bytes = fileSlice.call(this.file, start5, end2);
                this.fileReader.readAsArrayBuffer(bytes);
                this.chunkIndex++;
                return true;
              } else {
                return false;
              }
            }
          }]);
          return FileChecksum2;
        }();
        function getMetaValue(name) {
          var element = findElement(document.head, 'meta[name="' + name + '"]');
          if (element) {
            return element.getAttribute("content");
          }
        }
        function findElements(root, selector) {
          if (typeof root == "string") {
            selector = root;
            root = document;
          }
          var elements = root.querySelectorAll(selector);
          return toArray$1(elements);
        }
        function findElement(root, selector) {
          if (typeof root == "string") {
            selector = root;
            root = document;
          }
          return root.querySelector(selector);
        }
        function dispatchEvent2(element, type) {
          var eventInit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var disabled = element.disabled;
          var bubbles = eventInit.bubbles, cancelable = eventInit.cancelable, detail = eventInit.detail;
          var event = document.createEvent("Event");
          event.initEvent(type, bubbles || true, cancelable || true);
          event.detail = detail || {};
          try {
            element.disabled = false;
            element.dispatchEvent(event);
          } finally {
            element.disabled = disabled;
          }
          return event;
        }
        function toArray$1(value) {
          if (Array.isArray(value)) {
            return value;
          } else if (Array.from) {
            return Array.from(value);
          } else {
            return [].slice.call(value);
          }
        }
        var BlobRecord = function() {
          function BlobRecord2(file, checksum, url) {
            var _this = this;
            classCallCheck(this, BlobRecord2);
            this.file = file;
            this.attributes = {
              filename: file.name,
              content_type: file.type || "application/octet-stream",
              byte_size: file.size,
              checksum
            };
            this.xhr = new XMLHttpRequest();
            this.xhr.open("POST", url, true);
            this.xhr.responseType = "json";
            this.xhr.setRequestHeader("Content-Type", "application/json");
            this.xhr.setRequestHeader("Accept", "application/json");
            this.xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
            var csrfToken = getMetaValue("csrf-token");
            if (csrfToken != void 0) {
              this.xhr.setRequestHeader("X-CSRF-Token", csrfToken);
            }
            this.xhr.addEventListener("load", function(event) {
              return _this.requestDidLoad(event);
            });
            this.xhr.addEventListener("error", function(event) {
              return _this.requestDidError(event);
            });
          }
          createClass(BlobRecord2, [{
            key: "create",
            value: function create(callback) {
              this.callback = callback;
              this.xhr.send(JSON.stringify({
                blob: this.attributes
              }));
            }
          }, {
            key: "requestDidLoad",
            value: function requestDidLoad(event) {
              if (this.status >= 200 && this.status < 300) {
                var response = this.response;
                var direct_upload = response.direct_upload;
                delete response.direct_upload;
                this.attributes = response;
                this.directUploadData = direct_upload;
                this.callback(null, this.toJSON());
              } else {
                this.requestDidError(event);
              }
            }
          }, {
            key: "requestDidError",
            value: function requestDidError(event) {
              this.callback('Error creating Blob for "' + this.file.name + '". Status: ' + this.status);
            }
          }, {
            key: "toJSON",
            value: function toJSON() {
              var result = {};
              for (var key in this.attributes) {
                result[key] = this.attributes[key];
              }
              return result;
            }
          }, {
            key: "status",
            get: function get$$1() {
              return this.xhr.status;
            }
          }, {
            key: "response",
            get: function get$$1() {
              var _xhr = this.xhr, responseType = _xhr.responseType, response = _xhr.response;
              if (responseType == "json") {
                return response;
              } else {
                return JSON.parse(response);
              }
            }
          }]);
          return BlobRecord2;
        }();
        var BlobUpload = function() {
          function BlobUpload2(blob) {
            var _this = this;
            classCallCheck(this, BlobUpload2);
            this.blob = blob;
            this.file = blob.file;
            var _blob$directUploadDat = blob.directUploadData, url = _blob$directUploadDat.url, headers = _blob$directUploadDat.headers;
            this.xhr = new XMLHttpRequest();
            this.xhr.open("PUT", url, true);
            this.xhr.responseType = "text";
            for (var key in headers) {
              this.xhr.setRequestHeader(key, headers[key]);
            }
            this.xhr.addEventListener("load", function(event) {
              return _this.requestDidLoad(event);
            });
            this.xhr.addEventListener("error", function(event) {
              return _this.requestDidError(event);
            });
          }
          createClass(BlobUpload2, [{
            key: "create",
            value: function create(callback) {
              this.callback = callback;
              this.xhr.send(this.file.slice());
            }
          }, {
            key: "requestDidLoad",
            value: function requestDidLoad(event) {
              var _xhr = this.xhr, status = _xhr.status, response = _xhr.response;
              if (status >= 200 && status < 300) {
                this.callback(null, response);
              } else {
                this.requestDidError(event);
              }
            }
          }, {
            key: "requestDidError",
            value: function requestDidError(event) {
              this.callback('Error storing "' + this.file.name + '". Status: ' + this.xhr.status);
            }
          }]);
          return BlobUpload2;
        }();
        var id = 0;
        var DirectUpload = function() {
          function DirectUpload2(file, url, delegate) {
            classCallCheck(this, DirectUpload2);
            this.id = ++id;
            this.file = file;
            this.url = url;
            this.delegate = delegate;
          }
          createClass(DirectUpload2, [{
            key: "create",
            value: function create(callback) {
              var _this = this;
              FileChecksum.create(this.file, function(error2, checksum) {
                if (error2) {
                  callback(error2);
                  return;
                }
                var blob = new BlobRecord(_this.file, checksum, _this.url);
                notify(_this.delegate, "directUploadWillCreateBlobWithXHR", blob.xhr);
                blob.create(function(error3) {
                  if (error3) {
                    callback(error3);
                  } else {
                    var upload = new BlobUpload(blob);
                    notify(_this.delegate, "directUploadWillStoreFileWithXHR", upload.xhr);
                    upload.create(function(error4) {
                      if (error4) {
                        callback(error4);
                      } else {
                        callback(null, blob.toJSON());
                      }
                    });
                  }
                });
              });
            }
          }]);
          return DirectUpload2;
        }();
        function notify(object, methodName) {
          if (object && typeof object[methodName] == "function") {
            for (var _len = arguments.length, messages = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              messages[_key - 2] = arguments[_key];
            }
            return object[methodName].apply(object, messages);
          }
        }
        var DirectUploadController = function() {
          function DirectUploadController2(input, file) {
            classCallCheck(this, DirectUploadController2);
            this.input = input;
            this.file = file;
            this.directUpload = new DirectUpload(this.file, this.url, this);
            this.dispatch("initialize");
          }
          createClass(DirectUploadController2, [{
            key: "start",
            value: function start5(callback) {
              var _this = this;
              var hiddenInput = document.createElement("input");
              hiddenInput.type = "hidden";
              hiddenInput.name = this.input.name;
              this.input.insertAdjacentElement("beforebegin", hiddenInput);
              this.dispatch("start");
              this.directUpload.create(function(error2, attributes) {
                if (error2) {
                  hiddenInput.parentNode.removeChild(hiddenInput);
                  _this.dispatchError(error2);
                } else {
                  hiddenInput.value = attributes.signed_id;
                }
                _this.dispatch("end");
                callback(error2);
              });
            }
          }, {
            key: "uploadRequestDidProgress",
            value: function uploadRequestDidProgress(event) {
              var progress = event.loaded / event.total * 100;
              if (progress) {
                this.dispatch("progress", {
                  progress
                });
              }
            }
          }, {
            key: "dispatch",
            value: function dispatch3(name) {
              var detail = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              detail.file = this.file;
              detail.id = this.directUpload.id;
              return dispatchEvent2(this.input, "direct-upload:" + name, {
                detail
              });
            }
          }, {
            key: "dispatchError",
            value: function dispatchError(error2) {
              var event = this.dispatch("error", {
                error: error2
              });
              if (!event.defaultPrevented) {
                alert(error2);
              }
            }
          }, {
            key: "directUploadWillCreateBlobWithXHR",
            value: function directUploadWillCreateBlobWithXHR(xhr) {
              this.dispatch("before-blob-request", {
                xhr
              });
            }
          }, {
            key: "directUploadWillStoreFileWithXHR",
            value: function directUploadWillStoreFileWithXHR(xhr) {
              var _this2 = this;
              this.dispatch("before-storage-request", {
                xhr
              });
              xhr.upload.addEventListener("progress", function(event) {
                return _this2.uploadRequestDidProgress(event);
              });
            }
          }, {
            key: "url",
            get: function get$$1() {
              return this.input.getAttribute("data-direct-upload-url");
            }
          }]);
          return DirectUploadController2;
        }();
        var inputSelector = "input[type=file][data-direct-upload-url]:not([disabled])";
        var DirectUploadsController = function() {
          function DirectUploadsController2(form) {
            classCallCheck(this, DirectUploadsController2);
            this.form = form;
            this.inputs = findElements(form, inputSelector).filter(function(input) {
              return input.files.length;
            });
          }
          createClass(DirectUploadsController2, [{
            key: "start",
            value: function start5(callback) {
              var _this = this;
              var controllers = this.createDirectUploadControllers();
              var startNextController = function startNextController2() {
                var controller = controllers.shift();
                if (controller) {
                  controller.start(function(error2) {
                    if (error2) {
                      callback(error2);
                      _this.dispatch("end");
                    } else {
                      startNextController2();
                    }
                  });
                } else {
                  callback();
                  _this.dispatch("end");
                }
              };
              this.dispatch("start");
              startNextController();
            }
          }, {
            key: "createDirectUploadControllers",
            value: function createDirectUploadControllers() {
              var controllers = [];
              this.inputs.forEach(function(input) {
                toArray$1(input.files).forEach(function(file) {
                  var controller = new DirectUploadController(input, file);
                  controllers.push(controller);
                });
              });
              return controllers;
            }
          }, {
            key: "dispatch",
            value: function dispatch3(name) {
              var detail = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              return dispatchEvent2(this.form, "direct-uploads:" + name, {
                detail
              });
            }
          }]);
          return DirectUploadsController2;
        }();
        var processingAttribute = "data-direct-uploads-processing";
        var submitButtonsByForm = /* @__PURE__ */ new WeakMap();
        var started = false;
        function start4() {
          if (!started) {
            started = true;
            document.addEventListener("click", didClick, true);
            document.addEventListener("submit", didSubmitForm);
            document.addEventListener("ajax:before", didSubmitRemoteElement);
          }
        }
        function didClick(event) {
          var target = event.target;
          if ((target.tagName == "INPUT" || target.tagName == "BUTTON") && target.type == "submit" && target.form) {
            submitButtonsByForm.set(target.form, target);
          }
        }
        function didSubmitForm(event) {
          handleFormSubmissionEvent(event);
        }
        function didSubmitRemoteElement(event) {
          if (event.target.tagName == "FORM") {
            handleFormSubmissionEvent(event);
          }
        }
        function handleFormSubmissionEvent(event) {
          var form = event.target;
          if (form.hasAttribute(processingAttribute)) {
            event.preventDefault();
            return;
          }
          var controller = new DirectUploadsController(form);
          var inputs = controller.inputs;
          if (inputs.length) {
            event.preventDefault();
            form.setAttribute(processingAttribute, "");
            inputs.forEach(disable);
            controller.start(function(error2) {
              form.removeAttribute(processingAttribute);
              if (error2) {
                inputs.forEach(enable);
              } else {
                submitForm(form);
              }
            });
          }
        }
        function submitForm(form) {
          var button = submitButtonsByForm.get(form) || findElement(form, "input[type=submit], button[type=submit]");
          if (button) {
            var _button = button, disabled = _button.disabled;
            button.disabled = false;
            button.focus();
            button.click();
            button.disabled = disabled;
          } else {
            button = document.createElement("input");
            button.type = "submit";
            button.style.display = "none";
            form.appendChild(button);
            button.click();
            form.removeChild(button);
          }
          submitButtonsByForm.delete(form);
        }
        function disable(input) {
          input.disabled = true;
        }
        function enable(input) {
          input.disabled = false;
        }
        function autostart() {
          if (window.ActiveStorage) {
            start4();
          }
        }
        setTimeout(autostart, 1);
        exports2.start = start4;
        exports2.DirectUpload = DirectUpload;
        Object.defineProperty(exports2, "__esModule", {
          value: true
        });
      });
    }
  });

  // node_modules/mousetrap/mousetrap.js
  var require_mousetrap = __commonJS({
    "node_modules/mousetrap/mousetrap.js"(exports, module) {
      (function(window2, document2, undefined2) {
        if (!window2) {
          return;
        }
        var _MAP = {
          8: "backspace",
          9: "tab",
          13: "enter",
          16: "shift",
          17: "ctrl",
          18: "alt",
          20: "capslock",
          27: "esc",
          32: "space",
          33: "pageup",
          34: "pagedown",
          35: "end",
          36: "home",
          37: "left",
          38: "up",
          39: "right",
          40: "down",
          45: "ins",
          46: "del",
          91: "meta",
          93: "meta",
          224: "meta"
        };
        var _KEYCODE_MAP = {
          106: "*",
          107: "+",
          109: "-",
          110: ".",
          111: "/",
          186: ";",
          187: "=",
          188: ",",
          189: "-",
          190: ".",
          191: "/",
          192: "`",
          219: "[",
          220: "\\",
          221: "]",
          222: "'"
        };
        var _SHIFT_MAP = {
          "~": "`",
          "!": "1",
          "@": "2",
          "#": "3",
          "$": "4",
          "%": "5",
          "^": "6",
          "&": "7",
          "*": "8",
          "(": "9",
          ")": "0",
          "_": "-",
          "+": "=",
          ":": ";",
          '"': "'",
          "<": ",",
          ">": ".",
          "?": "/",
          "|": "\\"
        };
        var _SPECIAL_ALIASES = {
          "option": "alt",
          "command": "meta",
          "return": "enter",
          "escape": "esc",
          "plus": "+",
          "mod": /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? "meta" : "ctrl"
        };
        var _REVERSE_MAP;
        for (var i2 = 1; i2 < 20; ++i2) {
          _MAP[111 + i2] = "f" + i2;
        }
        for (i2 = 0; i2 <= 9; ++i2) {
          _MAP[i2 + 96] = i2.toString();
        }
        function _addEvent(object, type, callback) {
          if (object.addEventListener) {
            object.addEventListener(type, callback, false);
            return;
          }
          object.attachEvent("on" + type, callback);
        }
        function _characterFromEvent(e2) {
          if (e2.type == "keypress") {
            var character = String.fromCharCode(e2.which);
            if (!e2.shiftKey) {
              character = character.toLowerCase();
            }
            return character;
          }
          if (_MAP[e2.which]) {
            return _MAP[e2.which];
          }
          if (_KEYCODE_MAP[e2.which]) {
            return _KEYCODE_MAP[e2.which];
          }
          return String.fromCharCode(e2.which).toLowerCase();
        }
        function _modifiersMatch(modifiers1, modifiers2) {
          return modifiers1.sort().join(",") === modifiers2.sort().join(",");
        }
        function _eventModifiers(e2) {
          var modifiers = [];
          if (e2.shiftKey) {
            modifiers.push("shift");
          }
          if (e2.altKey) {
            modifiers.push("alt");
          }
          if (e2.ctrlKey) {
            modifiers.push("ctrl");
          }
          if (e2.metaKey) {
            modifiers.push("meta");
          }
          return modifiers;
        }
        function _preventDefault(e2) {
          if (e2.preventDefault) {
            e2.preventDefault();
            return;
          }
          e2.returnValue = false;
        }
        function _stopPropagation(e2) {
          if (e2.stopPropagation) {
            e2.stopPropagation();
            return;
          }
          e2.cancelBubble = true;
        }
        function _isModifier(key) {
          return key == "shift" || key == "ctrl" || key == "alt" || key == "meta";
        }
        function _getReverseMap() {
          if (!_REVERSE_MAP) {
            _REVERSE_MAP = {};
            for (var key in _MAP) {
              if (key > 95 && key < 112) {
                continue;
              }
              if (_MAP.hasOwnProperty(key)) {
                _REVERSE_MAP[_MAP[key]] = key;
              }
            }
          }
          return _REVERSE_MAP;
        }
        function _pickBestAction(key, modifiers, action) {
          if (!action) {
            action = _getReverseMap()[key] ? "keydown" : "keypress";
          }
          if (action == "keypress" && modifiers.length) {
            action = "keydown";
          }
          return action;
        }
        function _keysFromString(combination) {
          if (combination === "+") {
            return ["+"];
          }
          combination = combination.replace(/\+{2}/g, "+plus");
          return combination.split("+");
        }
        function _getKeyInfo(combination, action) {
          var keys;
          var key;
          var i3;
          var modifiers = [];
          keys = _keysFromString(combination);
          for (i3 = 0; i3 < keys.length; ++i3) {
            key = keys[i3];
            if (_SPECIAL_ALIASES[key]) {
              key = _SPECIAL_ALIASES[key];
            }
            if (action && action != "keypress" && _SHIFT_MAP[key]) {
              key = _SHIFT_MAP[key];
              modifiers.push("shift");
            }
            if (_isModifier(key)) {
              modifiers.push(key);
            }
          }
          action = _pickBestAction(key, modifiers, action);
          return {
            key,
            modifiers,
            action
          };
        }
        function _belongsTo(element, ancestor) {
          if (element === null || element === document2) {
            return false;
          }
          if (element === ancestor) {
            return true;
          }
          return _belongsTo(element.parentNode, ancestor);
        }
        function Mousetrap3(targetElement) {
          var self2 = this;
          targetElement = targetElement || document2;
          if (!(self2 instanceof Mousetrap3)) {
            return new Mousetrap3(targetElement);
          }
          self2.target = targetElement;
          self2._callbacks = {};
          self2._directMap = {};
          var _sequenceLevels = {};
          var _resetTimer;
          var _ignoreNextKeyup = false;
          var _ignoreNextKeypress = false;
          var _nextExpectedAction = false;
          function _resetSequences(doNotReset) {
            doNotReset = doNotReset || {};
            var activeSequences = false, key;
            for (key in _sequenceLevels) {
              if (doNotReset[key]) {
                activeSequences = true;
                continue;
              }
              _sequenceLevels[key] = 0;
            }
            if (!activeSequences) {
              _nextExpectedAction = false;
            }
          }
          function _getMatches(character, modifiers, e2, sequenceName, combination, level) {
            var i3;
            var callback;
            var matches = [];
            var action = e2.type;
            if (!self2._callbacks[character]) {
              return [];
            }
            if (action == "keyup" && _isModifier(character)) {
              modifiers = [character];
            }
            for (i3 = 0; i3 < self2._callbacks[character].length; ++i3) {
              callback = self2._callbacks[character][i3];
              if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
                continue;
              }
              if (action != callback.action) {
                continue;
              }
              if (action == "keypress" && !e2.metaKey && !e2.ctrlKey || _modifiersMatch(modifiers, callback.modifiers)) {
                var deleteCombo = !sequenceName && callback.combo == combination;
                var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;
                if (deleteCombo || deleteSequence) {
                  self2._callbacks[character].splice(i3, 1);
                }
                matches.push(callback);
              }
            }
            return matches;
          }
          function _fireCallback(callback, e2, combo, sequence) {
            if (self2.stopCallback(e2, e2.target || e2.srcElement, combo, sequence)) {
              return;
            }
            if (callback(e2, combo) === false) {
              _preventDefault(e2);
              _stopPropagation(e2);
            }
          }
          self2._handleKey = function(character, modifiers, e2) {
            var callbacks = _getMatches(character, modifiers, e2);
            var i3;
            var doNotReset = {};
            var maxLevel = 0;
            var processedSequenceCallback = false;
            for (i3 = 0; i3 < callbacks.length; ++i3) {
              if (callbacks[i3].seq) {
                maxLevel = Math.max(maxLevel, callbacks[i3].level);
              }
            }
            for (i3 = 0; i3 < callbacks.length; ++i3) {
              if (callbacks[i3].seq) {
                if (callbacks[i3].level != maxLevel) {
                  continue;
                }
                processedSequenceCallback = true;
                doNotReset[callbacks[i3].seq] = 1;
                _fireCallback(callbacks[i3].callback, e2, callbacks[i3].combo, callbacks[i3].seq);
                continue;
              }
              if (!processedSequenceCallback) {
                _fireCallback(callbacks[i3].callback, e2, callbacks[i3].combo);
              }
            }
            var ignoreThisKeypress = e2.type == "keypress" && _ignoreNextKeypress;
            if (e2.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
              _resetSequences(doNotReset);
            }
            _ignoreNextKeypress = processedSequenceCallback && e2.type == "keydown";
          };
          function _handleKeyEvent(e2) {
            if (typeof e2.which !== "number") {
              e2.which = e2.keyCode;
            }
            var character = _characterFromEvent(e2);
            if (!character) {
              return;
            }
            if (e2.type == "keyup" && _ignoreNextKeyup === character) {
              _ignoreNextKeyup = false;
              return;
            }
            self2.handleKey(character, _eventModifiers(e2), e2);
          }
          function _resetSequenceTimer() {
            clearTimeout(_resetTimer);
            _resetTimer = setTimeout(_resetSequences, 1e3);
          }
          function _bindSequence(combo, keys, callback, action) {
            _sequenceLevels[combo] = 0;
            function _increaseSequence(nextAction) {
              return function() {
                _nextExpectedAction = nextAction;
                ++_sequenceLevels[combo];
                _resetSequenceTimer();
              };
            }
            function _callbackAndReset(e2) {
              _fireCallback(callback, e2, combo);
              if (action !== "keyup") {
                _ignoreNextKeyup = _characterFromEvent(e2);
              }
              setTimeout(_resetSequences, 10);
            }
            for (var i3 = 0; i3 < keys.length; ++i3) {
              var isFinal = i3 + 1 === keys.length;
              var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i3 + 1]).action);
              _bindSingle(keys[i3], wrappedCallback, action, combo, i3);
            }
          }
          function _bindSingle(combination, callback, action, sequenceName, level) {
            self2._directMap[combination + ":" + action] = callback;
            combination = combination.replace(/\s+/g, " ");
            var sequence = combination.split(" ");
            var info;
            if (sequence.length > 1) {
              _bindSequence(combination, sequence, callback, action);
              return;
            }
            info = _getKeyInfo(combination, action);
            self2._callbacks[info.key] = self2._callbacks[info.key] || [];
            _getMatches(info.key, info.modifiers, { type: info.action }, sequenceName, combination, level);
            self2._callbacks[info.key][sequenceName ? "unshift" : "push"]({
              callback,
              modifiers: info.modifiers,
              action: info.action,
              seq: sequenceName,
              level,
              combo: combination
            });
          }
          self2._bindMultiple = function(combinations, callback, action) {
            for (var i3 = 0; i3 < combinations.length; ++i3) {
              _bindSingle(combinations[i3], callback, action);
            }
          };
          _addEvent(targetElement, "keypress", _handleKeyEvent);
          _addEvent(targetElement, "keydown", _handleKeyEvent);
          _addEvent(targetElement, "keyup", _handleKeyEvent);
        }
        Mousetrap3.prototype.bind = function(keys, callback, action) {
          var self2 = this;
          keys = keys instanceof Array ? keys : [keys];
          self2._bindMultiple.call(self2, keys, callback, action);
          return self2;
        };
        Mousetrap3.prototype.unbind = function(keys, action) {
          var self2 = this;
          return self2.bind.call(self2, keys, function() {
          }, action);
        };
        Mousetrap3.prototype.trigger = function(keys, action) {
          var self2 = this;
          if (self2._directMap[keys + ":" + action]) {
            self2._directMap[keys + ":" + action]({}, keys);
          }
          return self2;
        };
        Mousetrap3.prototype.reset = function() {
          var self2 = this;
          self2._callbacks = {};
          self2._directMap = {};
          return self2;
        };
        Mousetrap3.prototype.stopCallback = function(e2, element) {
          var self2 = this;
          if ((" " + element.className + " ").indexOf(" mousetrap ") > -1) {
            return false;
          }
          if (_belongsTo(element, self2.target)) {
            return false;
          }
          if ("composedPath" in e2 && typeof e2.composedPath === "function") {
            var initialEventTarget = e2.composedPath()[0];
            if (initialEventTarget !== e2.target) {
              element = initialEventTarget;
            }
          }
          return element.tagName == "INPUT" || element.tagName == "SELECT" || element.tagName == "TEXTAREA" || element.isContentEditable;
        };
        Mousetrap3.prototype.handleKey = function() {
          var self2 = this;
          return self2._handleKey.apply(self2, arguments);
        };
        Mousetrap3.addKeycodes = function(object) {
          for (var key in object) {
            if (object.hasOwnProperty(key)) {
              _MAP[key] = object[key];
            }
          }
          _REVERSE_MAP = null;
        };
        Mousetrap3.init = function() {
          var documentMousetrap = Mousetrap3(document2);
          for (var method in documentMousetrap) {
            if (method.charAt(0) !== "_") {
              Mousetrap3[method] = function(method2) {
                return function() {
                  return documentMousetrap[method2].apply(documentMousetrap, arguments);
                };
              }(method);
            }
          }
        };
        Mousetrap3.init();
        window2.Mousetrap = Mousetrap3;
        if (typeof module !== "undefined" && module.exports) {
          module.exports = Mousetrap3;
        }
        if (typeof define === "function" && define.amd) {
          define(function() {
            return Mousetrap3;
          });
        }
      })(typeof window !== "undefined" ? window : null, typeof window !== "undefined" ? document : null);
    }
  });

  // node_modules/@rails/actioncable/src/adapters.js
  var adapters_default;
  var init_adapters = __esm({
    "node_modules/@rails/actioncable/src/adapters.js"() {
      adapters_default = {
        logger: self.console,
        WebSocket: self.WebSocket
      };
    }
  });

  // node_modules/@rails/actioncable/src/logger.js
  var logger_default;
  var init_logger = __esm({
    "node_modules/@rails/actioncable/src/logger.js"() {
      init_adapters();
      logger_default = {
        log(...messages) {
          if (this.enabled) {
            messages.push(Date.now());
            adapters_default.logger.log("[ActionCable]", ...messages);
          }
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/connection_monitor.js
  var now, secondsSince, ConnectionMonitor, connection_monitor_default;
  var init_connection_monitor = __esm({
    "node_modules/@rails/actioncable/src/connection_monitor.js"() {
      init_logger();
      now = () => new Date().getTime();
      secondsSince = (time) => (now() - time) / 1e3;
      ConnectionMonitor = class {
        constructor(connection) {
          this.visibilityDidChange = this.visibilityDidChange.bind(this);
          this.connection = connection;
          this.reconnectAttempts = 0;
        }
        start() {
          if (!this.isRunning()) {
            this.startedAt = now();
            delete this.stoppedAt;
            this.startPolling();
            addEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);
          }
        }
        stop() {
          if (this.isRunning()) {
            this.stoppedAt = now();
            this.stopPolling();
            removeEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log("ConnectionMonitor stopped");
          }
        }
        isRunning() {
          return this.startedAt && !this.stoppedAt;
        }
        recordPing() {
          this.pingedAt = now();
        }
        recordConnect() {
          this.reconnectAttempts = 0;
          this.recordPing();
          delete this.disconnectedAt;
          logger_default.log("ConnectionMonitor recorded connect");
        }
        recordDisconnect() {
          this.disconnectedAt = now();
          logger_default.log("ConnectionMonitor recorded disconnect");
        }
        startPolling() {
          this.stopPolling();
          this.poll();
        }
        stopPolling() {
          clearTimeout(this.pollTimeout);
        }
        poll() {
          this.pollTimeout = setTimeout(() => {
            this.reconnectIfStale();
            this.poll();
          }, this.getPollInterval());
        }
        getPollInterval() {
          const { staleThreshold, reconnectionBackoffRate } = this.constructor;
          const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));
          const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;
          const jitter = jitterMax * Math.random();
          return staleThreshold * 1e3 * backoff * (1 + jitter);
        }
        reconnectIfStale() {
          if (this.connectionIsStale()) {
            logger_default.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);
            this.reconnectAttempts++;
            if (this.disconnectedRecently()) {
              logger_default.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);
            } else {
              logger_default.log("ConnectionMonitor reopening");
              this.connection.reopen();
            }
          }
        }
        get refreshedAt() {
          return this.pingedAt ? this.pingedAt : this.startedAt;
        }
        connectionIsStale() {
          return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;
        }
        disconnectedRecently() {
          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;
        }
        visibilityDidChange() {
          if (document.visibilityState === "visible") {
            setTimeout(() => {
              if (this.connectionIsStale() || !this.connection.isOpen()) {
                logger_default.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);
                this.connection.reopen();
              }
            }, 200);
          }
        }
      };
      ConnectionMonitor.staleThreshold = 6;
      ConnectionMonitor.reconnectionBackoffRate = 0.15;
      connection_monitor_default = ConnectionMonitor;
    }
  });

  // node_modules/@rails/actioncable/src/internal.js
  var internal_default;
  var init_internal = __esm({
    "node_modules/@rails/actioncable/src/internal.js"() {
      internal_default = {
        "message_types": {
          "welcome": "welcome",
          "disconnect": "disconnect",
          "ping": "ping",
          "confirmation": "confirm_subscription",
          "rejection": "reject_subscription"
        },
        "disconnect_reasons": {
          "unauthorized": "unauthorized",
          "invalid_request": "invalid_request",
          "server_restart": "server_restart"
        },
        "default_mount_path": "/cable",
        "protocols": [
          "actioncable-v1-json",
          "actioncable-unsupported"
        ]
      };
    }
  });

  // node_modules/@rails/actioncable/src/connection.js
  var message_types, protocols, supportedProtocols, indexOf, Connection, connection_default;
  var init_connection = __esm({
    "node_modules/@rails/actioncable/src/connection.js"() {
      init_adapters();
      init_connection_monitor();
      init_internal();
      init_logger();
      ({ message_types, protocols } = internal_default);
      supportedProtocols = protocols.slice(0, protocols.length - 1);
      indexOf = [].indexOf;
      Connection = class {
        constructor(consumer2) {
          this.open = this.open.bind(this);
          this.consumer = consumer2;
          this.subscriptions = this.consumer.subscriptions;
          this.monitor = new connection_monitor_default(this);
          this.disconnected = true;
        }
        send(data) {
          if (this.isOpen()) {
            this.webSocket.send(JSON.stringify(data));
            return true;
          } else {
            return false;
          }
        }
        open() {
          if (this.isActive()) {
            logger_default.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);
            return false;
          } else {
            logger_default.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${protocols}`);
            if (this.webSocket) {
              this.uninstallEventHandlers();
            }
            this.webSocket = new adapters_default.WebSocket(this.consumer.url, protocols);
            this.installEventHandlers();
            this.monitor.start();
            return true;
          }
        }
        close({ allowReconnect } = { allowReconnect: true }) {
          if (!allowReconnect) {
            this.monitor.stop();
          }
          if (this.isActive()) {
            return this.webSocket.close();
          }
        }
        reopen() {
          logger_default.log(`Reopening WebSocket, current state is ${this.getState()}`);
          if (this.isActive()) {
            try {
              return this.close();
            } catch (error2) {
              logger_default.log("Failed to reopen WebSocket", error2);
            } finally {
              logger_default.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);
              setTimeout(this.open, this.constructor.reopenDelay);
            }
          } else {
            return this.open();
          }
        }
        getProtocol() {
          if (this.webSocket) {
            return this.webSocket.protocol;
          }
        }
        isOpen() {
          return this.isState("open");
        }
        isActive() {
          return this.isState("open", "connecting");
        }
        isProtocolSupported() {
          return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;
        }
        isState(...states) {
          return indexOf.call(states, this.getState()) >= 0;
        }
        getState() {
          if (this.webSocket) {
            for (let state in adapters_default.WebSocket) {
              if (adapters_default.WebSocket[state] === this.webSocket.readyState) {
                return state.toLowerCase();
              }
            }
          }
          return null;
        }
        installEventHandlers() {
          for (let eventName in this.events) {
            const handler = this.events[eventName].bind(this);
            this.webSocket[`on${eventName}`] = handler;
          }
        }
        uninstallEventHandlers() {
          for (let eventName in this.events) {
            this.webSocket[`on${eventName}`] = function() {
            };
          }
        }
      };
      Connection.reopenDelay = 500;
      Connection.prototype.events = {
        message(event) {
          if (!this.isProtocolSupported()) {
            return;
          }
          const { identifier, message, reason, reconnect, type } = JSON.parse(event.data);
          switch (type) {
            case message_types.welcome:
              this.monitor.recordConnect();
              return this.subscriptions.reload();
            case message_types.disconnect:
              logger_default.log(`Disconnecting. Reason: ${reason}`);
              return this.close({ allowReconnect: reconnect });
            case message_types.ping:
              return this.monitor.recordPing();
            case message_types.confirmation:
              this.subscriptions.confirmSubscription(identifier);
              return this.subscriptions.notify(identifier, "connected");
            case message_types.rejection:
              return this.subscriptions.reject(identifier);
            default:
              return this.subscriptions.notify(identifier, "received", message);
          }
        },
        open() {
          logger_default.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);
          this.disconnected = false;
          if (!this.isProtocolSupported()) {
            logger_default.log("Protocol is unsupported. Stopping monitor and disconnecting.");
            return this.close({ allowReconnect: false });
          }
        },
        close(event) {
          logger_default.log("WebSocket onclose event");
          if (this.disconnected) {
            return;
          }
          this.disconnected = true;
          this.monitor.recordDisconnect();
          return this.subscriptions.notifyAll("disconnected", { willAttemptReconnect: this.monitor.isRunning() });
        },
        error() {
          logger_default.log("WebSocket onerror event");
        }
      };
      connection_default = Connection;
    }
  });

  // node_modules/@rails/actioncable/src/subscription.js
  var extend, Subscription;
  var init_subscription = __esm({
    "node_modules/@rails/actioncable/src/subscription.js"() {
      extend = function(object, properties) {
        if (properties != null) {
          for (let key in properties) {
            const value = properties[key];
            object[key] = value;
          }
        }
        return object;
      };
      Subscription = class {
        constructor(consumer2, params = {}, mixin) {
          this.consumer = consumer2;
          this.identifier = JSON.stringify(params);
          extend(this, mixin);
        }
        perform(action, data = {}) {
          data.action = action;
          return this.send(data);
        }
        send(data) {
          return this.consumer.send({ command: "message", identifier: this.identifier, data: JSON.stringify(data) });
        }
        unsubscribe() {
          return this.consumer.subscriptions.remove(this);
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/subscription_guarantor.js
  var SubscriptionGuarantor, subscription_guarantor_default;
  var init_subscription_guarantor = __esm({
    "node_modules/@rails/actioncable/src/subscription_guarantor.js"() {
      init_logger();
      SubscriptionGuarantor = class {
        constructor(subscriptions) {
          this.subscriptions = subscriptions;
          this.pendingSubscriptions = [];
        }
        guarantee(subscription) {
          if (this.pendingSubscriptions.indexOf(subscription) == -1) {
            logger_default.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);
            this.pendingSubscriptions.push(subscription);
          } else {
            logger_default.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);
          }
          this.startGuaranteeing();
        }
        forget(subscription) {
          logger_default.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);
          this.pendingSubscriptions = this.pendingSubscriptions.filter((s2) => s2 !== subscription);
        }
        startGuaranteeing() {
          this.stopGuaranteeing();
          this.retrySubscribing();
        }
        stopGuaranteeing() {
          clearTimeout(this.retryTimeout);
        }
        retrySubscribing() {
          this.retryTimeout = setTimeout(() => {
            if (this.subscriptions && typeof this.subscriptions.subscribe === "function") {
              this.pendingSubscriptions.map((subscription) => {
                logger_default.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);
                this.subscriptions.subscribe(subscription);
              });
            }
          }, 500);
        }
      };
      subscription_guarantor_default = SubscriptionGuarantor;
    }
  });

  // node_modules/@rails/actioncable/src/subscriptions.js
  var Subscriptions;
  var init_subscriptions = __esm({
    "node_modules/@rails/actioncable/src/subscriptions.js"() {
      init_subscription();
      init_subscription_guarantor();
      init_logger();
      Subscriptions = class {
        constructor(consumer2) {
          this.consumer = consumer2;
          this.guarantor = new subscription_guarantor_default(this);
          this.subscriptions = [];
        }
        create(channelName, mixin) {
          const channel = channelName;
          const params = typeof channel === "object" ? channel : { channel };
          const subscription = new Subscription(this.consumer, params, mixin);
          return this.add(subscription);
        }
        add(subscription) {
          this.subscriptions.push(subscription);
          this.consumer.ensureActiveConnection();
          this.notify(subscription, "initialized");
          this.subscribe(subscription);
          return subscription;
        }
        remove(subscription) {
          this.forget(subscription);
          if (!this.findAll(subscription.identifier).length) {
            this.sendCommand(subscription, "unsubscribe");
          }
          return subscription;
        }
        reject(identifier) {
          return this.findAll(identifier).map((subscription) => {
            this.forget(subscription);
            this.notify(subscription, "rejected");
            return subscription;
          });
        }
        forget(subscription) {
          this.guarantor.forget(subscription);
          this.subscriptions = this.subscriptions.filter((s2) => s2 !== subscription);
          return subscription;
        }
        findAll(identifier) {
          return this.subscriptions.filter((s2) => s2.identifier === identifier);
        }
        reload() {
          return this.subscriptions.map((subscription) => this.subscribe(subscription));
        }
        notifyAll(callbackName, ...args) {
          return this.subscriptions.map((subscription) => this.notify(subscription, callbackName, ...args));
        }
        notify(subscription, callbackName, ...args) {
          let subscriptions;
          if (typeof subscription === "string") {
            subscriptions = this.findAll(subscription);
          } else {
            subscriptions = [subscription];
          }
          return subscriptions.map((subscription2) => typeof subscription2[callbackName] === "function" ? subscription2[callbackName](...args) : void 0);
        }
        subscribe(subscription) {
          if (this.sendCommand(subscription, "subscribe")) {
            this.guarantor.guarantee(subscription);
          }
        }
        confirmSubscription(identifier) {
          logger_default.log(`Subscription confirmed ${identifier}`);
          this.findAll(identifier).map((subscription) => this.guarantor.forget(subscription));
        }
        sendCommand(subscription, command) {
          const { identifier } = subscription;
          return this.consumer.send({ command, identifier });
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/consumer.js
  function createWebSocketURL(url) {
    if (typeof url === "function") {
      url = url();
    }
    if (url && !/^wss?:/i.test(url)) {
      const a2 = document.createElement("a");
      a2.href = url;
      a2.href = a2.href;
      a2.protocol = a2.protocol.replace("http", "ws");
      return a2.href;
    } else {
      return url;
    }
  }
  var Consumer;
  var init_consumer = __esm({
    "node_modules/@rails/actioncable/src/consumer.js"() {
      init_connection();
      init_subscriptions();
      Consumer = class {
        constructor(url) {
          this._url = url;
          this.subscriptions = new Subscriptions(this);
          this.connection = new connection_default(this);
        }
        get url() {
          return createWebSocketURL(this._url);
        }
        send(data) {
          return this.connection.send(data);
        }
        connect() {
          return this.connection.open();
        }
        disconnect() {
          return this.connection.close({ allowReconnect: false });
        }
        ensureActiveConnection() {
          if (!this.connection.isActive()) {
            return this.connection.open();
          }
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/index.js
  var src_exports = {};
  __export(src_exports, {
    Connection: () => connection_default,
    ConnectionMonitor: () => connection_monitor_default,
    Consumer: () => Consumer,
    INTERNAL: () => internal_default,
    Subscription: () => Subscription,
    SubscriptionGuarantor: () => subscription_guarantor_default,
    Subscriptions: () => Subscriptions,
    adapters: () => adapters_default,
    createConsumer: () => createConsumer,
    createWebSocketURL: () => createWebSocketURL,
    getConfig: () => getConfig,
    logger: () => logger_default
  });
  function createConsumer(url = getConfig("url") || internal_default.default_mount_path) {
    return new Consumer(url);
  }
  function getConfig(name) {
    const element = document.head.querySelector(`meta[name='action-cable-${name}']`);
    if (element) {
      return element.getAttribute("content");
    }
  }
  var init_src = __esm({
    "node_modules/@rails/actioncable/src/index.js"() {
      init_connection();
      init_connection_monitor();
      init_consumer();
      init_internal();
      init_subscription();
      init_subscriptions();
      init_subscription_guarantor();
      init_adapters();
      init_logger();
    }
  });

  // node_modules/@rails/ujs/lib/assets/compiled/rails-ujs.js
  var require_rails_ujs = __commonJS({
    "node_modules/@rails/ujs/lib/assets/compiled/rails-ujs.js"(exports, module) {
      (function() {
        var context = this;
        (function() {
          (function() {
            this.Rails = {
              linkClickSelector: "a[data-confirm], a[data-method], a[data-remote]:not([disabled]), a[data-disable-with], a[data-disable]",
              buttonClickSelector: {
                selector: "button[data-remote]:not([form]), button[data-confirm]:not([form])",
                exclude: "form button"
              },
              inputChangeSelector: "select[data-remote], input[data-remote], textarea[data-remote]",
              formSubmitSelector: "form",
              formInputClickSelector: "form input[type=submit], form input[type=image], form button[type=submit], form button:not([type]), input[type=submit][form], input[type=image][form], button[type=submit][form], button[form]:not([type])",
              formDisableSelector: "input[data-disable-with]:enabled, button[data-disable-with]:enabled, textarea[data-disable-with]:enabled, input[data-disable]:enabled, button[data-disable]:enabled, textarea[data-disable]:enabled",
              formEnableSelector: "input[data-disable-with]:disabled, button[data-disable-with]:disabled, textarea[data-disable-with]:disabled, input[data-disable]:disabled, button[data-disable]:disabled, textarea[data-disable]:disabled",
              fileInputSelector: "input[name][type=file]:not([disabled])",
              linkDisableSelector: "a[data-disable-with], a[data-disable]",
              buttonDisableSelector: "button[data-remote][data-disable-with], button[data-remote][data-disable]"
            };
          }).call(this);
        }).call(context);
        var Rails2 = context.Rails;
        (function() {
          (function() {
            var nonce;
            nonce = null;
            Rails2.loadCSPNonce = function() {
              var ref;
              return nonce = (ref = document.querySelector("meta[name=csp-nonce]")) != null ? ref.content : void 0;
            };
            Rails2.cspNonce = function() {
              return nonce != null ? nonce : Rails2.loadCSPNonce();
            };
          }).call(this);
          (function() {
            var expando, m2;
            m2 = Element.prototype.matches || Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector;
            Rails2.matches = function(element, selector) {
              if (selector.exclude != null) {
                return m2.call(element, selector.selector) && !m2.call(element, selector.exclude);
              } else {
                return m2.call(element, selector);
              }
            };
            expando = "_ujsData";
            Rails2.getData = function(element, key) {
              var ref;
              return (ref = element[expando]) != null ? ref[key] : void 0;
            };
            Rails2.setData = function(element, key, value) {
              if (element[expando] == null) {
                element[expando] = {};
              }
              return element[expando][key] = value;
            };
            Rails2.$ = function(selector) {
              return Array.prototype.slice.call(document.querySelectorAll(selector));
            };
          }).call(this);
          (function() {
            var $2, csrfParam, csrfToken;
            $2 = Rails2.$;
            csrfToken = Rails2.csrfToken = function() {
              var meta;
              meta = document.querySelector("meta[name=csrf-token]");
              return meta && meta.content;
            };
            csrfParam = Rails2.csrfParam = function() {
              var meta;
              meta = document.querySelector("meta[name=csrf-param]");
              return meta && meta.content;
            };
            Rails2.CSRFProtection = function(xhr) {
              var token;
              token = csrfToken();
              if (token != null) {
                return xhr.setRequestHeader("X-CSRF-Token", token);
              }
            };
            Rails2.refreshCSRFTokens = function() {
              var param, token;
              token = csrfToken();
              param = csrfParam();
              if (token != null && param != null) {
                return $2('form input[name="' + param + '"]').forEach(function(input) {
                  return input.value = token;
                });
              }
            };
          }).call(this);
          (function() {
            var CustomEvent2, fire, matches, preventDefault;
            matches = Rails2.matches;
            CustomEvent2 = window.CustomEvent;
            if (typeof CustomEvent2 !== "function") {
              CustomEvent2 = function(event, params) {
                var evt;
                evt = document.createEvent("CustomEvent");
                evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
                return evt;
              };
              CustomEvent2.prototype = window.Event.prototype;
              preventDefault = CustomEvent2.prototype.preventDefault;
              CustomEvent2.prototype.preventDefault = function() {
                var result;
                result = preventDefault.call(this);
                if (this.cancelable && !this.defaultPrevented) {
                  Object.defineProperty(this, "defaultPrevented", {
                    get: function() {
                      return true;
                    }
                  });
                }
                return result;
              };
            }
            fire = Rails2.fire = function(obj, name, data) {
              var event;
              event = new CustomEvent2(name, {
                bubbles: true,
                cancelable: true,
                detail: data
              });
              obj.dispatchEvent(event);
              return !event.defaultPrevented;
            };
            Rails2.stopEverything = function(e2) {
              fire(e2.target, "ujs:everythingStopped");
              e2.preventDefault();
              e2.stopPropagation();
              return e2.stopImmediatePropagation();
            };
            Rails2.delegate = function(element, selector, eventType, handler) {
              return element.addEventListener(eventType, function(e2) {
                var target;
                target = e2.target;
                while (!(!(target instanceof Element) || matches(target, selector))) {
                  target = target.parentNode;
                }
                if (target instanceof Element && handler.call(target, e2) === false) {
                  e2.preventDefault();
                  return e2.stopPropagation();
                }
              });
            };
          }).call(this);
          (function() {
            var AcceptHeaders, CSRFProtection, createXHR, cspNonce, fire, prepareOptions, processResponse;
            cspNonce = Rails2.cspNonce, CSRFProtection = Rails2.CSRFProtection, fire = Rails2.fire;
            AcceptHeaders = {
              "*": "*/*",
              text: "text/plain",
              html: "text/html",
              xml: "application/xml, text/xml",
              json: "application/json, text/javascript",
              script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
            };
            Rails2.ajax = function(options) {
              var xhr;
              options = prepareOptions(options);
              xhr = createXHR(options, function() {
                var ref, response;
                response = processResponse((ref = xhr.response) != null ? ref : xhr.responseText, xhr.getResponseHeader("Content-Type"));
                if (Math.floor(xhr.status / 100) === 2) {
                  if (typeof options.success === "function") {
                    options.success(response, xhr.statusText, xhr);
                  }
                } else {
                  if (typeof options.error === "function") {
                    options.error(response, xhr.statusText, xhr);
                  }
                }
                return typeof options.complete === "function" ? options.complete(xhr, xhr.statusText) : void 0;
              });
              if (options.beforeSend != null && !options.beforeSend(xhr, options)) {
                return false;
              }
              if (xhr.readyState === XMLHttpRequest.OPENED) {
                return xhr.send(options.data);
              }
            };
            prepareOptions = function(options) {
              options.url = options.url || location.href;
              options.type = options.type.toUpperCase();
              if (options.type === "GET" && options.data) {
                if (options.url.indexOf("?") < 0) {
                  options.url += "?" + options.data;
                } else {
                  options.url += "&" + options.data;
                }
              }
              if (AcceptHeaders[options.dataType] == null) {
                options.dataType = "*";
              }
              options.accept = AcceptHeaders[options.dataType];
              if (options.dataType !== "*") {
                options.accept += ", */*; q=0.01";
              }
              return options;
            };
            createXHR = function(options, done) {
              var xhr;
              xhr = new XMLHttpRequest();
              xhr.open(options.type, options.url, true);
              xhr.setRequestHeader("Accept", options.accept);
              if (typeof options.data === "string") {
                xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
              }
              if (!options.crossDomain) {
                xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
                CSRFProtection(xhr);
              }
              xhr.withCredentials = !!options.withCredentials;
              xhr.onreadystatechange = function() {
                if (xhr.readyState === XMLHttpRequest.DONE) {
                  return done(xhr);
                }
              };
              return xhr;
            };
            processResponse = function(response, type) {
              var parser, script;
              if (typeof response === "string" && typeof type === "string") {
                if (type.match(/\bjson\b/)) {
                  try {
                    response = JSON.parse(response);
                  } catch (error2) {
                  }
                } else if (type.match(/\b(?:java|ecma)script\b/)) {
                  script = document.createElement("script");
                  script.setAttribute("nonce", cspNonce());
                  script.text = response;
                  document.head.appendChild(script).parentNode.removeChild(script);
                } else if (type.match(/\b(xml|html|svg)\b/)) {
                  parser = new DOMParser();
                  type = type.replace(/;.+/, "");
                  try {
                    response = parser.parseFromString(response, type);
                  } catch (error2) {
                  }
                }
              }
              return response;
            };
            Rails2.href = function(element) {
              return element.href;
            };
            Rails2.isCrossDomain = function(url) {
              var e2, originAnchor, urlAnchor;
              originAnchor = document.createElement("a");
              originAnchor.href = location.href;
              urlAnchor = document.createElement("a");
              try {
                urlAnchor.href = url;
                return !((!urlAnchor.protocol || urlAnchor.protocol === ":") && !urlAnchor.host || originAnchor.protocol + "//" + originAnchor.host === urlAnchor.protocol + "//" + urlAnchor.host);
              } catch (error2) {
                e2 = error2;
                return true;
              }
            };
          }).call(this);
          (function() {
            var matches, toArray;
            matches = Rails2.matches;
            toArray = function(e2) {
              return Array.prototype.slice.call(e2);
            };
            Rails2.serializeElement = function(element, additionalParam) {
              var inputs, params;
              inputs = [element];
              if (matches(element, "form")) {
                inputs = toArray(element.elements);
              }
              params = [];
              inputs.forEach(function(input) {
                if (!input.name || input.disabled) {
                  return;
                }
                if (matches(input, "fieldset[disabled] *")) {
                  return;
                }
                if (matches(input, "select")) {
                  return toArray(input.options).forEach(function(option) {
                    if (option.selected) {
                      return params.push({
                        name: input.name,
                        value: option.value
                      });
                    }
                  });
                } else if (input.checked || ["radio", "checkbox", "submit"].indexOf(input.type) === -1) {
                  return params.push({
                    name: input.name,
                    value: input.value
                  });
                }
              });
              if (additionalParam) {
                params.push(additionalParam);
              }
              return params.map(function(param) {
                if (param.name != null) {
                  return encodeURIComponent(param.name) + "=" + encodeURIComponent(param.value);
                } else {
                  return param;
                }
              }).join("&");
            };
            Rails2.formElements = function(form, selector) {
              if (matches(form, "form")) {
                return toArray(form.elements).filter(function(el) {
                  return matches(el, selector);
                });
              } else {
                return toArray(form.querySelectorAll(selector));
              }
            };
          }).call(this);
          (function() {
            var allowAction, fire, stopEverything;
            fire = Rails2.fire, stopEverything = Rails2.stopEverything;
            Rails2.handleConfirm = function(e2) {
              if (!allowAction(this)) {
                return stopEverything(e2);
              }
            };
            Rails2.confirm = function(message, element) {
              return confirm(message);
            };
            allowAction = function(element) {
              var answer, callback, message;
              message = element.getAttribute("data-confirm");
              if (!message) {
                return true;
              }
              answer = false;
              if (fire(element, "confirm")) {
                try {
                  answer = Rails2.confirm(message, element);
                } catch (error2) {
                }
                callback = fire(element, "confirm:complete", [answer]);
              }
              return answer && callback;
            };
          }).call(this);
          (function() {
            var disableFormElement, disableFormElements, disableLinkElement, enableFormElement, enableFormElements, enableLinkElement, formElements, getData, isXhrRedirect, matches, setData, stopEverything;
            matches = Rails2.matches, getData = Rails2.getData, setData = Rails2.setData, stopEverything = Rails2.stopEverything, formElements = Rails2.formElements;
            Rails2.handleDisabledElement = function(e2) {
              var element;
              element = this;
              if (element.disabled) {
                return stopEverything(e2);
              }
            };
            Rails2.enableElement = function(e2) {
              var element;
              if (e2 instanceof Event) {
                if (isXhrRedirect(e2)) {
                  return;
                }
                element = e2.target;
              } else {
                element = e2;
              }
              if (matches(element, Rails2.linkDisableSelector)) {
                return enableLinkElement(element);
              } else if (matches(element, Rails2.buttonDisableSelector) || matches(element, Rails2.formEnableSelector)) {
                return enableFormElement(element);
              } else if (matches(element, Rails2.formSubmitSelector)) {
                return enableFormElements(element);
              }
            };
            Rails2.disableElement = function(e2) {
              var element;
              element = e2 instanceof Event ? e2.target : e2;
              if (matches(element, Rails2.linkDisableSelector)) {
                return disableLinkElement(element);
              } else if (matches(element, Rails2.buttonDisableSelector) || matches(element, Rails2.formDisableSelector)) {
                return disableFormElement(element);
              } else if (matches(element, Rails2.formSubmitSelector)) {
                return disableFormElements(element);
              }
            };
            disableLinkElement = function(element) {
              var replacement;
              if (getData(element, "ujs:disabled")) {
                return;
              }
              replacement = element.getAttribute("data-disable-with");
              if (replacement != null) {
                setData(element, "ujs:enable-with", element.innerHTML);
                element.innerHTML = replacement;
              }
              element.addEventListener("click", stopEverything);
              return setData(element, "ujs:disabled", true);
            };
            enableLinkElement = function(element) {
              var originalText;
              originalText = getData(element, "ujs:enable-with");
              if (originalText != null) {
                element.innerHTML = originalText;
                setData(element, "ujs:enable-with", null);
              }
              element.removeEventListener("click", stopEverything);
              return setData(element, "ujs:disabled", null);
            };
            disableFormElements = function(form) {
              return formElements(form, Rails2.formDisableSelector).forEach(disableFormElement);
            };
            disableFormElement = function(element) {
              var replacement;
              if (getData(element, "ujs:disabled")) {
                return;
              }
              replacement = element.getAttribute("data-disable-with");
              if (replacement != null) {
                if (matches(element, "button")) {
                  setData(element, "ujs:enable-with", element.innerHTML);
                  element.innerHTML = replacement;
                } else {
                  setData(element, "ujs:enable-with", element.value);
                  element.value = replacement;
                }
              }
              element.disabled = true;
              return setData(element, "ujs:disabled", true);
            };
            enableFormElements = function(form) {
              return formElements(form, Rails2.formEnableSelector).forEach(enableFormElement);
            };
            enableFormElement = function(element) {
              var originalText;
              originalText = getData(element, "ujs:enable-with");
              if (originalText != null) {
                if (matches(element, "button")) {
                  element.innerHTML = originalText;
                } else {
                  element.value = originalText;
                }
                setData(element, "ujs:enable-with", null);
              }
              element.disabled = false;
              return setData(element, "ujs:disabled", null);
            };
            isXhrRedirect = function(event) {
              var ref, xhr;
              xhr = (ref = event.detail) != null ? ref[0] : void 0;
              return (xhr != null ? xhr.getResponseHeader("X-Xhr-Redirect") : void 0) != null;
            };
          }).call(this);
          (function() {
            var stopEverything;
            stopEverything = Rails2.stopEverything;
            Rails2.handleMethod = function(e2) {
              var csrfParam, csrfToken, form, formContent, href, link, method;
              link = this;
              method = link.getAttribute("data-method");
              if (!method) {
                return;
              }
              href = Rails2.href(link);
              csrfToken = Rails2.csrfToken();
              csrfParam = Rails2.csrfParam();
              form = document.createElement("form");
              formContent = "<input name='_method' value='" + method + "' type='hidden' />";
              if (csrfParam != null && csrfToken != null && !Rails2.isCrossDomain(href)) {
                formContent += "<input name='" + csrfParam + "' value='" + csrfToken + "' type='hidden' />";
              }
              formContent += '<input type="submit" />';
              form.method = "post";
              form.action = href;
              form.target = link.target;
              form.innerHTML = formContent;
              form.style.display = "none";
              document.body.appendChild(form);
              form.querySelector('[type="submit"]').click();
              return stopEverything(e2);
            };
          }).call(this);
          (function() {
            var ajax, fire, getData, isCrossDomain, isRemote, matches, serializeElement, setData, stopEverything, slice = [].slice;
            matches = Rails2.matches, getData = Rails2.getData, setData = Rails2.setData, fire = Rails2.fire, stopEverything = Rails2.stopEverything, ajax = Rails2.ajax, isCrossDomain = Rails2.isCrossDomain, serializeElement = Rails2.serializeElement;
            isRemote = function(element) {
              var value;
              value = element.getAttribute("data-remote");
              return value != null && value !== "false";
            };
            Rails2.handleRemote = function(e2) {
              var button, data, dataType, element, method, url, withCredentials;
              element = this;
              if (!isRemote(element)) {
                return true;
              }
              if (!fire(element, "ajax:before")) {
                fire(element, "ajax:stopped");
                return false;
              }
              withCredentials = element.getAttribute("data-with-credentials");
              dataType = element.getAttribute("data-type") || "script";
              if (matches(element, Rails2.formSubmitSelector)) {
                button = getData(element, "ujs:submit-button");
                method = getData(element, "ujs:submit-button-formmethod") || element.method;
                url = getData(element, "ujs:submit-button-formaction") || element.getAttribute("action") || location.href;
                if (method.toUpperCase() === "GET") {
                  url = url.replace(/\?.*$/, "");
                }
                if (element.enctype === "multipart/form-data") {
                  data = new FormData(element);
                  if (button != null) {
                    data.append(button.name, button.value);
                  }
                } else {
                  data = serializeElement(element, button);
                }
                setData(element, "ujs:submit-button", null);
                setData(element, "ujs:submit-button-formmethod", null);
                setData(element, "ujs:submit-button-formaction", null);
              } else if (matches(element, Rails2.buttonClickSelector) || matches(element, Rails2.inputChangeSelector)) {
                method = element.getAttribute("data-method");
                url = element.getAttribute("data-url");
                data = serializeElement(element, element.getAttribute("data-params"));
              } else {
                method = element.getAttribute("data-method");
                url = Rails2.href(element);
                data = element.getAttribute("data-params");
              }
              ajax({
                type: method || "GET",
                url,
                data,
                dataType,
                beforeSend: function(xhr, options) {
                  if (fire(element, "ajax:beforeSend", [xhr, options])) {
                    return fire(element, "ajax:send", [xhr]);
                  } else {
                    fire(element, "ajax:stopped");
                    return false;
                  }
                },
                success: function() {
                  var args;
                  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
                  return fire(element, "ajax:success", args);
                },
                error: function() {
                  var args;
                  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
                  return fire(element, "ajax:error", args);
                },
                complete: function() {
                  var args;
                  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
                  return fire(element, "ajax:complete", args);
                },
                crossDomain: isCrossDomain(url),
                withCredentials: withCredentials != null && withCredentials !== "false"
              });
              return stopEverything(e2);
            };
            Rails2.formSubmitButtonClick = function(e2) {
              var button, form;
              button = this;
              form = button.form;
              if (!form) {
                return;
              }
              if (button.name) {
                setData(form, "ujs:submit-button", {
                  name: button.name,
                  value: button.value
                });
              }
              setData(form, "ujs:formnovalidate-button", button.formNoValidate);
              setData(form, "ujs:submit-button-formaction", button.getAttribute("formaction"));
              return setData(form, "ujs:submit-button-formmethod", button.getAttribute("formmethod"));
            };
            Rails2.preventInsignificantClick = function(e2) {
              var data, insignificantMetaClick, link, metaClick, method, nonPrimaryMouseClick;
              link = this;
              method = (link.getAttribute("data-method") || "GET").toUpperCase();
              data = link.getAttribute("data-params");
              metaClick = e2.metaKey || e2.ctrlKey;
              insignificantMetaClick = metaClick && method === "GET" && !data;
              nonPrimaryMouseClick = e2.button != null && e2.button !== 0;
              if (nonPrimaryMouseClick || insignificantMetaClick) {
                return e2.stopImmediatePropagation();
              }
            };
          }).call(this);
          (function() {
            var $2, CSRFProtection, delegate, disableElement, enableElement, fire, formSubmitButtonClick, getData, handleConfirm, handleDisabledElement, handleMethod, handleRemote, loadCSPNonce, preventInsignificantClick, refreshCSRFTokens;
            fire = Rails2.fire, delegate = Rails2.delegate, getData = Rails2.getData, $2 = Rails2.$, refreshCSRFTokens = Rails2.refreshCSRFTokens, CSRFProtection = Rails2.CSRFProtection, loadCSPNonce = Rails2.loadCSPNonce, enableElement = Rails2.enableElement, disableElement = Rails2.disableElement, handleDisabledElement = Rails2.handleDisabledElement, handleConfirm = Rails2.handleConfirm, preventInsignificantClick = Rails2.preventInsignificantClick, handleRemote = Rails2.handleRemote, formSubmitButtonClick = Rails2.formSubmitButtonClick, handleMethod = Rails2.handleMethod;
            if (typeof jQuery !== "undefined" && jQuery !== null && jQuery.ajax != null) {
              if (jQuery.rails) {
                throw new Error("If you load both jquery_ujs and rails-ujs, use rails-ujs only.");
              }
              jQuery.rails = Rails2;
              jQuery.ajaxPrefilter(function(options, originalOptions, xhr) {
                if (!options.crossDomain) {
                  return CSRFProtection(xhr);
                }
              });
            }
            Rails2.start = function() {
              if (window._rails_loaded) {
                throw new Error("rails-ujs has already been loaded!");
              }
              window.addEventListener("pageshow", function() {
                $2(Rails2.formEnableSelector).forEach(function(el) {
                  if (getData(el, "ujs:disabled")) {
                    return enableElement(el);
                  }
                });
                return $2(Rails2.linkDisableSelector).forEach(function(el) {
                  if (getData(el, "ujs:disabled")) {
                    return enableElement(el);
                  }
                });
              });
              delegate(document, Rails2.linkDisableSelector, "ajax:complete", enableElement);
              delegate(document, Rails2.linkDisableSelector, "ajax:stopped", enableElement);
              delegate(document, Rails2.buttonDisableSelector, "ajax:complete", enableElement);
              delegate(document, Rails2.buttonDisableSelector, "ajax:stopped", enableElement);
              delegate(document, Rails2.linkClickSelector, "click", preventInsignificantClick);
              delegate(document, Rails2.linkClickSelector, "click", handleDisabledElement);
              delegate(document, Rails2.linkClickSelector, "click", handleConfirm);
              delegate(document, Rails2.linkClickSelector, "click", disableElement);
              delegate(document, Rails2.linkClickSelector, "click", handleRemote);
              delegate(document, Rails2.linkClickSelector, "click", handleMethod);
              delegate(document, Rails2.buttonClickSelector, "click", preventInsignificantClick);
              delegate(document, Rails2.buttonClickSelector, "click", handleDisabledElement);
              delegate(document, Rails2.buttonClickSelector, "click", handleConfirm);
              delegate(document, Rails2.buttonClickSelector, "click", disableElement);
              delegate(document, Rails2.buttonClickSelector, "click", handleRemote);
              delegate(document, Rails2.inputChangeSelector, "change", handleDisabledElement);
              delegate(document, Rails2.inputChangeSelector, "change", handleConfirm);
              delegate(document, Rails2.inputChangeSelector, "change", handleRemote);
              delegate(document, Rails2.formSubmitSelector, "submit", handleDisabledElement);
              delegate(document, Rails2.formSubmitSelector, "submit", handleConfirm);
              delegate(document, Rails2.formSubmitSelector, "submit", handleRemote);
              delegate(document, Rails2.formSubmitSelector, "submit", function(e2) {
                return setTimeout(function() {
                  return disableElement(e2);
                }, 13);
              });
              delegate(document, Rails2.formSubmitSelector, "ajax:send", disableElement);
              delegate(document, Rails2.formSubmitSelector, "ajax:complete", enableElement);
              delegate(document, Rails2.formInputClickSelector, "click", preventInsignificantClick);
              delegate(document, Rails2.formInputClickSelector, "click", handleDisabledElement);
              delegate(document, Rails2.formInputClickSelector, "click", handleConfirm);
              delegate(document, Rails2.formInputClickSelector, "click", formSubmitButtonClick);
              document.addEventListener("DOMContentLoaded", refreshCSRFTokens);
              document.addEventListener("DOMContentLoaded", loadCSPNonce);
              return window._rails_loaded = true;
            };
            if (window.Rails === Rails2 && fire(document, "rails:attachBindings")) {
              Rails2.start();
            }
          }).call(this);
        }).call(this);
        if (typeof module === "object" && module.exports) {
          module.exports = Rails2;
        } else if (typeof define === "function" && define.amd) {
          define(Rails2);
        }
      }).call(exports);
    }
  });

  // node_modules/urijs/src/punycode.js
  var require_punycode = __commonJS({
    "node_modules/urijs/src/punycode.js"(exports, module) {
      (function(root) {
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = typeof module == "object" && module && !module.nodeType && module;
        var freeGlobal = typeof global == "object" && global;
        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
          root = freeGlobal;
        }
        var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
          "overflow": "Overflow: input needs wider integers to process",
          "not-basic": "Illegal input >= 0x80 (not a basic code point)",
          "invalid-input": "Invalid input"
        }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
        function error2(type) {
          throw new RangeError(errors[type]);
        }
        function map(array, fn2) {
          var length = array.length;
          var result = [];
          while (length--) {
            result[length] = fn2(array[length]);
          }
          return result;
        }
        function mapDomain(string, fn2) {
          var parts = string.split("@");
          var result = "";
          if (parts.length > 1) {
            result = parts[0] + "@";
            string = parts[1];
          }
          string = string.replace(regexSeparators, ".");
          var labels = string.split(".");
          var encoded = map(labels, fn2).join(".");
          return result + encoded;
        }
        function ucs2decode(string) {
          var output = [], counter = 0, length = string.length, value, extra;
          while (counter < length) {
            value = string.charCodeAt(counter++);
            if (value >= 55296 && value <= 56319 && counter < length) {
              extra = string.charCodeAt(counter++);
              if ((extra & 64512) == 56320) {
                output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
              } else {
                output.push(value);
                counter--;
              }
            } else {
              output.push(value);
            }
          }
          return output;
        }
        function ucs2encode(array) {
          return map(array, function(value) {
            var output = "";
            if (value > 65535) {
              value -= 65536;
              output += stringFromCharCode(value >>> 10 & 1023 | 55296);
              value = 56320 | value & 1023;
            }
            output += stringFromCharCode(value);
            return output;
          }).join("");
        }
        function basicToDigit(codePoint) {
          if (codePoint - 48 < 10) {
            return codePoint - 22;
          }
          if (codePoint - 65 < 26) {
            return codePoint - 65;
          }
          if (codePoint - 97 < 26) {
            return codePoint - 97;
          }
          return base;
        }
        function digitToBasic(digit, flag) {
          return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        }
        function adapt(delta, numPoints, firstTime) {
          var k2 = 0;
          delta = firstTime ? floor(delta / damp) : delta >> 1;
          delta += floor(delta / numPoints);
          for (; delta > baseMinusTMin * tMax >> 1; k2 += base) {
            delta = floor(delta / baseMinusTMin);
          }
          return floor(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
        }
        function decode(input) {
          var output = [], inputLength = input.length, out, i2 = 0, n2 = initialN, bias = initialBias, basic, j2, index, oldi, w, k2, digit, t2, baseMinusT;
          basic = input.lastIndexOf(delimiter);
          if (basic < 0) {
            basic = 0;
          }
          for (j2 = 0; j2 < basic; ++j2) {
            if (input.charCodeAt(j2) >= 128) {
              error2("not-basic");
            }
            output.push(input.charCodeAt(j2));
          }
          for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
            for (oldi = i2, w = 1, k2 = base; ; k2 += base) {
              if (index >= inputLength) {
                error2("invalid-input");
              }
              digit = basicToDigit(input.charCodeAt(index++));
              if (digit >= base || digit > floor((maxInt - i2) / w)) {
                error2("overflow");
              }
              i2 += digit * w;
              t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
              if (digit < t2) {
                break;
              }
              baseMinusT = base - t2;
              if (w > floor(maxInt / baseMinusT)) {
                error2("overflow");
              }
              w *= baseMinusT;
            }
            out = output.length + 1;
            bias = adapt(i2 - oldi, out, oldi == 0);
            if (floor(i2 / out) > maxInt - n2) {
              error2("overflow");
            }
            n2 += floor(i2 / out);
            i2 %= out;
            output.splice(i2++, 0, n2);
          }
          return ucs2encode(output);
        }
        function encode(input) {
          var n2, delta, handledCPCount, basicLength, bias, j2, m2, q, k2, t2, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
          input = ucs2decode(input);
          inputLength = input.length;
          n2 = initialN;
          delta = 0;
          bias = initialBias;
          for (j2 = 0; j2 < inputLength; ++j2) {
            currentValue = input[j2];
            if (currentValue < 128) {
              output.push(stringFromCharCode(currentValue));
            }
          }
          handledCPCount = basicLength = output.length;
          if (basicLength) {
            output.push(delimiter);
          }
          while (handledCPCount < inputLength) {
            for (m2 = maxInt, j2 = 0; j2 < inputLength; ++j2) {
              currentValue = input[j2];
              if (currentValue >= n2 && currentValue < m2) {
                m2 = currentValue;
              }
            }
            handledCPCountPlusOne = handledCPCount + 1;
            if (m2 - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
              error2("overflow");
            }
            delta += (m2 - n2) * handledCPCountPlusOne;
            n2 = m2;
            for (j2 = 0; j2 < inputLength; ++j2) {
              currentValue = input[j2];
              if (currentValue < n2 && ++delta > maxInt) {
                error2("overflow");
              }
              if (currentValue == n2) {
                for (q = delta, k2 = base; ; k2 += base) {
                  t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
                  if (q < t2) {
                    break;
                  }
                  qMinusT = q - t2;
                  baseMinusT = base - t2;
                  output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
                  q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
            ++delta;
            ++n2;
          }
          return output.join("");
        }
        function toUnicode(input) {
          return mapDomain(input, function(string) {
            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
          });
        }
        function toASCII(input) {
          return mapDomain(input, function(string) {
            return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
          });
        }
        punycode = {
          "version": "1.3.2",
          "ucs2": {
            "decode": ucs2decode,
            "encode": ucs2encode
          },
          "decode": decode,
          "encode": encode,
          "toASCII": toASCII,
          "toUnicode": toUnicode
        };
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          define("punycode", function() {
            return punycode;
          });
        } else if (freeExports && freeModule) {
          if (module.exports == freeExports) {
            freeModule.exports = punycode;
          } else {
            for (key in punycode) {
              punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
            }
          }
        } else {
          root.punycode = punycode;
        }
      })(exports);
    }
  });

  // node_modules/urijs/src/IPv6.js
  var require_IPv6 = __commonJS({
    "node_modules/urijs/src/IPv6.js"(exports, module) {
      (function(root, factory) {
        "use strict";
        if (typeof module === "object" && module.exports) {
          module.exports = factory();
        } else if (typeof define === "function" && define.amd) {
          define(factory);
        } else {
          root.IPv6 = factory(root);
        }
      })(exports, function(root) {
        "use strict";
        var _IPv6 = root && root.IPv6;
        function bestPresentation(address) {
          var _address = address.toLowerCase();
          var segments = _address.split(":");
          var length = segments.length;
          var total = 8;
          if (segments[0] === "" && segments[1] === "" && segments[2] === "") {
            segments.shift();
            segments.shift();
          } else if (segments[0] === "" && segments[1] === "") {
            segments.shift();
          } else if (segments[length - 1] === "" && segments[length - 2] === "") {
            segments.pop();
          }
          length = segments.length;
          if (segments[length - 1].indexOf(".") !== -1) {
            total = 7;
          }
          var pos;
          for (pos = 0; pos < length; pos++) {
            if (segments[pos] === "") {
              break;
            }
          }
          if (pos < total) {
            segments.splice(pos, 1, "0000");
            while (segments.length < total) {
              segments.splice(pos, 0, "0000");
            }
          }
          var _segments;
          for (var i2 = 0; i2 < total; i2++) {
            _segments = segments[i2].split("");
            for (var j2 = 0; j2 < 3; j2++) {
              if (_segments[0] === "0" && _segments.length > 1) {
                _segments.splice(0, 1);
              } else {
                break;
              }
            }
            segments[i2] = _segments.join("");
          }
          var best = -1;
          var _best = 0;
          var _current = 0;
          var current = -1;
          var inzeroes = false;
          for (i2 = 0; i2 < total; i2++) {
            if (inzeroes) {
              if (segments[i2] === "0") {
                _current += 1;
              } else {
                inzeroes = false;
                if (_current > _best) {
                  best = current;
                  _best = _current;
                }
              }
            } else {
              if (segments[i2] === "0") {
                inzeroes = true;
                current = i2;
                _current = 1;
              }
            }
          }
          if (_current > _best) {
            best = current;
            _best = _current;
          }
          if (_best > 1) {
            segments.splice(best, _best, "");
          }
          length = segments.length;
          var result = "";
          if (segments[0] === "") {
            result = ":";
          }
          for (i2 = 0; i2 < length; i2++) {
            result += segments[i2];
            if (i2 === length - 1) {
              break;
            }
            result += ":";
          }
          if (segments[length - 1] === "") {
            result += ":";
          }
          return result;
        }
        function noConflict() {
          if (root.IPv6 === this) {
            root.IPv6 = _IPv6;
          }
          return this;
        }
        return {
          best: bestPresentation,
          noConflict
        };
      });
    }
  });

  // node_modules/urijs/src/SecondLevelDomains.js
  var require_SecondLevelDomains = __commonJS({
    "node_modules/urijs/src/SecondLevelDomains.js"(exports, module) {
      (function(root, factory) {
        "use strict";
        if (typeof module === "object" && module.exports) {
          module.exports = factory();
        } else if (typeof define === "function" && define.amd) {
          define(factory);
        } else {
          root.SecondLevelDomains = factory(root);
        }
      })(exports, function(root) {
        "use strict";
        var _SecondLevelDomains = root && root.SecondLevelDomains;
        var SLD = {
          list: {
            "ac": " com gov mil net org ",
            "ae": " ac co gov mil name net org pro sch ",
            "af": " com edu gov net org ",
            "al": " com edu gov mil net org ",
            "ao": " co ed gv it og pb ",
            "ar": " com edu gob gov int mil net org tur ",
            "at": " ac co gv or ",
            "au": " asn com csiro edu gov id net org ",
            "ba": " co com edu gov mil net org rs unbi unmo unsa untz unze ",
            "bb": " biz co com edu gov info net org store tv ",
            "bh": " biz cc com edu gov info net org ",
            "bn": " com edu gov net org ",
            "bo": " com edu gob gov int mil net org tv ",
            "br": " adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ",
            "bs": " com edu gov net org ",
            "bz": " du et om ov rg ",
            "ca": " ab bc mb nb nf nl ns nt nu on pe qc sk yk ",
            "ck": " biz co edu gen gov info net org ",
            "cn": " ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ",
            "co": " com edu gov mil net nom org ",
            "cr": " ac c co ed fi go or sa ",
            "cy": " ac biz com ekloges gov ltd name net org parliament press pro tm ",
            "do": " art com edu gob gov mil net org sld web ",
            "dz": " art asso com edu gov net org pol ",
            "ec": " com edu fin gov info med mil net org pro ",
            "eg": " com edu eun gov mil name net org sci ",
            "er": " com edu gov ind mil net org rochest w ",
            "es": " com edu gob nom org ",
            "et": " biz com edu gov info name net org ",
            "fj": " ac biz com info mil name net org pro ",
            "fk": " ac co gov net nom org ",
            "fr": " asso com f gouv nom prd presse tm ",
            "gg": " co net org ",
            "gh": " com edu gov mil org ",
            "gn": " ac com gov net org ",
            "gr": " com edu gov mil net org ",
            "gt": " com edu gob ind mil net org ",
            "gu": " com edu gov net org ",
            "hk": " com edu gov idv net org ",
            "hu": " 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ",
            "id": " ac co go mil net or sch web ",
            "il": " ac co gov idf k12 muni net org ",
            "in": " ac co edu ernet firm gen gov i ind mil net nic org res ",
            "iq": " com edu gov i mil net org ",
            "ir": " ac co dnssec gov i id net org sch ",
            "it": " edu gov ",
            "je": " co net org ",
            "jo": " com edu gov mil name net org sch ",
            "jp": " ac ad co ed go gr lg ne or ",
            "ke": " ac co go info me mobi ne or sc ",
            "kh": " com edu gov mil net org per ",
            "ki": " biz com de edu gov info mob net org tel ",
            "km": " asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ",
            "kn": " edu gov net org ",
            "kr": " ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ",
            "kw": " com edu gov net org ",
            "ky": " com edu gov net org ",
            "kz": " com edu gov mil net org ",
            "lb": " com edu gov net org ",
            "lk": " assn com edu gov grp hotel int ltd net ngo org sch soc web ",
            "lr": " com edu gov net org ",
            "lv": " asn com conf edu gov id mil net org ",
            "ly": " com edu gov id med net org plc sch ",
            "ma": " ac co gov m net org press ",
            "mc": " asso tm ",
            "me": " ac co edu gov its net org priv ",
            "mg": " com edu gov mil nom org prd tm ",
            "mk": " com edu gov inf name net org pro ",
            "ml": " com edu gov net org presse ",
            "mn": " edu gov org ",
            "mo": " com edu gov net org ",
            "mt": " com edu gov net org ",
            "mv": " aero biz com coop edu gov info int mil museum name net org pro ",
            "mw": " ac co com coop edu gov int museum net org ",
            "mx": " com edu gob net org ",
            "my": " com edu gov mil name net org sch ",
            "nf": " arts com firm info net other per rec store web ",
            "ng": " biz com edu gov mil mobi name net org sch ",
            "ni": " ac co com edu gob mil net nom org ",
            "np": " com edu gov mil net org ",
            "nr": " biz com edu gov info net org ",
            "om": " ac biz co com edu gov med mil museum net org pro sch ",
            "pe": " com edu gob mil net nom org sld ",
            "ph": " com edu gov i mil net ngo org ",
            "pk": " biz com edu fam gob gok gon gop gos gov net org web ",
            "pl": " art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ",
            "pr": " ac biz com edu est gov info isla name net org pro prof ",
            "ps": " com edu gov net org plo sec ",
            "pw": " belau co ed go ne or ",
            "ro": " arts com firm info nom nt org rec store tm www ",
            "rs": " ac co edu gov in org ",
            "sb": " com edu gov net org ",
            "sc": " com edu gov net org ",
            "sh": " co com edu gov net nom org ",
            "sl": " com edu gov net org ",
            "st": " co com consulado edu embaixada gov mil net org principe saotome store ",
            "sv": " com edu gob org red ",
            "sz": " ac co org ",
            "tr": " av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ",
            "tt": " aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ",
            "tw": " club com ebiz edu game gov idv mil net org ",
            "mu": " ac co com gov net or org ",
            "mz": " ac co edu gov org ",
            "na": " co com ",
            "nz": " ac co cri geek gen govt health iwi maori mil net org parliament school ",
            "pa": " abo ac com edu gob ing med net nom org sld ",
            "pt": " com edu gov int net nome org publ ",
            "py": " com edu gov mil net org ",
            "qa": " com edu gov mil net org ",
            "re": " asso com nom ",
            "ru": " ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ",
            "rw": " ac co com edu gouv gov int mil net ",
            "sa": " com edu gov med net org pub sch ",
            "sd": " com edu gov info med net org tv ",
            "se": " a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ",
            "sg": " com edu gov idn net org per ",
            "sn": " art com edu gouv org perso univ ",
            "sy": " com edu gov mil net news org ",
            "th": " ac co go in mi net or ",
            "tj": " ac biz co com edu go gov info int mil name net nic org test web ",
            "tn": " agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ",
            "tz": " ac co go ne or ",
            "ua": " biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ",
            "ug": " ac co go ne or org sc ",
            "uk": " ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ",
            "us": " dni fed isa kids nsn ",
            "uy": " com edu gub mil net org ",
            "ve": " co com edu gob info mil net org web ",
            "vi": " co com k12 net org ",
            "vn": " ac biz com edu gov health info int name net org pro ",
            "ye": " co com gov ltd me net org plc ",
            "yu": " ac co edu gov org ",
            "za": " ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ",
            "zm": " ac co com edu gov net org sch ",
            "com": "ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ",
            "net": "gb jp se uk ",
            "org": "ae",
            "de": "com "
          },
          has: function(domain) {
            var tldOffset = domain.lastIndexOf(".");
            if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
              return false;
            }
            var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
            if (sldOffset <= 0 || sldOffset >= tldOffset - 1) {
              return false;
            }
            var sldList = SLD.list[domain.slice(tldOffset + 1)];
            if (!sldList) {
              return false;
            }
            return sldList.indexOf(" " + domain.slice(sldOffset + 1, tldOffset) + " ") >= 0;
          },
          is: function(domain) {
            var tldOffset = domain.lastIndexOf(".");
            if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
              return false;
            }
            var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
            if (sldOffset >= 0) {
              return false;
            }
            var sldList = SLD.list[domain.slice(tldOffset + 1)];
            if (!sldList) {
              return false;
            }
            return sldList.indexOf(" " + domain.slice(0, tldOffset) + " ") >= 0;
          },
          get: function(domain) {
            var tldOffset = domain.lastIndexOf(".");
            if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
              return null;
            }
            var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
            if (sldOffset <= 0 || sldOffset >= tldOffset - 1) {
              return null;
            }
            var sldList = SLD.list[domain.slice(tldOffset + 1)];
            if (!sldList) {
              return null;
            }
            if (sldList.indexOf(" " + domain.slice(sldOffset + 1, tldOffset) + " ") < 0) {
              return null;
            }
            return domain.slice(sldOffset + 1);
          },
          noConflict: function() {
            if (root.SecondLevelDomains === this) {
              root.SecondLevelDomains = _SecondLevelDomains;
            }
            return this;
          }
        };
        return SLD;
      });
    }
  });

  // node_modules/urijs/src/URI.js
  var require_URI = __commonJS({
    "node_modules/urijs/src/URI.js"(exports, module) {
      (function(root, factory) {
        "use strict";
        if (typeof module === "object" && module.exports) {
          module.exports = factory(require_punycode(), require_IPv6(), require_SecondLevelDomains());
        } else if (typeof define === "function" && define.amd) {
          define(["./punycode", "./IPv6", "./SecondLevelDomains"], factory);
        } else {
          root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
        }
      })(exports, function(punycode, IPv6, SLD, root) {
        "use strict";
        var _URI = root && root.URI;
        function URI3(url, base) {
          var _urlSupplied = arguments.length >= 1;
          var _baseSupplied = arguments.length >= 2;
          if (!(this instanceof URI3)) {
            if (_urlSupplied) {
              if (_baseSupplied) {
                return new URI3(url, base);
              }
              return new URI3(url);
            }
            return new URI3();
          }
          if (url === void 0) {
            if (_urlSupplied) {
              throw new TypeError("undefined is not a valid argument for URI");
            }
            if (typeof location !== "undefined") {
              url = location.href + "";
            } else {
              url = "";
            }
          }
          if (url === null) {
            if (_urlSupplied) {
              throw new TypeError("null is not a valid argument for URI");
            }
          }
          this.href(url);
          if (base !== void 0) {
            return this.absoluteTo(base);
          }
          return this;
        }
        function isInteger(value) {
          return /^[0-9]+$/.test(value);
        }
        URI3.version = "1.19.7";
        var p2 = URI3.prototype;
        var hasOwn = Object.prototype.hasOwnProperty;
        function escapeRegEx(string) {
          return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
        }
        function getType(value) {
          if (value === void 0) {
            return "Undefined";
          }
          return String(Object.prototype.toString.call(value)).slice(8, -1);
        }
        function isArray(obj) {
          return getType(obj) === "Array";
        }
        function filterArrayValues(data, value) {
          var lookup = {};
          var i2, length;
          if (getType(value) === "RegExp") {
            lookup = null;
          } else if (isArray(value)) {
            for (i2 = 0, length = value.length; i2 < length; i2++) {
              lookup[value[i2]] = true;
            }
          } else {
            lookup[value] = true;
          }
          for (i2 = 0, length = data.length; i2 < length; i2++) {
            var _match = lookup && lookup[data[i2]] !== void 0 || !lookup && value.test(data[i2]);
            if (_match) {
              data.splice(i2, 1);
              length--;
              i2--;
            }
          }
          return data;
        }
        function arrayContains(list, value) {
          var i2, length;
          if (isArray(value)) {
            for (i2 = 0, length = value.length; i2 < length; i2++) {
              if (!arrayContains(list, value[i2])) {
                return false;
              }
            }
            return true;
          }
          var _type = getType(value);
          for (i2 = 0, length = list.length; i2 < length; i2++) {
            if (_type === "RegExp") {
              if (typeof list[i2] === "string" && list[i2].match(value)) {
                return true;
              }
            } else if (list[i2] === value) {
              return true;
            }
          }
          return false;
        }
        function arraysEqual(one, two) {
          if (!isArray(one) || !isArray(two)) {
            return false;
          }
          if (one.length !== two.length) {
            return false;
          }
          one.sort();
          two.sort();
          for (var i2 = 0, l2 = one.length; i2 < l2; i2++) {
            if (one[i2] !== two[i2]) {
              return false;
            }
          }
          return true;
        }
        function trimSlashes(text) {
          var trim_expression = /^\/+|\/+$/g;
          return text.replace(trim_expression, "");
        }
        URI3._parts = function() {
          return {
            protocol: null,
            username: null,
            password: null,
            hostname: null,
            urn: null,
            port: null,
            path: null,
            query: null,
            fragment: null,
            preventInvalidHostname: URI3.preventInvalidHostname,
            duplicateQueryParameters: URI3.duplicateQueryParameters,
            escapeQuerySpace: URI3.escapeQuerySpace
          };
        };
        URI3.preventInvalidHostname = false;
        URI3.duplicateQueryParameters = false;
        URI3.escapeQuerySpace = true;
        URI3.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
        URI3.idn_expression = /[^a-z0-9\._-]/i;
        URI3.punycode_expression = /(xn--)/i;
        URI3.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
        URI3.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
        URI3.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?]))/ig;
        URI3.findUri = {
          start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
          end: /[\s\r\n]|$/,
          trim: /[`!()\[\]{};:'".,<>?]+$/,
          parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g
        };
        URI3.defaultPorts = {
          http: "80",
          https: "443",
          ftp: "21",
          gopher: "70",
          ws: "80",
          wss: "443"
        };
        URI3.hostProtocols = [
          "http",
          "https"
        ];
        URI3.invalid_hostname_characters = /[^a-zA-Z0-9\.\-:_]/;
        URI3.domAttributes = {
          "a": "href",
          "blockquote": "cite",
          "link": "href",
          "base": "href",
          "script": "src",
          "form": "action",
          "img": "src",
          "area": "href",
          "iframe": "src",
          "embed": "src",
          "source": "src",
          "track": "src",
          "input": "src",
          "audio": "src",
          "video": "src"
        };
        URI3.getDomAttribute = function(node) {
          if (!node || !node.nodeName) {
            return void 0;
          }
          var nodeName = node.nodeName.toLowerCase();
          if (nodeName === "input" && node.type !== "image") {
            return void 0;
          }
          return URI3.domAttributes[nodeName];
        };
        function escapeForDumbFirefox36(value) {
          return escape(value);
        }
        function strictEncodeURIComponent(string) {
          return encodeURIComponent(string).replace(/[!'()*]/g, escapeForDumbFirefox36).replace(/\*/g, "%2A");
        }
        URI3.encode = strictEncodeURIComponent;
        URI3.decode = decodeURIComponent;
        URI3.iso8859 = function() {
          URI3.encode = escape;
          URI3.decode = unescape;
        };
        URI3.unicode = function() {
          URI3.encode = strictEncodeURIComponent;
          URI3.decode = decodeURIComponent;
        };
        URI3.characters = {
          pathname: {
            encode: {
              expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
              map: {
                "%24": "$",
                "%26": "&",
                "%2B": "+",
                "%2C": ",",
                "%3B": ";",
                "%3D": "=",
                "%3A": ":",
                "%40": "@"
              }
            },
            decode: {
              expression: /[\/\?#]/g,
              map: {
                "/": "%2F",
                "?": "%3F",
                "#": "%23"
              }
            }
          },
          reserved: {
            encode: {
              expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
              map: {
                "%3A": ":",
                "%2F": "/",
                "%3F": "?",
                "%23": "#",
                "%5B": "[",
                "%5D": "]",
                "%40": "@",
                "%21": "!",
                "%24": "$",
                "%26": "&",
                "%27": "'",
                "%28": "(",
                "%29": ")",
                "%2A": "*",
                "%2B": "+",
                "%2C": ",",
                "%3B": ";",
                "%3D": "="
              }
            }
          },
          urnpath: {
            encode: {
              expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
              map: {
                "%21": "!",
                "%24": "$",
                "%27": "'",
                "%28": "(",
                "%29": ")",
                "%2A": "*",
                "%2B": "+",
                "%2C": ",",
                "%3B": ";",
                "%3D": "=",
                "%40": "@"
              }
            },
            decode: {
              expression: /[\/\?#:]/g,
              map: {
                "/": "%2F",
                "?": "%3F",
                "#": "%23",
                ":": "%3A"
              }
            }
          }
        };
        URI3.encodeQuery = function(string, escapeQuerySpace) {
          var escaped = URI3.encode(string + "");
          if (escapeQuerySpace === void 0) {
            escapeQuerySpace = URI3.escapeQuerySpace;
          }
          return escapeQuerySpace ? escaped.replace(/%20/g, "+") : escaped;
        };
        URI3.decodeQuery = function(string, escapeQuerySpace) {
          string += "";
          if (escapeQuerySpace === void 0) {
            escapeQuerySpace = URI3.escapeQuerySpace;
          }
          try {
            return URI3.decode(escapeQuerySpace ? string.replace(/\+/g, "%20") : string);
          } catch (e2) {
            return string;
          }
        };
        var _parts = { "encode": "encode", "decode": "decode" };
        var _part;
        var generateAccessor = function(_group, _part2) {
          return function(string) {
            try {
              return URI3[_part2](string + "").replace(URI3.characters[_group][_part2].expression, function(c2) {
                return URI3.characters[_group][_part2].map[c2];
              });
            } catch (e2) {
              return string;
            }
          };
        };
        for (_part in _parts) {
          URI3[_part + "PathSegment"] = generateAccessor("pathname", _parts[_part]);
          URI3[_part + "UrnPathSegment"] = generateAccessor("urnpath", _parts[_part]);
        }
        var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {
          return function(string) {
            var actualCodingFunc;
            if (!_innerCodingFuncName) {
              actualCodingFunc = URI3[_codingFuncName];
            } else {
              actualCodingFunc = function(string2) {
                return URI3[_codingFuncName](URI3[_innerCodingFuncName](string2));
              };
            }
            var segments = (string + "").split(_sep);
            for (var i2 = 0, length = segments.length; i2 < length; i2++) {
              segments[i2] = actualCodingFunc(segments[i2]);
            }
            return segments.join(_sep);
          };
        };
        URI3.decodePath = generateSegmentedPathFunction("/", "decodePathSegment");
        URI3.decodeUrnPath = generateSegmentedPathFunction(":", "decodeUrnPathSegment");
        URI3.recodePath = generateSegmentedPathFunction("/", "encodePathSegment", "decode");
        URI3.recodeUrnPath = generateSegmentedPathFunction(":", "encodeUrnPathSegment", "decode");
        URI3.encodeReserved = generateAccessor("reserved", "encode");
        URI3.parse = function(string, parts) {
          var pos;
          if (!parts) {
            parts = {
              preventInvalidHostname: URI3.preventInvalidHostname
            };
          }
          pos = string.indexOf("#");
          if (pos > -1) {
            parts.fragment = string.substring(pos + 1) || null;
            string = string.substring(0, pos);
          }
          pos = string.indexOf("?");
          if (pos > -1) {
            parts.query = string.substring(pos + 1) || null;
            string = string.substring(0, pos);
          }
          string = string.replace(/^(https?|ftp|wss?)?:[/\\]*/, "$1://");
          if (string.substring(0, 2) === "//") {
            parts.protocol = null;
            string = string.substring(2);
            string = URI3.parseAuthority(string, parts);
          } else {
            pos = string.indexOf(":");
            if (pos > -1) {
              parts.protocol = string.substring(0, pos) || null;
              if (parts.protocol && !parts.protocol.match(URI3.protocol_expression)) {
                parts.protocol = void 0;
              } else if (string.substring(pos + 1, pos + 3).replace(/\\/g, "/") === "//") {
                string = string.substring(pos + 3);
                string = URI3.parseAuthority(string, parts);
              } else {
                string = string.substring(pos + 1);
                parts.urn = true;
              }
            }
          }
          parts.path = string;
          return parts;
        };
        URI3.parseHost = function(string, parts) {
          if (!string) {
            string = "";
          }
          string = string.replace(/\\/g, "/");
          var pos = string.indexOf("/");
          var bracketPos;
          var t2;
          if (pos === -1) {
            pos = string.length;
          }
          if (string.charAt(0) === "[") {
            bracketPos = string.indexOf("]");
            parts.hostname = string.substring(1, bracketPos) || null;
            parts.port = string.substring(bracketPos + 2, pos) || null;
            if (parts.port === "/") {
              parts.port = null;
            }
          } else {
            var firstColon = string.indexOf(":");
            var firstSlash = string.indexOf("/");
            var nextColon = string.indexOf(":", firstColon + 1);
            if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {
              parts.hostname = string.substring(0, pos) || null;
              parts.port = null;
            } else {
              t2 = string.substring(0, pos).split(":");
              parts.hostname = t2[0] || null;
              parts.port = t2[1] || null;
            }
          }
          if (parts.hostname && string.substring(pos).charAt(0) !== "/") {
            pos++;
            string = "/" + string;
          }
          if (parts.preventInvalidHostname) {
            URI3.ensureValidHostname(parts.hostname, parts.protocol);
          }
          if (parts.port) {
            URI3.ensureValidPort(parts.port);
          }
          return string.substring(pos) || "/";
        };
        URI3.parseAuthority = function(string, parts) {
          string = URI3.parseUserinfo(string, parts);
          return URI3.parseHost(string, parts);
        };
        URI3.parseUserinfo = function(string, parts) {
          var _string = string;
          var firstBackSlash = string.indexOf("\\");
          if (firstBackSlash !== -1) {
            string = string.replace(/\\/g, "/");
          }
          var firstSlash = string.indexOf("/");
          var pos = string.lastIndexOf("@", firstSlash > -1 ? firstSlash : string.length - 1);
          var t2;
          if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
            t2 = string.substring(0, pos).split(":");
            parts.username = t2[0] ? URI3.decode(t2[0]) : null;
            t2.shift();
            parts.password = t2[0] ? URI3.decode(t2.join(":")) : null;
            string = _string.substring(pos + 1);
          } else {
            parts.username = null;
            parts.password = null;
          }
          return string;
        };
        URI3.parseQuery = function(string, escapeQuerySpace) {
          if (!string) {
            return {};
          }
          string = string.replace(/&+/g, "&").replace(/^\?*&*|&+$/g, "");
          if (!string) {
            return {};
          }
          var items = {};
          var splits = string.split("&");
          var length = splits.length;
          var v2, name, value;
          for (var i2 = 0; i2 < length; i2++) {
            v2 = splits[i2].split("=");
            name = URI3.decodeQuery(v2.shift(), escapeQuerySpace);
            value = v2.length ? URI3.decodeQuery(v2.join("="), escapeQuerySpace) : null;
            if (name === "__proto__") {
              continue;
            } else if (hasOwn.call(items, name)) {
              if (typeof items[name] === "string" || items[name] === null) {
                items[name] = [items[name]];
              }
              items[name].push(value);
            } else {
              items[name] = value;
            }
          }
          return items;
        };
        URI3.build = function(parts) {
          var t2 = "";
          var requireAbsolutePath = false;
          if (parts.protocol) {
            t2 += parts.protocol + ":";
          }
          if (!parts.urn && (t2 || parts.hostname)) {
            t2 += "//";
            requireAbsolutePath = true;
          }
          t2 += URI3.buildAuthority(parts) || "";
          if (typeof parts.path === "string") {
            if (parts.path.charAt(0) !== "/" && requireAbsolutePath) {
              t2 += "/";
            }
            t2 += parts.path;
          }
          if (typeof parts.query === "string" && parts.query) {
            t2 += "?" + parts.query;
          }
          if (typeof parts.fragment === "string" && parts.fragment) {
            t2 += "#" + parts.fragment;
          }
          return t2;
        };
        URI3.buildHost = function(parts) {
          var t2 = "";
          if (!parts.hostname) {
            return "";
          } else if (URI3.ip6_expression.test(parts.hostname)) {
            t2 += "[" + parts.hostname + "]";
          } else {
            t2 += parts.hostname;
          }
          if (parts.port) {
            t2 += ":" + parts.port;
          }
          return t2;
        };
        URI3.buildAuthority = function(parts) {
          return URI3.buildUserinfo(parts) + URI3.buildHost(parts);
        };
        URI3.buildUserinfo = function(parts) {
          var t2 = "";
          if (parts.username) {
            t2 += URI3.encode(parts.username);
          }
          if (parts.password) {
            t2 += ":" + URI3.encode(parts.password);
          }
          if (t2) {
            t2 += "@";
          }
          return t2;
        };
        URI3.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
          var t2 = "";
          var unique2, key, i2, length;
          for (key in data) {
            if (key === "__proto__") {
              continue;
            } else if (hasOwn.call(data, key)) {
              if (isArray(data[key])) {
                unique2 = {};
                for (i2 = 0, length = data[key].length; i2 < length; i2++) {
                  if (data[key][i2] !== void 0 && unique2[data[key][i2] + ""] === void 0) {
                    t2 += "&" + URI3.buildQueryParameter(key, data[key][i2], escapeQuerySpace);
                    if (duplicateQueryParameters !== true) {
                      unique2[data[key][i2] + ""] = true;
                    }
                  }
                }
              } else if (data[key] !== void 0) {
                t2 += "&" + URI3.buildQueryParameter(key, data[key], escapeQuerySpace);
              }
            }
          }
          return t2.substring(1);
        };
        URI3.buildQueryParameter = function(name, value, escapeQuerySpace) {
          return URI3.encodeQuery(name, escapeQuerySpace) + (value !== null ? "=" + URI3.encodeQuery(value, escapeQuerySpace) : "");
        };
        URI3.addQuery = function(data, name, value) {
          if (typeof name === "object") {
            for (var key in name) {
              if (hasOwn.call(name, key)) {
                URI3.addQuery(data, key, name[key]);
              }
            }
          } else if (typeof name === "string") {
            if (data[name] === void 0) {
              data[name] = value;
              return;
            } else if (typeof data[name] === "string") {
              data[name] = [data[name]];
            }
            if (!isArray(value)) {
              value = [value];
            }
            data[name] = (data[name] || []).concat(value);
          } else {
            throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
          }
        };
        URI3.setQuery = function(data, name, value) {
          if (typeof name === "object") {
            for (var key in name) {
              if (hasOwn.call(name, key)) {
                URI3.setQuery(data, key, name[key]);
              }
            }
          } else if (typeof name === "string") {
            data[name] = value === void 0 ? null : value;
          } else {
            throw new TypeError("URI.setQuery() accepts an object, string as the name parameter");
          }
        };
        URI3.removeQuery = function(data, name, value) {
          var i2, length, key;
          if (isArray(name)) {
            for (i2 = 0, length = name.length; i2 < length; i2++) {
              data[name[i2]] = void 0;
            }
          } else if (getType(name) === "RegExp") {
            for (key in data) {
              if (name.test(key)) {
                data[key] = void 0;
              }
            }
          } else if (typeof name === "object") {
            for (key in name) {
              if (hasOwn.call(name, key)) {
                URI3.removeQuery(data, key, name[key]);
              }
            }
          } else if (typeof name === "string") {
            if (value !== void 0) {
              if (getType(value) === "RegExp") {
                if (!isArray(data[name]) && value.test(data[name])) {
                  data[name] = void 0;
                } else {
                  data[name] = filterArrayValues(data[name], value);
                }
              } else if (data[name] === String(value) && (!isArray(value) || value.length === 1)) {
                data[name] = void 0;
              } else if (isArray(data[name])) {
                data[name] = filterArrayValues(data[name], value);
              }
            } else {
              data[name] = void 0;
            }
          } else {
            throw new TypeError("URI.removeQuery() accepts an object, string, RegExp as the first parameter");
          }
        };
        URI3.hasQuery = function(data, name, value, withinArray) {
          switch (getType(name)) {
            case "String":
              break;
            case "RegExp":
              for (var key in data) {
                if (hasOwn.call(data, key)) {
                  if (name.test(key) && (value === void 0 || URI3.hasQuery(data, key, value))) {
                    return true;
                  }
                }
              }
              return false;
            case "Object":
              for (var _key in name) {
                if (hasOwn.call(name, _key)) {
                  if (!URI3.hasQuery(data, _key, name[_key])) {
                    return false;
                  }
                }
              }
              return true;
            default:
              throw new TypeError("URI.hasQuery() accepts a string, regular expression or object as the name parameter");
          }
          switch (getType(value)) {
            case "Undefined":
              return name in data;
            case "Boolean":
              var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);
              return value === _booly;
            case "Function":
              return !!value(data[name], name, data);
            case "Array":
              if (!isArray(data[name])) {
                return false;
              }
              var op = withinArray ? arrayContains : arraysEqual;
              return op(data[name], value);
            case "RegExp":
              if (!isArray(data[name])) {
                return Boolean(data[name] && data[name].match(value));
              }
              if (!withinArray) {
                return false;
              }
              return arrayContains(data[name], value);
            case "Number":
              value = String(value);
            case "String":
              if (!isArray(data[name])) {
                return data[name] === value;
              }
              if (!withinArray) {
                return false;
              }
              return arrayContains(data[name], value);
            default:
              throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter");
          }
        };
        URI3.joinPaths = function() {
          var input = [];
          var segments = [];
          var nonEmptySegments = 0;
          for (var i2 = 0; i2 < arguments.length; i2++) {
            var url = new URI3(arguments[i2]);
            input.push(url);
            var _segments = url.segment();
            for (var s2 = 0; s2 < _segments.length; s2++) {
              if (typeof _segments[s2] === "string") {
                segments.push(_segments[s2]);
              }
              if (_segments[s2]) {
                nonEmptySegments++;
              }
            }
          }
          if (!segments.length || !nonEmptySegments) {
            return new URI3("");
          }
          var uri = new URI3("").segment(segments);
          if (input[0].path() === "" || input[0].path().slice(0, 1) === "/") {
            uri.path("/" + uri.path());
          }
          return uri.normalize();
        };
        URI3.commonPath = function(one, two) {
          var length = Math.min(one.length, two.length);
          var pos;
          for (pos = 0; pos < length; pos++) {
            if (one.charAt(pos) !== two.charAt(pos)) {
              pos--;
              break;
            }
          }
          if (pos < 1) {
            return one.charAt(0) === two.charAt(0) && one.charAt(0) === "/" ? "/" : "";
          }
          if (one.charAt(pos) !== "/" || two.charAt(pos) !== "/") {
            pos = one.substring(0, pos).lastIndexOf("/");
          }
          return one.substring(0, pos + 1);
        };
        URI3.withinString = function(string, callback, options) {
          options || (options = {});
          var _start = options.start || URI3.findUri.start;
          var _end = options.end || URI3.findUri.end;
          var _trim = options.trim || URI3.findUri.trim;
          var _parens = options.parens || URI3.findUri.parens;
          var _attributeOpen = /[a-z0-9-]=["']?$/i;
          _start.lastIndex = 0;
          while (true) {
            var match = _start.exec(string);
            if (!match) {
              break;
            }
            var start4 = match.index;
            if (options.ignoreHtml) {
              var attributeOpen = string.slice(Math.max(start4 - 3, 0), start4);
              if (attributeOpen && _attributeOpen.test(attributeOpen)) {
                continue;
              }
            }
            var end2 = start4 + string.slice(start4).search(_end);
            var slice = string.slice(start4, end2);
            var parensEnd = -1;
            while (true) {
              var parensMatch = _parens.exec(slice);
              if (!parensMatch) {
                break;
              }
              var parensMatchEnd = parensMatch.index + parensMatch[0].length;
              parensEnd = Math.max(parensEnd, parensMatchEnd);
            }
            if (parensEnd > -1) {
              slice = slice.slice(0, parensEnd) + slice.slice(parensEnd).replace(_trim, "");
            } else {
              slice = slice.replace(_trim, "");
            }
            if (slice.length <= match[0].length) {
              continue;
            }
            if (options.ignore && options.ignore.test(slice)) {
              continue;
            }
            end2 = start4 + slice.length;
            var result = callback(slice, start4, end2, string);
            if (result === void 0) {
              _start.lastIndex = end2;
              continue;
            }
            result = String(result);
            string = string.slice(0, start4) + result + string.slice(end2);
            _start.lastIndex = start4 + result.length;
          }
          _start.lastIndex = 0;
          return string;
        };
        URI3.ensureValidHostname = function(v2, protocol) {
          var hasHostname = !!v2;
          var hasProtocol = !!protocol;
          var rejectEmptyHostname = false;
          if (hasProtocol) {
            rejectEmptyHostname = arrayContains(URI3.hostProtocols, protocol);
          }
          if (rejectEmptyHostname && !hasHostname) {
            throw new TypeError("Hostname cannot be empty, if protocol is " + protocol);
          } else if (v2 && v2.match(URI3.invalid_hostname_characters)) {
            if (!punycode) {
              throw new TypeError('Hostname "' + v2 + '" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');
            }
            if (punycode.toASCII(v2).match(URI3.invalid_hostname_characters)) {
              throw new TypeError('Hostname "' + v2 + '" contains characters other than [A-Z0-9.-:_]');
            }
          }
        };
        URI3.ensureValidPort = function(v2) {
          if (!v2) {
            return;
          }
          var port = Number(v2);
          if (isInteger(port) && port > 0 && port < 65536) {
            return;
          }
          throw new TypeError('Port "' + v2 + '" is not a valid port');
        };
        URI3.noConflict = function(removeAll) {
          if (removeAll) {
            var unconflicted = {
              URI: this.noConflict()
            };
            if (root.URITemplate && typeof root.URITemplate.noConflict === "function") {
              unconflicted.URITemplate = root.URITemplate.noConflict();
            }
            if (root.IPv6 && typeof root.IPv6.noConflict === "function") {
              unconflicted.IPv6 = root.IPv6.noConflict();
            }
            if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === "function") {
              unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();
            }
            return unconflicted;
          } else if (root.URI === this) {
            root.URI = _URI;
          }
          return this;
        };
        p2.build = function(deferBuild) {
          if (deferBuild === true) {
            this._deferred_build = true;
          } else if (deferBuild === void 0 || this._deferred_build) {
            this._string = URI3.build(this._parts);
            this._deferred_build = false;
          }
          return this;
        };
        p2.clone = function() {
          return new URI3(this);
        };
        p2.valueOf = p2.toString = function() {
          return this.build(false)._string;
        };
        function generateSimpleAccessor(_part2) {
          return function(v2, build) {
            if (v2 === void 0) {
              return this._parts[_part2] || "";
            } else {
              this._parts[_part2] = v2 || null;
              this.build(!build);
              return this;
            }
          };
        }
        function generatePrefixAccessor(_part2, _key) {
          return function(v2, build) {
            if (v2 === void 0) {
              return this._parts[_part2] || "";
            } else {
              if (v2 !== null) {
                v2 = v2 + "";
                if (v2.charAt(0) === _key) {
                  v2 = v2.substring(1);
                }
              }
              this._parts[_part2] = v2;
              this.build(!build);
              return this;
            }
          };
        }
        p2.protocol = generateSimpleAccessor("protocol");
        p2.username = generateSimpleAccessor("username");
        p2.password = generateSimpleAccessor("password");
        p2.hostname = generateSimpleAccessor("hostname");
        p2.port = generateSimpleAccessor("port");
        p2.query = generatePrefixAccessor("query", "?");
        p2.fragment = generatePrefixAccessor("fragment", "#");
        p2.search = function(v2, build) {
          var t2 = this.query(v2, build);
          return typeof t2 === "string" && t2.length ? "?" + t2 : t2;
        };
        p2.hash = function(v2, build) {
          var t2 = this.fragment(v2, build);
          return typeof t2 === "string" && t2.length ? "#" + t2 : t2;
        };
        p2.pathname = function(v2, build) {
          if (v2 === void 0 || v2 === true) {
            var res = this._parts.path || (this._parts.hostname ? "/" : "");
            return v2 ? (this._parts.urn ? URI3.decodeUrnPath : URI3.decodePath)(res) : res;
          } else {
            if (this._parts.urn) {
              this._parts.path = v2 ? URI3.recodeUrnPath(v2) : "";
            } else {
              this._parts.path = v2 ? URI3.recodePath(v2) : "/";
            }
            this.build(!build);
            return this;
          }
        };
        p2.path = p2.pathname;
        p2.href = function(href, build) {
          var key;
          if (href === void 0) {
            return this.toString();
          }
          this._string = "";
          this._parts = URI3._parts();
          var _URI2 = href instanceof URI3;
          var _object = typeof href === "object" && (href.hostname || href.path || href.pathname);
          if (href.nodeName) {
            var attribute = URI3.getDomAttribute(href);
            href = href[attribute] || "";
            _object = false;
          }
          if (!_URI2 && _object && href.pathname !== void 0) {
            href = href.toString();
          }
          if (typeof href === "string" || href instanceof String) {
            this._parts = URI3.parse(String(href), this._parts);
          } else if (_URI2 || _object) {
            var src = _URI2 ? href._parts : href;
            for (key in src) {
              if (key === "query") {
                continue;
              }
              if (hasOwn.call(this._parts, key)) {
                this._parts[key] = src[key];
              }
            }
            if (src.query) {
              this.query(src.query, false);
            }
          } else {
            throw new TypeError("invalid input");
          }
          this.build(!build);
          return this;
        };
        p2.is = function(what) {
          var ip = false;
          var ip4 = false;
          var ip6 = false;
          var name = false;
          var sld = false;
          var idn = false;
          var punycode2 = false;
          var relative = !this._parts.urn;
          if (this._parts.hostname) {
            relative = false;
            ip4 = URI3.ip4_expression.test(this._parts.hostname);
            ip6 = URI3.ip6_expression.test(this._parts.hostname);
            ip = ip4 || ip6;
            name = !ip;
            sld = name && SLD && SLD.has(this._parts.hostname);
            idn = name && URI3.idn_expression.test(this._parts.hostname);
            punycode2 = name && URI3.punycode_expression.test(this._parts.hostname);
          }
          switch (what.toLowerCase()) {
            case "relative":
              return relative;
            case "absolute":
              return !relative;
            case "domain":
            case "name":
              return name;
            case "sld":
              return sld;
            case "ip":
              return ip;
            case "ip4":
            case "ipv4":
            case "inet4":
              return ip4;
            case "ip6":
            case "ipv6":
            case "inet6":
              return ip6;
            case "idn":
              return idn;
            case "url":
              return !this._parts.urn;
            case "urn":
              return !!this._parts.urn;
            case "punycode":
              return punycode2;
          }
          return null;
        };
        var _protocol = p2.protocol;
        var _port = p2.port;
        var _hostname = p2.hostname;
        p2.protocol = function(v2, build) {
          if (v2) {
            v2 = v2.replace(/:(\/\/)?$/, "");
            if (!v2.match(URI3.protocol_expression)) {
              throw new TypeError('Protocol "' + v2 + `" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]`);
            }
          }
          return _protocol.call(this, v2, build);
        };
        p2.scheme = p2.protocol;
        p2.port = function(v2, build) {
          if (this._parts.urn) {
            return v2 === void 0 ? "" : this;
          }
          if (v2 !== void 0) {
            if (v2 === 0) {
              v2 = null;
            }
            if (v2) {
              v2 += "";
              if (v2.charAt(0) === ":") {
                v2 = v2.substring(1);
              }
              URI3.ensureValidPort(v2);
            }
          }
          return _port.call(this, v2, build);
        };
        p2.hostname = function(v2, build) {
          if (this._parts.urn) {
            return v2 === void 0 ? "" : this;
          }
          if (v2 !== void 0) {
            var x2 = { preventInvalidHostname: this._parts.preventInvalidHostname };
            var res = URI3.parseHost(v2, x2);
            if (res !== "/") {
              throw new TypeError('Hostname "' + v2 + '" contains characters other than [A-Z0-9.-]');
            }
            v2 = x2.hostname;
            if (this._parts.preventInvalidHostname) {
              URI3.ensureValidHostname(v2, this._parts.protocol);
            }
          }
          return _hostname.call(this, v2, build);
        };
        p2.origin = function(v2, build) {
          if (this._parts.urn) {
            return v2 === void 0 ? "" : this;
          }
          if (v2 === void 0) {
            var protocol = this.protocol();
            var authority = this.authority();
            if (!authority) {
              return "";
            }
            return (protocol ? protocol + "://" : "") + this.authority();
          } else {
            var origin = URI3(v2);
            this.protocol(origin.protocol()).authority(origin.authority()).build(!build);
            return this;
          }
        };
        p2.host = function(v2, build) {
          if (this._parts.urn) {
            return v2 === void 0 ? "" : this;
          }
          if (v2 === void 0) {
            return this._parts.hostname ? URI3.buildHost(this._parts) : "";
          } else {
            var res = URI3.parseHost(v2, this._parts);
            if (res !== "/") {
              throw new TypeError('Hostname "' + v2 + '" contains characters other than [A-Z0-9.-]');
            }
            this.build(!build);
            return this;
          }
        };
        p2.authority = function(v2, build) {
          if (this._parts.urn) {
            return v2 === void 0 ? "" : this;
          }
          if (v2 === void 0) {
            return this._parts.hostname ? URI3.buildAuthority(this._parts) : "";
          } else {
            var res = URI3.parseAuthority(v2, this._parts);
            if (res !== "/") {
              throw new TypeError('Hostname "' + v2 + '" contains characters other than [A-Z0-9.-]');
            }
            this.build(!build);
            return this;
          }
        };
        p2.userinfo = function(v2, build) {
          if (this._parts.urn) {
            return v2 === void 0 ? "" : this;
          }
          if (v2 === void 0) {
            var t2 = URI3.buildUserinfo(this._parts);
            return t2 ? t2.substring(0, t2.length - 1) : t2;
          } else {
            if (v2[v2.length - 1] !== "@") {
              v2 += "@";
            }
            URI3.parseUserinfo(v2, this._parts);
            this.build(!build);
            return this;
          }
        };
        p2.resource = function(v2, build) {
          var parts;
          if (v2 === void 0) {
            return this.path() + this.search() + this.hash();
          }
          parts = URI3.parse(v2);
          this._parts.path = parts.path;
          this._parts.query = parts.query;
          this._parts.fragment = parts.fragment;
          this.build(!build);
          return this;
        };
        p2.subdomain = function(v2, build) {
          if (this._parts.urn) {
            return v2 === void 0 ? "" : this;
          }
          if (v2 === void 0) {
            if (!this._parts.hostname || this.is("IP")) {
              return "";
            }
            var end2 = this._parts.hostname.length - this.domain().length - 1;
            return this._parts.hostname.substring(0, end2) || "";
          } else {
            var e2 = this._parts.hostname.length - this.domain().length;
            var sub = this._parts.hostname.substring(0, e2);
            var replace = new RegExp("^" + escapeRegEx(sub));
            if (v2 && v2.charAt(v2.length - 1) !== ".") {
              v2 += ".";
            }
            if (v2.indexOf(":") !== -1) {
              throw new TypeError("Domains cannot contain colons");
            }
            if (v2) {
              URI3.ensureValidHostname(v2, this._parts.protocol);
            }
            this._parts.hostname = this._parts.hostname.replace(replace, v2);
            this.build(!build);
            return this;
          }
        };
        p2.domain = function(v2, build) {
          if (this._parts.urn) {
            return v2 === void 0 ? "" : this;
          }
          if (typeof v2 === "boolean") {
            build = v2;
            v2 = void 0;
          }
          if (v2 === void 0) {
            if (!this._parts.hostname || this.is("IP")) {
              return "";
            }
            var t2 = this._parts.hostname.match(/\./g);
            if (t2 && t2.length < 2) {
              return this._parts.hostname;
            }
            var end2 = this._parts.hostname.length - this.tld(build).length - 1;
            end2 = this._parts.hostname.lastIndexOf(".", end2 - 1) + 1;
            return this._parts.hostname.substring(end2) || "";
          } else {
            if (!v2) {
              throw new TypeError("cannot set domain empty");
            }
            if (v2.indexOf(":") !== -1) {
              throw new TypeError("Domains cannot contain colons");
            }
            URI3.ensureValidHostname(v2, this._parts.protocol);
            if (!this._parts.hostname || this.is("IP")) {
              this._parts.hostname = v2;
            } else {
              var replace = new RegExp(escapeRegEx(this.domain()) + "$");
              this._parts.hostname = this._parts.hostname.replace(replace, v2);
            }
            this.build(!build);
            return this;
          }
        };
        p2.tld = function(v2, build) {
          if (this._parts.urn) {
            return v2 === void 0 ? "" : this;
          }
          if (typeof v2 === "boolean") {
            build = v2;
            v2 = void 0;
          }
          if (v2 === void 0) {
            if (!this._parts.hostname || this.is("IP")) {
              return "";
            }
            var pos = this._parts.hostname.lastIndexOf(".");
            var tld = this._parts.hostname.substring(pos + 1);
            if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
              return SLD.get(this._parts.hostname) || tld;
            }
            return tld;
          } else {
            var replace;
            if (!v2) {
              throw new TypeError("cannot set TLD empty");
            } else if (v2.match(/[^a-zA-Z0-9-]/)) {
              if (SLD && SLD.is(v2)) {
                replace = new RegExp(escapeRegEx(this.tld()) + "$");
                this._parts.hostname = this._parts.hostname.replace(replace, v2);
              } else {
                throw new TypeError('TLD "' + v2 + '" contains characters other than [A-Z0-9]');
              }
            } else if (!this._parts.hostname || this.is("IP")) {
              throw new ReferenceError("cannot set TLD on non-domain host");
            } else {
              replace = new RegExp(escapeRegEx(this.tld()) + "$");
              this._parts.hostname = this._parts.hostname.replace(replace, v2);
            }
            this.build(!build);
            return this;
          }
        };
        p2.directory = function(v2, build) {
          if (this._parts.urn) {
            return v2 === void 0 ? "" : this;
          }
          if (v2 === void 0 || v2 === true) {
            if (!this._parts.path && !this._parts.hostname) {
              return "";
            }
            if (this._parts.path === "/") {
              return "/";
            }
            var end2 = this._parts.path.length - this.filename().length - 1;
            var res = this._parts.path.substring(0, end2) || (this._parts.hostname ? "/" : "");
            return v2 ? URI3.decodePath(res) : res;
          } else {
            var e2 = this._parts.path.length - this.filename().length;
            var directory = this._parts.path.substring(0, e2);
            var replace = new RegExp("^" + escapeRegEx(directory));
            if (!this.is("relative")) {
              if (!v2) {
                v2 = "/";
              }
              if (v2.charAt(0) !== "/") {
                v2 = "/" + v2;
              }
            }
            if (v2 && v2.charAt(v2.length - 1) !== "/") {
              v2 += "/";
            }
            v2 = URI3.recodePath(v2);
            this._parts.path = this._parts.path.replace(replace, v2);
            this.build(!build);
            return this;
          }
        };
        p2.filename = function(v2, build) {
          if (this._parts.urn) {
            return v2 === void 0 ? "" : this;
          }
          if (typeof v2 !== "string") {
            if (!this._parts.path || this._parts.path === "/") {
              return "";
            }
            var pos = this._parts.path.lastIndexOf("/");
            var res = this._parts.path.substring(pos + 1);
            return v2 ? URI3.decodePathSegment(res) : res;
          } else {
            var mutatedDirectory = false;
            if (v2.charAt(0) === "/") {
              v2 = v2.substring(1);
            }
            if (v2.match(/\.?\//)) {
              mutatedDirectory = true;
            }
            var replace = new RegExp(escapeRegEx(this.filename()) + "$");
            v2 = URI3.recodePath(v2);
            this._parts.path = this._parts.path.replace(replace, v2);
            if (mutatedDirectory) {
              this.normalizePath(build);
            } else {
              this.build(!build);
            }
            return this;
          }
        };
        p2.suffix = function(v2, build) {
          if (this._parts.urn) {
            return v2 === void 0 ? "" : this;
          }
          if (v2 === void 0 || v2 === true) {
            if (!this._parts.path || this._parts.path === "/") {
              return "";
            }
            var filename = this.filename();
            var pos = filename.lastIndexOf(".");
            var s2, res;
            if (pos === -1) {
              return "";
            }
            s2 = filename.substring(pos + 1);
            res = /^[a-z0-9%]+$/i.test(s2) ? s2 : "";
            return v2 ? URI3.decodePathSegment(res) : res;
          } else {
            if (v2.charAt(0) === ".") {
              v2 = v2.substring(1);
            }
            var suffix = this.suffix();
            var replace;
            if (!suffix) {
              if (!v2) {
                return this;
              }
              this._parts.path += "." + URI3.recodePath(v2);
            } else if (!v2) {
              replace = new RegExp(escapeRegEx("." + suffix) + "$");
            } else {
              replace = new RegExp(escapeRegEx(suffix) + "$");
            }
            if (replace) {
              v2 = URI3.recodePath(v2);
              this._parts.path = this._parts.path.replace(replace, v2);
            }
            this.build(!build);
            return this;
          }
        };
        p2.segment = function(segment, v2, build) {
          var separator = this._parts.urn ? ":" : "/";
          var path = this.path();
          var absolute = path.substring(0, 1) === "/";
          var segments = path.split(separator);
          if (segment !== void 0 && typeof segment !== "number") {
            build = v2;
            v2 = segment;
            segment = void 0;
          }
          if (segment !== void 0 && typeof segment !== "number") {
            throw new Error('Bad segment "' + segment + '", must be 0-based integer');
          }
          if (absolute) {
            segments.shift();
          }
          if (segment < 0) {
            segment = Math.max(segments.length + segment, 0);
          }
          if (v2 === void 0) {
            return segment === void 0 ? segments : segments[segment];
          } else if (segment === null || segments[segment] === void 0) {
            if (isArray(v2)) {
              segments = [];
              for (var i2 = 0, l2 = v2.length; i2 < l2; i2++) {
                if (!v2[i2].length && (!segments.length || !segments[segments.length - 1].length)) {
                  continue;
                }
                if (segments.length && !segments[segments.length - 1].length) {
                  segments.pop();
                }
                segments.push(trimSlashes(v2[i2]));
              }
            } else if (v2 || typeof v2 === "string") {
              v2 = trimSlashes(v2);
              if (segments[segments.length - 1] === "") {
                segments[segments.length - 1] = v2;
              } else {
                segments.push(v2);
              }
            }
          } else {
            if (v2) {
              segments[segment] = trimSlashes(v2);
            } else {
              segments.splice(segment, 1);
            }
          }
          if (absolute) {
            segments.unshift("");
          }
          return this.path(segments.join(separator), build);
        };
        p2.segmentCoded = function(segment, v2, build) {
          var segments, i2, l2;
          if (typeof segment !== "number") {
            build = v2;
            v2 = segment;
            segment = void 0;
          }
          if (v2 === void 0) {
            segments = this.segment(segment, v2, build);
            if (!isArray(segments)) {
              segments = segments !== void 0 ? URI3.decode(segments) : void 0;
            } else {
              for (i2 = 0, l2 = segments.length; i2 < l2; i2++) {
                segments[i2] = URI3.decode(segments[i2]);
              }
            }
            return segments;
          }
          if (!isArray(v2)) {
            v2 = typeof v2 === "string" || v2 instanceof String ? URI3.encode(v2) : v2;
          } else {
            for (i2 = 0, l2 = v2.length; i2 < l2; i2++) {
              v2[i2] = URI3.encode(v2[i2]);
            }
          }
          return this.segment(segment, v2, build);
        };
        var q = p2.query;
        p2.query = function(v2, build) {
          if (v2 === true) {
            return URI3.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
          } else if (typeof v2 === "function") {
            var data = URI3.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            var result = v2.call(this, data);
            this._parts.query = URI3.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
            this.build(!build);
            return this;
          } else if (v2 !== void 0 && typeof v2 !== "string") {
            this._parts.query = URI3.buildQuery(v2, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
            this.build(!build);
            return this;
          } else {
            return q.call(this, v2, build);
          }
        };
        p2.setQuery = function(name, value, build) {
          var data = URI3.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
          if (typeof name === "string" || name instanceof String) {
            data[name] = value !== void 0 ? value : null;
          } else if (typeof name === "object") {
            for (var key in name) {
              if (hasOwn.call(name, key)) {
                data[key] = name[key];
              }
            }
          } else {
            throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
          }
          this._parts.query = URI3.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
          if (typeof name !== "string") {
            build = value;
          }
          this.build(!build);
          return this;
        };
        p2.addQuery = function(name, value, build) {
          var data = URI3.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
          URI3.addQuery(data, name, value === void 0 ? null : value);
          this._parts.query = URI3.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
          if (typeof name !== "string") {
            build = value;
          }
          this.build(!build);
          return this;
        };
        p2.removeQuery = function(name, value, build) {
          var data = URI3.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
          URI3.removeQuery(data, name, value);
          this._parts.query = URI3.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
          if (typeof name !== "string") {
            build = value;
          }
          this.build(!build);
          return this;
        };
        p2.hasQuery = function(name, value, withinArray) {
          var data = URI3.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
          return URI3.hasQuery(data, name, value, withinArray);
        };
        p2.setSearch = p2.setQuery;
        p2.addSearch = p2.addQuery;
        p2.removeSearch = p2.removeQuery;
        p2.hasSearch = p2.hasQuery;
        p2.normalize = function() {
          if (this._parts.urn) {
            return this.normalizeProtocol(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
          }
          return this.normalizeProtocol(false).normalizeHostname(false).normalizePort(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
        };
        p2.normalizeProtocol = function(build) {
          if (typeof this._parts.protocol === "string") {
            this._parts.protocol = this._parts.protocol.toLowerCase();
            this.build(!build);
          }
          return this;
        };
        p2.normalizeHostname = function(build) {
          if (this._parts.hostname) {
            if (this.is("IDN") && punycode) {
              this._parts.hostname = punycode.toASCII(this._parts.hostname);
            } else if (this.is("IPv6") && IPv6) {
              this._parts.hostname = IPv6.best(this._parts.hostname);
            }
            this._parts.hostname = this._parts.hostname.toLowerCase();
            this.build(!build);
          }
          return this;
        };
        p2.normalizePort = function(build) {
          if (typeof this._parts.protocol === "string" && this._parts.port === URI3.defaultPorts[this._parts.protocol]) {
            this._parts.port = null;
            this.build(!build);
          }
          return this;
        };
        p2.normalizePath = function(build) {
          var _path = this._parts.path;
          if (!_path) {
            return this;
          }
          if (this._parts.urn) {
            this._parts.path = URI3.recodeUrnPath(this._parts.path);
            this.build(!build);
            return this;
          }
          if (this._parts.path === "/") {
            return this;
          }
          _path = URI3.recodePath(_path);
          var _was_relative;
          var _leadingParents = "";
          var _parent, _pos;
          if (_path.charAt(0) !== "/") {
            _was_relative = true;
            _path = "/" + _path;
          }
          if (_path.slice(-3) === "/.." || _path.slice(-2) === "/.") {
            _path += "/";
          }
          _path = _path.replace(/(\/(\.\/)+)|(\/\.$)/g, "/").replace(/\/{2,}/g, "/");
          if (_was_relative) {
            _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || "";
            if (_leadingParents) {
              _leadingParents = _leadingParents[0];
            }
          }
          while (true) {
            _parent = _path.search(/\/\.\.(\/|$)/);
            if (_parent === -1) {
              break;
            } else if (_parent === 0) {
              _path = _path.substring(3);
              continue;
            }
            _pos = _path.substring(0, _parent).lastIndexOf("/");
            if (_pos === -1) {
              _pos = _parent;
            }
            _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
          }
          if (_was_relative && this.is("relative")) {
            _path = _leadingParents + _path.substring(1);
          }
          this._parts.path = _path;
          this.build(!build);
          return this;
        };
        p2.normalizePathname = p2.normalizePath;
        p2.normalizeQuery = function(build) {
          if (typeof this._parts.query === "string") {
            if (!this._parts.query.length) {
              this._parts.query = null;
            } else {
              this.query(URI3.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
            }
            this.build(!build);
          }
          return this;
        };
        p2.normalizeFragment = function(build) {
          if (!this._parts.fragment) {
            this._parts.fragment = null;
            this.build(!build);
          }
          return this;
        };
        p2.normalizeSearch = p2.normalizeQuery;
        p2.normalizeHash = p2.normalizeFragment;
        p2.iso8859 = function() {
          var e2 = URI3.encode;
          var d2 = URI3.decode;
          URI3.encode = escape;
          URI3.decode = decodeURIComponent;
          try {
            this.normalize();
          } finally {
            URI3.encode = e2;
            URI3.decode = d2;
          }
          return this;
        };
        p2.unicode = function() {
          var e2 = URI3.encode;
          var d2 = URI3.decode;
          URI3.encode = strictEncodeURIComponent;
          URI3.decode = unescape;
          try {
            this.normalize();
          } finally {
            URI3.encode = e2;
            URI3.decode = d2;
          }
          return this;
        };
        p2.readable = function() {
          var uri = this.clone();
          uri.username("").password("").normalize();
          var t2 = "";
          if (uri._parts.protocol) {
            t2 += uri._parts.protocol + "://";
          }
          if (uri._parts.hostname) {
            if (uri.is("punycode") && punycode) {
              t2 += punycode.toUnicode(uri._parts.hostname);
              if (uri._parts.port) {
                t2 += ":" + uri._parts.port;
              }
            } else {
              t2 += uri.host();
            }
          }
          if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== "/") {
            t2 += "/";
          }
          t2 += uri.path(true);
          if (uri._parts.query) {
            var q2 = "";
            for (var i2 = 0, qp = uri._parts.query.split("&"), l2 = qp.length; i2 < l2; i2++) {
              var kv = (qp[i2] || "").split("=");
              q2 += "&" + URI3.decodeQuery(kv[0], this._parts.escapeQuerySpace).replace(/&/g, "%26");
              if (kv[1] !== void 0) {
                q2 += "=" + URI3.decodeQuery(kv[1], this._parts.escapeQuerySpace).replace(/&/g, "%26");
              }
            }
            t2 += "?" + q2.substring(1);
          }
          t2 += URI3.decodeQuery(uri.hash(), true);
          return t2;
        };
        p2.absoluteTo = function(base) {
          var resolved = this.clone();
          var properties = ["protocol", "username", "password", "hostname", "port"];
          var basedir, i2, p3;
          if (this._parts.urn) {
            throw new Error("URNs do not have any generally defined hierarchical components");
          }
          if (!(base instanceof URI3)) {
            base = new URI3(base);
          }
          if (resolved._parts.protocol) {
            return resolved;
          } else {
            resolved._parts.protocol = base._parts.protocol;
          }
          if (this._parts.hostname) {
            return resolved;
          }
          for (i2 = 0; p3 = properties[i2]; i2++) {
            resolved._parts[p3] = base._parts[p3];
          }
          if (!resolved._parts.path) {
            resolved._parts.path = base._parts.path;
            if (!resolved._parts.query) {
              resolved._parts.query = base._parts.query;
            }
          } else {
            if (resolved._parts.path.substring(-2) === "..") {
              resolved._parts.path += "/";
            }
            if (resolved.path().charAt(0) !== "/") {
              basedir = base.directory();
              basedir = basedir ? basedir : base.path().indexOf("/") === 0 ? "/" : "";
              resolved._parts.path = (basedir ? basedir + "/" : "") + resolved._parts.path;
              resolved.normalizePath();
            }
          }
          resolved.build();
          return resolved;
        };
        p2.relativeTo = function(base) {
          var relative = this.clone().normalize();
          var relativeParts, baseParts, common, relativePath, basePath;
          if (relative._parts.urn) {
            throw new Error("URNs do not have any generally defined hierarchical components");
          }
          base = new URI3(base).normalize();
          relativeParts = relative._parts;
          baseParts = base._parts;
          relativePath = relative.path();
          basePath = base.path();
          if (relativePath.charAt(0) !== "/") {
            throw new Error("URI is already relative");
          }
          if (basePath.charAt(0) !== "/") {
            throw new Error("Cannot calculate a URI relative to another relative URI");
          }
          if (relativeParts.protocol === baseParts.protocol) {
            relativeParts.protocol = null;
          }
          if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {
            return relative.build();
          }
          if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {
            return relative.build();
          }
          if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
            relativeParts.hostname = null;
            relativeParts.port = null;
          } else {
            return relative.build();
          }
          if (relativePath === basePath) {
            relativeParts.path = "";
            return relative.build();
          }
          common = URI3.commonPath(relativePath, basePath);
          if (!common) {
            return relative.build();
          }
          var parents = baseParts.path.substring(common.length).replace(/[^\/]*$/, "").replace(/.*?\//g, "../");
          relativeParts.path = parents + relativeParts.path.substring(common.length) || "./";
          return relative.build();
        };
        p2.equals = function(uri) {
          var one = this.clone();
          var two = new URI3(uri);
          var one_map = {};
          var two_map = {};
          var checked = {};
          var one_query, two_query, key;
          one.normalize();
          two.normalize();
          if (one.toString() === two.toString()) {
            return true;
          }
          one_query = one.query();
          two_query = two.query();
          one.query("");
          two.query("");
          if (one.toString() !== two.toString()) {
            return false;
          }
          if (one_query.length !== two_query.length) {
            return false;
          }
          one_map = URI3.parseQuery(one_query, this._parts.escapeQuerySpace);
          two_map = URI3.parseQuery(two_query, this._parts.escapeQuerySpace);
          for (key in one_map) {
            if (hasOwn.call(one_map, key)) {
              if (!isArray(one_map[key])) {
                if (one_map[key] !== two_map[key]) {
                  return false;
                }
              } else if (!arraysEqual(one_map[key], two_map[key])) {
                return false;
              }
              checked[key] = true;
            }
          }
          for (key in two_map) {
            if (hasOwn.call(two_map, key)) {
              if (!checked[key]) {
                return false;
              }
            }
          }
          return true;
        };
        p2.preventInvalidHostname = function(v2) {
          this._parts.preventInvalidHostname = !!v2;
          return this;
        };
        p2.duplicateQueryParameters = function(v2) {
          this._parts.duplicateQueryParameters = !!v2;
          return this;
        };
        p2.escapeQuerySpace = function(v2) {
          this._parts.escapeQuerySpace = !!v2;
          return this;
        };
        return URI3;
      });
    }
  });

  // node_modules/codemirror/lib/codemirror.js
  var require_codemirror = __commonJS({
    "node_modules/codemirror/lib/codemirror.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.CodeMirror = factory());
      })(exports, function() {
        "use strict";
        var userAgent = navigator.userAgent;
        var platform = navigator.platform;
        var gecko = /gecko\/\d/i.test(userAgent);
        var ie_upto10 = /MSIE \d/.test(userAgent);
        var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
        var edge = /Edge\/(\d+)/.exec(userAgent);
        var ie = ie_upto10 || ie_11up || edge;
        var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
        var webkit = !edge && /WebKit\//.test(userAgent);
        var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
        var chrome2 = !edge && /Chrome\//.test(userAgent);
        var presto = /Opera\//.test(userAgent);
        var safari = /Apple Computer/.test(navigator.vendor);
        var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
        var phantom = /PhantomJS/.test(userAgent);
        var ios = safari && (/Mobile\/\w+/.test(userAgent) || navigator.maxTouchPoints > 2);
        var android = /Android/.test(userAgent);
        var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
        var mac = ios || /Mac/.test(platform);
        var chromeOS = /\bCrOS\b/.test(userAgent);
        var windows = /win/i.test(platform);
        var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
        if (presto_version) {
          presto_version = Number(presto_version[1]);
        }
        if (presto_version && presto_version >= 15) {
          presto = false;
          webkit = true;
        }
        var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
        var captureRightClick = gecko || ie && ie_version >= 9;
        function classTest(cls) {
          return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
        }
        var rmClass = function(node, cls) {
          var current = node.className;
          var match = classTest(cls).exec(current);
          if (match) {
            var after = current.slice(match.index + match[0].length);
            node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
          }
        };
        function removeChildren(e2) {
          for (var count = e2.childNodes.length; count > 0; --count) {
            e2.removeChild(e2.firstChild);
          }
          return e2;
        }
        function removeChildrenAndAdd(parent, e2) {
          return removeChildren(parent).appendChild(e2);
        }
        function elt(tag, content, className, style) {
          var e2 = document.createElement(tag);
          if (className) {
            e2.className = className;
          }
          if (style) {
            e2.style.cssText = style;
          }
          if (typeof content == "string") {
            e2.appendChild(document.createTextNode(content));
          } else if (content) {
            for (var i3 = 0; i3 < content.length; ++i3) {
              e2.appendChild(content[i3]);
            }
          }
          return e2;
        }
        function eltP(tag, content, className, style) {
          var e2 = elt(tag, content, className, style);
          e2.setAttribute("role", "presentation");
          return e2;
        }
        var range;
        if (document.createRange) {
          range = function(node, start4, end2, endNode) {
            var r2 = document.createRange();
            r2.setEnd(endNode || node, end2);
            r2.setStart(node, start4);
            return r2;
          };
        } else {
          range = function(node, start4, end2) {
            var r2 = document.body.createTextRange();
            try {
              r2.moveToElementText(node.parentNode);
            } catch (e2) {
              return r2;
            }
            r2.collapse(true);
            r2.moveEnd("character", end2);
            r2.moveStart("character", start4);
            return r2;
          };
        }
        function contains2(parent, child) {
          if (child.nodeType == 3) {
            child = child.parentNode;
          }
          if (parent.contains) {
            return parent.contains(child);
          }
          do {
            if (child.nodeType == 11) {
              child = child.host;
            }
            if (child == parent) {
              return true;
            }
          } while (child = child.parentNode);
        }
        function activeElt() {
          var activeElement;
          try {
            activeElement = document.activeElement;
          } catch (e2) {
            activeElement = document.body || null;
          }
          while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
            activeElement = activeElement.shadowRoot.activeElement;
          }
          return activeElement;
        }
        function addClass(node, cls) {
          var current = node.className;
          if (!classTest(cls).test(current)) {
            node.className += (current ? " " : "") + cls;
          }
        }
        function joinClasses(a2, b2) {
          var as = a2.split(" ");
          for (var i3 = 0; i3 < as.length; i3++) {
            if (as[i3] && !classTest(as[i3]).test(b2)) {
              b2 += " " + as[i3];
            }
          }
          return b2;
        }
        var selectInput = function(node) {
          node.select();
        };
        if (ios) {
          selectInput = function(node) {
            node.selectionStart = 0;
            node.selectionEnd = node.value.length;
          };
        } else if (ie) {
          selectInput = function(node) {
            try {
              node.select();
            } catch (_e) {
            }
          };
        }
        function bind3(f2) {
          var args = Array.prototype.slice.call(arguments, 1);
          return function() {
            return f2.apply(null, args);
          };
        }
        function copyObj(obj, target, overwrite) {
          if (!target) {
            target = {};
          }
          for (var prop2 in obj) {
            if (obj.hasOwnProperty(prop2) && (overwrite !== false || !target.hasOwnProperty(prop2))) {
              target[prop2] = obj[prop2];
            }
          }
          return target;
        }
        function countColumn(string, end2, tabSize, startIndex, startValue) {
          if (end2 == null) {
            end2 = string.search(/[^\s\u00a0]/);
            if (end2 == -1) {
              end2 = string.length;
            }
          }
          for (var i3 = startIndex || 0, n2 = startValue || 0; ; ) {
            var nextTab = string.indexOf("	", i3);
            if (nextTab < 0 || nextTab >= end2) {
              return n2 + (end2 - i3);
            }
            n2 += nextTab - i3;
            n2 += tabSize - n2 % tabSize;
            i3 = nextTab + 1;
          }
        }
        var Delayed = function() {
          this.id = null;
          this.f = null;
          this.time = 0;
          this.handler = bind3(this.onTimeout, this);
        };
        Delayed.prototype.onTimeout = function(self2) {
          self2.id = 0;
          if (self2.time <= +new Date()) {
            self2.f();
          } else {
            setTimeout(self2.handler, self2.time - +new Date());
          }
        };
        Delayed.prototype.set = function(ms, f2) {
          this.f = f2;
          var time = +new Date() + ms;
          if (!this.id || time < this.time) {
            clearTimeout(this.id);
            this.id = setTimeout(this.handler, ms);
            this.time = time;
          }
        };
        function indexOf2(array, elt2) {
          for (var i3 = 0; i3 < array.length; ++i3) {
            if (array[i3] == elt2) {
              return i3;
            }
          }
          return -1;
        }
        var scrollerGap = 50;
        var Pass = { toString: function() {
          return "CodeMirror.Pass";
        } };
        var sel_dontScroll = { scroll: false }, sel_mouse = { origin: "*mouse" }, sel_move = { origin: "+move" };
        function findColumn(string, goal, tabSize) {
          for (var pos = 0, col = 0; ; ) {
            var nextTab = string.indexOf("	", pos);
            if (nextTab == -1) {
              nextTab = string.length;
            }
            var skipped = nextTab - pos;
            if (nextTab == string.length || col + skipped >= goal) {
              return pos + Math.min(skipped, goal - col);
            }
            col += nextTab - pos;
            col += tabSize - col % tabSize;
            pos = nextTab + 1;
            if (col >= goal) {
              return pos;
            }
          }
        }
        var spaceStrs = [""];
        function spaceStr(n2) {
          while (spaceStrs.length <= n2) {
            spaceStrs.push(lst(spaceStrs) + " ");
          }
          return spaceStrs[n2];
        }
        function lst(arr) {
          return arr[arr.length - 1];
        }
        function map(array, f2) {
          var out = [];
          for (var i3 = 0; i3 < array.length; i3++) {
            out[i3] = f2(array[i3], i3);
          }
          return out;
        }
        function insertSorted(array, value, score) {
          var pos = 0, priority = score(value);
          while (pos < array.length && score(array[pos]) <= priority) {
            pos++;
          }
          array.splice(pos, 0, value);
        }
        function nothing() {
        }
        function createObj(base, props) {
          var inst;
          if (Object.create) {
            inst = Object.create(base);
          } else {
            nothing.prototype = base;
            inst = new nothing();
          }
          if (props) {
            copyObj(props, inst);
          }
          return inst;
        }
        var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
        function isWordCharBasic(ch) {
          return /\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
        }
        function isWordChar(ch, helper) {
          if (!helper) {
            return isWordCharBasic(ch);
          }
          if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) {
            return true;
          }
          return helper.test(ch);
        }
        function isEmpty(obj) {
          for (var n2 in obj) {
            if (obj.hasOwnProperty(n2) && obj[n2]) {
              return false;
            }
          }
          return true;
        }
        var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
        function isExtendingChar(ch) {
          return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
        }
        function skipExtendingChars(str, pos, dir) {
          while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {
            pos += dir;
          }
          return pos;
        }
        function findFirst(pred, from, to) {
          var dir = from > to ? -1 : 1;
          for (; ; ) {
            if (from == to) {
              return from;
            }
            var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
            if (mid == from) {
              return pred(mid) ? from : to;
            }
            if (pred(mid)) {
              to = mid;
            } else {
              from = mid + dir;
            }
          }
        }
        function iterateBidiSections(order2, from, to, f2) {
          if (!order2) {
            return f2(from, to, "ltr", 0);
          }
          var found = false;
          for (var i3 = 0; i3 < order2.length; ++i3) {
            var part = order2[i3];
            if (part.from < to && part.to > from || from == to && part.to == from) {
              f2(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i3);
              found = true;
            }
          }
          if (!found) {
            f2(from, to, "ltr");
          }
        }
        var bidiOther = null;
        function getBidiPartAt(order2, ch, sticky) {
          var found;
          bidiOther = null;
          for (var i3 = 0; i3 < order2.length; ++i3) {
            var cur = order2[i3];
            if (cur.from < ch && cur.to > ch) {
              return i3;
            }
            if (cur.to == ch) {
              if (cur.from != cur.to && sticky == "before") {
                found = i3;
              } else {
                bidiOther = i3;
              }
            }
            if (cur.from == ch) {
              if (cur.from != cur.to && sticky != "before") {
                found = i3;
              } else {
                bidiOther = i3;
              }
            }
          }
          return found != null ? found : bidiOther;
        }
        var bidiOrdering = function() {
          var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
          var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
          function charType(code3) {
            if (code3 <= 247) {
              return lowTypes.charAt(code3);
            } else if (1424 <= code3 && code3 <= 1524) {
              return "R";
            } else if (1536 <= code3 && code3 <= 1785) {
              return arabicTypes.charAt(code3 - 1536);
            } else if (1774 <= code3 && code3 <= 2220) {
              return "r";
            } else if (8192 <= code3 && code3 <= 8203) {
              return "w";
            } else if (code3 == 8204) {
              return "b";
            } else {
              return "L";
            }
          }
          var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
          var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
          function BidiSpan(level, from, to) {
            this.level = level;
            this.from = from;
            this.to = to;
          }
          return function(str, direction) {
            var outerType = direction == "ltr" ? "L" : "R";
            if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {
              return false;
            }
            var len = str.length, types = [];
            for (var i3 = 0; i3 < len; ++i3) {
              types.push(charType(str.charCodeAt(i3)));
            }
            for (var i$12 = 0, prev = outerType; i$12 < len; ++i$12) {
              var type = types[i$12];
              if (type == "m") {
                types[i$12] = prev;
              } else {
                prev = type;
              }
            }
            for (var i$22 = 0, cur = outerType; i$22 < len; ++i$22) {
              var type$1 = types[i$22];
              if (type$1 == "1" && cur == "r") {
                types[i$22] = "n";
              } else if (isStrong.test(type$1)) {
                cur = type$1;
                if (type$1 == "r") {
                  types[i$22] = "R";
                }
              }
            }
            for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
              var type$2 = types[i$3];
              if (type$2 == "+" && prev$1 == "1" && types[i$3 + 1] == "1") {
                types[i$3] = "1";
              } else if (type$2 == "," && prev$1 == types[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
                types[i$3] = prev$1;
              }
              prev$1 = type$2;
            }
            for (var i$4 = 0; i$4 < len; ++i$4) {
              var type$3 = types[i$4];
              if (type$3 == ",") {
                types[i$4] = "N";
              } else if (type$3 == "%") {
                var end2 = void 0;
                for (end2 = i$4 + 1; end2 < len && types[end2] == "%"; ++end2) {
                }
                var replace = i$4 && types[i$4 - 1] == "!" || end2 < len && types[end2] == "1" ? "1" : "N";
                for (var j2 = i$4; j2 < end2; ++j2) {
                  types[j2] = replace;
                }
                i$4 = end2 - 1;
              }
            }
            for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
              var type$4 = types[i$5];
              if (cur$1 == "L" && type$4 == "1") {
                types[i$5] = "L";
              } else if (isStrong.test(type$4)) {
                cur$1 = type$4;
              }
            }
            for (var i$6 = 0; i$6 < len; ++i$6) {
              if (isNeutral.test(types[i$6])) {
                var end$1 = void 0;
                for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {
                }
                var before = (i$6 ? types[i$6 - 1] : outerType) == "L";
                var after = (end$1 < len ? types[end$1] : outerType) == "L";
                var replace$1 = before == after ? before ? "L" : "R" : outerType;
                for (var j$1 = i$6; j$1 < end$1; ++j$1) {
                  types[j$1] = replace$1;
                }
                i$6 = end$1 - 1;
              }
            }
            var order2 = [], m2;
            for (var i$7 = 0; i$7 < len; ) {
              if (countsAsLeft.test(types[i$7])) {
                var start4 = i$7;
                for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {
                }
                order2.push(new BidiSpan(0, start4, i$7));
              } else {
                var pos = i$7, at = order2.length, isRTL = direction == "rtl" ? 1 : 0;
                for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {
                }
                for (var j$2 = pos; j$2 < i$7; ) {
                  if (countsAsNum.test(types[j$2])) {
                    if (pos < j$2) {
                      order2.splice(at, 0, new BidiSpan(1, pos, j$2));
                      at += isRTL;
                    }
                    var nstart = j$2;
                    for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {
                    }
                    order2.splice(at, 0, new BidiSpan(2, nstart, j$2));
                    at += isRTL;
                    pos = j$2;
                  } else {
                    ++j$2;
                  }
                }
                if (pos < i$7) {
                  order2.splice(at, 0, new BidiSpan(1, pos, i$7));
                }
              }
            }
            if (direction == "ltr") {
              if (order2[0].level == 1 && (m2 = str.match(/^\s+/))) {
                order2[0].from = m2[0].length;
                order2.unshift(new BidiSpan(0, 0, m2[0].length));
              }
              if (lst(order2).level == 1 && (m2 = str.match(/\s+$/))) {
                lst(order2).to -= m2[0].length;
                order2.push(new BidiSpan(0, len - m2[0].length, len));
              }
            }
            return direction == "rtl" ? order2.reverse() : order2;
          };
        }();
        function getOrder(line, direction) {
          var order2 = line.order;
          if (order2 == null) {
            order2 = line.order = bidiOrdering(line.text, direction);
          }
          return order2;
        }
        var noHandlers = [];
        var on = function(emitter, type, f2) {
          if (emitter.addEventListener) {
            emitter.addEventListener(type, f2, false);
          } else if (emitter.attachEvent) {
            emitter.attachEvent("on" + type, f2);
          } else {
            var map2 = emitter._handlers || (emitter._handlers = {});
            map2[type] = (map2[type] || noHandlers).concat(f2);
          }
        };
        function getHandlers(emitter, type) {
          return emitter._handlers && emitter._handlers[type] || noHandlers;
        }
        function off(emitter, type, f2) {
          if (emitter.removeEventListener) {
            emitter.removeEventListener(type, f2, false);
          } else if (emitter.detachEvent) {
            emitter.detachEvent("on" + type, f2);
          } else {
            var map2 = emitter._handlers, arr = map2 && map2[type];
            if (arr) {
              var index = indexOf2(arr, f2);
              if (index > -1) {
                map2[type] = arr.slice(0, index).concat(arr.slice(index + 1));
              }
            }
          }
        }
        function signal(emitter, type) {
          var handlers = getHandlers(emitter, type);
          if (!handlers.length) {
            return;
          }
          var args = Array.prototype.slice.call(arguments, 2);
          for (var i3 = 0; i3 < handlers.length; ++i3) {
            handlers[i3].apply(null, args);
          }
        }
        function signalDOMEvent(cm, e2, override) {
          if (typeof e2 == "string") {
            e2 = { type: e2, preventDefault: function() {
              this.defaultPrevented = true;
            } };
          }
          signal(cm, override || e2.type, cm, e2);
          return e_defaultPrevented(e2) || e2.codemirrorIgnore;
        }
        function signalCursorActivity(cm) {
          var arr = cm._handlers && cm._handlers.cursorActivity;
          if (!arr) {
            return;
          }
          var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
          for (var i3 = 0; i3 < arr.length; ++i3) {
            if (indexOf2(set, arr[i3]) == -1) {
              set.push(arr[i3]);
            }
          }
        }
        function hasHandler(emitter, type) {
          return getHandlers(emitter, type).length > 0;
        }
        function eventMixin(ctor) {
          ctor.prototype.on = function(type, f2) {
            on(this, type, f2);
          };
          ctor.prototype.off = function(type, f2) {
            off(this, type, f2);
          };
        }
        function e_preventDefault(e2) {
          if (e2.preventDefault) {
            e2.preventDefault();
          } else {
            e2.returnValue = false;
          }
        }
        function e_stopPropagation(e2) {
          if (e2.stopPropagation) {
            e2.stopPropagation();
          } else {
            e2.cancelBubble = true;
          }
        }
        function e_defaultPrevented(e2) {
          return e2.defaultPrevented != null ? e2.defaultPrevented : e2.returnValue == false;
        }
        function e_stop(e2) {
          e_preventDefault(e2);
          e_stopPropagation(e2);
        }
        function e_target(e2) {
          return e2.target || e2.srcElement;
        }
        function e_button(e2) {
          var b2 = e2.which;
          if (b2 == null) {
            if (e2.button & 1) {
              b2 = 1;
            } else if (e2.button & 2) {
              b2 = 3;
            } else if (e2.button & 4) {
              b2 = 2;
            }
          }
          if (mac && e2.ctrlKey && b2 == 1) {
            b2 = 3;
          }
          return b2;
        }
        var dragAndDrop = function() {
          if (ie && ie_version < 9) {
            return false;
          }
          var div2 = elt("div");
          return "draggable" in div2 || "dragDrop" in div2;
        }();
        var zwspSupported;
        function zeroWidthElement(measure) {
          if (zwspSupported == null) {
            var test = elt("span", "\u200B");
            removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
            if (measure.firstChild.offsetHeight != 0) {
              zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
            }
          }
          var node = zwspSupported ? elt("span", "\u200B") : elt("span", "\xA0", null, "display: inline-block; width: 1px; margin-right: -1px");
          node.setAttribute("cm-text", "");
          return node;
        }
        var badBidiRects;
        function hasBadBidiRects(measure) {
          if (badBidiRects != null) {
            return badBidiRects;
          }
          var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062EA"));
          var r0 = range(txt, 0, 1).getBoundingClientRect();
          var r1 = range(txt, 1, 2).getBoundingClientRect();
          removeChildren(measure);
          if (!r0 || r0.left == r0.right) {
            return false;
          }
          return badBidiRects = r1.right - r0.right < 3;
        }
        var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function(string) {
          var pos = 0, result = [], l2 = string.length;
          while (pos <= l2) {
            var nl = string.indexOf("\n", pos);
            if (nl == -1) {
              nl = string.length;
            }
            var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
            var rt = line.indexOf("\r");
            if (rt != -1) {
              result.push(line.slice(0, rt));
              pos += rt + 1;
            } else {
              result.push(line);
              pos = nl + 1;
            }
          }
          return result;
        } : function(string) {
          return string.split(/\r\n?|\n/);
        };
        var hasSelection = window.getSelection ? function(te) {
          try {
            return te.selectionStart != te.selectionEnd;
          } catch (e2) {
            return false;
          }
        } : function(te) {
          var range2;
          try {
            range2 = te.ownerDocument.selection.createRange();
          } catch (e2) {
          }
          if (!range2 || range2.parentElement() != te) {
            return false;
          }
          return range2.compareEndPoints("StartToEnd", range2) != 0;
        };
        var hasCopyEvent = function() {
          var e2 = elt("div");
          if ("oncopy" in e2) {
            return true;
          }
          e2.setAttribute("oncopy", "return;");
          return typeof e2.oncopy == "function";
        }();
        var badZoomedRects = null;
        function hasBadZoomedRects(measure) {
          if (badZoomedRects != null) {
            return badZoomedRects;
          }
          var node = removeChildrenAndAdd(measure, elt("span", "x"));
          var normal = node.getBoundingClientRect();
          var fromRange = range(node, 0, 1).getBoundingClientRect();
          return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
        }
        var modes = {}, mimeModes = {};
        function defineMode(name, mode) {
          if (arguments.length > 2) {
            mode.dependencies = Array.prototype.slice.call(arguments, 2);
          }
          modes[name] = mode;
        }
        function defineMIME(mime, spec) {
          mimeModes[mime] = spec;
        }
        function resolveMode(spec) {
          if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
            spec = mimeModes[spec];
          } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
            var found = mimeModes[spec.name];
            if (typeof found == "string") {
              found = { name: found };
            }
            spec = createObj(found, spec);
            spec.name = found.name;
          } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
            return resolveMode("application/xml");
          } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
            return resolveMode("application/json");
          }
          if (typeof spec == "string") {
            return { name: spec };
          } else {
            return spec || { name: "null" };
          }
        }
        function getMode(options, spec) {
          spec = resolveMode(spec);
          var mfactory = modes[spec.name];
          if (!mfactory) {
            return getMode(options, "text/plain");
          }
          var modeObj = mfactory(options, spec);
          if (modeExtensions.hasOwnProperty(spec.name)) {
            var exts = modeExtensions[spec.name];
            for (var prop2 in exts) {
              if (!exts.hasOwnProperty(prop2)) {
                continue;
              }
              if (modeObj.hasOwnProperty(prop2)) {
                modeObj["_" + prop2] = modeObj[prop2];
              }
              modeObj[prop2] = exts[prop2];
            }
          }
          modeObj.name = spec.name;
          if (spec.helperType) {
            modeObj.helperType = spec.helperType;
          }
          if (spec.modeProps) {
            for (var prop$1 in spec.modeProps) {
              modeObj[prop$1] = spec.modeProps[prop$1];
            }
          }
          return modeObj;
        }
        var modeExtensions = {};
        function extendMode(mode, properties) {
          var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
          copyObj(properties, exts);
        }
        function copyState(mode, state) {
          if (state === true) {
            return state;
          }
          if (mode.copyState) {
            return mode.copyState(state);
          }
          var nstate = {};
          for (var n2 in state) {
            var val = state[n2];
            if (val instanceof Array) {
              val = val.concat([]);
            }
            nstate[n2] = val;
          }
          return nstate;
        }
        function innerMode(mode, state) {
          var info;
          while (mode.innerMode) {
            info = mode.innerMode(state);
            if (!info || info.mode == mode) {
              break;
            }
            state = info.state;
            mode = info.mode;
          }
          return info || { mode, state };
        }
        function startState(mode, a1, a2) {
          return mode.startState ? mode.startState(a1, a2) : true;
        }
        var StringStream = function(string, tabSize, lineOracle) {
          this.pos = this.start = 0;
          this.string = string;
          this.tabSize = tabSize || 8;
          this.lastColumnPos = this.lastColumnValue = 0;
          this.lineStart = 0;
          this.lineOracle = lineOracle;
        };
        StringStream.prototype.eol = function() {
          return this.pos >= this.string.length;
        };
        StringStream.prototype.sol = function() {
          return this.pos == this.lineStart;
        };
        StringStream.prototype.peek = function() {
          return this.string.charAt(this.pos) || void 0;
        };
        StringStream.prototype.next = function() {
          if (this.pos < this.string.length) {
            return this.string.charAt(this.pos++);
          }
        };
        StringStream.prototype.eat = function(match) {
          var ch = this.string.charAt(this.pos);
          var ok;
          if (typeof match == "string") {
            ok = ch == match;
          } else {
            ok = ch && (match.test ? match.test(ch) : match(ch));
          }
          if (ok) {
            ++this.pos;
            return ch;
          }
        };
        StringStream.prototype.eatWhile = function(match) {
          var start4 = this.pos;
          while (this.eat(match)) {
          }
          return this.pos > start4;
        };
        StringStream.prototype.eatSpace = function() {
          var start4 = this.pos;
          while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
            ++this.pos;
          }
          return this.pos > start4;
        };
        StringStream.prototype.skipToEnd = function() {
          this.pos = this.string.length;
        };
        StringStream.prototype.skipTo = function(ch) {
          var found = this.string.indexOf(ch, this.pos);
          if (found > -1) {
            this.pos = found;
            return true;
          }
        };
        StringStream.prototype.backUp = function(n2) {
          this.pos -= n2;
        };
        StringStream.prototype.column = function() {
          if (this.lastColumnPos < this.start) {
            this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
            this.lastColumnPos = this.start;
          }
          return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
        };
        StringStream.prototype.indentation = function() {
          return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
        };
        StringStream.prototype.match = function(pattern, consume, caseInsensitive) {
          if (typeof pattern == "string") {
            var cased = function(str) {
              return caseInsensitive ? str.toLowerCase() : str;
            };
            var substr = this.string.substr(this.pos, pattern.length);
            if (cased(substr) == cased(pattern)) {
              if (consume !== false) {
                this.pos += pattern.length;
              }
              return true;
            }
          } else {
            var match = this.string.slice(this.pos).match(pattern);
            if (match && match.index > 0) {
              return null;
            }
            if (match && consume !== false) {
              this.pos += match[0].length;
            }
            return match;
          }
        };
        StringStream.prototype.current = function() {
          return this.string.slice(this.start, this.pos);
        };
        StringStream.prototype.hideFirstChars = function(n2, inner) {
          this.lineStart += n2;
          try {
            return inner();
          } finally {
            this.lineStart -= n2;
          }
        };
        StringStream.prototype.lookAhead = function(n2) {
          var oracle = this.lineOracle;
          return oracle && oracle.lookAhead(n2);
        };
        StringStream.prototype.baseToken = function() {
          var oracle = this.lineOracle;
          return oracle && oracle.baseToken(this.pos);
        };
        function getLine(doc, n2) {
          n2 -= doc.first;
          if (n2 < 0 || n2 >= doc.size) {
            throw new Error("There is no line " + (n2 + doc.first) + " in the document.");
          }
          var chunk = doc;
          while (!chunk.lines) {
            for (var i3 = 0; ; ++i3) {
              var child = chunk.children[i3], sz = child.chunkSize();
              if (n2 < sz) {
                chunk = child;
                break;
              }
              n2 -= sz;
            }
          }
          return chunk.lines[n2];
        }
        function getBetween(doc, start4, end2) {
          var out = [], n2 = start4.line;
          doc.iter(start4.line, end2.line + 1, function(line) {
            var text = line.text;
            if (n2 == end2.line) {
              text = text.slice(0, end2.ch);
            }
            if (n2 == start4.line) {
              text = text.slice(start4.ch);
            }
            out.push(text);
            ++n2;
          });
          return out;
        }
        function getLines(doc, from, to) {
          var out = [];
          doc.iter(from, to, function(line) {
            out.push(line.text);
          });
          return out;
        }
        function updateLineHeight(line, height) {
          var diff = height - line.height;
          if (diff) {
            for (var n2 = line; n2; n2 = n2.parent) {
              n2.height += diff;
            }
          }
        }
        function lineNo(line) {
          if (line.parent == null) {
            return null;
          }
          var cur = line.parent, no = indexOf2(cur.lines, line);
          for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
            for (var i3 = 0; ; ++i3) {
              if (chunk.children[i3] == cur) {
                break;
              }
              no += chunk.children[i3].chunkSize();
            }
          }
          return no + cur.first;
        }
        function lineAtHeight(chunk, h) {
          var n2 = chunk.first;
          outer:
            do {
              for (var i$12 = 0; i$12 < chunk.children.length; ++i$12) {
                var child = chunk.children[i$12], ch = child.height;
                if (h < ch) {
                  chunk = child;
                  continue outer;
                }
                h -= ch;
                n2 += child.chunkSize();
              }
              return n2;
            } while (!chunk.lines);
          var i3 = 0;
          for (; i3 < chunk.lines.length; ++i3) {
            var line = chunk.lines[i3], lh = line.height;
            if (h < lh) {
              break;
            }
            h -= lh;
          }
          return n2 + i3;
        }
        function isLine(doc, l2) {
          return l2 >= doc.first && l2 < doc.first + doc.size;
        }
        function lineNumberFor(options, i3) {
          return String(options.lineNumberFormatter(i3 + options.firstLineNumber));
        }
        function Pos(line, ch, sticky) {
          if (sticky === void 0)
            sticky = null;
          if (!(this instanceof Pos)) {
            return new Pos(line, ch, sticky);
          }
          this.line = line;
          this.ch = ch;
          this.sticky = sticky;
        }
        function cmp(a2, b2) {
          return a2.line - b2.line || a2.ch - b2.ch;
        }
        function equalCursorPos(a2, b2) {
          return a2.sticky == b2.sticky && cmp(a2, b2) == 0;
        }
        function copyPos(x2) {
          return Pos(x2.line, x2.ch);
        }
        function maxPos(a2, b2) {
          return cmp(a2, b2) < 0 ? b2 : a2;
        }
        function minPos(a2, b2) {
          return cmp(a2, b2) < 0 ? a2 : b2;
        }
        function clipLine(doc, n2) {
          return Math.max(doc.first, Math.min(n2, doc.first + doc.size - 1));
        }
        function clipPos(doc, pos) {
          if (pos.line < doc.first) {
            return Pos(doc.first, 0);
          }
          var last = doc.first + doc.size - 1;
          if (pos.line > last) {
            return Pos(last, getLine(doc, last).text.length);
          }
          return clipToLen(pos, getLine(doc, pos.line).text.length);
        }
        function clipToLen(pos, linelen) {
          var ch = pos.ch;
          if (ch == null || ch > linelen) {
            return Pos(pos.line, linelen);
          } else if (ch < 0) {
            return Pos(pos.line, 0);
          } else {
            return pos;
          }
        }
        function clipPosArray(doc, array) {
          var out = [];
          for (var i3 = 0; i3 < array.length; i3++) {
            out[i3] = clipPos(doc, array[i3]);
          }
          return out;
        }
        var SavedContext = function(state, lookAhead) {
          this.state = state;
          this.lookAhead = lookAhead;
        };
        var Context2 = function(doc, state, line, lookAhead) {
          this.state = state;
          this.doc = doc;
          this.line = line;
          this.maxLookAhead = lookAhead || 0;
          this.baseTokens = null;
          this.baseTokenPos = 1;
        };
        Context2.prototype.lookAhead = function(n2) {
          var line = this.doc.getLine(this.line + n2);
          if (line != null && n2 > this.maxLookAhead) {
            this.maxLookAhead = n2;
          }
          return line;
        };
        Context2.prototype.baseToken = function(n2) {
          if (!this.baseTokens) {
            return null;
          }
          while (this.baseTokens[this.baseTokenPos] <= n2) {
            this.baseTokenPos += 2;
          }
          var type = this.baseTokens[this.baseTokenPos + 1];
          return {
            type: type && type.replace(/( |^)overlay .*/, ""),
            size: this.baseTokens[this.baseTokenPos] - n2
          };
        };
        Context2.prototype.nextLine = function() {
          this.line++;
          if (this.maxLookAhead > 0) {
            this.maxLookAhead--;
          }
        };
        Context2.fromSaved = function(doc, saved, line) {
          if (saved instanceof SavedContext) {
            return new Context2(doc, copyState(doc.mode, saved.state), line, saved.lookAhead);
          } else {
            return new Context2(doc, copyState(doc.mode, saved), line);
          }
        };
        Context2.prototype.save = function(copy) {
          var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
          return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
        };
        function highlightLine(cm, line, context, forceToEnd) {
          var st = [cm.state.modeGen], lineClasses = {};
          runMode(cm, line.text, cm.doc.mode, context, function(end2, style) {
            return st.push(end2, style);
          }, lineClasses, forceToEnd);
          var state = context.state;
          var loop = function(o3) {
            context.baseTokens = st;
            var overlay = cm.state.overlays[o3], i3 = 1, at = 0;
            context.state = true;
            runMode(cm, line.text, overlay.mode, context, function(end2, style) {
              var start4 = i3;
              while (at < end2) {
                var i_end = st[i3];
                if (i_end > end2) {
                  st.splice(i3, 1, end2, st[i3 + 1], i_end);
                }
                i3 += 2;
                at = Math.min(end2, i_end);
              }
              if (!style) {
                return;
              }
              if (overlay.opaque) {
                st.splice(start4, i3 - start4, end2, "overlay " + style);
                i3 = start4 + 2;
              } else {
                for (; start4 < i3; start4 += 2) {
                  var cur = st[start4 + 1];
                  st[start4 + 1] = (cur ? cur + " " : "") + "overlay " + style;
                }
              }
            }, lineClasses);
            context.state = state;
            context.baseTokens = null;
            context.baseTokenPos = 1;
          };
          for (var o2 = 0; o2 < cm.state.overlays.length; ++o2)
            loop(o2);
          return { styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null };
        }
        function getLineStyles(cm, line, updateFrontier) {
          if (!line.styles || line.styles[0] != cm.state.modeGen) {
            var context = getContextBefore(cm, lineNo(line));
            var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
            var result = highlightLine(cm, line, context);
            if (resetState) {
              context.state = resetState;
            }
            line.stateAfter = context.save(!resetState);
            line.styles = result.styles;
            if (result.classes) {
              line.styleClasses = result.classes;
            } else if (line.styleClasses) {
              line.styleClasses = null;
            }
            if (updateFrontier === cm.doc.highlightFrontier) {
              cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
            }
          }
          return line.styles;
        }
        function getContextBefore(cm, n2, precise) {
          var doc = cm.doc, display = cm.display;
          if (!doc.mode.startState) {
            return new Context2(doc, true, n2);
          }
          var start4 = findStartLine(cm, n2, precise);
          var saved = start4 > doc.first && getLine(doc, start4 - 1).stateAfter;
          var context = saved ? Context2.fromSaved(doc, saved, start4) : new Context2(doc, startState(doc.mode), start4);
          doc.iter(start4, n2, function(line) {
            processLine(cm, line.text, context);
            var pos = context.line;
            line.stateAfter = pos == n2 - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
            context.nextLine();
          });
          if (precise) {
            doc.modeFrontier = context.line;
          }
          return context;
        }
        function processLine(cm, text, context, startAt) {
          var mode = cm.doc.mode;
          var stream = new StringStream(text, cm.options.tabSize, context);
          stream.start = stream.pos = startAt || 0;
          if (text == "") {
            callBlankLine(mode, context.state);
          }
          while (!stream.eol()) {
            readToken(mode, stream, context.state);
            stream.start = stream.pos;
          }
        }
        function callBlankLine(mode, state) {
          if (mode.blankLine) {
            return mode.blankLine(state);
          }
          if (!mode.innerMode) {
            return;
          }
          var inner = innerMode(mode, state);
          if (inner.mode.blankLine) {
            return inner.mode.blankLine(inner.state);
          }
        }
        function readToken(mode, stream, state, inner) {
          for (var i3 = 0; i3 < 10; i3++) {
            if (inner) {
              inner[0] = innerMode(mode, state).mode;
            }
            var style = mode.token(stream, state);
            if (stream.pos > stream.start) {
              return style;
            }
          }
          throw new Error("Mode " + mode.name + " failed to advance stream.");
        }
        var Token = function(stream, type, state) {
          this.start = stream.start;
          this.end = stream.pos;
          this.string = stream.current();
          this.type = type || null;
          this.state = state;
        };
        function takeToken(cm, pos, precise, asArray) {
          var doc = cm.doc, mode = doc.mode, style;
          pos = clipPos(doc, pos);
          var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
          var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
          if (asArray) {
            tokens = [];
          }
          while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
            stream.start = stream.pos;
            style = readToken(mode, stream, context.state);
            if (asArray) {
              tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));
            }
          }
          return asArray ? tokens : new Token(stream, style, context.state);
        }
        function extractLineClasses(type, output) {
          if (type) {
            for (; ; ) {
              var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
              if (!lineClass) {
                break;
              }
              type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
              var prop2 = lineClass[1] ? "bgClass" : "textClass";
              if (output[prop2] == null) {
                output[prop2] = lineClass[2];
              } else if (!new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)").test(output[prop2])) {
                output[prop2] += " " + lineClass[2];
              }
            }
          }
          return type;
        }
        function runMode(cm, text, mode, context, f2, lineClasses, forceToEnd) {
          var flattenSpans = mode.flattenSpans;
          if (flattenSpans == null) {
            flattenSpans = cm.options.flattenSpans;
          }
          var curStart = 0, curStyle = null;
          var stream = new StringStream(text, cm.options.tabSize, context), style;
          var inner = cm.options.addModeClass && [null];
          if (text == "") {
            extractLineClasses(callBlankLine(mode, context.state), lineClasses);
          }
          while (!stream.eol()) {
            if (stream.pos > cm.options.maxHighlightLength) {
              flattenSpans = false;
              if (forceToEnd) {
                processLine(cm, text, context, stream.pos);
              }
              stream.pos = text.length;
              style = null;
            } else {
              style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
            }
            if (inner) {
              var mName = inner[0].name;
              if (mName) {
                style = "m-" + (style ? mName + " " + style : mName);
              }
            }
            if (!flattenSpans || curStyle != style) {
              while (curStart < stream.start) {
                curStart = Math.min(stream.start, curStart + 5e3);
                f2(curStart, curStyle);
              }
              curStyle = style;
            }
            stream.start = stream.pos;
          }
          while (curStart < stream.pos) {
            var pos = Math.min(stream.pos, curStart + 5e3);
            f2(pos, curStyle);
            curStart = pos;
          }
        }
        function findStartLine(cm, n2, precise) {
          var minindent, minline, doc = cm.doc;
          var lim = precise ? -1 : n2 - (cm.doc.mode.innerMode ? 1e3 : 100);
          for (var search = n2; search > lim; --search) {
            if (search <= doc.first) {
              return doc.first;
            }
            var line = getLine(doc, search - 1), after = line.stateAfter;
            if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) {
              return search;
            }
            var indented = countColumn(line.text, null, cm.options.tabSize);
            if (minline == null || minindent > indented) {
              minline = search - 1;
              minindent = indented;
            }
          }
          return minline;
        }
        function retreatFrontier(doc, n2) {
          doc.modeFrontier = Math.min(doc.modeFrontier, n2);
          if (doc.highlightFrontier < n2 - 10) {
            return;
          }
          var start4 = doc.first;
          for (var line = n2 - 1; line > start4; line--) {
            var saved = getLine(doc, line).stateAfter;
            if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n2)) {
              start4 = line + 1;
              break;
            }
          }
          doc.highlightFrontier = Math.min(doc.highlightFrontier, start4);
        }
        var sawReadOnlySpans = false, sawCollapsedSpans = false;
        function seeReadOnlySpans() {
          sawReadOnlySpans = true;
        }
        function seeCollapsedSpans() {
          sawCollapsedSpans = true;
        }
        function MarkedSpan(marker, from, to) {
          this.marker = marker;
          this.from = from;
          this.to = to;
        }
        function getMarkedSpanFor(spans, marker) {
          if (spans) {
            for (var i3 = 0; i3 < spans.length; ++i3) {
              var span = spans[i3];
              if (span.marker == marker) {
                return span;
              }
            }
          }
        }
        function removeMarkedSpan(spans, span) {
          var r2;
          for (var i3 = 0; i3 < spans.length; ++i3) {
            if (spans[i3] != span) {
              (r2 || (r2 = [])).push(spans[i3]);
            }
          }
          return r2;
        }
        function addMarkedSpan(line, span) {
          line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
          span.marker.attachLine(line);
        }
        function markedSpansBefore(old, startCh, isInsert) {
          var nw;
          if (old) {
            for (var i3 = 0; i3 < old.length; ++i3) {
              var span = old[i3], marker = span.marker;
              var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
              if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
                var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
                (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
              }
            }
          }
          return nw;
        }
        function markedSpansAfter(old, endCh, isInsert) {
          var nw;
          if (old) {
            for (var i3 = 0; i3 < old.length; ++i3) {
              var span = old[i3], marker = span.marker;
              var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
              if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
                var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
                (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
              }
            }
          }
          return nw;
        }
        function stretchSpansOverChange(doc, change) {
          if (change.full) {
            return null;
          }
          var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
          var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
          if (!oldFirst && !oldLast) {
            return null;
          }
          var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
          var first = markedSpansBefore(oldFirst, startCh, isInsert);
          var last = markedSpansAfter(oldLast, endCh, isInsert);
          var sameLine = change.text.length == 1, offset2 = lst(change.text).length + (sameLine ? startCh : 0);
          if (first) {
            for (var i3 = 0; i3 < first.length; ++i3) {
              var span = first[i3];
              if (span.to == null) {
                var found = getMarkedSpanFor(last, span.marker);
                if (!found) {
                  span.to = startCh;
                } else if (sameLine) {
                  span.to = found.to == null ? null : found.to + offset2;
                }
              }
            }
          }
          if (last) {
            for (var i$12 = 0; i$12 < last.length; ++i$12) {
              var span$1 = last[i$12];
              if (span$1.to != null) {
                span$1.to += offset2;
              }
              if (span$1.from == null) {
                var found$1 = getMarkedSpanFor(first, span$1.marker);
                if (!found$1) {
                  span$1.from = offset2;
                  if (sameLine) {
                    (first || (first = [])).push(span$1);
                  }
                }
              } else {
                span$1.from += offset2;
                if (sameLine) {
                  (first || (first = [])).push(span$1);
                }
              }
            }
          }
          if (first) {
            first = clearEmptySpans(first);
          }
          if (last && last != first) {
            last = clearEmptySpans(last);
          }
          var newMarkers = [first];
          if (!sameLine) {
            var gap = change.text.length - 2, gapMarkers;
            if (gap > 0 && first) {
              for (var i$22 = 0; i$22 < first.length; ++i$22) {
                if (first[i$22].to == null) {
                  (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$22].marker, null, null));
                }
              }
            }
            for (var i$3 = 0; i$3 < gap; ++i$3) {
              newMarkers.push(gapMarkers);
            }
            newMarkers.push(last);
          }
          return newMarkers;
        }
        function clearEmptySpans(spans) {
          for (var i3 = 0; i3 < spans.length; ++i3) {
            var span = spans[i3];
            if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
              spans.splice(i3--, 1);
            }
          }
          if (!spans.length) {
            return null;
          }
          return spans;
        }
        function removeReadOnlyRanges(doc, from, to) {
          var markers = null;
          doc.iter(from.line, to.line + 1, function(line) {
            if (line.markedSpans) {
              for (var i4 = 0; i4 < line.markedSpans.length; ++i4) {
                var mark = line.markedSpans[i4].marker;
                if (mark.readOnly && (!markers || indexOf2(markers, mark) == -1)) {
                  (markers || (markers = [])).push(mark);
                }
              }
            }
          });
          if (!markers) {
            return null;
          }
          var parts = [{ from, to }];
          for (var i3 = 0; i3 < markers.length; ++i3) {
            var mk = markers[i3], m2 = mk.find(0);
            for (var j2 = 0; j2 < parts.length; ++j2) {
              var p2 = parts[j2];
              if (cmp(p2.to, m2.from) < 0 || cmp(p2.from, m2.to) > 0) {
                continue;
              }
              var newParts = [j2, 1], dfrom = cmp(p2.from, m2.from), dto = cmp(p2.to, m2.to);
              if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
                newParts.push({ from: p2.from, to: m2.from });
              }
              if (dto > 0 || !mk.inclusiveRight && !dto) {
                newParts.push({ from: m2.to, to: p2.to });
              }
              parts.splice.apply(parts, newParts);
              j2 += newParts.length - 3;
            }
          }
          return parts;
        }
        function detachMarkedSpans(line) {
          var spans = line.markedSpans;
          if (!spans) {
            return;
          }
          for (var i3 = 0; i3 < spans.length; ++i3) {
            spans[i3].marker.detachLine(line);
          }
          line.markedSpans = null;
        }
        function attachMarkedSpans(line, spans) {
          if (!spans) {
            return;
          }
          for (var i3 = 0; i3 < spans.length; ++i3) {
            spans[i3].marker.attachLine(line);
          }
          line.markedSpans = spans;
        }
        function extraLeft(marker) {
          return marker.inclusiveLeft ? -1 : 0;
        }
        function extraRight(marker) {
          return marker.inclusiveRight ? 1 : 0;
        }
        function compareCollapsedMarkers(a2, b2) {
          var lenDiff = a2.lines.length - b2.lines.length;
          if (lenDiff != 0) {
            return lenDiff;
          }
          var aPos = a2.find(), bPos = b2.find();
          var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a2) - extraLeft(b2);
          if (fromCmp) {
            return -fromCmp;
          }
          var toCmp = cmp(aPos.to, bPos.to) || extraRight(a2) - extraRight(b2);
          if (toCmp) {
            return toCmp;
          }
          return b2.id - a2.id;
        }
        function collapsedSpanAtSide(line, start4) {
          var sps = sawCollapsedSpans && line.markedSpans, found;
          if (sps) {
            for (var sp = void 0, i3 = 0; i3 < sps.length; ++i3) {
              sp = sps[i3];
              if (sp.marker.collapsed && (start4 ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
                found = sp.marker;
              }
            }
          }
          return found;
        }
        function collapsedSpanAtStart(line) {
          return collapsedSpanAtSide(line, true);
        }
        function collapsedSpanAtEnd(line) {
          return collapsedSpanAtSide(line, false);
        }
        function collapsedSpanAround(line, ch) {
          var sps = sawCollapsedSpans && line.markedSpans, found;
          if (sps) {
            for (var i3 = 0; i3 < sps.length; ++i3) {
              var sp = sps[i3];
              if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
                found = sp.marker;
              }
            }
          }
          return found;
        }
        function conflictingCollapsedRange(doc, lineNo2, from, to, marker) {
          var line = getLine(doc, lineNo2);
          var sps = sawCollapsedSpans && line.markedSpans;
          if (sps) {
            for (var i3 = 0; i3 < sps.length; ++i3) {
              var sp = sps[i3];
              if (!sp.marker.collapsed) {
                continue;
              }
              var found = sp.marker.find(0);
              var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
              var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
              if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
                continue;
              }
              if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
                return true;
              }
            }
          }
        }
        function visualLine(line) {
          var merged;
          while (merged = collapsedSpanAtStart(line)) {
            line = merged.find(-1, true).line;
          }
          return line;
        }
        function visualLineEnd(line) {
          var merged;
          while (merged = collapsedSpanAtEnd(line)) {
            line = merged.find(1, true).line;
          }
          return line;
        }
        function visualLineContinued(line) {
          var merged, lines;
          while (merged = collapsedSpanAtEnd(line)) {
            line = merged.find(1, true).line;
            (lines || (lines = [])).push(line);
          }
          return lines;
        }
        function visualLineNo(doc, lineN) {
          var line = getLine(doc, lineN), vis = visualLine(line);
          if (line == vis) {
            return lineN;
          }
          return lineNo(vis);
        }
        function visualLineEndNo(doc, lineN) {
          if (lineN > doc.lastLine()) {
            return lineN;
          }
          var line = getLine(doc, lineN), merged;
          if (!lineIsHidden(doc, line)) {
            return lineN;
          }
          while (merged = collapsedSpanAtEnd(line)) {
            line = merged.find(1, true).line;
          }
          return lineNo(line) + 1;
        }
        function lineIsHidden(doc, line) {
          var sps = sawCollapsedSpans && line.markedSpans;
          if (sps) {
            for (var sp = void 0, i3 = 0; i3 < sps.length; ++i3) {
              sp = sps[i3];
              if (!sp.marker.collapsed) {
                continue;
              }
              if (sp.from == null) {
                return true;
              }
              if (sp.marker.widgetNode) {
                continue;
              }
              if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {
                return true;
              }
            }
          }
        }
        function lineIsHiddenInner(doc, line, span) {
          if (span.to == null) {
            var end2 = span.marker.find(1, true);
            return lineIsHiddenInner(doc, end2.line, getMarkedSpanFor(end2.line.markedSpans, span.marker));
          }
          if (span.marker.inclusiveRight && span.to == line.text.length) {
            return true;
          }
          for (var sp = void 0, i3 = 0; i3 < line.markedSpans.length; ++i3) {
            sp = line.markedSpans[i3];
            if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {
              return true;
            }
          }
        }
        function heightAtLine(lineObj) {
          lineObj = visualLine(lineObj);
          var h = 0, chunk = lineObj.parent;
          for (var i3 = 0; i3 < chunk.lines.length; ++i3) {
            var line = chunk.lines[i3];
            if (line == lineObj) {
              break;
            } else {
              h += line.height;
            }
          }
          for (var p2 = chunk.parent; p2; chunk = p2, p2 = chunk.parent) {
            for (var i$12 = 0; i$12 < p2.children.length; ++i$12) {
              var cur = p2.children[i$12];
              if (cur == chunk) {
                break;
              } else {
                h += cur.height;
              }
            }
          }
          return h;
        }
        function lineLength(line) {
          if (line.height == 0) {
            return 0;
          }
          var len = line.text.length, merged, cur = line;
          while (merged = collapsedSpanAtStart(cur)) {
            var found = merged.find(0, true);
            cur = found.from.line;
            len += found.from.ch - found.to.ch;
          }
          cur = line;
          while (merged = collapsedSpanAtEnd(cur)) {
            var found$1 = merged.find(0, true);
            len -= cur.text.length - found$1.from.ch;
            cur = found$1.to.line;
            len += cur.text.length - found$1.to.ch;
          }
          return len;
        }
        function findMaxLine(cm) {
          var d2 = cm.display, doc = cm.doc;
          d2.maxLine = getLine(doc, doc.first);
          d2.maxLineLength = lineLength(d2.maxLine);
          d2.maxLineChanged = true;
          doc.iter(function(line) {
            var len = lineLength(line);
            if (len > d2.maxLineLength) {
              d2.maxLineLength = len;
              d2.maxLine = line;
            }
          });
        }
        var Line = function(text, markedSpans, estimateHeight2) {
          this.text = text;
          attachMarkedSpans(this, markedSpans);
          this.height = estimateHeight2 ? estimateHeight2(this) : 1;
        };
        Line.prototype.lineNo = function() {
          return lineNo(this);
        };
        eventMixin(Line);
        function updateLine(line, text, markedSpans, estimateHeight2) {
          line.text = text;
          if (line.stateAfter) {
            line.stateAfter = null;
          }
          if (line.styles) {
            line.styles = null;
          }
          if (line.order != null) {
            line.order = null;
          }
          detachMarkedSpans(line);
          attachMarkedSpans(line, markedSpans);
          var estHeight = estimateHeight2 ? estimateHeight2(line) : 1;
          if (estHeight != line.height) {
            updateLineHeight(line, estHeight);
          }
        }
        function cleanUpLine(line) {
          line.parent = null;
          detachMarkedSpans(line);
        }
        var styleToClassCache = {}, styleToClassCacheWithMode = {};
        function interpretTokenStyle(style, options) {
          if (!style || /^\s*$/.test(style)) {
            return null;
          }
          var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
          return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
        }
        function buildLineContent(cm, lineView) {
          var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
          var builder = {
            pre: eltP("pre", [content], "CodeMirror-line"),
            content,
            col: 0,
            pos: 0,
            cm,
            trailingSpace: false,
            splitSpaces: cm.getOption("lineWrapping")
          };
          lineView.measure = {};
          for (var i3 = 0; i3 <= (lineView.rest ? lineView.rest.length : 0); i3++) {
            var line = i3 ? lineView.rest[i3 - 1] : lineView.line, order2 = void 0;
            builder.pos = 0;
            builder.addToken = buildToken;
            if (hasBadBidiRects(cm.display.measure) && (order2 = getOrder(line, cm.doc.direction))) {
              builder.addToken = buildTokenBadBidi(builder.addToken, order2);
            }
            builder.map = [];
            var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
            insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
            if (line.styleClasses) {
              if (line.styleClasses.bgClass) {
                builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
              }
              if (line.styleClasses.textClass) {
                builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
              }
            }
            if (builder.map.length == 0) {
              builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
            }
            if (i3 == 0) {
              lineView.measure.map = builder.map;
              lineView.measure.cache = {};
            } else {
              (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
              (lineView.measure.caches || (lineView.measure.caches = [])).push({});
            }
          }
          if (webkit) {
            var last = builder.content.lastChild;
            if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
              builder.content.className = "cm-tab-wrap-hack";
            }
          }
          signal(cm, "renderLine", cm, lineView.line, builder.pre);
          if (builder.pre.className) {
            builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
          }
          return builder;
        }
        function defaultSpecialCharPlaceholder(ch) {
          var token = elt("span", "\u2022", "cm-invalidchar");
          token.title = "\\u" + ch.charCodeAt(0).toString(16);
          token.setAttribute("aria-label", token.title);
          return token;
        }
        function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
          if (!text) {
            return;
          }
          var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
          var special = builder.cm.state.specialChars, mustWrap = false;
          var content;
          if (!special.test(text)) {
            builder.col += text.length;
            content = document.createTextNode(displayText);
            builder.map.push(builder.pos, builder.pos + text.length, content);
            if (ie && ie_version < 9) {
              mustWrap = true;
            }
            builder.pos += text.length;
          } else {
            content = document.createDocumentFragment();
            var pos = 0;
            while (true) {
              special.lastIndex = pos;
              var m2 = special.exec(text);
              var skipped = m2 ? m2.index - pos : text.length - pos;
              if (skipped) {
                var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
                if (ie && ie_version < 9) {
                  content.appendChild(elt("span", [txt]));
                } else {
                  content.appendChild(txt);
                }
                builder.map.push(builder.pos, builder.pos + skipped, txt);
                builder.col += skipped;
                builder.pos += skipped;
              }
              if (!m2) {
                break;
              }
              pos += skipped + 1;
              var txt$1 = void 0;
              if (m2[0] == "	") {
                var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
                txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
                txt$1.setAttribute("role", "presentation");
                txt$1.setAttribute("cm-text", "	");
                builder.col += tabWidth;
              } else if (m2[0] == "\r" || m2[0] == "\n") {
                txt$1 = content.appendChild(elt("span", m2[0] == "\r" ? "\u240D" : "\u2424", "cm-invalidchar"));
                txt$1.setAttribute("cm-text", m2[0]);
                builder.col += 1;
              } else {
                txt$1 = builder.cm.options.specialCharPlaceholder(m2[0]);
                txt$1.setAttribute("cm-text", m2[0]);
                if (ie && ie_version < 9) {
                  content.appendChild(elt("span", [txt$1]));
                } else {
                  content.appendChild(txt$1);
                }
                builder.col += 1;
              }
              builder.map.push(builder.pos, builder.pos + 1, txt$1);
              builder.pos++;
            }
          }
          builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
          if (style || startStyle || endStyle || mustWrap || css || attributes) {
            var fullStyle = style || "";
            if (startStyle) {
              fullStyle += startStyle;
            }
            if (endStyle) {
              fullStyle += endStyle;
            }
            var token = elt("span", [content], fullStyle, css);
            if (attributes) {
              for (var attr in attributes) {
                if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class") {
                  token.setAttribute(attr, attributes[attr]);
                }
              }
            }
            return builder.content.appendChild(token);
          }
          builder.content.appendChild(content);
        }
        function splitSpaces(text, trailingBefore) {
          if (text.length > 1 && !/  /.test(text)) {
            return text;
          }
          var spaceBefore = trailingBefore, result = "";
          for (var i3 = 0; i3 < text.length; i3++) {
            var ch = text.charAt(i3);
            if (ch == " " && spaceBefore && (i3 == text.length - 1 || text.charCodeAt(i3 + 1) == 32)) {
              ch = "\xA0";
            }
            result += ch;
            spaceBefore = ch == " ";
          }
          return result;
        }
        function buildTokenBadBidi(inner, order2) {
          return function(builder, text, style, startStyle, endStyle, css, attributes) {
            style = style ? style + " cm-force-border" : "cm-force-border";
            var start4 = builder.pos, end2 = start4 + text.length;
            for (; ; ) {
              var part = void 0;
              for (var i3 = 0; i3 < order2.length; i3++) {
                part = order2[i3];
                if (part.to > start4 && part.from <= start4) {
                  break;
                }
              }
              if (part.to >= end2) {
                return inner(builder, text, style, startStyle, endStyle, css, attributes);
              }
              inner(builder, text.slice(0, part.to - start4), style, startStyle, null, css, attributes);
              startStyle = null;
              text = text.slice(part.to - start4);
              start4 = part.to;
            }
          };
        }
        function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
          var widget = !ignoreWidget && marker.widgetNode;
          if (widget) {
            builder.map.push(builder.pos, builder.pos + size, widget);
          }
          if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
            if (!widget) {
              widget = builder.content.appendChild(document.createElement("span"));
            }
            widget.setAttribute("cm-marker", marker.id);
          }
          if (widget) {
            builder.cm.display.input.setUneditable(widget);
            builder.content.appendChild(widget);
          }
          builder.pos += size;
          builder.trailingSpace = false;
        }
        function insertLineContent(line, builder, styles) {
          var spans = line.markedSpans, allText = line.text, at = 0;
          if (!spans) {
            for (var i$12 = 1; i$12 < styles.length; i$12 += 2) {
              builder.addToken(builder, allText.slice(at, at = styles[i$12]), interpretTokenStyle(styles[i$12 + 1], builder.cm.options));
            }
            return;
          }
          var len = allText.length, pos = 0, i3 = 1, text = "", style, css;
          var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
          for (; ; ) {
            if (nextChange == pos) {
              spanStyle = spanEndStyle = spanStartStyle = css = "";
              attributes = null;
              collapsed = null;
              nextChange = Infinity;
              var foundBookmarks = [], endStyles = void 0;
              for (var j2 = 0; j2 < spans.length; ++j2) {
                var sp = spans[j2], m2 = sp.marker;
                if (m2.type == "bookmark" && sp.from == pos && m2.widgetNode) {
                  foundBookmarks.push(m2);
                } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m2.collapsed && sp.to == pos && sp.from == pos)) {
                  if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                    nextChange = sp.to;
                    spanEndStyle = "";
                  }
                  if (m2.className) {
                    spanStyle += " " + m2.className;
                  }
                  if (m2.css) {
                    css = (css ? css + ";" : "") + m2.css;
                  }
                  if (m2.startStyle && sp.from == pos) {
                    spanStartStyle += " " + m2.startStyle;
                  }
                  if (m2.endStyle && sp.to == nextChange) {
                    (endStyles || (endStyles = [])).push(m2.endStyle, sp.to);
                  }
                  if (m2.title) {
                    (attributes || (attributes = {})).title = m2.title;
                  }
                  if (m2.attributes) {
                    for (var attr in m2.attributes) {
                      (attributes || (attributes = {}))[attr] = m2.attributes[attr];
                    }
                  }
                  if (m2.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m2) < 0)) {
                    collapsed = sp;
                  }
                } else if (sp.from > pos && nextChange > sp.from) {
                  nextChange = sp.from;
                }
              }
              if (endStyles) {
                for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {
                  if (endStyles[j$1 + 1] == nextChange) {
                    spanEndStyle += " " + endStyles[j$1];
                  }
                }
              }
              if (!collapsed || collapsed.from == pos) {
                for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
                  buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
                }
              }
              if (collapsed && (collapsed.from || 0) == pos) {
                buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
                if (collapsed.to == null) {
                  return;
                }
                if (collapsed.to == pos) {
                  collapsed = false;
                }
              }
            }
            if (pos >= len) {
              break;
            }
            var upto = Math.min(len, nextChange);
            while (true) {
              if (text) {
                var end2 = pos + text.length;
                if (!collapsed) {
                  var tokenText = end2 > upto ? text.slice(0, upto - pos) : text;
                  builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
                }
                if (end2 >= upto) {
                  text = text.slice(upto - pos);
                  pos = upto;
                  break;
                }
                pos = end2;
                spanStartStyle = "";
              }
              text = allText.slice(at, at = styles[i3++]);
              style = interpretTokenStyle(styles[i3++], builder.cm.options);
            }
          }
        }
        function LineView(doc, line, lineN) {
          this.line = line;
          this.rest = visualLineContinued(line);
          this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
          this.node = this.text = null;
          this.hidden = lineIsHidden(doc, line);
        }
        function buildViewArray(cm, from, to) {
          var array = [], nextPos;
          for (var pos = from; pos < to; pos = nextPos) {
            var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
            nextPos = pos + view.size;
            array.push(view);
          }
          return array;
        }
        var operationGroup = null;
        function pushOperation(op) {
          if (operationGroup) {
            operationGroup.ops.push(op);
          } else {
            op.ownsGroup = operationGroup = {
              ops: [op],
              delayedCallbacks: []
            };
          }
        }
        function fireCallbacksForOps(group) {
          var callbacks = group.delayedCallbacks, i3 = 0;
          do {
            for (; i3 < callbacks.length; i3++) {
              callbacks[i3].call(null);
            }
            for (var j2 = 0; j2 < group.ops.length; j2++) {
              var op = group.ops[j2];
              if (op.cursorActivityHandlers) {
                while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
                  op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
                }
              }
            }
          } while (i3 < callbacks.length);
        }
        function finishOperation(op, endCb) {
          var group = op.ownsGroup;
          if (!group) {
            return;
          }
          try {
            fireCallbacksForOps(group);
          } finally {
            operationGroup = null;
            endCb(group);
          }
        }
        var orphanDelayedCallbacks = null;
        function signalLater(emitter, type) {
          var arr = getHandlers(emitter, type);
          if (!arr.length) {
            return;
          }
          var args = Array.prototype.slice.call(arguments, 2), list;
          if (operationGroup) {
            list = operationGroup.delayedCallbacks;
          } else if (orphanDelayedCallbacks) {
            list = orphanDelayedCallbacks;
          } else {
            list = orphanDelayedCallbacks = [];
            setTimeout(fireOrphanDelayed, 0);
          }
          var loop = function(i4) {
            list.push(function() {
              return arr[i4].apply(null, args);
            });
          };
          for (var i3 = 0; i3 < arr.length; ++i3)
            loop(i3);
        }
        function fireOrphanDelayed() {
          var delayed = orphanDelayedCallbacks;
          orphanDelayedCallbacks = null;
          for (var i3 = 0; i3 < delayed.length; ++i3) {
            delayed[i3]();
          }
        }
        function updateLineForChanges(cm, lineView, lineN, dims) {
          for (var j2 = 0; j2 < lineView.changes.length; j2++) {
            var type = lineView.changes[j2];
            if (type == "text") {
              updateLineText(cm, lineView);
            } else if (type == "gutter") {
              updateLineGutter(cm, lineView, lineN, dims);
            } else if (type == "class") {
              updateLineClasses(cm, lineView);
            } else if (type == "widget") {
              updateLineWidgets(cm, lineView, dims);
            }
          }
          lineView.changes = null;
        }
        function ensureLineWrapped(lineView) {
          if (lineView.node == lineView.text) {
            lineView.node = elt("div", null, null, "position: relative");
            if (lineView.text.parentNode) {
              lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
            }
            lineView.node.appendChild(lineView.text);
            if (ie && ie_version < 8) {
              lineView.node.style.zIndex = 2;
            }
          }
          return lineView.node;
        }
        function updateLineBackground(cm, lineView) {
          var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
          if (cls) {
            cls += " CodeMirror-linebackground";
          }
          if (lineView.background) {
            if (cls) {
              lineView.background.className = cls;
            } else {
              lineView.background.parentNode.removeChild(lineView.background);
              lineView.background = null;
            }
          } else if (cls) {
            var wrap2 = ensureLineWrapped(lineView);
            lineView.background = wrap2.insertBefore(elt("div", null, cls), wrap2.firstChild);
            cm.display.input.setUneditable(lineView.background);
          }
        }
        function getLineContent(cm, lineView) {
          var ext = cm.display.externalMeasured;
          if (ext && ext.line == lineView.line) {
            cm.display.externalMeasured = null;
            lineView.measure = ext.measure;
            return ext.built;
          }
          return buildLineContent(cm, lineView);
        }
        function updateLineText(cm, lineView) {
          var cls = lineView.text.className;
          var built = getLineContent(cm, lineView);
          if (lineView.text == lineView.node) {
            lineView.node = built.pre;
          }
          lineView.text.parentNode.replaceChild(built.pre, lineView.text);
          lineView.text = built.pre;
          if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
            lineView.bgClass = built.bgClass;
            lineView.textClass = built.textClass;
            updateLineClasses(cm, lineView);
          } else if (cls) {
            lineView.text.className = cls;
          }
        }
        function updateLineClasses(cm, lineView) {
          updateLineBackground(cm, lineView);
          if (lineView.line.wrapClass) {
            ensureLineWrapped(lineView).className = lineView.line.wrapClass;
          } else if (lineView.node != lineView.text) {
            lineView.node.className = "";
          }
          var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
          lineView.text.className = textClass || "";
        }
        function updateLineGutter(cm, lineView, lineN, dims) {
          if (lineView.gutter) {
            lineView.node.removeChild(lineView.gutter);
            lineView.gutter = null;
          }
          if (lineView.gutterBackground) {
            lineView.node.removeChild(lineView.gutterBackground);
            lineView.gutterBackground = null;
          }
          if (lineView.line.gutterClass) {
            var wrap2 = ensureLineWrapped(lineView);
            lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
            cm.display.input.setUneditable(lineView.gutterBackground);
            wrap2.insertBefore(lineView.gutterBackground, lineView.text);
          }
          var markers = lineView.line.gutterMarkers;
          if (cm.options.lineNumbers || markers) {
            var wrap$1 = ensureLineWrapped(lineView);
            var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
            cm.display.input.setUneditable(gutterWrap);
            wrap$1.insertBefore(gutterWrap, lineView.text);
            if (lineView.line.gutterClass) {
              gutterWrap.className += " " + lineView.line.gutterClass;
            }
            if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
              lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));
            }
            if (markers) {
              for (var k2 = 0; k2 < cm.display.gutterSpecs.length; ++k2) {
                var id = cm.display.gutterSpecs[k2].className, found = markers.hasOwnProperty(id) && markers[id];
                if (found) {
                  gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
                }
              }
            }
          }
        }
        function updateLineWidgets(cm, lineView, dims) {
          if (lineView.alignable) {
            lineView.alignable = null;
          }
          var isWidget = classTest("CodeMirror-linewidget");
          for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
            next = node.nextSibling;
            if (isWidget.test(node.className)) {
              lineView.node.removeChild(node);
            }
          }
          insertLineWidgets(cm, lineView, dims);
        }
        function buildLineElement(cm, lineView, lineN, dims) {
          var built = getLineContent(cm, lineView);
          lineView.text = lineView.node = built.pre;
          if (built.bgClass) {
            lineView.bgClass = built.bgClass;
          }
          if (built.textClass) {
            lineView.textClass = built.textClass;
          }
          updateLineClasses(cm, lineView);
          updateLineGutter(cm, lineView, lineN, dims);
          insertLineWidgets(cm, lineView, dims);
          return lineView.node;
        }
        function insertLineWidgets(cm, lineView, dims) {
          insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
          if (lineView.rest) {
            for (var i3 = 0; i3 < lineView.rest.length; i3++) {
              insertLineWidgetsFor(cm, lineView.rest[i3], lineView, dims, false);
            }
          }
        }
        function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
          if (!line.widgets) {
            return;
          }
          var wrap2 = ensureLineWrapped(lineView);
          for (var i3 = 0, ws = line.widgets; i3 < ws.length; ++i3) {
            var widget = ws[i3], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
            if (!widget.handleMouseEvents) {
              node.setAttribute("cm-ignore-events", "true");
            }
            positionLineWidget(widget, node, lineView, dims);
            cm.display.input.setUneditable(node);
            if (allowAbove && widget.above) {
              wrap2.insertBefore(node, lineView.gutter || lineView.text);
            } else {
              wrap2.appendChild(node);
            }
            signalLater(widget, "redraw");
          }
        }
        function positionLineWidget(widget, node, lineView, dims) {
          if (widget.noHScroll) {
            (lineView.alignable || (lineView.alignable = [])).push(node);
            var width = dims.wrapperWidth;
            node.style.left = dims.fixedPos + "px";
            if (!widget.coverGutter) {
              width -= dims.gutterTotalWidth;
              node.style.paddingLeft = dims.gutterTotalWidth + "px";
            }
            node.style.width = width + "px";
          }
          if (widget.coverGutter) {
            node.style.zIndex = 5;
            node.style.position = "relative";
            if (!widget.noHScroll) {
              node.style.marginLeft = -dims.gutterTotalWidth + "px";
            }
          }
        }
        function widgetHeight(widget) {
          if (widget.height != null) {
            return widget.height;
          }
          var cm = widget.doc.cm;
          if (!cm) {
            return 0;
          }
          if (!contains2(document.body, widget.node)) {
            var parentStyle = "position: relative;";
            if (widget.coverGutter) {
              parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
            }
            if (widget.noHScroll) {
              parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
            }
            removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
          }
          return widget.height = widget.node.parentNode.offsetHeight;
        }
        function eventInWidget(display, e2) {
          for (var n2 = e_target(e2); n2 != display.wrapper; n2 = n2.parentNode) {
            if (!n2 || n2.nodeType == 1 && n2.getAttribute("cm-ignore-events") == "true" || n2.parentNode == display.sizer && n2 != display.mover) {
              return true;
            }
          }
        }
        function paddingTop(display) {
          return display.lineSpace.offsetTop;
        }
        function paddingVert(display) {
          return display.mover.offsetHeight - display.lineSpace.offsetHeight;
        }
        function paddingH(display) {
          if (display.cachedPaddingH) {
            return display.cachedPaddingH;
          }
          var e2 = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
          var style = window.getComputedStyle ? window.getComputedStyle(e2) : e2.currentStyle;
          var data = { left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight) };
          if (!isNaN(data.left) && !isNaN(data.right)) {
            display.cachedPaddingH = data;
          }
          return data;
        }
        function scrollGap(cm) {
          return scrollerGap - cm.display.nativeBarWidth;
        }
        function displayWidth(cm) {
          return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
        }
        function displayHeight(cm) {
          return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
        }
        function ensureLineHeights(cm, lineView, rect) {
          var wrapping = cm.options.lineWrapping;
          var curWidth = wrapping && displayWidth(cm);
          if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
            var heights = lineView.measure.heights = [];
            if (wrapping) {
              lineView.measure.width = curWidth;
              var rects = lineView.text.firstChild.getClientRects();
              for (var i3 = 0; i3 < rects.length - 1; i3++) {
                var cur = rects[i3], next = rects[i3 + 1];
                if (Math.abs(cur.bottom - next.bottom) > 2) {
                  heights.push((cur.bottom + next.top) / 2 - rect.top);
                }
              }
            }
            heights.push(rect.bottom - rect.top);
          }
        }
        function mapFromLineView(lineView, line, lineN) {
          if (lineView.line == line) {
            return { map: lineView.measure.map, cache: lineView.measure.cache };
          }
          for (var i3 = 0; i3 < lineView.rest.length; i3++) {
            if (lineView.rest[i3] == line) {
              return { map: lineView.measure.maps[i3], cache: lineView.measure.caches[i3] };
            }
          }
          for (var i$12 = 0; i$12 < lineView.rest.length; i$12++) {
            if (lineNo(lineView.rest[i$12]) > lineN) {
              return { map: lineView.measure.maps[i$12], cache: lineView.measure.caches[i$12], before: true };
            }
          }
        }
        function updateExternalMeasurement(cm, line) {
          line = visualLine(line);
          var lineN = lineNo(line);
          var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
          view.lineN = lineN;
          var built = view.built = buildLineContent(cm, view);
          view.text = built.pre;
          removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
          return view;
        }
        function measureChar(cm, line, ch, bias) {
          return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
        }
        function findViewForLine(cm, lineN) {
          if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
            return cm.display.view[findViewIndex(cm, lineN)];
          }
          var ext = cm.display.externalMeasured;
          if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
            return ext;
          }
        }
        function prepareMeasureForLine(cm, line) {
          var lineN = lineNo(line);
          var view = findViewForLine(cm, lineN);
          if (view && !view.text) {
            view = null;
          } else if (view && view.changes) {
            updateLineForChanges(cm, view, lineN, getDimensions(cm));
            cm.curOp.forceUpdate = true;
          }
          if (!view) {
            view = updateExternalMeasurement(cm, line);
          }
          var info = mapFromLineView(view, line, lineN);
          return {
            line,
            view,
            rect: null,
            map: info.map,
            cache: info.cache,
            before: info.before,
            hasHeights: false
          };
        }
        function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
          if (prepared.before) {
            ch = -1;
          }
          var key = ch + (bias || ""), found;
          if (prepared.cache.hasOwnProperty(key)) {
            found = prepared.cache[key];
          } else {
            if (!prepared.rect) {
              prepared.rect = prepared.view.text.getBoundingClientRect();
            }
            if (!prepared.hasHeights) {
              ensureLineHeights(cm, prepared.view, prepared.rect);
              prepared.hasHeights = true;
            }
            found = measureCharInner(cm, prepared, ch, bias);
            if (!found.bogus) {
              prepared.cache[key] = found;
            }
          }
          return {
            left: found.left,
            right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom
          };
        }
        var nullRect = { left: 0, right: 0, top: 0, bottom: 0 };
        function nodeAndOffsetInLineMap(map2, ch, bias) {
          var node, start4, end2, collapse, mStart, mEnd;
          for (var i3 = 0; i3 < map2.length; i3 += 3) {
            mStart = map2[i3];
            mEnd = map2[i3 + 1];
            if (ch < mStart) {
              start4 = 0;
              end2 = 1;
              collapse = "left";
            } else if (ch < mEnd) {
              start4 = ch - mStart;
              end2 = start4 + 1;
            } else if (i3 == map2.length - 3 || ch == mEnd && map2[i3 + 3] > ch) {
              end2 = mEnd - mStart;
              start4 = end2 - 1;
              if (ch >= mEnd) {
                collapse = "right";
              }
            }
            if (start4 != null) {
              node = map2[i3 + 2];
              if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
                collapse = bias;
              }
              if (bias == "left" && start4 == 0) {
                while (i3 && map2[i3 - 2] == map2[i3 - 3] && map2[i3 - 1].insertLeft) {
                  node = map2[(i3 -= 3) + 2];
                  collapse = "left";
                }
              }
              if (bias == "right" && start4 == mEnd - mStart) {
                while (i3 < map2.length - 3 && map2[i3 + 3] == map2[i3 + 4] && !map2[i3 + 5].insertLeft) {
                  node = map2[(i3 += 3) + 2];
                  collapse = "right";
                }
              }
              break;
            }
          }
          return { node, start: start4, end: end2, collapse, coverStart: mStart, coverEnd: mEnd };
        }
        function getUsefulRect(rects, bias) {
          var rect = nullRect;
          if (bias == "left") {
            for (var i3 = 0; i3 < rects.length; i3++) {
              if ((rect = rects[i3]).left != rect.right) {
                break;
              }
            }
          } else {
            for (var i$12 = rects.length - 1; i$12 >= 0; i$12--) {
              if ((rect = rects[i$12]).left != rect.right) {
                break;
              }
            }
          }
          return rect;
        }
        function measureCharInner(cm, prepared, ch, bias) {
          var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
          var node = place.node, start4 = place.start, end2 = place.end, collapse = place.collapse;
          var rect;
          if (node.nodeType == 3) {
            for (var i$12 = 0; i$12 < 4; i$12++) {
              while (start4 && isExtendingChar(prepared.line.text.charAt(place.coverStart + start4))) {
                --start4;
              }
              while (place.coverStart + end2 < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end2))) {
                ++end2;
              }
              if (ie && ie_version < 9 && start4 == 0 && end2 == place.coverEnd - place.coverStart) {
                rect = node.parentNode.getBoundingClientRect();
              } else {
                rect = getUsefulRect(range(node, start4, end2).getClientRects(), bias);
              }
              if (rect.left || rect.right || start4 == 0) {
                break;
              }
              end2 = start4;
              start4 = start4 - 1;
              collapse = "right";
            }
            if (ie && ie_version < 11) {
              rect = maybeUpdateRectForZooming(cm.display.measure, rect);
            }
          } else {
            if (start4 > 0) {
              collapse = bias = "right";
            }
            var rects;
            if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
              rect = rects[bias == "right" ? rects.length - 1 : 0];
            } else {
              rect = node.getBoundingClientRect();
            }
          }
          if (ie && ie_version < 9 && !start4 && (!rect || !rect.left && !rect.right)) {
            var rSpan = node.parentNode.getClientRects()[0];
            if (rSpan) {
              rect = { left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom };
            } else {
              rect = nullRect;
            }
          }
          var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
          var mid = (rtop + rbot) / 2;
          var heights = prepared.view.measure.heights;
          var i3 = 0;
          for (; i3 < heights.length - 1; i3++) {
            if (mid < heights[i3]) {
              break;
            }
          }
          var top2 = i3 ? heights[i3 - 1] : 0, bot = heights[i3];
          var result = {
            left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
            right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
            top: top2,
            bottom: bot
          };
          if (!rect.left && !rect.right) {
            result.bogus = true;
          }
          if (!cm.options.singleCursorHeightPerLine) {
            result.rtop = rtop;
            result.rbottom = rbot;
          }
          return result;
        }
        function maybeUpdateRectForZooming(measure, rect) {
          if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
            return rect;
          }
          var scaleX = screen.logicalXDPI / screen.deviceXDPI;
          var scaleY = screen.logicalYDPI / screen.deviceYDPI;
          return {
            left: rect.left * scaleX,
            right: rect.right * scaleX,
            top: rect.top * scaleY,
            bottom: rect.bottom * scaleY
          };
        }
        function clearLineMeasurementCacheFor(lineView) {
          if (lineView.measure) {
            lineView.measure.cache = {};
            lineView.measure.heights = null;
            if (lineView.rest) {
              for (var i3 = 0; i3 < lineView.rest.length; i3++) {
                lineView.measure.caches[i3] = {};
              }
            }
          }
        }
        function clearLineMeasurementCache(cm) {
          cm.display.externalMeasure = null;
          removeChildren(cm.display.lineMeasure);
          for (var i3 = 0; i3 < cm.display.view.length; i3++) {
            clearLineMeasurementCacheFor(cm.display.view[i3]);
          }
        }
        function clearCaches(cm) {
          clearLineMeasurementCache(cm);
          cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
          if (!cm.options.lineWrapping) {
            cm.display.maxLineChanged = true;
          }
          cm.display.lineNumChars = null;
        }
        function pageScrollX() {
          if (chrome2 && android) {
            return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));
          }
          return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
        }
        function pageScrollY() {
          if (chrome2 && android) {
            return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));
          }
          return window.pageYOffset || (document.documentElement || document.body).scrollTop;
        }
        function widgetTopHeight(lineObj) {
          var height = 0;
          if (lineObj.widgets) {
            for (var i3 = 0; i3 < lineObj.widgets.length; ++i3) {
              if (lineObj.widgets[i3].above) {
                height += widgetHeight(lineObj.widgets[i3]);
              }
            }
          }
          return height;
        }
        function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
          if (!includeWidgets) {
            var height = widgetTopHeight(lineObj);
            rect.top += height;
            rect.bottom += height;
          }
          if (context == "line") {
            return rect;
          }
          if (!context) {
            context = "local";
          }
          var yOff = heightAtLine(lineObj);
          if (context == "local") {
            yOff += paddingTop(cm.display);
          } else {
            yOff -= cm.display.viewOffset;
          }
          if (context == "page" || context == "window") {
            var lOff = cm.display.lineSpace.getBoundingClientRect();
            yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
            var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
            rect.left += xOff;
            rect.right += xOff;
          }
          rect.top += yOff;
          rect.bottom += yOff;
          return rect;
        }
        function fromCoordSystem(cm, coords, context) {
          if (context == "div") {
            return coords;
          }
          var left2 = coords.left, top2 = coords.top;
          if (context == "page") {
            left2 -= pageScrollX();
            top2 -= pageScrollY();
          } else if (context == "local" || !context) {
            var localBox = cm.display.sizer.getBoundingClientRect();
            left2 += localBox.left;
            top2 += localBox.top;
          }
          var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
          return { left: left2 - lineSpaceBox.left, top: top2 - lineSpaceBox.top };
        }
        function charCoords(cm, pos, context, lineObj, bias) {
          if (!lineObj) {
            lineObj = getLine(cm.doc, pos.line);
          }
          return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
        }
        function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
          lineObj = lineObj || getLine(cm.doc, pos.line);
          if (!preparedMeasure) {
            preparedMeasure = prepareMeasureForLine(cm, lineObj);
          }
          function get(ch2, right2) {
            var m2 = measureCharPrepared(cm, preparedMeasure, ch2, right2 ? "right" : "left", varHeight);
            if (right2) {
              m2.left = m2.right;
            } else {
              m2.right = m2.left;
            }
            return intoCoordSystem(cm, lineObj, m2, context);
          }
          var order2 = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
          if (ch >= lineObj.text.length) {
            ch = lineObj.text.length;
            sticky = "before";
          } else if (ch <= 0) {
            ch = 0;
            sticky = "after";
          }
          if (!order2) {
            return get(sticky == "before" ? ch - 1 : ch, sticky == "before");
          }
          function getBidi(ch2, partPos2, invert) {
            var part = order2[partPos2], right2 = part.level == 1;
            return get(invert ? ch2 - 1 : ch2, right2 != invert);
          }
          var partPos = getBidiPartAt(order2, ch, sticky);
          var other = bidiOther;
          var val = getBidi(ch, partPos, sticky == "before");
          if (other != null) {
            val.other = getBidi(ch, other, sticky != "before");
          }
          return val;
        }
        function estimateCoords(cm, pos) {
          var left2 = 0;
          pos = clipPos(cm.doc, pos);
          if (!cm.options.lineWrapping) {
            left2 = charWidth(cm.display) * pos.ch;
          }
          var lineObj = getLine(cm.doc, pos.line);
          var top2 = heightAtLine(lineObj) + paddingTop(cm.display);
          return { left: left2, right: left2, top: top2, bottom: top2 + lineObj.height };
        }
        function PosWithInfo(line, ch, sticky, outside, xRel) {
          var pos = Pos(line, ch, sticky);
          pos.xRel = xRel;
          if (outside) {
            pos.outside = outside;
          }
          return pos;
        }
        function coordsChar(cm, x2, y2) {
          var doc = cm.doc;
          y2 += cm.display.viewOffset;
          if (y2 < 0) {
            return PosWithInfo(doc.first, 0, null, -1, -1);
          }
          var lineN = lineAtHeight(doc, y2), last = doc.first + doc.size - 1;
          if (lineN > last) {
            return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1);
          }
          if (x2 < 0) {
            x2 = 0;
          }
          var lineObj = getLine(doc, lineN);
          for (; ; ) {
            var found = coordsCharInner(cm, lineObj, lineN, x2, y2);
            var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
            if (!collapsed) {
              return found;
            }
            var rangeEnd = collapsed.find(1);
            if (rangeEnd.line == lineN) {
              return rangeEnd;
            }
            lineObj = getLine(doc, lineN = rangeEnd.line);
          }
        }
        function wrappedLineExtent(cm, lineObj, preparedMeasure, y2) {
          y2 -= widgetTopHeight(lineObj);
          var end2 = lineObj.text.length;
          var begin = findFirst(function(ch) {
            return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y2;
          }, end2, 0);
          end2 = findFirst(function(ch) {
            return measureCharPrepared(cm, preparedMeasure, ch).top > y2;
          }, begin, end2);
          return { begin, end: end2 };
        }
        function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
          if (!preparedMeasure) {
            preparedMeasure = prepareMeasureForLine(cm, lineObj);
          }
          var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
          return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
        }
        function boxIsAfter(box, x2, y2, left2) {
          return box.bottom <= y2 ? false : box.top > y2 ? true : (left2 ? box.left : box.right) > x2;
        }
        function coordsCharInner(cm, lineObj, lineNo2, x2, y2) {
          y2 -= heightAtLine(lineObj);
          var preparedMeasure = prepareMeasureForLine(cm, lineObj);
          var widgetHeight2 = widgetTopHeight(lineObj);
          var begin = 0, end2 = lineObj.text.length, ltr = true;
          var order2 = getOrder(lineObj, cm.doc.direction);
          if (order2) {
            var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo2, preparedMeasure, order2, x2, y2);
            ltr = part.level != 1;
            begin = ltr ? part.from : part.to - 1;
            end2 = ltr ? part.to : part.from - 1;
          }
          var chAround = null, boxAround = null;
          var ch = findFirst(function(ch2) {
            var box = measureCharPrepared(cm, preparedMeasure, ch2);
            box.top += widgetHeight2;
            box.bottom += widgetHeight2;
            if (!boxIsAfter(box, x2, y2, false)) {
              return false;
            }
            if (box.top <= y2 && box.left <= x2) {
              chAround = ch2;
              boxAround = box;
            }
            return true;
          }, begin, end2);
          var baseX, sticky, outside = false;
          if (boxAround) {
            var atLeft = x2 - boxAround.left < boxAround.right - x2, atStart = atLeft == ltr;
            ch = chAround + (atStart ? 0 : 1);
            sticky = atStart ? "after" : "before";
            baseX = atLeft ? boxAround.left : boxAround.right;
          } else {
            if (!ltr && (ch == end2 || ch == begin)) {
              ch++;
            }
            sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight2 <= y2 == ltr ? "after" : "before";
            var coords = cursorCoords(cm, Pos(lineNo2, ch, sticky), "line", lineObj, preparedMeasure);
            baseX = coords.left;
            outside = y2 < coords.top ? -1 : y2 >= coords.bottom ? 1 : 0;
          }
          ch = skipExtendingChars(lineObj.text, ch, 1);
          return PosWithInfo(lineNo2, ch, sticky, outside, x2 - baseX);
        }
        function coordsBidiPart(cm, lineObj, lineNo2, preparedMeasure, order2, x2, y2) {
          var index = findFirst(function(i3) {
            var part2 = order2[i3], ltr2 = part2.level != 1;
            return boxIsAfter(cursorCoords(cm, Pos(lineNo2, ltr2 ? part2.to : part2.from, ltr2 ? "before" : "after"), "line", lineObj, preparedMeasure), x2, y2, true);
          }, 0, order2.length - 1);
          var part = order2[index];
          if (index > 0) {
            var ltr = part.level != 1;
            var start4 = cursorCoords(cm, Pos(lineNo2, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);
            if (boxIsAfter(start4, x2, y2, true) && start4.top > y2) {
              part = order2[index - 1];
            }
          }
          return part;
        }
        function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order2, x2, y2) {
          var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y2);
          var begin = ref.begin;
          var end2 = ref.end;
          if (/\s/.test(lineObj.text.charAt(end2 - 1))) {
            end2--;
          }
          var part = null, closestDist = null;
          for (var i3 = 0; i3 < order2.length; i3++) {
            var p2 = order2[i3];
            if (p2.from >= end2 || p2.to <= begin) {
              continue;
            }
            var ltr = p2.level != 1;
            var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end2, p2.to) - 1 : Math.max(begin, p2.from)).right;
            var dist = endX < x2 ? x2 - endX + 1e9 : endX - x2;
            if (!part || closestDist > dist) {
              part = p2;
              closestDist = dist;
            }
          }
          if (!part) {
            part = order2[order2.length - 1];
          }
          if (part.from < begin) {
            part = { from: begin, to: part.to, level: part.level };
          }
          if (part.to > end2) {
            part = { from: part.from, to: end2, level: part.level };
          }
          return part;
        }
        var measureText;
        function textHeight(display) {
          if (display.cachedTextHeight != null) {
            return display.cachedTextHeight;
          }
          if (measureText == null) {
            measureText = elt("pre", null, "CodeMirror-line-like");
            for (var i3 = 0; i3 < 49; ++i3) {
              measureText.appendChild(document.createTextNode("x"));
              measureText.appendChild(elt("br"));
            }
            measureText.appendChild(document.createTextNode("x"));
          }
          removeChildrenAndAdd(display.measure, measureText);
          var height = measureText.offsetHeight / 50;
          if (height > 3) {
            display.cachedTextHeight = height;
          }
          removeChildren(display.measure);
          return height || 1;
        }
        function charWidth(display) {
          if (display.cachedCharWidth != null) {
            return display.cachedCharWidth;
          }
          var anchor = elt("span", "xxxxxxxxxx");
          var pre = elt("pre", [anchor], "CodeMirror-line-like");
          removeChildrenAndAdd(display.measure, pre);
          var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
          if (width > 2) {
            display.cachedCharWidth = width;
          }
          return width || 10;
        }
        function getDimensions(cm) {
          var d2 = cm.display, left2 = {}, width = {};
          var gutterLeft = d2.gutters.clientLeft;
          for (var n2 = d2.gutters.firstChild, i3 = 0; n2; n2 = n2.nextSibling, ++i3) {
            var id = cm.display.gutterSpecs[i3].className;
            left2[id] = n2.offsetLeft + n2.clientLeft + gutterLeft;
            width[id] = n2.clientWidth;
          }
          return {
            fixedPos: compensateForHScroll(d2),
            gutterTotalWidth: d2.gutters.offsetWidth,
            gutterLeft: left2,
            gutterWidth: width,
            wrapperWidth: d2.wrapper.clientWidth
          };
        }
        function compensateForHScroll(display) {
          return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
        }
        function estimateHeight(cm) {
          var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
          var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
          return function(line) {
            if (lineIsHidden(cm.doc, line)) {
              return 0;
            }
            var widgetsHeight = 0;
            if (line.widgets) {
              for (var i3 = 0; i3 < line.widgets.length; i3++) {
                if (line.widgets[i3].height) {
                  widgetsHeight += line.widgets[i3].height;
                }
              }
            }
            if (wrapping) {
              return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
            } else {
              return widgetsHeight + th;
            }
          };
        }
        function estimateLineHeights(cm) {
          var doc = cm.doc, est = estimateHeight(cm);
          doc.iter(function(line) {
            var estHeight = est(line);
            if (estHeight != line.height) {
              updateLineHeight(line, estHeight);
            }
          });
        }
        function posFromMouse(cm, e2, liberal, forRect) {
          var display = cm.display;
          if (!liberal && e_target(e2).getAttribute("cm-not-content") == "true") {
            return null;
          }
          var x2, y2, space = display.lineSpace.getBoundingClientRect();
          try {
            x2 = e2.clientX - space.left;
            y2 = e2.clientY - space.top;
          } catch (e$1) {
            return null;
          }
          var coords = coordsChar(cm, x2, y2), line;
          if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
            var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
            coords = Pos(coords.line, Math.max(0, Math.round((x2 - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
          }
          return coords;
        }
        function findViewIndex(cm, n2) {
          if (n2 >= cm.display.viewTo) {
            return null;
          }
          n2 -= cm.display.viewFrom;
          if (n2 < 0) {
            return null;
          }
          var view = cm.display.view;
          for (var i3 = 0; i3 < view.length; i3++) {
            n2 -= view[i3].size;
            if (n2 < 0) {
              return i3;
            }
          }
        }
        function regChange(cm, from, to, lendiff) {
          if (from == null) {
            from = cm.doc.first;
          }
          if (to == null) {
            to = cm.doc.first + cm.doc.size;
          }
          if (!lendiff) {
            lendiff = 0;
          }
          var display = cm.display;
          if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
            display.updateLineNumbers = from;
          }
          cm.curOp.viewChanged = true;
          if (from >= display.viewTo) {
            if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {
              resetView(cm);
            }
          } else if (to <= display.viewFrom) {
            if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
              resetView(cm);
            } else {
              display.viewFrom += lendiff;
              display.viewTo += lendiff;
            }
          } else if (from <= display.viewFrom && to >= display.viewTo) {
            resetView(cm);
          } else if (from <= display.viewFrom) {
            var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
            if (cut) {
              display.view = display.view.slice(cut.index);
              display.viewFrom = cut.lineN;
              display.viewTo += lendiff;
            } else {
              resetView(cm);
            }
          } else if (to >= display.viewTo) {
            var cut$1 = viewCuttingPoint(cm, from, from, -1);
            if (cut$1) {
              display.view = display.view.slice(0, cut$1.index);
              display.viewTo = cut$1.lineN;
            } else {
              resetView(cm);
            }
          } else {
            var cutTop = viewCuttingPoint(cm, from, from, -1);
            var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
            if (cutTop && cutBot) {
              display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
              display.viewTo += lendiff;
            } else {
              resetView(cm);
            }
          }
          var ext = display.externalMeasured;
          if (ext) {
            if (to < ext.lineN) {
              ext.lineN += lendiff;
            } else if (from < ext.lineN + ext.size) {
              display.externalMeasured = null;
            }
          }
        }
        function regLineChange(cm, line, type) {
          cm.curOp.viewChanged = true;
          var display = cm.display, ext = cm.display.externalMeasured;
          if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
            display.externalMeasured = null;
          }
          if (line < display.viewFrom || line >= display.viewTo) {
            return;
          }
          var lineView = display.view[findViewIndex(cm, line)];
          if (lineView.node == null) {
            return;
          }
          var arr = lineView.changes || (lineView.changes = []);
          if (indexOf2(arr, type) == -1) {
            arr.push(type);
          }
        }
        function resetView(cm) {
          cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
          cm.display.view = [];
          cm.display.viewOffset = 0;
        }
        function viewCuttingPoint(cm, oldN, newN, dir) {
          var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
          if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
            return { index, lineN: newN };
          }
          var n2 = cm.display.viewFrom;
          for (var i3 = 0; i3 < index; i3++) {
            n2 += view[i3].size;
          }
          if (n2 != oldN) {
            if (dir > 0) {
              if (index == view.length - 1) {
                return null;
              }
              diff = n2 + view[index].size - oldN;
              index++;
            } else {
              diff = n2 - oldN;
            }
            oldN += diff;
            newN += diff;
          }
          while (visualLineNo(cm.doc, newN) != newN) {
            if (index == (dir < 0 ? 0 : view.length - 1)) {
              return null;
            }
            newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
            index += dir;
          }
          return { index, lineN: newN };
        }
        function adjustView(cm, from, to) {
          var display = cm.display, view = display.view;
          if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
            display.view = buildViewArray(cm, from, to);
            display.viewFrom = from;
          } else {
            if (display.viewFrom > from) {
              display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
            } else if (display.viewFrom < from) {
              display.view = display.view.slice(findViewIndex(cm, from));
            }
            display.viewFrom = from;
            if (display.viewTo < to) {
              display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
            } else if (display.viewTo > to) {
              display.view = display.view.slice(0, findViewIndex(cm, to));
            }
          }
          display.viewTo = to;
        }
        function countDirtyView(cm) {
          var view = cm.display.view, dirty = 0;
          for (var i3 = 0; i3 < view.length; i3++) {
            var lineView = view[i3];
            if (!lineView.hidden && (!lineView.node || lineView.changes)) {
              ++dirty;
            }
          }
          return dirty;
        }
        function updateSelection(cm) {
          cm.display.input.showSelection(cm.display.input.prepareSelection());
        }
        function prepareSelection(cm, primary) {
          if (primary === void 0)
            primary = true;
          var doc = cm.doc, result = {};
          var curFragment = result.cursors = document.createDocumentFragment();
          var selFragment = result.selection = document.createDocumentFragment();
          for (var i3 = 0; i3 < doc.sel.ranges.length; i3++) {
            if (!primary && i3 == doc.sel.primIndex) {
              continue;
            }
            var range2 = doc.sel.ranges[i3];
            if (range2.from().line >= cm.display.viewTo || range2.to().line < cm.display.viewFrom) {
              continue;
            }
            var collapsed = range2.empty();
            if (collapsed || cm.options.showCursorWhenSelecting) {
              drawSelectionCursor(cm, range2.head, curFragment);
            }
            if (!collapsed) {
              drawSelectionRange(cm, range2, selFragment);
            }
          }
          return result;
        }
        function drawSelectionCursor(cm, head, output) {
          var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
          var cursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor"));
          cursor.style.left = pos.left + "px";
          cursor.style.top = pos.top + "px";
          cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
          if (pos.other) {
            var otherCursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor CodeMirror-secondarycursor"));
            otherCursor.style.display = "";
            otherCursor.style.left = pos.other.left + "px";
            otherCursor.style.top = pos.other.top + "px";
            otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + "px";
          }
        }
        function cmpCoords(a2, b2) {
          return a2.top - b2.top || a2.left - b2.left;
        }
        function drawSelectionRange(cm, range2, output) {
          var display = cm.display, doc = cm.doc;
          var fragment = document.createDocumentFragment();
          var padding = paddingH(cm.display), leftSide = padding.left;
          var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
          var docLTR = doc.direction == "ltr";
          function add3(left2, top2, width, bottom2) {
            if (top2 < 0) {
              top2 = 0;
            }
            top2 = Math.round(top2);
            bottom2 = Math.round(bottom2);
            fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left2 + "px;\n                             top: " + top2 + "px; width: " + (width == null ? rightSide - left2 : width) + "px;\n                             height: " + (bottom2 - top2) + "px"));
          }
          function drawForLine(line, fromArg, toArg) {
            var lineObj = getLine(doc, line);
            var lineLen = lineObj.text.length;
            var start4, end2;
            function coords(ch, bias) {
              return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
            }
            function wrapX(pos, dir, side) {
              var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
              var prop2 = dir == "ltr" == (side == "after") ? "left" : "right";
              var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
              return coords(ch, prop2)[prop2];
            }
            var order2 = getOrder(lineObj, doc.direction);
            iterateBidiSections(order2, fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir, i3) {
              var ltr = dir == "ltr";
              var fromPos = coords(from, ltr ? "left" : "right");
              var toPos = coords(to - 1, ltr ? "right" : "left");
              var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
              var first = i3 == 0, last = !order2 || i3 == order2.length - 1;
              if (toPos.top - fromPos.top <= 3) {
                var openLeft = (docLTR ? openStart : openEnd) && first;
                var openRight = (docLTR ? openEnd : openStart) && last;
                var left2 = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
                var right2 = openRight ? rightSide : (ltr ? toPos : fromPos).right;
                add3(left2, fromPos.top, right2 - left2, fromPos.bottom);
              } else {
                var topLeft, topRight, botLeft, botRight;
                if (ltr) {
                  topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
                  topRight = docLTR ? rightSide : wrapX(from, dir, "before");
                  botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
                  botRight = docLTR && openEnd && last ? rightSide : toPos.right;
                } else {
                  topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
                  topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
                  botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
                  botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
                }
                add3(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
                if (fromPos.bottom < toPos.top) {
                  add3(leftSide, fromPos.bottom, null, toPos.top);
                }
                add3(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
              }
              if (!start4 || cmpCoords(fromPos, start4) < 0) {
                start4 = fromPos;
              }
              if (cmpCoords(toPos, start4) < 0) {
                start4 = toPos;
              }
              if (!end2 || cmpCoords(fromPos, end2) < 0) {
                end2 = fromPos;
              }
              if (cmpCoords(toPos, end2) < 0) {
                end2 = toPos;
              }
            });
            return { start: start4, end: end2 };
          }
          var sFrom = range2.from(), sTo = range2.to();
          if (sFrom.line == sTo.line) {
            drawForLine(sFrom.line, sFrom.ch, sTo.ch);
          } else {
            var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
            var singleVLine = visualLine(fromLine) == visualLine(toLine);
            var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
            var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
            if (singleVLine) {
              if (leftEnd.top < rightStart.top - 2) {
                add3(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
                add3(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
              } else {
                add3(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
              }
            }
            if (leftEnd.bottom < rightStart.top) {
              add3(leftSide, leftEnd.bottom, null, rightStart.top);
            }
          }
          output.appendChild(fragment);
        }
        function restartBlink(cm) {
          if (!cm.state.focused) {
            return;
          }
          var display = cm.display;
          clearInterval(display.blinker);
          var on2 = true;
          display.cursorDiv.style.visibility = "";
          if (cm.options.cursorBlinkRate > 0) {
            display.blinker = setInterval(function() {
              if (!cm.hasFocus()) {
                onBlur(cm);
              }
              display.cursorDiv.style.visibility = (on2 = !on2) ? "" : "hidden";
            }, cm.options.cursorBlinkRate);
          } else if (cm.options.cursorBlinkRate < 0) {
            display.cursorDiv.style.visibility = "hidden";
          }
        }
        function ensureFocus(cm) {
          if (!cm.hasFocus()) {
            cm.display.input.focus();
            if (!cm.state.focused) {
              onFocus(cm);
            }
          }
        }
        function delayBlurEvent(cm) {
          cm.state.delayingBlurEvent = true;
          setTimeout(function() {
            if (cm.state.delayingBlurEvent) {
              cm.state.delayingBlurEvent = false;
              if (cm.state.focused) {
                onBlur(cm);
              }
            }
          }, 100);
        }
        function onFocus(cm, e2) {
          if (cm.state.delayingBlurEvent && !cm.state.draggingText) {
            cm.state.delayingBlurEvent = false;
          }
          if (cm.options.readOnly == "nocursor") {
            return;
          }
          if (!cm.state.focused) {
            signal(cm, "focus", cm, e2);
            cm.state.focused = true;
            addClass(cm.display.wrapper, "CodeMirror-focused");
            if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
              cm.display.input.reset();
              if (webkit) {
                setTimeout(function() {
                  return cm.display.input.reset(true);
                }, 20);
              }
            }
            cm.display.input.receivedFocus();
          }
          restartBlink(cm);
        }
        function onBlur(cm, e2) {
          if (cm.state.delayingBlurEvent) {
            return;
          }
          if (cm.state.focused) {
            signal(cm, "blur", cm, e2);
            cm.state.focused = false;
            rmClass(cm.display.wrapper, "CodeMirror-focused");
          }
          clearInterval(cm.display.blinker);
          setTimeout(function() {
            if (!cm.state.focused) {
              cm.display.shift = false;
            }
          }, 150);
        }
        function updateHeightsInViewport(cm) {
          var display = cm.display;
          var prevBottom = display.lineDiv.offsetTop;
          for (var i3 = 0; i3 < display.view.length; i3++) {
            var cur = display.view[i3], wrapping = cm.options.lineWrapping;
            var height = void 0, width = 0;
            if (cur.hidden) {
              continue;
            }
            if (ie && ie_version < 8) {
              var bot = cur.node.offsetTop + cur.node.offsetHeight;
              height = bot - prevBottom;
              prevBottom = bot;
            } else {
              var box = cur.node.getBoundingClientRect();
              height = box.bottom - box.top;
              if (!wrapping && cur.text.firstChild) {
                width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;
              }
            }
            var diff = cur.line.height - height;
            if (diff > 5e-3 || diff < -5e-3) {
              updateLineHeight(cur.line, height);
              updateWidgetHeight(cur.line);
              if (cur.rest) {
                for (var j2 = 0; j2 < cur.rest.length; j2++) {
                  updateWidgetHeight(cur.rest[j2]);
                }
              }
            }
            if (width > cm.display.sizerWidth) {
              var chWidth = Math.ceil(width / charWidth(cm.display));
              if (chWidth > cm.display.maxLineLength) {
                cm.display.maxLineLength = chWidth;
                cm.display.maxLine = cur.line;
                cm.display.maxLineChanged = true;
              }
            }
          }
        }
        function updateWidgetHeight(line) {
          if (line.widgets) {
            for (var i3 = 0; i3 < line.widgets.length; ++i3) {
              var w = line.widgets[i3], parent = w.node.parentNode;
              if (parent) {
                w.height = parent.offsetHeight;
              }
            }
          }
        }
        function visibleLines(display, doc, viewport2) {
          var top2 = viewport2 && viewport2.top != null ? Math.max(0, viewport2.top) : display.scroller.scrollTop;
          top2 = Math.floor(top2 - paddingTop(display));
          var bottom2 = viewport2 && viewport2.bottom != null ? viewport2.bottom : top2 + display.wrapper.clientHeight;
          var from = lineAtHeight(doc, top2), to = lineAtHeight(doc, bottom2);
          if (viewport2 && viewport2.ensure) {
            var ensureFrom = viewport2.ensure.from.line, ensureTo = viewport2.ensure.to.line;
            if (ensureFrom < from) {
              from = ensureFrom;
              to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
            } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
              from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
              to = ensureTo;
            }
          }
          return { from, to: Math.max(to, from + 1) };
        }
        function maybeScrollWindow(cm, rect) {
          if (signalDOMEvent(cm, "scrollCursorIntoView")) {
            return;
          }
          var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
          if (rect.top + box.top < 0) {
            doScroll = true;
          } else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {
            doScroll = false;
          }
          if (doScroll != null && !phantom) {
            var scrollNode = elt("div", "\u200B", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
            cm.display.lineSpace.appendChild(scrollNode);
            scrollNode.scrollIntoView(doScroll);
            cm.display.lineSpace.removeChild(scrollNode);
          }
        }
        function scrollPosIntoView(cm, pos, end2, margin) {
          if (margin == null) {
            margin = 0;
          }
          var rect;
          if (!cm.options.lineWrapping && pos == end2) {
            pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
            end2 = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
          }
          for (var limit = 0; limit < 5; limit++) {
            var changed = false;
            var coords = cursorCoords(cm, pos);
            var endCoords = !end2 || end2 == pos ? coords : cursorCoords(cm, end2);
            rect = {
              left: Math.min(coords.left, endCoords.left),
              top: Math.min(coords.top, endCoords.top) - margin,
              right: Math.max(coords.left, endCoords.left),
              bottom: Math.max(coords.bottom, endCoords.bottom) + margin
            };
            var scrollPos = calculateScrollPos(cm, rect);
            var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
            if (scrollPos.scrollTop != null) {
              updateScrollTop(cm, scrollPos.scrollTop);
              if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
                changed = true;
              }
            }
            if (scrollPos.scrollLeft != null) {
              setScrollLeft(cm, scrollPos.scrollLeft);
              if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
                changed = true;
              }
            }
            if (!changed) {
              break;
            }
          }
          return rect;
        }
        function scrollIntoView(cm, rect) {
          var scrollPos = calculateScrollPos(cm, rect);
          if (scrollPos.scrollTop != null) {
            updateScrollTop(cm, scrollPos.scrollTop);
          }
          if (scrollPos.scrollLeft != null) {
            setScrollLeft(cm, scrollPos.scrollLeft);
          }
        }
        function calculateScrollPos(cm, rect) {
          var display = cm.display, snapMargin = textHeight(cm.display);
          if (rect.top < 0) {
            rect.top = 0;
          }
          var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
          var screen2 = displayHeight(cm), result = {};
          if (rect.bottom - rect.top > screen2) {
            rect.bottom = rect.top + screen2;
          }
          var docBottom = cm.doc.height + paddingVert(display);
          var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
          if (rect.top < screentop) {
            result.scrollTop = atTop ? 0 : rect.top;
          } else if (rect.bottom > screentop + screen2) {
            var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen2);
            if (newTop != screentop) {
              result.scrollTop = newTop;
            }
          }
          var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
          var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
          var screenw = displayWidth(cm) - display.gutters.offsetWidth;
          var tooWide = rect.right - rect.left > screenw;
          if (tooWide) {
            rect.right = rect.left + screenw;
          }
          if (rect.left < 10) {
            result.scrollLeft = 0;
          } else if (rect.left < screenleft) {
            result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10));
          } else if (rect.right > screenw + screenleft - 3) {
            result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
          }
          return result;
        }
        function addToScrollTop(cm, top2) {
          if (top2 == null) {
            return;
          }
          resolveScrollToPos(cm);
          cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top2;
        }
        function ensureCursorVisible(cm) {
          resolveScrollToPos(cm);
          var cur = cm.getCursor();
          cm.curOp.scrollToPos = { from: cur, to: cur, margin: cm.options.cursorScrollMargin };
        }
        function scrollToCoords(cm, x2, y2) {
          if (x2 != null || y2 != null) {
            resolveScrollToPos(cm);
          }
          if (x2 != null) {
            cm.curOp.scrollLeft = x2;
          }
          if (y2 != null) {
            cm.curOp.scrollTop = y2;
          }
        }
        function scrollToRange(cm, range2) {
          resolveScrollToPos(cm);
          cm.curOp.scrollToPos = range2;
        }
        function resolveScrollToPos(cm) {
          var range2 = cm.curOp.scrollToPos;
          if (range2) {
            cm.curOp.scrollToPos = null;
            var from = estimateCoords(cm, range2.from), to = estimateCoords(cm, range2.to);
            scrollToCoordsRange(cm, from, to, range2.margin);
          }
        }
        function scrollToCoordsRange(cm, from, to, margin) {
          var sPos = calculateScrollPos(cm, {
            left: Math.min(from.left, to.left),
            top: Math.min(from.top, to.top) - margin,
            right: Math.max(from.right, to.right),
            bottom: Math.max(from.bottom, to.bottom) + margin
          });
          scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
        }
        function updateScrollTop(cm, val) {
          if (Math.abs(cm.doc.scrollTop - val) < 2) {
            return;
          }
          if (!gecko) {
            updateDisplaySimple(cm, { top: val });
          }
          setScrollTop(cm, val, true);
          if (gecko) {
            updateDisplaySimple(cm);
          }
          startWorker(cm, 100);
        }
        function setScrollTop(cm, val, forceScroll) {
          val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
          if (cm.display.scroller.scrollTop == val && !forceScroll) {
            return;
          }
          cm.doc.scrollTop = val;
          cm.display.scrollbars.setScrollTop(val);
          if (cm.display.scroller.scrollTop != val) {
            cm.display.scroller.scrollTop = val;
          }
        }
        function setScrollLeft(cm, val, isScroller, forceScroll) {
          val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
          if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
            return;
          }
          cm.doc.scrollLeft = val;
          alignHorizontally(cm);
          if (cm.display.scroller.scrollLeft != val) {
            cm.display.scroller.scrollLeft = val;
          }
          cm.display.scrollbars.setScrollLeft(val);
        }
        function measureForScrollbars(cm) {
          var d2 = cm.display, gutterW = d2.gutters.offsetWidth;
          var docH = Math.round(cm.doc.height + paddingVert(cm.display));
          return {
            clientHeight: d2.scroller.clientHeight,
            viewHeight: d2.wrapper.clientHeight,
            scrollWidth: d2.scroller.scrollWidth,
            clientWidth: d2.scroller.clientWidth,
            viewWidth: d2.wrapper.clientWidth,
            barLeft: cm.options.fixedGutter ? gutterW : 0,
            docHeight: docH,
            scrollHeight: docH + scrollGap(cm) + d2.barHeight,
            nativeBarWidth: d2.nativeBarWidth,
            gutterWidth: gutterW
          };
        }
        var NativeScrollbars = function(place, scroll, cm) {
          this.cm = cm;
          var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
          var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
          vert.tabIndex = horiz.tabIndex = -1;
          place(vert);
          place(horiz);
          on(vert, "scroll", function() {
            if (vert.clientHeight) {
              scroll(vert.scrollTop, "vertical");
            }
          });
          on(horiz, "scroll", function() {
            if (horiz.clientWidth) {
              scroll(horiz.scrollLeft, "horizontal");
            }
          });
          this.checkedZeroWidth = false;
          if (ie && ie_version < 8) {
            this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
          }
        };
        NativeScrollbars.prototype.update = function(measure) {
          var needsH = measure.scrollWidth > measure.clientWidth + 1;
          var needsV = measure.scrollHeight > measure.clientHeight + 1;
          var sWidth = measure.nativeBarWidth;
          if (needsV) {
            this.vert.style.display = "block";
            this.vert.style.bottom = needsH ? sWidth + "px" : "0";
            var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
            this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
          } else {
            this.vert.style.display = "";
            this.vert.firstChild.style.height = "0";
          }
          if (needsH) {
            this.horiz.style.display = "block";
            this.horiz.style.right = needsV ? sWidth + "px" : "0";
            this.horiz.style.left = measure.barLeft + "px";
            var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
            this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
          } else {
            this.horiz.style.display = "";
            this.horiz.firstChild.style.width = "0";
          }
          if (!this.checkedZeroWidth && measure.clientHeight > 0) {
            if (sWidth == 0) {
              this.zeroWidthHack();
            }
            this.checkedZeroWidth = true;
          }
          return { right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0 };
        };
        NativeScrollbars.prototype.setScrollLeft = function(pos) {
          if (this.horiz.scrollLeft != pos) {
            this.horiz.scrollLeft = pos;
          }
          if (this.disableHoriz) {
            this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
          }
        };
        NativeScrollbars.prototype.setScrollTop = function(pos) {
          if (this.vert.scrollTop != pos) {
            this.vert.scrollTop = pos;
          }
          if (this.disableVert) {
            this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
          }
        };
        NativeScrollbars.prototype.zeroWidthHack = function() {
          var w = mac && !mac_geMountainLion ? "12px" : "18px";
          this.horiz.style.height = this.vert.style.width = w;
          this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
          this.disableHoriz = new Delayed();
          this.disableVert = new Delayed();
        };
        NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay, type) {
          bar.style.pointerEvents = "auto";
          function maybeDisable() {
            var box = bar.getBoundingClientRect();
            var elt2 = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
            if (elt2 != bar) {
              bar.style.pointerEvents = "none";
            } else {
              delay.set(1e3, maybeDisable);
            }
          }
          delay.set(1e3, maybeDisable);
        };
        NativeScrollbars.prototype.clear = function() {
          var parent = this.horiz.parentNode;
          parent.removeChild(this.horiz);
          parent.removeChild(this.vert);
        };
        var NullScrollbars = function() {
        };
        NullScrollbars.prototype.update = function() {
          return { bottom: 0, right: 0 };
        };
        NullScrollbars.prototype.setScrollLeft = function() {
        };
        NullScrollbars.prototype.setScrollTop = function() {
        };
        NullScrollbars.prototype.clear = function() {
        };
        function updateScrollbars(cm, measure) {
          if (!measure) {
            measure = measureForScrollbars(cm);
          }
          var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
          updateScrollbarsInner(cm, measure);
          for (var i3 = 0; i3 < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i3++) {
            if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
              updateHeightsInViewport(cm);
            }
            updateScrollbarsInner(cm, measureForScrollbars(cm));
            startWidth = cm.display.barWidth;
            startHeight = cm.display.barHeight;
          }
        }
        function updateScrollbarsInner(cm, measure) {
          var d2 = cm.display;
          var sizes = d2.scrollbars.update(measure);
          d2.sizer.style.paddingRight = (d2.barWidth = sizes.right) + "px";
          d2.sizer.style.paddingBottom = (d2.barHeight = sizes.bottom) + "px";
          d2.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
          if (sizes.right && sizes.bottom) {
            d2.scrollbarFiller.style.display = "block";
            d2.scrollbarFiller.style.height = sizes.bottom + "px";
            d2.scrollbarFiller.style.width = sizes.right + "px";
          } else {
            d2.scrollbarFiller.style.display = "";
          }
          if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
            d2.gutterFiller.style.display = "block";
            d2.gutterFiller.style.height = sizes.bottom + "px";
            d2.gutterFiller.style.width = measure.gutterWidth + "px";
          } else {
            d2.gutterFiller.style.display = "";
          }
        }
        var scrollbarModel = { "native": NativeScrollbars, "null": NullScrollbars };
        function initScrollbars(cm) {
          if (cm.display.scrollbars) {
            cm.display.scrollbars.clear();
            if (cm.display.scrollbars.addClass) {
              rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
            }
          }
          cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {
            cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
            on(node, "mousedown", function() {
              if (cm.state.focused) {
                setTimeout(function() {
                  return cm.display.input.focus();
                }, 0);
              }
            });
            node.setAttribute("cm-not-content", "true");
          }, function(pos, axis) {
            if (axis == "horizontal") {
              setScrollLeft(cm, pos);
            } else {
              updateScrollTop(cm, pos);
            }
          }, cm);
          if (cm.display.scrollbars.addClass) {
            addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
          }
        }
        var nextOpId = 0;
        function startOperation(cm) {
          cm.curOp = {
            cm,
            viewChanged: false,
            startHeight: cm.doc.height,
            forceUpdate: false,
            updateInput: 0,
            typing: false,
            changeObjs: null,
            cursorActivityHandlers: null,
            cursorActivityCalled: 0,
            selectionChanged: false,
            updateMaxLine: false,
            scrollLeft: null,
            scrollTop: null,
            scrollToPos: null,
            focus: false,
            id: ++nextOpId
          };
          pushOperation(cm.curOp);
        }
        function endOperation(cm) {
          var op = cm.curOp;
          if (op) {
            finishOperation(op, function(group) {
              for (var i3 = 0; i3 < group.ops.length; i3++) {
                group.ops[i3].cm.curOp = null;
              }
              endOperations(group);
            });
          }
        }
        function endOperations(group) {
          var ops = group.ops;
          for (var i3 = 0; i3 < ops.length; i3++) {
            endOperation_R1(ops[i3]);
          }
          for (var i$12 = 0; i$12 < ops.length; i$12++) {
            endOperation_W1(ops[i$12]);
          }
          for (var i$22 = 0; i$22 < ops.length; i$22++) {
            endOperation_R2(ops[i$22]);
          }
          for (var i$3 = 0; i$3 < ops.length; i$3++) {
            endOperation_W2(ops[i$3]);
          }
          for (var i$4 = 0; i$4 < ops.length; i$4++) {
            endOperation_finish(ops[i$4]);
          }
        }
        function endOperation_R1(op) {
          var cm = op.cm, display = cm.display;
          maybeClipScrollbars(cm);
          if (op.updateMaxLine) {
            findMaxLine(cm);
          }
          op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
          op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && { top: op.scrollTop, ensure: op.scrollToPos }, op.forceUpdate);
        }
        function endOperation_W1(op) {
          op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
        }
        function endOperation_R2(op) {
          var cm = op.cm, display = cm.display;
          if (op.updatedDisplay) {
            updateHeightsInViewport(cm);
          }
          op.barMeasure = measureForScrollbars(cm);
          if (display.maxLineChanged && !cm.options.lineWrapping) {
            op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
            cm.display.sizerWidth = op.adjustWidthTo;
            op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
            op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
          }
          if (op.updatedDisplay || op.selectionChanged) {
            op.preparedSelection = display.input.prepareSelection();
          }
        }
        function endOperation_W2(op) {
          var cm = op.cm;
          if (op.adjustWidthTo != null) {
            cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
            if (op.maxScrollLeft < cm.doc.scrollLeft) {
              setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
            }
            cm.display.maxLineChanged = false;
          }
          var takeFocus = op.focus && op.focus == activeElt();
          if (op.preparedSelection) {
            cm.display.input.showSelection(op.preparedSelection, takeFocus);
          }
          if (op.updatedDisplay || op.startHeight != cm.doc.height) {
            updateScrollbars(cm, op.barMeasure);
          }
          if (op.updatedDisplay) {
            setDocumentHeight(cm, op.barMeasure);
          }
          if (op.selectionChanged) {
            restartBlink(cm);
          }
          if (cm.state.focused && op.updateInput) {
            cm.display.input.reset(op.typing);
          }
          if (takeFocus) {
            ensureFocus(op.cm);
          }
        }
        function endOperation_finish(op) {
          var cm = op.cm, display = cm.display, doc = cm.doc;
          if (op.updatedDisplay) {
            postUpdateDisplay(cm, op.update);
          }
          if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
            display.wheelStartX = display.wheelStartY = null;
          }
          if (op.scrollTop != null) {
            setScrollTop(cm, op.scrollTop, op.forceScroll);
          }
          if (op.scrollLeft != null) {
            setScrollLeft(cm, op.scrollLeft, true, true);
          }
          if (op.scrollToPos) {
            var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
            maybeScrollWindow(cm, rect);
          }
          var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
          if (hidden) {
            for (var i3 = 0; i3 < hidden.length; ++i3) {
              if (!hidden[i3].lines.length) {
                signal(hidden[i3], "hide");
              }
            }
          }
          if (unhidden) {
            for (var i$12 = 0; i$12 < unhidden.length; ++i$12) {
              if (unhidden[i$12].lines.length) {
                signal(unhidden[i$12], "unhide");
              }
            }
          }
          if (display.wrapper.offsetHeight) {
            doc.scrollTop = cm.display.scroller.scrollTop;
          }
          if (op.changeObjs) {
            signal(cm, "changes", cm, op.changeObjs);
          }
          if (op.update) {
            op.update.finish();
          }
        }
        function runInOp(cm, f2) {
          if (cm.curOp) {
            return f2();
          }
          startOperation(cm);
          try {
            return f2();
          } finally {
            endOperation(cm);
          }
        }
        function operation(cm, f2) {
          return function() {
            if (cm.curOp) {
              return f2.apply(cm, arguments);
            }
            startOperation(cm);
            try {
              return f2.apply(cm, arguments);
            } finally {
              endOperation(cm);
            }
          };
        }
        function methodOp(f2) {
          return function() {
            if (this.curOp) {
              return f2.apply(this, arguments);
            }
            startOperation(this);
            try {
              return f2.apply(this, arguments);
            } finally {
              endOperation(this);
            }
          };
        }
        function docMethodOp(f2) {
          return function() {
            var cm = this.cm;
            if (!cm || cm.curOp) {
              return f2.apply(this, arguments);
            }
            startOperation(cm);
            try {
              return f2.apply(this, arguments);
            } finally {
              endOperation(cm);
            }
          };
        }
        function startWorker(cm, time) {
          if (cm.doc.highlightFrontier < cm.display.viewTo) {
            cm.state.highlight.set(time, bind3(highlightWorker, cm));
          }
        }
        function highlightWorker(cm) {
          var doc = cm.doc;
          if (doc.highlightFrontier >= cm.display.viewTo) {
            return;
          }
          var end2 = +new Date() + cm.options.workTime;
          var context = getContextBefore(cm, doc.highlightFrontier);
          var changedLines = [];
          doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
            if (context.line >= cm.display.viewFrom) {
              var oldStyles = line.styles;
              var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
              var highlighted = highlightLine(cm, line, context, true);
              if (resetState) {
                context.state = resetState;
              }
              line.styles = highlighted.styles;
              var oldCls = line.styleClasses, newCls = highlighted.classes;
              if (newCls) {
                line.styleClasses = newCls;
              } else if (oldCls) {
                line.styleClasses = null;
              }
              var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
              for (var i3 = 0; !ischange && i3 < oldStyles.length; ++i3) {
                ischange = oldStyles[i3] != line.styles[i3];
              }
              if (ischange) {
                changedLines.push(context.line);
              }
              line.stateAfter = context.save();
              context.nextLine();
            } else {
              if (line.text.length <= cm.options.maxHighlightLength) {
                processLine(cm, line.text, context);
              }
              line.stateAfter = context.line % 5 == 0 ? context.save() : null;
              context.nextLine();
            }
            if (+new Date() > end2) {
              startWorker(cm, cm.options.workDelay);
              return true;
            }
          });
          doc.highlightFrontier = context.line;
          doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
          if (changedLines.length) {
            runInOp(cm, function() {
              for (var i3 = 0; i3 < changedLines.length; i3++) {
                regLineChange(cm, changedLines[i3], "text");
              }
            });
          }
        }
        var DisplayUpdate = function(cm, viewport2, force) {
          var display = cm.display;
          this.viewport = viewport2;
          this.visible = visibleLines(display, cm.doc, viewport2);
          this.editorIsHidden = !display.wrapper.offsetWidth;
          this.wrapperHeight = display.wrapper.clientHeight;
          this.wrapperWidth = display.wrapper.clientWidth;
          this.oldDisplayWidth = displayWidth(cm);
          this.force = force;
          this.dims = getDimensions(cm);
          this.events = [];
        };
        DisplayUpdate.prototype.signal = function(emitter, type) {
          if (hasHandler(emitter, type)) {
            this.events.push(arguments);
          }
        };
        DisplayUpdate.prototype.finish = function() {
          for (var i3 = 0; i3 < this.events.length; i3++) {
            signal.apply(null, this.events[i3]);
          }
        };
        function maybeClipScrollbars(cm) {
          var display = cm.display;
          if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
            display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
            display.heightForcer.style.height = scrollGap(cm) + "px";
            display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
            display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
            display.scrollbarsClipped = true;
          }
        }
        function selectionSnapshot(cm) {
          if (cm.hasFocus()) {
            return null;
          }
          var active = activeElt();
          if (!active || !contains2(cm.display.lineDiv, active)) {
            return null;
          }
          var result = { activeElt: active };
          if (window.getSelection) {
            var sel = window.getSelection();
            if (sel.anchorNode && sel.extend && contains2(cm.display.lineDiv, sel.anchorNode)) {
              result.anchorNode = sel.anchorNode;
              result.anchorOffset = sel.anchorOffset;
              result.focusNode = sel.focusNode;
              result.focusOffset = sel.focusOffset;
            }
          }
          return result;
        }
        function restoreSelection(snapshot) {
          if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) {
            return;
          }
          snapshot.activeElt.focus();
          if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains2(document.body, snapshot.anchorNode) && contains2(document.body, snapshot.focusNode)) {
            var sel = window.getSelection(), range2 = document.createRange();
            range2.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
            range2.collapse(false);
            sel.removeAllRanges();
            sel.addRange(range2);
            sel.extend(snapshot.focusNode, snapshot.focusOffset);
          }
        }
        function updateDisplayIfNeeded(cm, update) {
          var display = cm.display, doc = cm.doc;
          if (update.editorIsHidden) {
            resetView(cm);
            return false;
          }
          if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
            return false;
          }
          if (maybeUpdateLineNumberWidth(cm)) {
            resetView(cm);
            update.dims = getDimensions(cm);
          }
          var end2 = doc.first + doc.size;
          var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
          var to = Math.min(end2, update.visible.to + cm.options.viewportMargin);
          if (display.viewFrom < from && from - display.viewFrom < 20) {
            from = Math.max(doc.first, display.viewFrom);
          }
          if (display.viewTo > to && display.viewTo - to < 20) {
            to = Math.min(end2, display.viewTo);
          }
          if (sawCollapsedSpans) {
            from = visualLineNo(cm.doc, from);
            to = visualLineEndNo(cm.doc, to);
          }
          var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
          adjustView(cm, from, to);
          display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
          cm.display.mover.style.top = display.viewOffset + "px";
          var toUpdate = countDirtyView(cm);
          if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
            return false;
          }
          var selSnapshot = selectionSnapshot(cm);
          if (toUpdate > 4) {
            display.lineDiv.style.display = "none";
          }
          patchDisplay(cm, display.updateLineNumbers, update.dims);
          if (toUpdate > 4) {
            display.lineDiv.style.display = "";
          }
          display.renderedView = display.view;
          restoreSelection(selSnapshot);
          removeChildren(display.cursorDiv);
          removeChildren(display.selectionDiv);
          display.gutters.style.height = display.sizer.style.minHeight = 0;
          if (different) {
            display.lastWrapHeight = update.wrapperHeight;
            display.lastWrapWidth = update.wrapperWidth;
            startWorker(cm, 400);
          }
          display.updateLineNumbers = null;
          return true;
        }
        function postUpdateDisplay(cm, update) {
          var viewport2 = update.viewport;
          for (var first = true; ; first = false) {
            if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
              if (viewport2 && viewport2.top != null) {
                viewport2 = { top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport2.top) };
              }
              update.visible = visibleLines(cm.display, cm.doc, viewport2);
              if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
                break;
              }
            } else if (first) {
              update.visible = visibleLines(cm.display, cm.doc, viewport2);
            }
            if (!updateDisplayIfNeeded(cm, update)) {
              break;
            }
            updateHeightsInViewport(cm);
            var barMeasure = measureForScrollbars(cm);
            updateSelection(cm);
            updateScrollbars(cm, barMeasure);
            setDocumentHeight(cm, barMeasure);
            update.force = false;
          }
          update.signal(cm, "update", cm);
          if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
            update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
            cm.display.reportedViewFrom = cm.display.viewFrom;
            cm.display.reportedViewTo = cm.display.viewTo;
          }
        }
        function updateDisplaySimple(cm, viewport2) {
          var update = new DisplayUpdate(cm, viewport2);
          if (updateDisplayIfNeeded(cm, update)) {
            updateHeightsInViewport(cm);
            postUpdateDisplay(cm, update);
            var barMeasure = measureForScrollbars(cm);
            updateSelection(cm);
            updateScrollbars(cm, barMeasure);
            setDocumentHeight(cm, barMeasure);
            update.finish();
          }
        }
        function patchDisplay(cm, updateNumbersFrom, dims) {
          var display = cm.display, lineNumbers = cm.options.lineNumbers;
          var container = display.lineDiv, cur = container.firstChild;
          function rm(node2) {
            var next = node2.nextSibling;
            if (webkit && mac && cm.display.currentWheelTarget == node2) {
              node2.style.display = "none";
            } else {
              node2.parentNode.removeChild(node2);
            }
            return next;
          }
          var view = display.view, lineN = display.viewFrom;
          for (var i3 = 0; i3 < view.length; i3++) {
            var lineView = view[i3];
            if (lineView.hidden)
              ;
            else if (!lineView.node || lineView.node.parentNode != container) {
              var node = buildLineElement(cm, lineView, lineN, dims);
              container.insertBefore(node, cur);
            } else {
              while (cur != lineView.node) {
                cur = rm(cur);
              }
              var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
              if (lineView.changes) {
                if (indexOf2(lineView.changes, "gutter") > -1) {
                  updateNumber = false;
                }
                updateLineForChanges(cm, lineView, lineN, dims);
              }
              if (updateNumber) {
                removeChildren(lineView.lineNumber);
                lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
              }
              cur = lineView.node.nextSibling;
            }
            lineN += lineView.size;
          }
          while (cur) {
            cur = rm(cur);
          }
        }
        function updateGutterSpace(display) {
          var width = display.gutters.offsetWidth;
          display.sizer.style.marginLeft = width + "px";
        }
        function setDocumentHeight(cm, measure) {
          cm.display.sizer.style.minHeight = measure.docHeight + "px";
          cm.display.heightForcer.style.top = measure.docHeight + "px";
          cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
        }
        function alignHorizontally(cm) {
          var display = cm.display, view = display.view;
          if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
            return;
          }
          var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
          var gutterW = display.gutters.offsetWidth, left2 = comp + "px";
          for (var i3 = 0; i3 < view.length; i3++) {
            if (!view[i3].hidden) {
              if (cm.options.fixedGutter) {
                if (view[i3].gutter) {
                  view[i3].gutter.style.left = left2;
                }
                if (view[i3].gutterBackground) {
                  view[i3].gutterBackground.style.left = left2;
                }
              }
              var align = view[i3].alignable;
              if (align) {
                for (var j2 = 0; j2 < align.length; j2++) {
                  align[j2].style.left = left2;
                }
              }
            }
          }
          if (cm.options.fixedGutter) {
            display.gutters.style.left = comp + gutterW + "px";
          }
        }
        function maybeUpdateLineNumberWidth(cm) {
          if (!cm.options.lineNumbers) {
            return false;
          }
          var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
          if (last.length != display.lineNumChars) {
            var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
            var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
            display.lineGutter.style.width = "";
            display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
            display.lineNumWidth = display.lineNumInnerWidth + padding;
            display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
            display.lineGutter.style.width = display.lineNumWidth + "px";
            updateGutterSpace(cm.display);
            return true;
          }
          return false;
        }
        function getGutters(gutters, lineNumbers) {
          var result = [], sawLineNumbers = false;
          for (var i3 = 0; i3 < gutters.length; i3++) {
            var name = gutters[i3], style = null;
            if (typeof name != "string") {
              style = name.style;
              name = name.className;
            }
            if (name == "CodeMirror-linenumbers") {
              if (!lineNumbers) {
                continue;
              } else {
                sawLineNumbers = true;
              }
            }
            result.push({ className: name, style });
          }
          if (lineNumbers && !sawLineNumbers) {
            result.push({ className: "CodeMirror-linenumbers", style: null });
          }
          return result;
        }
        function renderGutters(display) {
          var gutters = display.gutters, specs = display.gutterSpecs;
          removeChildren(gutters);
          display.lineGutter = null;
          for (var i3 = 0; i3 < specs.length; ++i3) {
            var ref = specs[i3];
            var className = ref.className;
            var style = ref.style;
            var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
            if (style) {
              gElt.style.cssText = style;
            }
            if (className == "CodeMirror-linenumbers") {
              display.lineGutter = gElt;
              gElt.style.width = (display.lineNumWidth || 1) + "px";
            }
          }
          gutters.style.display = specs.length ? "" : "none";
          updateGutterSpace(display);
        }
        function updateGutters(cm) {
          renderGutters(cm.display);
          regChange(cm);
          alignHorizontally(cm);
        }
        function Display(place, doc, input, options) {
          var d2 = this;
          this.input = input;
          d2.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
          d2.scrollbarFiller.setAttribute("cm-not-content", "true");
          d2.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
          d2.gutterFiller.setAttribute("cm-not-content", "true");
          d2.lineDiv = eltP("div", null, "CodeMirror-code");
          d2.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
          d2.cursorDiv = elt("div", null, "CodeMirror-cursors");
          d2.measure = elt("div", null, "CodeMirror-measure");
          d2.lineMeasure = elt("div", null, "CodeMirror-measure");
          d2.lineSpace = eltP("div", [d2.measure, d2.lineMeasure, d2.selectionDiv, d2.cursorDiv, d2.lineDiv], null, "position: relative; outline: none");
          var lines = eltP("div", [d2.lineSpace], "CodeMirror-lines");
          d2.mover = elt("div", [lines], null, "position: relative");
          d2.sizer = elt("div", [d2.mover], "CodeMirror-sizer");
          d2.sizerWidth = null;
          d2.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
          d2.gutters = elt("div", null, "CodeMirror-gutters");
          d2.lineGutter = null;
          d2.scroller = elt("div", [d2.sizer, d2.heightForcer, d2.gutters], "CodeMirror-scroll");
          d2.scroller.setAttribute("tabIndex", "-1");
          d2.wrapper = elt("div", [d2.scrollbarFiller, d2.gutterFiller, d2.scroller], "CodeMirror");
          if (ie && ie_version < 8) {
            d2.gutters.style.zIndex = -1;
            d2.scroller.style.paddingRight = 0;
          }
          if (!webkit && !(gecko && mobile)) {
            d2.scroller.draggable = true;
          }
          if (place) {
            if (place.appendChild) {
              place.appendChild(d2.wrapper);
            } else {
              place(d2.wrapper);
            }
          }
          d2.viewFrom = d2.viewTo = doc.first;
          d2.reportedViewFrom = d2.reportedViewTo = doc.first;
          d2.view = [];
          d2.renderedView = null;
          d2.externalMeasured = null;
          d2.viewOffset = 0;
          d2.lastWrapHeight = d2.lastWrapWidth = 0;
          d2.updateLineNumbers = null;
          d2.nativeBarWidth = d2.barHeight = d2.barWidth = 0;
          d2.scrollbarsClipped = false;
          d2.lineNumWidth = d2.lineNumInnerWidth = d2.lineNumChars = null;
          d2.alignWidgets = false;
          d2.cachedCharWidth = d2.cachedTextHeight = d2.cachedPaddingH = null;
          d2.maxLine = null;
          d2.maxLineLength = 0;
          d2.maxLineChanged = false;
          d2.wheelDX = d2.wheelDY = d2.wheelStartX = d2.wheelStartY = null;
          d2.shift = false;
          d2.selForContextMenu = null;
          d2.activeTouch = null;
          d2.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
          renderGutters(d2);
          input.init(d2);
        }
        var wheelSamples = 0, wheelPixelsPerUnit = null;
        if (ie) {
          wheelPixelsPerUnit = -0.53;
        } else if (gecko) {
          wheelPixelsPerUnit = 15;
        } else if (chrome2) {
          wheelPixelsPerUnit = -0.7;
        } else if (safari) {
          wheelPixelsPerUnit = -1 / 3;
        }
        function wheelEventDelta(e2) {
          var dx = e2.wheelDeltaX, dy = e2.wheelDeltaY;
          if (dx == null && e2.detail && e2.axis == e2.HORIZONTAL_AXIS) {
            dx = e2.detail;
          }
          if (dy == null && e2.detail && e2.axis == e2.VERTICAL_AXIS) {
            dy = e2.detail;
          } else if (dy == null) {
            dy = e2.wheelDelta;
          }
          return { x: dx, y: dy };
        }
        function wheelEventPixels(e2) {
          var delta = wheelEventDelta(e2);
          delta.x *= wheelPixelsPerUnit;
          delta.y *= wheelPixelsPerUnit;
          return delta;
        }
        function onScrollWheel(cm, e2) {
          var delta = wheelEventDelta(e2), dx = delta.x, dy = delta.y;
          var display = cm.display, scroll = display.scroller;
          var canScrollX = scroll.scrollWidth > scroll.clientWidth;
          var canScrollY = scroll.scrollHeight > scroll.clientHeight;
          if (!(dx && canScrollX || dy && canScrollY)) {
            return;
          }
          if (dy && mac && webkit) {
            outer:
              for (var cur = e2.target, view = display.view; cur != scroll; cur = cur.parentNode) {
                for (var i3 = 0; i3 < view.length; i3++) {
                  if (view[i3].node == cur) {
                    cm.display.currentWheelTarget = cur;
                    break outer;
                  }
                }
              }
          }
          if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
            if (dy && canScrollY) {
              updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit));
            }
            setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
            if (!dy || dy && canScrollY) {
              e_preventDefault(e2);
            }
            display.wheelStartX = null;
            return;
          }
          if (dy && wheelPixelsPerUnit != null) {
            var pixels = dy * wheelPixelsPerUnit;
            var top2 = cm.doc.scrollTop, bot = top2 + display.wrapper.clientHeight;
            if (pixels < 0) {
              top2 = Math.max(0, top2 + pixels - 50);
            } else {
              bot = Math.min(cm.doc.height, bot + pixels + 50);
            }
            updateDisplaySimple(cm, { top: top2, bottom: bot });
          }
          if (wheelSamples < 20) {
            if (display.wheelStartX == null) {
              display.wheelStartX = scroll.scrollLeft;
              display.wheelStartY = scroll.scrollTop;
              display.wheelDX = dx;
              display.wheelDY = dy;
              setTimeout(function() {
                if (display.wheelStartX == null) {
                  return;
                }
                var movedX = scroll.scrollLeft - display.wheelStartX;
                var movedY = scroll.scrollTop - display.wheelStartY;
                var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
                display.wheelStartX = display.wheelStartY = null;
                if (!sample) {
                  return;
                }
                wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
                ++wheelSamples;
              }, 200);
            } else {
              display.wheelDX += dx;
              display.wheelDY += dy;
            }
          }
        }
        var Selection = function(ranges, primIndex) {
          this.ranges = ranges;
          this.primIndex = primIndex;
        };
        Selection.prototype.primary = function() {
          return this.ranges[this.primIndex];
        };
        Selection.prototype.equals = function(other) {
          if (other == this) {
            return true;
          }
          if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
            return false;
          }
          for (var i3 = 0; i3 < this.ranges.length; i3++) {
            var here = this.ranges[i3], there = other.ranges[i3];
            if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {
              return false;
            }
          }
          return true;
        };
        Selection.prototype.deepCopy = function() {
          var out = [];
          for (var i3 = 0; i3 < this.ranges.length; i3++) {
            out[i3] = new Range(copyPos(this.ranges[i3].anchor), copyPos(this.ranges[i3].head));
          }
          return new Selection(out, this.primIndex);
        };
        Selection.prototype.somethingSelected = function() {
          for (var i3 = 0; i3 < this.ranges.length; i3++) {
            if (!this.ranges[i3].empty()) {
              return true;
            }
          }
          return false;
        };
        Selection.prototype.contains = function(pos, end2) {
          if (!end2) {
            end2 = pos;
          }
          for (var i3 = 0; i3 < this.ranges.length; i3++) {
            var range2 = this.ranges[i3];
            if (cmp(end2, range2.from()) >= 0 && cmp(pos, range2.to()) <= 0) {
              return i3;
            }
          }
          return -1;
        };
        var Range = function(anchor, head) {
          this.anchor = anchor;
          this.head = head;
        };
        Range.prototype.from = function() {
          return minPos(this.anchor, this.head);
        };
        Range.prototype.to = function() {
          return maxPos(this.anchor, this.head);
        };
        Range.prototype.empty = function() {
          return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
        };
        function normalizeSelection(cm, ranges, primIndex) {
          var mayTouch = cm && cm.options.selectionsMayTouch;
          var prim = ranges[primIndex];
          ranges.sort(function(a2, b2) {
            return cmp(a2.from(), b2.from());
          });
          primIndex = indexOf2(ranges, prim);
          for (var i3 = 1; i3 < ranges.length; i3++) {
            var cur = ranges[i3], prev = ranges[i3 - 1];
            var diff = cmp(prev.to(), cur.from());
            if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
              var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
              var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
              if (i3 <= primIndex) {
                --primIndex;
              }
              ranges.splice(--i3, 2, new Range(inv ? to : from, inv ? from : to));
            }
          }
          return new Selection(ranges, primIndex);
        }
        function simpleSelection(anchor, head) {
          return new Selection([new Range(anchor, head || anchor)], 0);
        }
        function changeEnd(change) {
          if (!change.text) {
            return change.to;
          }
          return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
        }
        function adjustForChange(pos, change) {
          if (cmp(pos, change.from) < 0) {
            return pos;
          }
          if (cmp(pos, change.to) <= 0) {
            return changeEnd(change);
          }
          var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
          if (pos.line == change.to.line) {
            ch += changeEnd(change).ch - change.to.ch;
          }
          return Pos(line, ch);
        }
        function computeSelAfterChange(doc, change) {
          var out = [];
          for (var i3 = 0; i3 < doc.sel.ranges.length; i3++) {
            var range2 = doc.sel.ranges[i3];
            out.push(new Range(adjustForChange(range2.anchor, change), adjustForChange(range2.head, change)));
          }
          return normalizeSelection(doc.cm, out, doc.sel.primIndex);
        }
        function offsetPos(pos, old, nw) {
          if (pos.line == old.line) {
            return Pos(nw.line, pos.ch - old.ch + nw.ch);
          } else {
            return Pos(nw.line + (pos.line - old.line), pos.ch);
          }
        }
        function computeReplacedSel(doc, changes, hint) {
          var out = [];
          var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
          for (var i3 = 0; i3 < changes.length; i3++) {
            var change = changes[i3];
            var from = offsetPos(change.from, oldPrev, newPrev);
            var to = offsetPos(changeEnd(change), oldPrev, newPrev);
            oldPrev = change.to;
            newPrev = to;
            if (hint == "around") {
              var range2 = doc.sel.ranges[i3], inv = cmp(range2.head, range2.anchor) < 0;
              out[i3] = new Range(inv ? to : from, inv ? from : to);
            } else {
              out[i3] = new Range(from, from);
            }
          }
          return new Selection(out, doc.sel.primIndex);
        }
        function loadMode(cm) {
          cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
          resetModeState(cm);
        }
        function resetModeState(cm) {
          cm.doc.iter(function(line) {
            if (line.stateAfter) {
              line.stateAfter = null;
            }
            if (line.styles) {
              line.styles = null;
            }
          });
          cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
          startWorker(cm, 100);
          cm.state.modeGen++;
          if (cm.curOp) {
            regChange(cm);
          }
        }
        function isWholeLineUpdate(doc, change) {
          return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
        }
        function updateDoc(doc, change, markedSpans, estimateHeight2) {
          function spansFor(n2) {
            return markedSpans ? markedSpans[n2] : null;
          }
          function update(line, text2, spans) {
            updateLine(line, text2, spans, estimateHeight2);
            signalLater(line, "change", line, change);
          }
          function linesFor(start4, end2) {
            var result = [];
            for (var i3 = start4; i3 < end2; ++i3) {
              result.push(new Line(text[i3], spansFor(i3), estimateHeight2));
            }
            return result;
          }
          var from = change.from, to = change.to, text = change.text;
          var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
          var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
          if (change.full) {
            doc.insert(0, linesFor(0, text.length));
            doc.remove(text.length, doc.size - text.length);
          } else if (isWholeLineUpdate(doc, change)) {
            var added = linesFor(0, text.length - 1);
            update(lastLine, lastLine.text, lastSpans);
            if (nlines) {
              doc.remove(from.line, nlines);
            }
            if (added.length) {
              doc.insert(from.line, added);
            }
          } else if (firstLine == lastLine) {
            if (text.length == 1) {
              update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
            } else {
              var added$1 = linesFor(1, text.length - 1);
              added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight2));
              update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
              doc.insert(from.line + 1, added$1);
            }
          } else if (text.length == 1) {
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
            doc.remove(from.line + 1, nlines);
          } else {
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
            update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
            var added$2 = linesFor(1, text.length - 1);
            if (nlines > 1) {
              doc.remove(from.line + 1, nlines - 1);
            }
            doc.insert(from.line + 1, added$2);
          }
          signalLater(doc, "change", doc, change);
        }
        function linkedDocs(doc, f2, sharedHistOnly) {
          function propagate(doc2, skip, sharedHist) {
            if (doc2.linked) {
              for (var i3 = 0; i3 < doc2.linked.length; ++i3) {
                var rel = doc2.linked[i3];
                if (rel.doc == skip) {
                  continue;
                }
                var shared = sharedHist && rel.sharedHist;
                if (sharedHistOnly && !shared) {
                  continue;
                }
                f2(rel.doc, shared);
                propagate(rel.doc, doc2, shared);
              }
            }
          }
          propagate(doc, null, true);
        }
        function attachDoc(cm, doc) {
          if (doc.cm) {
            throw new Error("This document is already in use.");
          }
          cm.doc = doc;
          doc.cm = cm;
          estimateLineHeights(cm);
          loadMode(cm);
          setDirectionClass(cm);
          if (!cm.options.lineWrapping) {
            findMaxLine(cm);
          }
          cm.options.mode = doc.modeOption;
          regChange(cm);
        }
        function setDirectionClass(cm) {
          (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
        }
        function directionChanged(cm) {
          runInOp(cm, function() {
            setDirectionClass(cm);
            regChange(cm);
          });
        }
        function History2(prev) {
          this.done = [];
          this.undone = [];
          this.undoDepth = prev ? prev.undoDepth : Infinity;
          this.lastModTime = this.lastSelTime = 0;
          this.lastOp = this.lastSelOp = null;
          this.lastOrigin = this.lastSelOrigin = null;
          this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;
        }
        function historyChangeFromChange(doc, change) {
          var histChange = { from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to) };
          attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
          linkedDocs(doc, function(doc2) {
            return attachLocalSpans(doc2, histChange, change.from.line, change.to.line + 1);
          }, true);
          return histChange;
        }
        function clearSelectionEvents(array) {
          while (array.length) {
            var last = lst(array);
            if (last.ranges) {
              array.pop();
            } else {
              break;
            }
          }
        }
        function lastChangeEvent(hist, force) {
          if (force) {
            clearSelectionEvents(hist.done);
            return lst(hist.done);
          } else if (hist.done.length && !lst(hist.done).ranges) {
            return lst(hist.done);
          } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
            hist.done.pop();
            return lst(hist.done);
          }
        }
        function addChangeToHistory(doc, change, selAfter, opId) {
          var hist = doc.history;
          hist.undone.length = 0;
          var time = +new Date(), cur;
          var last;
          if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
            last = lst(cur.changes);
            if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
              last.to = changeEnd(change);
            } else {
              cur.changes.push(historyChangeFromChange(doc, change));
            }
          } else {
            var before = lst(hist.done);
            if (!before || !before.ranges) {
              pushSelectionToHistory(doc.sel, hist.done);
            }
            cur = {
              changes: [historyChangeFromChange(doc, change)],
              generation: hist.generation
            };
            hist.done.push(cur);
            while (hist.done.length > hist.undoDepth) {
              hist.done.shift();
              if (!hist.done[0].ranges) {
                hist.done.shift();
              }
            }
          }
          hist.done.push(selAfter);
          hist.generation = ++hist.maxGeneration;
          hist.lastModTime = hist.lastSelTime = time;
          hist.lastOp = hist.lastSelOp = opId;
          hist.lastOrigin = hist.lastSelOrigin = change.origin;
          if (!last) {
            signal(doc, "historyAdded");
          }
        }
        function selectionEventCanBeMerged(doc, origin, prev, sel) {
          var ch = origin.charAt(0);
          return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
        }
        function addSelectionToHistory(doc, sel, opId, options) {
          var hist = doc.history, origin = options && options.origin;
          if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {
            hist.done[hist.done.length - 1] = sel;
          } else {
            pushSelectionToHistory(sel, hist.done);
          }
          hist.lastSelTime = +new Date();
          hist.lastSelOrigin = origin;
          hist.lastSelOp = opId;
          if (options && options.clearRedo !== false) {
            clearSelectionEvents(hist.undone);
          }
        }
        function pushSelectionToHistory(sel, dest) {
          var top2 = lst(dest);
          if (!(top2 && top2.ranges && top2.equals(sel))) {
            dest.push(sel);
          }
        }
        function attachLocalSpans(doc, change, from, to) {
          var existing = change["spans_" + doc.id], n2 = 0;
          doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
            if (line.markedSpans) {
              (existing || (existing = change["spans_" + doc.id] = {}))[n2] = line.markedSpans;
            }
            ++n2;
          });
        }
        function removeClearedSpans(spans) {
          if (!spans) {
            return null;
          }
          var out;
          for (var i3 = 0; i3 < spans.length; ++i3) {
            if (spans[i3].marker.explicitlyCleared) {
              if (!out) {
                out = spans.slice(0, i3);
              }
            } else if (out) {
              out.push(spans[i3]);
            }
          }
          return !out ? spans : out.length ? out : null;
        }
        function getOldSpans(doc, change) {
          var found = change["spans_" + doc.id];
          if (!found) {
            return null;
          }
          var nw = [];
          for (var i3 = 0; i3 < change.text.length; ++i3) {
            nw.push(removeClearedSpans(found[i3]));
          }
          return nw;
        }
        function mergeOldSpans(doc, change) {
          var old = getOldSpans(doc, change);
          var stretched = stretchSpansOverChange(doc, change);
          if (!old) {
            return stretched;
          }
          if (!stretched) {
            return old;
          }
          for (var i3 = 0; i3 < old.length; ++i3) {
            var oldCur = old[i3], stretchCur = stretched[i3];
            if (oldCur && stretchCur) {
              spans:
                for (var j2 = 0; j2 < stretchCur.length; ++j2) {
                  var span = stretchCur[j2];
                  for (var k2 = 0; k2 < oldCur.length; ++k2) {
                    if (oldCur[k2].marker == span.marker) {
                      continue spans;
                    }
                  }
                  oldCur.push(span);
                }
            } else if (stretchCur) {
              old[i3] = stretchCur;
            }
          }
          return old;
        }
        function copyHistoryArray(events, newGroup, instantiateSel) {
          var copy = [];
          for (var i3 = 0; i3 < events.length; ++i3) {
            var event = events[i3];
            if (event.ranges) {
              copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
              continue;
            }
            var changes = event.changes, newChanges = [];
            copy.push({ changes: newChanges });
            for (var j2 = 0; j2 < changes.length; ++j2) {
              var change = changes[j2], m2 = void 0;
              newChanges.push({ from: change.from, to: change.to, text: change.text });
              if (newGroup) {
                for (var prop2 in change) {
                  if (m2 = prop2.match(/^spans_(\d+)$/)) {
                    if (indexOf2(newGroup, Number(m2[1])) > -1) {
                      lst(newChanges)[prop2] = change[prop2];
                      delete change[prop2];
                    }
                  }
                }
              }
            }
          }
          return copy;
        }
        function extendRange(range2, head, other, extend3) {
          if (extend3) {
            var anchor = range2.anchor;
            if (other) {
              var posBefore = cmp(head, anchor) < 0;
              if (posBefore != cmp(other, anchor) < 0) {
                anchor = head;
                head = other;
              } else if (posBefore != cmp(head, other) < 0) {
                head = other;
              }
            }
            return new Range(anchor, head);
          } else {
            return new Range(other || head, head);
          }
        }
        function extendSelection(doc, head, other, options, extend3) {
          if (extend3 == null) {
            extend3 = doc.cm && (doc.cm.display.shift || doc.extend);
          }
          setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend3)], 0), options);
        }
        function extendSelections(doc, heads, options) {
          var out = [];
          var extend3 = doc.cm && (doc.cm.display.shift || doc.extend);
          for (var i3 = 0; i3 < doc.sel.ranges.length; i3++) {
            out[i3] = extendRange(doc.sel.ranges[i3], heads[i3], null, extend3);
          }
          var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
          setSelection(doc, newSel, options);
        }
        function replaceOneSelection(doc, i3, range2, options) {
          var ranges = doc.sel.ranges.slice(0);
          ranges[i3] = range2;
          setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
        }
        function setSimpleSelection(doc, anchor, head, options) {
          setSelection(doc, simpleSelection(anchor, head), options);
        }
        function filterSelectionChange(doc, sel, options) {
          var obj = {
            ranges: sel.ranges,
            update: function(ranges) {
              this.ranges = [];
              for (var i3 = 0; i3 < ranges.length; i3++) {
                this.ranges[i3] = new Range(clipPos(doc, ranges[i3].anchor), clipPos(doc, ranges[i3].head));
              }
            },
            origin: options && options.origin
          };
          signal(doc, "beforeSelectionChange", doc, obj);
          if (doc.cm) {
            signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
          }
          if (obj.ranges != sel.ranges) {
            return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1);
          } else {
            return sel;
          }
        }
        function setSelectionReplaceHistory(doc, sel, options) {
          var done = doc.history.done, last = lst(done);
          if (last && last.ranges) {
            done[done.length - 1] = sel;
            setSelectionNoUndo(doc, sel, options);
          } else {
            setSelection(doc, sel, options);
          }
        }
        function setSelection(doc, sel, options) {
          setSelectionNoUndo(doc, sel, options);
          addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
        }
        function setSelectionNoUndo(doc, sel, options) {
          if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
            sel = filterSelectionChange(doc, sel, options);
          }
          var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
          setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));
          if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption("readOnly") != "nocursor") {
            ensureCursorVisible(doc.cm);
          }
        }
        function setSelectionInner(doc, sel) {
          if (sel.equals(doc.sel)) {
            return;
          }
          doc.sel = sel;
          if (doc.cm) {
            doc.cm.curOp.updateInput = 1;
            doc.cm.curOp.selectionChanged = true;
            signalCursorActivity(doc.cm);
          }
          signalLater(doc, "cursorActivity", doc);
        }
        function reCheckSelection(doc) {
          setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
        }
        function skipAtomicInSelection(doc, sel, bias, mayClear) {
          var out;
          for (var i3 = 0; i3 < sel.ranges.length; i3++) {
            var range2 = sel.ranges[i3];
            var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i3];
            var newAnchor = skipAtomic(doc, range2.anchor, old && old.anchor, bias, mayClear);
            var newHead = skipAtomic(doc, range2.head, old && old.head, bias, mayClear);
            if (out || newAnchor != range2.anchor || newHead != range2.head) {
              if (!out) {
                out = sel.ranges.slice(0, i3);
              }
              out[i3] = new Range(newAnchor, newHead);
            }
          }
          return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel;
        }
        function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
          var line = getLine(doc, pos.line);
          if (line.markedSpans) {
            for (var i3 = 0; i3 < line.markedSpans.length; ++i3) {
              var sp = line.markedSpans[i3], m2 = sp.marker;
              var preventCursorLeft = "selectLeft" in m2 ? !m2.selectLeft : m2.inclusiveLeft;
              var preventCursorRight = "selectRight" in m2 ? !m2.selectRight : m2.inclusiveRight;
              if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
                if (mayClear) {
                  signal(m2, "beforeCursorEnter");
                  if (m2.explicitlyCleared) {
                    if (!line.markedSpans) {
                      break;
                    } else {
                      --i3;
                      continue;
                    }
                  }
                }
                if (!m2.atomic) {
                  continue;
                }
                if (oldPos) {
                  var near = m2.find(dir < 0 ? 1 : -1), diff = void 0;
                  if (dir < 0 ? preventCursorRight : preventCursorLeft) {
                    near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
                  }
                  if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {
                    return skipAtomicInner(doc, near, pos, dir, mayClear);
                  }
                }
                var far = m2.find(dir < 0 ? -1 : 1);
                if (dir < 0 ? preventCursorLeft : preventCursorRight) {
                  far = movePos(doc, far, dir, far.line == pos.line ? line : null);
                }
                return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
              }
            }
          }
          return pos;
        }
        function skipAtomic(doc, pos, oldPos, bias, mayClear) {
          var dir = bias || 1;
          var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);
          if (!found) {
            doc.cantEdit = true;
            return Pos(doc.first, 0);
          }
          return found;
        }
        function movePos(doc, pos, dir, line) {
          if (dir < 0 && pos.ch == 0) {
            if (pos.line > doc.first) {
              return clipPos(doc, Pos(pos.line - 1));
            } else {
              return null;
            }
          } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
            if (pos.line < doc.first + doc.size - 1) {
              return Pos(pos.line + 1, 0);
            } else {
              return null;
            }
          } else {
            return new Pos(pos.line, pos.ch + dir);
          }
        }
        function selectAll(cm) {
          cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
        }
        function filterChange(doc, change, update) {
          var obj = {
            canceled: false,
            from: change.from,
            to: change.to,
            text: change.text,
            origin: change.origin,
            cancel: function() {
              return obj.canceled = true;
            }
          };
          if (update) {
            obj.update = function(from, to, text, origin) {
              if (from) {
                obj.from = clipPos(doc, from);
              }
              if (to) {
                obj.to = clipPos(doc, to);
              }
              if (text) {
                obj.text = text;
              }
              if (origin !== void 0) {
                obj.origin = origin;
              }
            };
          }
          signal(doc, "beforeChange", doc, obj);
          if (doc.cm) {
            signal(doc.cm, "beforeChange", doc.cm, obj);
          }
          if (obj.canceled) {
            if (doc.cm) {
              doc.cm.curOp.updateInput = 2;
            }
            return null;
          }
          return { from: obj.from, to: obj.to, text: obj.text, origin: obj.origin };
        }
        function makeChange(doc, change, ignoreReadOnly) {
          if (doc.cm) {
            if (!doc.cm.curOp) {
              return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
            }
            if (doc.cm.state.suppressEdits) {
              return;
            }
          }
          if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
            change = filterChange(doc, change, true);
            if (!change) {
              return;
            }
          }
          var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
          if (split) {
            for (var i3 = split.length - 1; i3 >= 0; --i3) {
              makeChangeInner(doc, { from: split[i3].from, to: split[i3].to, text: i3 ? [""] : change.text, origin: change.origin });
            }
          } else {
            makeChangeInner(doc, change);
          }
        }
        function makeChangeInner(doc, change) {
          if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
            return;
          }
          var selAfter = computeSelAfterChange(doc, change);
          addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
          makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
          var rebased = [];
          linkedDocs(doc, function(doc2, sharedHist) {
            if (!sharedHist && indexOf2(rebased, doc2.history) == -1) {
              rebaseHist(doc2.history, change);
              rebased.push(doc2.history);
            }
            makeChangeSingleDoc(doc2, change, null, stretchSpansOverChange(doc2, change));
          });
        }
        function makeChangeFromHistory(doc, type, allowSelectionOnly) {
          var suppress = doc.cm && doc.cm.state.suppressEdits;
          if (suppress && !allowSelectionOnly) {
            return;
          }
          var hist = doc.history, event, selAfter = doc.sel;
          var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;
          var i3 = 0;
          for (; i3 < source.length; i3++) {
            event = source[i3];
            if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) {
              break;
            }
          }
          if (i3 == source.length) {
            return;
          }
          hist.lastOrigin = hist.lastSelOrigin = null;
          for (; ; ) {
            event = source.pop();
            if (event.ranges) {
              pushSelectionToHistory(event, dest);
              if (allowSelectionOnly && !event.equals(doc.sel)) {
                setSelection(doc, event, { clearRedo: false });
                return;
              }
              selAfter = event;
            } else if (suppress) {
              source.push(event);
              return;
            } else {
              break;
            }
          }
          var antiChanges = [];
          pushSelectionToHistory(selAfter, dest);
          dest.push({ changes: antiChanges, generation: hist.generation });
          hist.generation = event.generation || ++hist.maxGeneration;
          var filter2 = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");
          var loop = function(i4) {
            var change = event.changes[i4];
            change.origin = type;
            if (filter2 && !filterChange(doc, change, false)) {
              source.length = 0;
              return {};
            }
            antiChanges.push(historyChangeFromChange(doc, change));
            var after = i4 ? computeSelAfterChange(doc, change) : lst(source);
            makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
            if (!i4 && doc.cm) {
              doc.cm.scrollIntoView({ from: change.from, to: changeEnd(change) });
            }
            var rebased = [];
            linkedDocs(doc, function(doc2, sharedHist) {
              if (!sharedHist && indexOf2(rebased, doc2.history) == -1) {
                rebaseHist(doc2.history, change);
                rebased.push(doc2.history);
              }
              makeChangeSingleDoc(doc2, change, null, mergeOldSpans(doc2, change));
            });
          };
          for (var i$12 = event.changes.length - 1; i$12 >= 0; --i$12) {
            var returned = loop(i$12);
            if (returned)
              return returned.v;
          }
        }
        function shiftDoc(doc, distance) {
          if (distance == 0) {
            return;
          }
          doc.first += distance;
          doc.sel = new Selection(map(doc.sel.ranges, function(range2) {
            return new Range(Pos(range2.anchor.line + distance, range2.anchor.ch), Pos(range2.head.line + distance, range2.head.ch));
          }), doc.sel.primIndex);
          if (doc.cm) {
            regChange(doc.cm, doc.first, doc.first - distance, distance);
            for (var d2 = doc.cm.display, l2 = d2.viewFrom; l2 < d2.viewTo; l2++) {
              regLineChange(doc.cm, l2, "gutter");
            }
          }
        }
        function makeChangeSingleDoc(doc, change, selAfter, spans) {
          if (doc.cm && !doc.cm.curOp) {
            return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
          }
          if (change.to.line < doc.first) {
            shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
            return;
          }
          if (change.from.line > doc.lastLine()) {
            return;
          }
          if (change.from.line < doc.first) {
            var shift = change.text.length - 1 - (doc.first - change.from.line);
            shiftDoc(doc, shift);
            change = {
              from: Pos(doc.first, 0),
              to: Pos(change.to.line + shift, change.to.ch),
              text: [lst(change.text)],
              origin: change.origin
            };
          }
          var last = doc.lastLine();
          if (change.to.line > last) {
            change = {
              from: change.from,
              to: Pos(last, getLine(doc, last).text.length),
              text: [change.text[0]],
              origin: change.origin
            };
          }
          change.removed = getBetween(doc, change.from, change.to);
          if (!selAfter) {
            selAfter = computeSelAfterChange(doc, change);
          }
          if (doc.cm) {
            makeChangeSingleDocInEditor(doc.cm, change, spans);
          } else {
            updateDoc(doc, change, spans);
          }
          setSelectionNoUndo(doc, selAfter, sel_dontScroll);
          if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0))) {
            doc.cantEdit = false;
          }
        }
        function makeChangeSingleDocInEditor(cm, change, spans) {
          var doc = cm.doc, display = cm.display, from = change.from, to = change.to;
          var recomputeMaxLength = false, checkWidthStart = from.line;
          if (!cm.options.lineWrapping) {
            checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
            doc.iter(checkWidthStart, to.line + 1, function(line) {
              if (line == display.maxLine) {
                recomputeMaxLength = true;
                return true;
              }
            });
          }
          if (doc.sel.contains(change.from, change.to) > -1) {
            signalCursorActivity(cm);
          }
          updateDoc(doc, change, spans, estimateHeight(cm));
          if (!cm.options.lineWrapping) {
            doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
              var len = lineLength(line);
              if (len > display.maxLineLength) {
                display.maxLine = line;
                display.maxLineLength = len;
                display.maxLineChanged = true;
                recomputeMaxLength = false;
              }
            });
            if (recomputeMaxLength) {
              cm.curOp.updateMaxLine = true;
            }
          }
          retreatFrontier(doc, from.line);
          startWorker(cm, 400);
          var lendiff = change.text.length - (to.line - from.line) - 1;
          if (change.full) {
            regChange(cm);
          } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
            regLineChange(cm, from.line, "text");
          } else {
            regChange(cm, from.line, to.line + 1, lendiff);
          }
          var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
          if (changeHandler || changesHandler) {
            var obj = {
              from,
              to,
              text: change.text,
              removed: change.removed,
              origin: change.origin
            };
            if (changeHandler) {
              signalLater(cm, "change", cm, obj);
            }
            if (changesHandler) {
              (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
            }
          }
          cm.display.selForContextMenu = null;
        }
        function replaceRange(doc, code3, from, to, origin) {
          var assign;
          if (!to) {
            to = from;
          }
          if (cmp(to, from) < 0) {
            assign = [to, from], from = assign[0], to = assign[1];
          }
          if (typeof code3 == "string") {
            code3 = doc.splitLines(code3);
          }
          makeChange(doc, { from, to, text: code3, origin });
        }
        function rebaseHistSelSingle(pos, from, to, diff) {
          if (to < pos.line) {
            pos.line += diff;
          } else if (from < pos.line) {
            pos.line = from;
            pos.ch = 0;
          }
        }
        function rebaseHistArray(array, from, to, diff) {
          for (var i3 = 0; i3 < array.length; ++i3) {
            var sub = array[i3], ok = true;
            if (sub.ranges) {
              if (!sub.copied) {
                sub = array[i3] = sub.deepCopy();
                sub.copied = true;
              }
              for (var j2 = 0; j2 < sub.ranges.length; j2++) {
                rebaseHistSelSingle(sub.ranges[j2].anchor, from, to, diff);
                rebaseHistSelSingle(sub.ranges[j2].head, from, to, diff);
              }
              continue;
            }
            for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
              var cur = sub.changes[j$1];
              if (to < cur.from.line) {
                cur.from = Pos(cur.from.line + diff, cur.from.ch);
                cur.to = Pos(cur.to.line + diff, cur.to.ch);
              } else if (from <= cur.to.line) {
                ok = false;
                break;
              }
            }
            if (!ok) {
              array.splice(0, i3 + 1);
              i3 = 0;
            }
          }
        }
        function rebaseHist(hist, change) {
          var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
          rebaseHistArray(hist.done, from, to, diff);
          rebaseHistArray(hist.undone, from, to, diff);
        }
        function changeLine(doc, handle, changeType, op) {
          var no = handle, line = handle;
          if (typeof handle == "number") {
            line = getLine(doc, clipLine(doc, handle));
          } else {
            no = lineNo(handle);
          }
          if (no == null) {
            return null;
          }
          if (op(line, no) && doc.cm) {
            regLineChange(doc.cm, no, changeType);
          }
          return line;
        }
        function LeafChunk(lines) {
          this.lines = lines;
          this.parent = null;
          var height = 0;
          for (var i3 = 0; i3 < lines.length; ++i3) {
            lines[i3].parent = this;
            height += lines[i3].height;
          }
          this.height = height;
        }
        LeafChunk.prototype = {
          chunkSize: function() {
            return this.lines.length;
          },
          removeInner: function(at, n2) {
            for (var i3 = at, e2 = at + n2; i3 < e2; ++i3) {
              var line = this.lines[i3];
              this.height -= line.height;
              cleanUpLine(line);
              signalLater(line, "delete");
            }
            this.lines.splice(at, n2);
          },
          collapse: function(lines) {
            lines.push.apply(lines, this.lines);
          },
          insertInner: function(at, lines, height) {
            this.height += height;
            this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
            for (var i3 = 0; i3 < lines.length; ++i3) {
              lines[i3].parent = this;
            }
          },
          iterN: function(at, n2, op) {
            for (var e2 = at + n2; at < e2; ++at) {
              if (op(this.lines[at])) {
                return true;
              }
            }
          }
        };
        function BranchChunk(children) {
          this.children = children;
          var size = 0, height = 0;
          for (var i3 = 0; i3 < children.length; ++i3) {
            var ch = children[i3];
            size += ch.chunkSize();
            height += ch.height;
            ch.parent = this;
          }
          this.size = size;
          this.height = height;
          this.parent = null;
        }
        BranchChunk.prototype = {
          chunkSize: function() {
            return this.size;
          },
          removeInner: function(at, n2) {
            this.size -= n2;
            for (var i3 = 0; i3 < this.children.length; ++i3) {
              var child = this.children[i3], sz = child.chunkSize();
              if (at < sz) {
                var rm = Math.min(n2, sz - at), oldHeight = child.height;
                child.removeInner(at, rm);
                this.height -= oldHeight - child.height;
                if (sz == rm) {
                  this.children.splice(i3--, 1);
                  child.parent = null;
                }
                if ((n2 -= rm) == 0) {
                  break;
                }
                at = 0;
              } else {
                at -= sz;
              }
            }
            if (this.size - n2 < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
              var lines = [];
              this.collapse(lines);
              this.children = [new LeafChunk(lines)];
              this.children[0].parent = this;
            }
          },
          collapse: function(lines) {
            for (var i3 = 0; i3 < this.children.length; ++i3) {
              this.children[i3].collapse(lines);
            }
          },
          insertInner: function(at, lines, height) {
            this.size += lines.length;
            this.height += height;
            for (var i3 = 0; i3 < this.children.length; ++i3) {
              var child = this.children[i3], sz = child.chunkSize();
              if (at <= sz) {
                child.insertInner(at, lines, height);
                if (child.lines && child.lines.length > 50) {
                  var remaining = child.lines.length % 25 + 25;
                  for (var pos = remaining; pos < child.lines.length; ) {
                    var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                    child.height -= leaf.height;
                    this.children.splice(++i3, 0, leaf);
                    leaf.parent = this;
                  }
                  child.lines = child.lines.slice(0, remaining);
                  this.maybeSpill();
                }
                break;
              }
              at -= sz;
            }
          },
          maybeSpill: function() {
            if (this.children.length <= 10) {
              return;
            }
            var me = this;
            do {
              var spilled = me.children.splice(me.children.length - 5, 5);
              var sibling = new BranchChunk(spilled);
              if (!me.parent) {
                var copy = new BranchChunk(me.children);
                copy.parent = me;
                me.children = [copy, sibling];
                me = copy;
              } else {
                me.size -= sibling.size;
                me.height -= sibling.height;
                var myIndex = indexOf2(me.parent.children, me);
                me.parent.children.splice(myIndex + 1, 0, sibling);
              }
              sibling.parent = me.parent;
            } while (me.children.length > 10);
            me.parent.maybeSpill();
          },
          iterN: function(at, n2, op) {
            for (var i3 = 0; i3 < this.children.length; ++i3) {
              var child = this.children[i3], sz = child.chunkSize();
              if (at < sz) {
                var used = Math.min(n2, sz - at);
                if (child.iterN(at, used, op)) {
                  return true;
                }
                if ((n2 -= used) == 0) {
                  break;
                }
                at = 0;
              } else {
                at -= sz;
              }
            }
          }
        };
        var LineWidget = function(doc, node, options) {
          if (options) {
            for (var opt in options) {
              if (options.hasOwnProperty(opt)) {
                this[opt] = options[opt];
              }
            }
          }
          this.doc = doc;
          this.node = node;
        };
        LineWidget.prototype.clear = function() {
          var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
          if (no == null || !ws) {
            return;
          }
          for (var i3 = 0; i3 < ws.length; ++i3) {
            if (ws[i3] == this) {
              ws.splice(i3--, 1);
            }
          }
          if (!ws.length) {
            line.widgets = null;
          }
          var height = widgetHeight(this);
          updateLineHeight(line, Math.max(0, line.height - height));
          if (cm) {
            runInOp(cm, function() {
              adjustScrollWhenAboveVisible(cm, line, -height);
              regLineChange(cm, no, "widget");
            });
            signalLater(cm, "lineWidgetCleared", cm, this, no);
          }
        };
        LineWidget.prototype.changed = function() {
          var this$1 = this;
          var oldH = this.height, cm = this.doc.cm, line = this.line;
          this.height = null;
          var diff = widgetHeight(this) - oldH;
          if (!diff) {
            return;
          }
          if (!lineIsHidden(this.doc, line)) {
            updateLineHeight(line, line.height + diff);
          }
          if (cm) {
            runInOp(cm, function() {
              cm.curOp.forceUpdate = true;
              adjustScrollWhenAboveVisible(cm, line, diff);
              signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
            });
          }
        };
        eventMixin(LineWidget);
        function adjustScrollWhenAboveVisible(cm, line, diff) {
          if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
            addToScrollTop(cm, diff);
          }
        }
        function addLineWidget(doc, handle, node, options) {
          var widget = new LineWidget(doc, node, options);
          var cm = doc.cm;
          if (cm && widget.noHScroll) {
            cm.display.alignWidgets = true;
          }
          changeLine(doc, handle, "widget", function(line) {
            var widgets = line.widgets || (line.widgets = []);
            if (widget.insertAt == null) {
              widgets.push(widget);
            } else {
              widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);
            }
            widget.line = line;
            if (cm && !lineIsHidden(doc, line)) {
              var aboveVisible = heightAtLine(line) < doc.scrollTop;
              updateLineHeight(line, line.height + widgetHeight(widget));
              if (aboveVisible) {
                addToScrollTop(cm, widget.height);
              }
              cm.curOp.forceUpdate = true;
            }
            return true;
          });
          if (cm) {
            signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
          }
          return widget;
        }
        var nextMarkerId = 0;
        var TextMarker = function(doc, type) {
          this.lines = [];
          this.type = type;
          this.doc = doc;
          this.id = ++nextMarkerId;
        };
        TextMarker.prototype.clear = function() {
          if (this.explicitlyCleared) {
            return;
          }
          var cm = this.doc.cm, withOp = cm && !cm.curOp;
          if (withOp) {
            startOperation(cm);
          }
          if (hasHandler(this, "clear")) {
            var found = this.find();
            if (found) {
              signalLater(this, "clear", found.from, found.to);
            }
          }
          var min2 = null, max2 = null;
          for (var i3 = 0; i3 < this.lines.length; ++i3) {
            var line = this.lines[i3];
            var span = getMarkedSpanFor(line.markedSpans, this);
            if (cm && !this.collapsed) {
              regLineChange(cm, lineNo(line), "text");
            } else if (cm) {
              if (span.to != null) {
                max2 = lineNo(line);
              }
              if (span.from != null) {
                min2 = lineNo(line);
              }
            }
            line.markedSpans = removeMarkedSpan(line.markedSpans, span);
            if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {
              updateLineHeight(line, textHeight(cm.display));
            }
          }
          if (cm && this.collapsed && !cm.options.lineWrapping) {
            for (var i$12 = 0; i$12 < this.lines.length; ++i$12) {
              var visual = visualLine(this.lines[i$12]), len = lineLength(visual);
              if (len > cm.display.maxLineLength) {
                cm.display.maxLine = visual;
                cm.display.maxLineLength = len;
                cm.display.maxLineChanged = true;
              }
            }
          }
          if (min2 != null && cm && this.collapsed) {
            regChange(cm, min2, max2 + 1);
          }
          this.lines.length = 0;
          this.explicitlyCleared = true;
          if (this.atomic && this.doc.cantEdit) {
            this.doc.cantEdit = false;
            if (cm) {
              reCheckSelection(cm.doc);
            }
          }
          if (cm) {
            signalLater(cm, "markerCleared", cm, this, min2, max2);
          }
          if (withOp) {
            endOperation(cm);
          }
          if (this.parent) {
            this.parent.clear();
          }
        };
        TextMarker.prototype.find = function(side, lineObj) {
          if (side == null && this.type == "bookmark") {
            side = 1;
          }
          var from, to;
          for (var i3 = 0; i3 < this.lines.length; ++i3) {
            var line = this.lines[i3];
            var span = getMarkedSpanFor(line.markedSpans, this);
            if (span.from != null) {
              from = Pos(lineObj ? line : lineNo(line), span.from);
              if (side == -1) {
                return from;
              }
            }
            if (span.to != null) {
              to = Pos(lineObj ? line : lineNo(line), span.to);
              if (side == 1) {
                return to;
              }
            }
          }
          return from && { from, to };
        };
        TextMarker.prototype.changed = function() {
          var this$1 = this;
          var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
          if (!pos || !cm) {
            return;
          }
          runInOp(cm, function() {
            var line = pos.line, lineN = lineNo(pos.line);
            var view = findViewForLine(cm, lineN);
            if (view) {
              clearLineMeasurementCacheFor(view);
              cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
            }
            cm.curOp.updateMaxLine = true;
            if (!lineIsHidden(widget.doc, line) && widget.height != null) {
              var oldHeight = widget.height;
              widget.height = null;
              var dHeight = widgetHeight(widget) - oldHeight;
              if (dHeight) {
                updateLineHeight(line, line.height + dHeight);
              }
            }
            signalLater(cm, "markerChanged", cm, this$1);
          });
        };
        TextMarker.prototype.attachLine = function(line) {
          if (!this.lines.length && this.doc.cm) {
            var op = this.doc.cm.curOp;
            if (!op.maybeHiddenMarkers || indexOf2(op.maybeHiddenMarkers, this) == -1) {
              (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
            }
          }
          this.lines.push(line);
        };
        TextMarker.prototype.detachLine = function(line) {
          this.lines.splice(indexOf2(this.lines, line), 1);
          if (!this.lines.length && this.doc.cm) {
            var op = this.doc.cm.curOp;
            (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
          }
        };
        eventMixin(TextMarker);
        function markText(doc, from, to, options, type) {
          if (options && options.shared) {
            return markTextShared(doc, from, to, options, type);
          }
          if (doc.cm && !doc.cm.curOp) {
            return operation(doc.cm, markText)(doc, from, to, options, type);
          }
          var marker = new TextMarker(doc, type), diff = cmp(from, to);
          if (options) {
            copyObj(options, marker, false);
          }
          if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {
            return marker;
          }
          if (marker.replacedWith) {
            marker.collapsed = true;
            marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
            if (!options.handleMouseEvents) {
              marker.widgetNode.setAttribute("cm-ignore-events", "true");
            }
            if (options.insertLeft) {
              marker.widgetNode.insertLeft = true;
            }
          }
          if (marker.collapsed) {
            if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) {
              throw new Error("Inserting collapsed marker partially overlapping an existing one");
            }
            seeCollapsedSpans();
          }
          if (marker.addToHistory) {
            addChangeToHistory(doc, { from, to, origin: "markText" }, doc.sel, NaN);
          }
          var curLine = from.line, cm = doc.cm, updateMaxLine;
          doc.iter(curLine, to.line + 1, function(line) {
            if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
              updateMaxLine = true;
            }
            if (marker.collapsed && curLine != from.line) {
              updateLineHeight(line, 0);
            }
            addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null));
            ++curLine;
          });
          if (marker.collapsed) {
            doc.iter(from.line, to.line + 1, function(line) {
              if (lineIsHidden(doc, line)) {
                updateLineHeight(line, 0);
              }
            });
          }
          if (marker.clearOnEnter) {
            on(marker, "beforeCursorEnter", function() {
              return marker.clear();
            });
          }
          if (marker.readOnly) {
            seeReadOnlySpans();
            if (doc.history.done.length || doc.history.undone.length) {
              doc.clearHistory();
            }
          }
          if (marker.collapsed) {
            marker.id = ++nextMarkerId;
            marker.atomic = true;
          }
          if (cm) {
            if (updateMaxLine) {
              cm.curOp.updateMaxLine = true;
            }
            if (marker.collapsed) {
              regChange(cm, from.line, to.line + 1);
            } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {
              for (var i3 = from.line; i3 <= to.line; i3++) {
                regLineChange(cm, i3, "text");
              }
            }
            if (marker.atomic) {
              reCheckSelection(cm.doc);
            }
            signalLater(cm, "markerAdded", cm, marker);
          }
          return marker;
        }
        var SharedTextMarker = function(markers, primary) {
          this.markers = markers;
          this.primary = primary;
          for (var i3 = 0; i3 < markers.length; ++i3) {
            markers[i3].parent = this;
          }
        };
        SharedTextMarker.prototype.clear = function() {
          if (this.explicitlyCleared) {
            return;
          }
          this.explicitlyCleared = true;
          for (var i3 = 0; i3 < this.markers.length; ++i3) {
            this.markers[i3].clear();
          }
          signalLater(this, "clear");
        };
        SharedTextMarker.prototype.find = function(side, lineObj) {
          return this.primary.find(side, lineObj);
        };
        eventMixin(SharedTextMarker);
        function markTextShared(doc, from, to, options, type) {
          options = copyObj(options);
          options.shared = false;
          var markers = [markText(doc, from, to, options, type)], primary = markers[0];
          var widget = options.widgetNode;
          linkedDocs(doc, function(doc2) {
            if (widget) {
              options.widgetNode = widget.cloneNode(true);
            }
            markers.push(markText(doc2, clipPos(doc2, from), clipPos(doc2, to), options, type));
            for (var i3 = 0; i3 < doc2.linked.length; ++i3) {
              if (doc2.linked[i3].isParent) {
                return;
              }
            }
            primary = lst(markers);
          });
          return new SharedTextMarker(markers, primary);
        }
        function findSharedMarkers(doc) {
          return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function(m2) {
            return m2.parent;
          });
        }
        function copySharedMarkers(doc, markers) {
          for (var i3 = 0; i3 < markers.length; i3++) {
            var marker = markers[i3], pos = marker.find();
            var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
            if (cmp(mFrom, mTo)) {
              var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
              marker.markers.push(subMark);
              subMark.parent = marker;
            }
          }
        }
        function detachSharedMarkers(markers) {
          var loop = function(i4) {
            var marker = markers[i4], linked = [marker.primary.doc];
            linkedDocs(marker.primary.doc, function(d2) {
              return linked.push(d2);
            });
            for (var j2 = 0; j2 < marker.markers.length; j2++) {
              var subMarker = marker.markers[j2];
              if (indexOf2(linked, subMarker.doc) == -1) {
                subMarker.parent = null;
                marker.markers.splice(j2--, 1);
              }
            }
          };
          for (var i3 = 0; i3 < markers.length; i3++)
            loop(i3);
        }
        var nextDocId = 0;
        var Doc = function(text, mode, firstLine, lineSep, direction) {
          if (!(this instanceof Doc)) {
            return new Doc(text, mode, firstLine, lineSep, direction);
          }
          if (firstLine == null) {
            firstLine = 0;
          }
          BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
          this.first = firstLine;
          this.scrollTop = this.scrollLeft = 0;
          this.cantEdit = false;
          this.cleanGeneration = 1;
          this.modeFrontier = this.highlightFrontier = firstLine;
          var start4 = Pos(firstLine, 0);
          this.sel = simpleSelection(start4);
          this.history = new History2(null);
          this.id = ++nextDocId;
          this.modeOption = mode;
          this.lineSep = lineSep;
          this.direction = direction == "rtl" ? "rtl" : "ltr";
          this.extend = false;
          if (typeof text == "string") {
            text = this.splitLines(text);
          }
          updateDoc(this, { from: start4, to: start4, text });
          setSelection(this, simpleSelection(start4), sel_dontScroll);
        };
        Doc.prototype = createObj(BranchChunk.prototype, {
          constructor: Doc,
          iter: function(from, to, op) {
            if (op) {
              this.iterN(from - this.first, to - from, op);
            } else {
              this.iterN(this.first, this.first + this.size, from);
            }
          },
          insert: function(at, lines) {
            var height = 0;
            for (var i3 = 0; i3 < lines.length; ++i3) {
              height += lines[i3].height;
            }
            this.insertInner(at - this.first, lines, height);
          },
          remove: function(at, n2) {
            this.removeInner(at - this.first, n2);
          },
          getValue: function(lineSep) {
            var lines = getLines(this, this.first, this.first + this.size);
            if (lineSep === false) {
              return lines;
            }
            return lines.join(lineSep || this.lineSeparator());
          },
          setValue: docMethodOp(function(code3) {
            var top2 = Pos(this.first, 0), last = this.first + this.size - 1;
            makeChange(this, {
              from: top2,
              to: Pos(last, getLine(this, last).text.length),
              text: this.splitLines(code3),
              origin: "setValue",
              full: true
            }, true);
            if (this.cm) {
              scrollToCoords(this.cm, 0, 0);
            }
            setSelection(this, simpleSelection(top2), sel_dontScroll);
          }),
          replaceRange: function(code3, from, to, origin) {
            from = clipPos(this, from);
            to = to ? clipPos(this, to) : from;
            replaceRange(this, code3, from, to, origin);
          },
          getRange: function(from, to, lineSep) {
            var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
            if (lineSep === false) {
              return lines;
            }
            return lines.join(lineSep || this.lineSeparator());
          },
          getLine: function(line) {
            var l2 = this.getLineHandle(line);
            return l2 && l2.text;
          },
          getLineHandle: function(line) {
            if (isLine(this, line)) {
              return getLine(this, line);
            }
          },
          getLineNumber: function(line) {
            return lineNo(line);
          },
          getLineHandleVisualStart: function(line) {
            if (typeof line == "number") {
              line = getLine(this, line);
            }
            return visualLine(line);
          },
          lineCount: function() {
            return this.size;
          },
          firstLine: function() {
            return this.first;
          },
          lastLine: function() {
            return this.first + this.size - 1;
          },
          clipPos: function(pos) {
            return clipPos(this, pos);
          },
          getCursor: function(start4) {
            var range2 = this.sel.primary(), pos;
            if (start4 == null || start4 == "head") {
              pos = range2.head;
            } else if (start4 == "anchor") {
              pos = range2.anchor;
            } else if (start4 == "end" || start4 == "to" || start4 === false) {
              pos = range2.to();
            } else {
              pos = range2.from();
            }
            return pos;
          },
          listSelections: function() {
            return this.sel.ranges;
          },
          somethingSelected: function() {
            return this.sel.somethingSelected();
          },
          setCursor: docMethodOp(function(line, ch, options) {
            setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
          }),
          setSelection: docMethodOp(function(anchor, head, options) {
            setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
          }),
          extendSelection: docMethodOp(function(head, other, options) {
            extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
          }),
          extendSelections: docMethodOp(function(heads, options) {
            extendSelections(this, clipPosArray(this, heads), options);
          }),
          extendSelectionsBy: docMethodOp(function(f2, options) {
            var heads = map(this.sel.ranges, f2);
            extendSelections(this, clipPosArray(this, heads), options);
          }),
          setSelections: docMethodOp(function(ranges, primary, options) {
            if (!ranges.length) {
              return;
            }
            var out = [];
            for (var i3 = 0; i3 < ranges.length; i3++) {
              out[i3] = new Range(clipPos(this, ranges[i3].anchor), clipPos(this, ranges[i3].head));
            }
            if (primary == null) {
              primary = Math.min(ranges.length - 1, this.sel.primIndex);
            }
            setSelection(this, normalizeSelection(this.cm, out, primary), options);
          }),
          addSelection: docMethodOp(function(anchor, head, options) {
            var ranges = this.sel.ranges.slice(0);
            ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
            setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
          }),
          getSelection: function(lineSep) {
            var ranges = this.sel.ranges, lines;
            for (var i3 = 0; i3 < ranges.length; i3++) {
              var sel = getBetween(this, ranges[i3].from(), ranges[i3].to());
              lines = lines ? lines.concat(sel) : sel;
            }
            if (lineSep === false) {
              return lines;
            } else {
              return lines.join(lineSep || this.lineSeparator());
            }
          },
          getSelections: function(lineSep) {
            var parts = [], ranges = this.sel.ranges;
            for (var i3 = 0; i3 < ranges.length; i3++) {
              var sel = getBetween(this, ranges[i3].from(), ranges[i3].to());
              if (lineSep !== false) {
                sel = sel.join(lineSep || this.lineSeparator());
              }
              parts[i3] = sel;
            }
            return parts;
          },
          replaceSelection: function(code3, collapse, origin) {
            var dup = [];
            for (var i3 = 0; i3 < this.sel.ranges.length; i3++) {
              dup[i3] = code3;
            }
            this.replaceSelections(dup, collapse, origin || "+input");
          },
          replaceSelections: docMethodOp(function(code3, collapse, origin) {
            var changes = [], sel = this.sel;
            for (var i3 = 0; i3 < sel.ranges.length; i3++) {
              var range2 = sel.ranges[i3];
              changes[i3] = { from: range2.from(), to: range2.to(), text: this.splitLines(code3[i3]), origin };
            }
            var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
            for (var i$12 = changes.length - 1; i$12 >= 0; i$12--) {
              makeChange(this, changes[i$12]);
            }
            if (newSel) {
              setSelectionReplaceHistory(this, newSel);
            } else if (this.cm) {
              ensureCursorVisible(this.cm);
            }
          }),
          undo: docMethodOp(function() {
            makeChangeFromHistory(this, "undo");
          }),
          redo: docMethodOp(function() {
            makeChangeFromHistory(this, "redo");
          }),
          undoSelection: docMethodOp(function() {
            makeChangeFromHistory(this, "undo", true);
          }),
          redoSelection: docMethodOp(function() {
            makeChangeFromHistory(this, "redo", true);
          }),
          setExtending: function(val) {
            this.extend = val;
          },
          getExtending: function() {
            return this.extend;
          },
          historySize: function() {
            var hist = this.history, done = 0, undone = 0;
            for (var i3 = 0; i3 < hist.done.length; i3++) {
              if (!hist.done[i3].ranges) {
                ++done;
              }
            }
            for (var i$12 = 0; i$12 < hist.undone.length; i$12++) {
              if (!hist.undone[i$12].ranges) {
                ++undone;
              }
            }
            return { undo: done, redo: undone };
          },
          clearHistory: function() {
            var this$1 = this;
            this.history = new History2(this.history);
            linkedDocs(this, function(doc) {
              return doc.history = this$1.history;
            }, true);
          },
          markClean: function() {
            this.cleanGeneration = this.changeGeneration(true);
          },
          changeGeneration: function(forceSplit) {
            if (forceSplit) {
              this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
            }
            return this.history.generation;
          },
          isClean: function(gen) {
            return this.history.generation == (gen || this.cleanGeneration);
          },
          getHistory: function() {
            return {
              done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)
            };
          },
          setHistory: function(histData) {
            var hist = this.history = new History2(this.history);
            hist.done = copyHistoryArray(histData.done.slice(0), null, true);
            hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
          },
          setGutterMarker: docMethodOp(function(line, gutterID, value) {
            return changeLine(this, line, "gutter", function(line2) {
              var markers = line2.gutterMarkers || (line2.gutterMarkers = {});
              markers[gutterID] = value;
              if (!value && isEmpty(markers)) {
                line2.gutterMarkers = null;
              }
              return true;
            });
          }),
          clearGutter: docMethodOp(function(gutterID) {
            var this$1 = this;
            this.iter(function(line) {
              if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
                changeLine(this$1, line, "gutter", function() {
                  line.gutterMarkers[gutterID] = null;
                  if (isEmpty(line.gutterMarkers)) {
                    line.gutterMarkers = null;
                  }
                  return true;
                });
              }
            });
          }),
          lineInfo: function(line) {
            var n2;
            if (typeof line == "number") {
              if (!isLine(this, line)) {
                return null;
              }
              n2 = line;
              line = getLine(this, line);
              if (!line) {
                return null;
              }
            } else {
              n2 = lineNo(line);
              if (n2 == null) {
                return null;
              }
            }
            return {
              line: n2,
              handle: line,
              text: line.text,
              gutterMarkers: line.gutterMarkers,
              textClass: line.textClass,
              bgClass: line.bgClass,
              wrapClass: line.wrapClass,
              widgets: line.widgets
            };
          },
          addLineClass: docMethodOp(function(handle, where, cls) {
            return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
              var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
              if (!line[prop2]) {
                line[prop2] = cls;
              } else if (classTest(cls).test(line[prop2])) {
                return false;
              } else {
                line[prop2] += " " + cls;
              }
              return true;
            });
          }),
          removeLineClass: docMethodOp(function(handle, where, cls) {
            return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
              var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
              var cur = line[prop2];
              if (!cur) {
                return false;
              } else if (cls == null) {
                line[prop2] = null;
              } else {
                var found = cur.match(classTest(cls));
                if (!found) {
                  return false;
                }
                var end2 = found.index + found[0].length;
                line[prop2] = cur.slice(0, found.index) + (!found.index || end2 == cur.length ? "" : " ") + cur.slice(end2) || null;
              }
              return true;
            });
          }),
          addLineWidget: docMethodOp(function(handle, node, options) {
            return addLineWidget(this, handle, node, options);
          }),
          removeLineWidget: function(widget) {
            widget.clear();
          },
          markText: function(from, to, options) {
            return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
          },
          setBookmark: function(pos, options) {
            var realOpts = {
              replacedWith: options && (options.nodeType == null ? options.widget : options),
              insertLeft: options && options.insertLeft,
              clearWhenEmpty: false,
              shared: options && options.shared,
              handleMouseEvents: options && options.handleMouseEvents
            };
            pos = clipPos(this, pos);
            return markText(this, pos, pos, realOpts, "bookmark");
          },
          findMarksAt: function(pos) {
            pos = clipPos(this, pos);
            var markers = [], spans = getLine(this, pos.line).markedSpans;
            if (spans) {
              for (var i3 = 0; i3 < spans.length; ++i3) {
                var span = spans[i3];
                if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
                  markers.push(span.marker.parent || span.marker);
                }
              }
            }
            return markers;
          },
          findMarks: function(from, to, filter2) {
            from = clipPos(this, from);
            to = clipPos(this, to);
            var found = [], lineNo2 = from.line;
            this.iter(from.line, to.line + 1, function(line) {
              var spans = line.markedSpans;
              if (spans) {
                for (var i3 = 0; i3 < spans.length; i3++) {
                  var span = spans[i3];
                  if (!(span.to != null && lineNo2 == from.line && from.ch >= span.to || span.from == null && lineNo2 != from.line || span.from != null && lineNo2 == to.line && span.from >= to.ch) && (!filter2 || filter2(span.marker))) {
                    found.push(span.marker.parent || span.marker);
                  }
                }
              }
              ++lineNo2;
            });
            return found;
          },
          getAllMarks: function() {
            var markers = [];
            this.iter(function(line) {
              var sps = line.markedSpans;
              if (sps) {
                for (var i3 = 0; i3 < sps.length; ++i3) {
                  if (sps[i3].from != null) {
                    markers.push(sps[i3].marker);
                  }
                }
              }
            });
            return markers;
          },
          posFromIndex: function(off2) {
            var ch, lineNo2 = this.first, sepSize = this.lineSeparator().length;
            this.iter(function(line) {
              var sz = line.text.length + sepSize;
              if (sz > off2) {
                ch = off2;
                return true;
              }
              off2 -= sz;
              ++lineNo2;
            });
            return clipPos(this, Pos(lineNo2, ch));
          },
          indexFromPos: function(coords) {
            coords = clipPos(this, coords);
            var index = coords.ch;
            if (coords.line < this.first || coords.ch < 0) {
              return 0;
            }
            var sepSize = this.lineSeparator().length;
            this.iter(this.first, coords.line, function(line) {
              index += line.text.length + sepSize;
            });
            return index;
          },
          copy: function(copyHistory) {
            var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
            doc.scrollTop = this.scrollTop;
            doc.scrollLeft = this.scrollLeft;
            doc.sel = this.sel;
            doc.extend = false;
            if (copyHistory) {
              doc.history.undoDepth = this.history.undoDepth;
              doc.setHistory(this.getHistory());
            }
            return doc;
          },
          linkedDoc: function(options) {
            if (!options) {
              options = {};
            }
            var from = this.first, to = this.first + this.size;
            if (options.from != null && options.from > from) {
              from = options.from;
            }
            if (options.to != null && options.to < to) {
              to = options.to;
            }
            var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
            if (options.sharedHist) {
              copy.history = this.history;
            }
            (this.linked || (this.linked = [])).push({ doc: copy, sharedHist: options.sharedHist });
            copy.linked = [{ doc: this, isParent: true, sharedHist: options.sharedHist }];
            copySharedMarkers(copy, findSharedMarkers(this));
            return copy;
          },
          unlinkDoc: function(other) {
            if (other instanceof CodeMirror3) {
              other = other.doc;
            }
            if (this.linked) {
              for (var i3 = 0; i3 < this.linked.length; ++i3) {
                var link = this.linked[i3];
                if (link.doc != other) {
                  continue;
                }
                this.linked.splice(i3, 1);
                other.unlinkDoc(this);
                detachSharedMarkers(findSharedMarkers(this));
                break;
              }
            }
            if (other.history == this.history) {
              var splitIds = [other.id];
              linkedDocs(other, function(doc) {
                return splitIds.push(doc.id);
              }, true);
              other.history = new History2(null);
              other.history.done = copyHistoryArray(this.history.done, splitIds);
              other.history.undone = copyHistoryArray(this.history.undone, splitIds);
            }
          },
          iterLinkedDocs: function(f2) {
            linkedDocs(this, f2);
          },
          getMode: function() {
            return this.mode;
          },
          getEditor: function() {
            return this.cm;
          },
          splitLines: function(str) {
            if (this.lineSep) {
              return str.split(this.lineSep);
            }
            return splitLinesAuto(str);
          },
          lineSeparator: function() {
            return this.lineSep || "\n";
          },
          setDirection: docMethodOp(function(dir) {
            if (dir != "rtl") {
              dir = "ltr";
            }
            if (dir == this.direction) {
              return;
            }
            this.direction = dir;
            this.iter(function(line) {
              return line.order = null;
            });
            if (this.cm) {
              directionChanged(this.cm);
            }
          })
        });
        Doc.prototype.eachLine = Doc.prototype.iter;
        var lastDrop = 0;
        function onDrop(e2) {
          var cm = this;
          clearDragCursor(cm);
          if (signalDOMEvent(cm, e2) || eventInWidget(cm.display, e2)) {
            return;
          }
          e_preventDefault(e2);
          if (ie) {
            lastDrop = +new Date();
          }
          var pos = posFromMouse(cm, e2, true), files = e2.dataTransfer.files;
          if (!pos || cm.isReadOnly()) {
            return;
          }
          if (files && files.length && window.FileReader && window.File) {
            var n2 = files.length, text = Array(n2), read2 = 0;
            var markAsReadAndPasteIfAllFilesAreRead = function() {
              if (++read2 == n2) {
                operation(cm, function() {
                  pos = clipPos(cm.doc, pos);
                  var change = {
                    from: pos,
                    to: pos,
                    text: cm.doc.splitLines(text.filter(function(t2) {
                      return t2 != null;
                    }).join(cm.doc.lineSeparator())),
                    origin: "paste"
                  };
                  makeChange(cm.doc, change);
                  setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
                })();
              }
            };
            var readTextFromFile = function(file, i4) {
              if (cm.options.allowDropFileTypes && indexOf2(cm.options.allowDropFileTypes, file.type) == -1) {
                markAsReadAndPasteIfAllFilesAreRead();
                return;
              }
              var reader = new FileReader();
              reader.onerror = function() {
                return markAsReadAndPasteIfAllFilesAreRead();
              };
              reader.onload = function() {
                var content = reader.result;
                if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
                  markAsReadAndPasteIfAllFilesAreRead();
                  return;
                }
                text[i4] = content;
                markAsReadAndPasteIfAllFilesAreRead();
              };
              reader.readAsText(file);
            };
            for (var i3 = 0; i3 < files.length; i3++) {
              readTextFromFile(files[i3], i3);
            }
          } else {
            if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
              cm.state.draggingText(e2);
              setTimeout(function() {
                return cm.display.input.focus();
              }, 20);
              return;
            }
            try {
              var text$1 = e2.dataTransfer.getData("Text");
              if (text$1) {
                var selected;
                if (cm.state.draggingText && !cm.state.draggingText.copy) {
                  selected = cm.listSelections();
                }
                setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
                if (selected) {
                  for (var i$12 = 0; i$12 < selected.length; ++i$12) {
                    replaceRange(cm.doc, "", selected[i$12].anchor, selected[i$12].head, "drag");
                  }
                }
                cm.replaceSelection(text$1, "around", "paste");
                cm.display.input.focus();
              }
            } catch (e$1) {
            }
          }
        }
        function onDragStart(cm, e2) {
          if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
            e_stop(e2);
            return;
          }
          if (signalDOMEvent(cm, e2) || eventInWidget(cm.display, e2)) {
            return;
          }
          e2.dataTransfer.setData("Text", cm.getSelection());
          e2.dataTransfer.effectAllowed = "copyMove";
          if (e2.dataTransfer.setDragImage && !safari) {
            var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
            img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
            if (presto) {
              img.width = img.height = 1;
              cm.display.wrapper.appendChild(img);
              img._top = img.offsetTop;
            }
            e2.dataTransfer.setDragImage(img, 0, 0);
            if (presto) {
              img.parentNode.removeChild(img);
            }
          }
        }
        function onDragOver(cm, e2) {
          var pos = posFromMouse(cm, e2);
          if (!pos) {
            return;
          }
          var frag = document.createDocumentFragment();
          drawSelectionCursor(cm, pos, frag);
          if (!cm.display.dragCursor) {
            cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
            cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
          }
          removeChildrenAndAdd(cm.display.dragCursor, frag);
        }
        function clearDragCursor(cm) {
          if (cm.display.dragCursor) {
            cm.display.lineSpace.removeChild(cm.display.dragCursor);
            cm.display.dragCursor = null;
          }
        }
        function forEachCodeMirror(f2) {
          if (!document.getElementsByClassName) {
            return;
          }
          var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
          for (var i3 = 0; i3 < byClass.length; i3++) {
            var cm = byClass[i3].CodeMirror;
            if (cm) {
              editors.push(cm);
            }
          }
          if (editors.length) {
            editors[0].operation(function() {
              for (var i4 = 0; i4 < editors.length; i4++) {
                f2(editors[i4]);
              }
            });
          }
        }
        var globalsRegistered = false;
        function ensureGlobalHandlers() {
          if (globalsRegistered) {
            return;
          }
          registerGlobalHandlers();
          globalsRegistered = true;
        }
        function registerGlobalHandlers() {
          var resizeTimer;
          on(window, "resize", function() {
            if (resizeTimer == null) {
              resizeTimer = setTimeout(function() {
                resizeTimer = null;
                forEachCodeMirror(onResize);
              }, 100);
            }
          });
          on(window, "blur", function() {
            return forEachCodeMirror(onBlur);
          });
        }
        function onResize(cm) {
          var d2 = cm.display;
          d2.cachedCharWidth = d2.cachedTextHeight = d2.cachedPaddingH = null;
          d2.scrollbarsClipped = false;
          cm.setSize();
        }
        var keyNames = {
          3: "Pause",
          8: "Backspace",
          9: "Tab",
          13: "Enter",
          16: "Shift",
          17: "Ctrl",
          18: "Alt",
          19: "Pause",
          20: "CapsLock",
          27: "Esc",
          32: "Space",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "Left",
          38: "Up",
          39: "Right",
          40: "Down",
          44: "PrintScrn",
          45: "Insert",
          46: "Delete",
          59: ";",
          61: "=",
          91: "Mod",
          92: "Mod",
          93: "Mod",
          106: "*",
          107: "=",
          109: "-",
          110: ".",
          111: "/",
          145: "ScrollLock",
          173: "-",
          186: ";",
          187: "=",
          188: ",",
          189: "-",
          190: ".",
          191: "/",
          192: "`",
          219: "[",
          220: "\\",
          221: "]",
          222: "'",
          224: "Mod",
          63232: "Up",
          63233: "Down",
          63234: "Left",
          63235: "Right",
          63272: "Delete",
          63273: "Home",
          63275: "End",
          63276: "PageUp",
          63277: "PageDown",
          63302: "Insert"
        };
        for (var i2 = 0; i2 < 10; i2++) {
          keyNames[i2 + 48] = keyNames[i2 + 96] = String(i2);
        }
        for (var i$1 = 65; i$1 <= 90; i$1++) {
          keyNames[i$1] = String.fromCharCode(i$1);
        }
        for (var i$2 = 1; i$2 <= 12; i$2++) {
          keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
        }
        var keyMap = {};
        keyMap.basic = {
          "Left": "goCharLeft",
          "Right": "goCharRight",
          "Up": "goLineUp",
          "Down": "goLineDown",
          "End": "goLineEnd",
          "Home": "goLineStartSmart",
          "PageUp": "goPageUp",
          "PageDown": "goPageDown",
          "Delete": "delCharAfter",
          "Backspace": "delCharBefore",
          "Shift-Backspace": "delCharBefore",
          "Tab": "defaultTab",
          "Shift-Tab": "indentAuto",
          "Enter": "newlineAndIndent",
          "Insert": "toggleOverwrite",
          "Esc": "singleSelection"
        };
        keyMap.pcDefault = {
          "Ctrl-A": "selectAll",
          "Ctrl-D": "deleteLine",
          "Ctrl-Z": "undo",
          "Shift-Ctrl-Z": "redo",
          "Ctrl-Y": "redo",
          "Ctrl-Home": "goDocStart",
          "Ctrl-End": "goDocEnd",
          "Ctrl-Up": "goLineUp",
          "Ctrl-Down": "goLineDown",
          "Ctrl-Left": "goGroupLeft",
          "Ctrl-Right": "goGroupRight",
          "Alt-Left": "goLineStart",
          "Alt-Right": "goLineEnd",
          "Ctrl-Backspace": "delGroupBefore",
          "Ctrl-Delete": "delGroupAfter",
          "Ctrl-S": "save",
          "Ctrl-F": "find",
          "Ctrl-G": "findNext",
          "Shift-Ctrl-G": "findPrev",
          "Shift-Ctrl-F": "replace",
          "Shift-Ctrl-R": "replaceAll",
          "Ctrl-[": "indentLess",
          "Ctrl-]": "indentMore",
          "Ctrl-U": "undoSelection",
          "Shift-Ctrl-U": "redoSelection",
          "Alt-U": "redoSelection",
          "fallthrough": "basic"
        };
        keyMap.emacsy = {
          "Ctrl-F": "goCharRight",
          "Ctrl-B": "goCharLeft",
          "Ctrl-P": "goLineUp",
          "Ctrl-N": "goLineDown",
          "Alt-F": "goWordRight",
          "Alt-B": "goWordLeft",
          "Ctrl-A": "goLineStart",
          "Ctrl-E": "goLineEnd",
          "Ctrl-V": "goPageDown",
          "Shift-Ctrl-V": "goPageUp",
          "Ctrl-D": "delCharAfter",
          "Ctrl-H": "delCharBefore",
          "Alt-D": "delWordAfter",
          "Alt-Backspace": "delWordBefore",
          "Ctrl-K": "killLine",
          "Ctrl-T": "transposeChars",
          "Ctrl-O": "openLine"
        };
        keyMap.macDefault = {
          "Cmd-A": "selectAll",
          "Cmd-D": "deleteLine",
          "Cmd-Z": "undo",
          "Shift-Cmd-Z": "redo",
          "Cmd-Y": "redo",
          "Cmd-Home": "goDocStart",
          "Cmd-Up": "goDocStart",
          "Cmd-End": "goDocEnd",
          "Cmd-Down": "goDocEnd",
          "Alt-Left": "goGroupLeft",
          "Alt-Right": "goGroupRight",
          "Cmd-Left": "goLineLeft",
          "Cmd-Right": "goLineRight",
          "Alt-Backspace": "delGroupBefore",
          "Ctrl-Alt-Backspace": "delGroupAfter",
          "Alt-Delete": "delGroupAfter",
          "Cmd-S": "save",
          "Cmd-F": "find",
          "Cmd-G": "findNext",
          "Shift-Cmd-G": "findPrev",
          "Cmd-Alt-F": "replace",
          "Shift-Cmd-Alt-F": "replaceAll",
          "Cmd-[": "indentLess",
          "Cmd-]": "indentMore",
          "Cmd-Backspace": "delWrappedLineLeft",
          "Cmd-Delete": "delWrappedLineRight",
          "Cmd-U": "undoSelection",
          "Shift-Cmd-U": "redoSelection",
          "Ctrl-Up": "goDocStart",
          "Ctrl-Down": "goDocEnd",
          "fallthrough": ["basic", "emacsy"]
        };
        keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
        function normalizeKeyName(name) {
          var parts = name.split(/-(?!$)/);
          name = parts[parts.length - 1];
          var alt, ctrl, shift, cmd;
          for (var i3 = 0; i3 < parts.length - 1; i3++) {
            var mod = parts[i3];
            if (/^(cmd|meta|m)$/i.test(mod)) {
              cmd = true;
            } else if (/^a(lt)?$/i.test(mod)) {
              alt = true;
            } else if (/^(c|ctrl|control)$/i.test(mod)) {
              ctrl = true;
            } else if (/^s(hift)?$/i.test(mod)) {
              shift = true;
            } else {
              throw new Error("Unrecognized modifier name: " + mod);
            }
          }
          if (alt) {
            name = "Alt-" + name;
          }
          if (ctrl) {
            name = "Ctrl-" + name;
          }
          if (cmd) {
            name = "Cmd-" + name;
          }
          if (shift) {
            name = "Shift-" + name;
          }
          return name;
        }
        function normalizeKeyMap(keymap) {
          var copy = {};
          for (var keyname in keymap) {
            if (keymap.hasOwnProperty(keyname)) {
              var value = keymap[keyname];
              if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
                continue;
              }
              if (value == "...") {
                delete keymap[keyname];
                continue;
              }
              var keys = map(keyname.split(" "), normalizeKeyName);
              for (var i3 = 0; i3 < keys.length; i3++) {
                var val = void 0, name = void 0;
                if (i3 == keys.length - 1) {
                  name = keys.join(" ");
                  val = value;
                } else {
                  name = keys.slice(0, i3 + 1).join(" ");
                  val = "...";
                }
                var prev = copy[name];
                if (!prev) {
                  copy[name] = val;
                } else if (prev != val) {
                  throw new Error("Inconsistent bindings for " + name);
                }
              }
              delete keymap[keyname];
            }
          }
          for (var prop2 in copy) {
            keymap[prop2] = copy[prop2];
          }
          return keymap;
        }
        function lookupKey(key, map2, handle, context) {
          map2 = getKeyMap(map2);
          var found = map2.call ? map2.call(key, context) : map2[key];
          if (found === false) {
            return "nothing";
          }
          if (found === "...") {
            return "multi";
          }
          if (found != null && handle(found)) {
            return "handled";
          }
          if (map2.fallthrough) {
            if (Object.prototype.toString.call(map2.fallthrough) != "[object Array]") {
              return lookupKey(key, map2.fallthrough, handle, context);
            }
            for (var i3 = 0; i3 < map2.fallthrough.length; i3++) {
              var result = lookupKey(key, map2.fallthrough[i3], handle, context);
              if (result) {
                return result;
              }
            }
          }
        }
        function isModifierKey(value) {
          var name = typeof value == "string" ? value : keyNames[value.keyCode];
          return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
        }
        function addModifierNames(name, event, noShift) {
          var base = name;
          if (event.altKey && base != "Alt") {
            name = "Alt-" + name;
          }
          if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") {
            name = "Ctrl-" + name;
          }
          if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Mod") {
            name = "Cmd-" + name;
          }
          if (!noShift && event.shiftKey && base != "Shift") {
            name = "Shift-" + name;
          }
          return name;
        }
        function keyName(event, noShift) {
          if (presto && event.keyCode == 34 && event["char"]) {
            return false;
          }
          var name = keyNames[event.keyCode];
          if (name == null || event.altGraphKey) {
            return false;
          }
          if (event.keyCode == 3 && event.code) {
            name = event.code;
          }
          return addModifierNames(name, event, noShift);
        }
        function getKeyMap(val) {
          return typeof val == "string" ? keyMap[val] : val;
        }
        function deleteNearSelection(cm, compute) {
          var ranges = cm.doc.sel.ranges, kill = [];
          for (var i3 = 0; i3 < ranges.length; i3++) {
            var toKill = compute(ranges[i3]);
            while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
              var replaced = kill.pop();
              if (cmp(replaced.from, toKill.from) < 0) {
                toKill.from = replaced.from;
                break;
              }
            }
            kill.push(toKill);
          }
          runInOp(cm, function() {
            for (var i4 = kill.length - 1; i4 >= 0; i4--) {
              replaceRange(cm.doc, "", kill[i4].from, kill[i4].to, "+delete");
            }
            ensureCursorVisible(cm);
          });
        }
        function moveCharLogically(line, ch, dir) {
          var target = skipExtendingChars(line.text, ch + dir, dir);
          return target < 0 || target > line.text.length ? null : target;
        }
        function moveLogically(line, start4, dir) {
          var ch = moveCharLogically(line, start4.ch, dir);
          return ch == null ? null : new Pos(start4.line, ch, dir < 0 ? "after" : "before");
        }
        function endOfLine(visually, cm, lineObj, lineNo2, dir) {
          if (visually) {
            if (cm.doc.direction == "rtl") {
              dir = -dir;
            }
            var order2 = getOrder(lineObj, cm.doc.direction);
            if (order2) {
              var part = dir < 0 ? lst(order2) : order2[0];
              var moveInStorageOrder = dir < 0 == (part.level == 1);
              var sticky = moveInStorageOrder ? "after" : "before";
              var ch;
              if (part.level > 0 || cm.doc.direction == "rtl") {
                var prep = prepareMeasureForLine(cm, lineObj);
                ch = dir < 0 ? lineObj.text.length - 1 : 0;
                var targetTop = measureCharPrepared(cm, prep, ch).top;
                ch = findFirst(function(ch2) {
                  return measureCharPrepared(cm, prep, ch2).top == targetTop;
                }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);
                if (sticky == "before") {
                  ch = moveCharLogically(lineObj, ch, 1);
                }
              } else {
                ch = dir < 0 ? part.to : part.from;
              }
              return new Pos(lineNo2, ch, sticky);
            }
          }
          return new Pos(lineNo2, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
        }
        function moveVisually(cm, line, start4, dir) {
          var bidi = getOrder(line, cm.doc.direction);
          if (!bidi) {
            return moveLogically(line, start4, dir);
          }
          if (start4.ch >= line.text.length) {
            start4.ch = line.text.length;
            start4.sticky = "before";
          } else if (start4.ch <= 0) {
            start4.ch = 0;
            start4.sticky = "after";
          }
          var partPos = getBidiPartAt(bidi, start4.ch, start4.sticky), part = bidi[partPos];
          if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start4.ch : part.from < start4.ch)) {
            return moveLogically(line, start4, dir);
          }
          var mv = function(pos, dir2) {
            return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir2);
          };
          var prep;
          var getWrappedLineExtent = function(ch2) {
            if (!cm.options.lineWrapping) {
              return { begin: 0, end: line.text.length };
            }
            prep = prep || prepareMeasureForLine(cm, line);
            return wrappedLineExtentChar(cm, line, prep, ch2);
          };
          var wrappedLineExtent2 = getWrappedLineExtent(start4.sticky == "before" ? mv(start4, -1) : start4.ch);
          if (cm.doc.direction == "rtl" || part.level == 1) {
            var moveInStorageOrder = part.level == 1 == dir < 0;
            var ch = mv(start4, moveInStorageOrder ? 1 : -1);
            if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent2.begin : ch <= part.to && ch <= wrappedLineExtent2.end)) {
              var sticky = moveInStorageOrder ? "before" : "after";
              return new Pos(start4.line, ch, sticky);
            }
          }
          var searchInVisualLine = function(partPos2, dir2, wrappedLineExtent3) {
            var getRes = function(ch3, moveInStorageOrder3) {
              return moveInStorageOrder3 ? new Pos(start4.line, mv(ch3, 1), "before") : new Pos(start4.line, ch3, "after");
            };
            for (; partPos2 >= 0 && partPos2 < bidi.length; partPos2 += dir2) {
              var part2 = bidi[partPos2];
              var moveInStorageOrder2 = dir2 > 0 == (part2.level != 1);
              var ch2 = moveInStorageOrder2 ? wrappedLineExtent3.begin : mv(wrappedLineExtent3.end, -1);
              if (part2.from <= ch2 && ch2 < part2.to) {
                return getRes(ch2, moveInStorageOrder2);
              }
              ch2 = moveInStorageOrder2 ? part2.from : mv(part2.to, -1);
              if (wrappedLineExtent3.begin <= ch2 && ch2 < wrappedLineExtent3.end) {
                return getRes(ch2, moveInStorageOrder2);
              }
            }
          };
          var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent2);
          if (res) {
            return res;
          }
          var nextCh = dir > 0 ? wrappedLineExtent2.end : mv(wrappedLineExtent2.begin, -1);
          if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
            res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
            if (res) {
              return res;
            }
          }
          return null;
        }
        var commands = {
          selectAll,
          singleSelection: function(cm) {
            return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
          },
          killLine: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              if (range2.empty()) {
                var len = getLine(cm.doc, range2.head.line).text.length;
                if (range2.head.ch == len && range2.head.line < cm.lastLine()) {
                  return { from: range2.head, to: Pos(range2.head.line + 1, 0) };
                } else {
                  return { from: range2.head, to: Pos(range2.head.line, len) };
                }
              } else {
                return { from: range2.from(), to: range2.to() };
              }
            });
          },
          deleteLine: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              return {
                from: Pos(range2.from().line, 0),
                to: clipPos(cm.doc, Pos(range2.to().line + 1, 0))
              };
            });
          },
          delLineLeft: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              return {
                from: Pos(range2.from().line, 0),
                to: range2.from()
              };
            });
          },
          delWrappedLineLeft: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              var top2 = cm.charCoords(range2.head, "div").top + 5;
              var leftPos = cm.coordsChar({ left: 0, top: top2 }, "div");
              return { from: leftPos, to: range2.from() };
            });
          },
          delWrappedLineRight: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              var top2 = cm.charCoords(range2.head, "div").top + 5;
              var rightPos = cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top2 }, "div");
              return { from: range2.from(), to: rightPos };
            });
          },
          undo: function(cm) {
            return cm.undo();
          },
          redo: function(cm) {
            return cm.redo();
          },
          undoSelection: function(cm) {
            return cm.undoSelection();
          },
          redoSelection: function(cm) {
            return cm.redoSelection();
          },
          goDocStart: function(cm) {
            return cm.extendSelection(Pos(cm.firstLine(), 0));
          },
          goDocEnd: function(cm) {
            return cm.extendSelection(Pos(cm.lastLine()));
          },
          goLineStart: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              return lineStart(cm, range2.head.line);
            }, { origin: "+move", bias: 1 });
          },
          goLineStartSmart: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              return lineStartSmart(cm, range2.head);
            }, { origin: "+move", bias: 1 });
          },
          goLineEnd: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              return lineEnd(cm, range2.head.line);
            }, { origin: "+move", bias: -1 });
          },
          goLineRight: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              var top2 = cm.cursorCoords(range2.head, "div").top + 5;
              return cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top2 }, "div");
            }, sel_move);
          },
          goLineLeft: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              var top2 = cm.cursorCoords(range2.head, "div").top + 5;
              return cm.coordsChar({ left: 0, top: top2 }, "div");
            }, sel_move);
          },
          goLineLeftSmart: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              var top2 = cm.cursorCoords(range2.head, "div").top + 5;
              var pos = cm.coordsChar({ left: 0, top: top2 }, "div");
              if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
                return lineStartSmart(cm, range2.head);
              }
              return pos;
            }, sel_move);
          },
          goLineUp: function(cm) {
            return cm.moveV(-1, "line");
          },
          goLineDown: function(cm) {
            return cm.moveV(1, "line");
          },
          goPageUp: function(cm) {
            return cm.moveV(-1, "page");
          },
          goPageDown: function(cm) {
            return cm.moveV(1, "page");
          },
          goCharLeft: function(cm) {
            return cm.moveH(-1, "char");
          },
          goCharRight: function(cm) {
            return cm.moveH(1, "char");
          },
          goColumnLeft: function(cm) {
            return cm.moveH(-1, "column");
          },
          goColumnRight: function(cm) {
            return cm.moveH(1, "column");
          },
          goWordLeft: function(cm) {
            return cm.moveH(-1, "word");
          },
          goGroupRight: function(cm) {
            return cm.moveH(1, "group");
          },
          goGroupLeft: function(cm) {
            return cm.moveH(-1, "group");
          },
          goWordRight: function(cm) {
            return cm.moveH(1, "word");
          },
          delCharBefore: function(cm) {
            return cm.deleteH(-1, "codepoint");
          },
          delCharAfter: function(cm) {
            return cm.deleteH(1, "char");
          },
          delWordBefore: function(cm) {
            return cm.deleteH(-1, "word");
          },
          delWordAfter: function(cm) {
            return cm.deleteH(1, "word");
          },
          delGroupBefore: function(cm) {
            return cm.deleteH(-1, "group");
          },
          delGroupAfter: function(cm) {
            return cm.deleteH(1, "group");
          },
          indentAuto: function(cm) {
            return cm.indentSelection("smart");
          },
          indentMore: function(cm) {
            return cm.indentSelection("add");
          },
          indentLess: function(cm) {
            return cm.indentSelection("subtract");
          },
          insertTab: function(cm) {
            return cm.replaceSelection("	");
          },
          insertSoftTab: function(cm) {
            var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
            for (var i3 = 0; i3 < ranges.length; i3++) {
              var pos = ranges[i3].from();
              var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
              spaces.push(spaceStr(tabSize - col % tabSize));
            }
            cm.replaceSelections(spaces);
          },
          defaultTab: function(cm) {
            if (cm.somethingSelected()) {
              cm.indentSelection("add");
            } else {
              cm.execCommand("insertTab");
            }
          },
          transposeChars: function(cm) {
            return runInOp(cm, function() {
              var ranges = cm.listSelections(), newSel = [];
              for (var i3 = 0; i3 < ranges.length; i3++) {
                if (!ranges[i3].empty()) {
                  continue;
                }
                var cur = ranges[i3].head, line = getLine(cm.doc, cur.line).text;
                if (line) {
                  if (cur.ch == line.length) {
                    cur = new Pos(cur.line, cur.ch - 1);
                  }
                  if (cur.ch > 0) {
                    cur = new Pos(cur.line, cur.ch + 1);
                    cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
                  } else if (cur.line > cm.doc.first) {
                    var prev = getLine(cm.doc, cur.line - 1).text;
                    if (prev) {
                      cur = new Pos(cur.line, 1);
                      cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
                    }
                  }
                }
                newSel.push(new Range(cur, cur));
              }
              cm.setSelections(newSel);
            });
          },
          newlineAndIndent: function(cm) {
            return runInOp(cm, function() {
              var sels = cm.listSelections();
              for (var i3 = sels.length - 1; i3 >= 0; i3--) {
                cm.replaceRange(cm.doc.lineSeparator(), sels[i3].anchor, sels[i3].head, "+input");
              }
              sels = cm.listSelections();
              for (var i$12 = 0; i$12 < sels.length; i$12++) {
                cm.indentLine(sels[i$12].from().line, null, true);
              }
              ensureCursorVisible(cm);
            });
          },
          openLine: function(cm) {
            return cm.replaceSelection("\n", "start");
          },
          toggleOverwrite: function(cm) {
            return cm.toggleOverwrite();
          }
        };
        function lineStart(cm, lineN) {
          var line = getLine(cm.doc, lineN);
          var visual = visualLine(line);
          if (visual != line) {
            lineN = lineNo(visual);
          }
          return endOfLine(true, cm, visual, lineN, 1);
        }
        function lineEnd(cm, lineN) {
          var line = getLine(cm.doc, lineN);
          var visual = visualLineEnd(line);
          if (visual != line) {
            lineN = lineNo(visual);
          }
          return endOfLine(true, cm, line, lineN, -1);
        }
        function lineStartSmart(cm, pos) {
          var start4 = lineStart(cm, pos.line);
          var line = getLine(cm.doc, start4.line);
          var order2 = getOrder(line, cm.doc.direction);
          if (!order2 || order2[0].level == 0) {
            var firstNonWS = Math.max(start4.ch, line.text.search(/\S/));
            var inWS = pos.line == start4.line && pos.ch <= firstNonWS && pos.ch;
            return Pos(start4.line, inWS ? 0 : firstNonWS, start4.sticky);
          }
          return start4;
        }
        function doHandleBinding(cm, bound, dropShift) {
          if (typeof bound == "string") {
            bound = commands[bound];
            if (!bound) {
              return false;
            }
          }
          cm.display.input.ensurePolled();
          var prevShift = cm.display.shift, done = false;
          try {
            if (cm.isReadOnly()) {
              cm.state.suppressEdits = true;
            }
            if (dropShift) {
              cm.display.shift = false;
            }
            done = bound(cm) != Pass;
          } finally {
            cm.display.shift = prevShift;
            cm.state.suppressEdits = false;
          }
          return done;
        }
        function lookupKeyForEditor(cm, name, handle) {
          for (var i3 = 0; i3 < cm.state.keyMaps.length; i3++) {
            var result = lookupKey(name, cm.state.keyMaps[i3], handle, cm);
            if (result) {
              return result;
            }
          }
          return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
        }
        var stopSeq = new Delayed();
        function dispatchKey(cm, name, e2, handle) {
          var seq = cm.state.keySeq;
          if (seq) {
            if (isModifierKey(name)) {
              return "handled";
            }
            if (/\'$/.test(name)) {
              cm.state.keySeq = null;
            } else {
              stopSeq.set(50, function() {
                if (cm.state.keySeq == seq) {
                  cm.state.keySeq = null;
                  cm.display.input.reset();
                }
              });
            }
            if (dispatchKeyInner(cm, seq + " " + name, e2, handle)) {
              return true;
            }
          }
          return dispatchKeyInner(cm, name, e2, handle);
        }
        function dispatchKeyInner(cm, name, e2, handle) {
          var result = lookupKeyForEditor(cm, name, handle);
          if (result == "multi") {
            cm.state.keySeq = name;
          }
          if (result == "handled") {
            signalLater(cm, "keyHandled", cm, name, e2);
          }
          if (result == "handled" || result == "multi") {
            e_preventDefault(e2);
            restartBlink(cm);
          }
          return !!result;
        }
        function handleKeyBinding(cm, e2) {
          var name = keyName(e2, true);
          if (!name) {
            return false;
          }
          if (e2.shiftKey && !cm.state.keySeq) {
            return dispatchKey(cm, "Shift-" + name, e2, function(b2) {
              return doHandleBinding(cm, b2, true);
            }) || dispatchKey(cm, name, e2, function(b2) {
              if (typeof b2 == "string" ? /^go[A-Z]/.test(b2) : b2.motion) {
                return doHandleBinding(cm, b2);
              }
            });
          } else {
            return dispatchKey(cm, name, e2, function(b2) {
              return doHandleBinding(cm, b2);
            });
          }
        }
        function handleCharBinding(cm, e2, ch) {
          return dispatchKey(cm, "'" + ch + "'", e2, function(b2) {
            return doHandleBinding(cm, b2, true);
          });
        }
        var lastStoppedKey = null;
        function onKeyDown2(e2) {
          var cm = this;
          if (e2.target && e2.target != cm.display.input.getField()) {
            return;
          }
          cm.curOp.focus = activeElt();
          if (signalDOMEvent(cm, e2)) {
            return;
          }
          if (ie && ie_version < 11 && e2.keyCode == 27) {
            e2.returnValue = false;
          }
          var code3 = e2.keyCode;
          cm.display.shift = code3 == 16 || e2.shiftKey;
          var handled = handleKeyBinding(cm, e2);
          if (presto) {
            lastStoppedKey = handled ? code3 : null;
            if (!handled && code3 == 88 && !hasCopyEvent && (mac ? e2.metaKey : e2.ctrlKey)) {
              cm.replaceSelection("", null, "cut");
            }
          }
          if (gecko && !mac && !handled && code3 == 46 && e2.shiftKey && !e2.ctrlKey && document.execCommand) {
            document.execCommand("cut");
          }
          if (code3 == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
            showCrossHair(cm);
          }
        }
        function showCrossHair(cm) {
          var lineDiv = cm.display.lineDiv;
          addClass(lineDiv, "CodeMirror-crosshair");
          function up(e2) {
            if (e2.keyCode == 18 || !e2.altKey) {
              rmClass(lineDiv, "CodeMirror-crosshair");
              off(document, "keyup", up);
              off(document, "mouseover", up);
            }
          }
          on(document, "keyup", up);
          on(document, "mouseover", up);
        }
        function onKeyUp(e2) {
          if (e2.keyCode == 16) {
            this.doc.sel.shift = false;
          }
          signalDOMEvent(this, e2);
        }
        function onKeyPress(e2) {
          var cm = this;
          if (e2.target && e2.target != cm.display.input.getField()) {
            return;
          }
          if (eventInWidget(cm.display, e2) || signalDOMEvent(cm, e2) || e2.ctrlKey && !e2.altKey || mac && e2.metaKey) {
            return;
          }
          var keyCode = e2.keyCode, charCode = e2.charCode;
          if (presto && keyCode == lastStoppedKey) {
            lastStoppedKey = null;
            e_preventDefault(e2);
            return;
          }
          if (presto && (!e2.which || e2.which < 10) && handleKeyBinding(cm, e2)) {
            return;
          }
          var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
          if (ch == "\b") {
            return;
          }
          if (handleCharBinding(cm, e2, ch)) {
            return;
          }
          cm.display.input.onKeyPress(e2);
        }
        var DOUBLECLICK_DELAY = 400;
        var PastClick = function(time, pos, button) {
          this.time = time;
          this.pos = pos;
          this.button = button;
        };
        PastClick.prototype.compare = function(time, pos, button) {
          return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
        };
        var lastClick, lastDoubleClick;
        function clickRepeat(pos, button) {
          var now2 = +new Date();
          if (lastDoubleClick && lastDoubleClick.compare(now2, pos, button)) {
            lastClick = lastDoubleClick = null;
            return "triple";
          } else if (lastClick && lastClick.compare(now2, pos, button)) {
            lastDoubleClick = new PastClick(now2, pos, button);
            lastClick = null;
            return "double";
          } else {
            lastClick = new PastClick(now2, pos, button);
            lastDoubleClick = null;
            return "single";
          }
        }
        function onMouseDown(e2) {
          var cm = this, display = cm.display;
          if (signalDOMEvent(cm, e2) || display.activeTouch && display.input.supportsTouch()) {
            return;
          }
          display.input.ensurePolled();
          display.shift = e2.shiftKey;
          if (eventInWidget(display, e2)) {
            if (!webkit) {
              display.scroller.draggable = false;
              setTimeout(function() {
                return display.scroller.draggable = true;
              }, 100);
            }
            return;
          }
          if (clickInGutter(cm, e2)) {
            return;
          }
          var pos = posFromMouse(cm, e2), button = e_button(e2), repeat = pos ? clickRepeat(pos, button) : "single";
          window.focus();
          if (button == 1 && cm.state.selectingText) {
            cm.state.selectingText(e2);
          }
          if (pos && handleMappedButton(cm, button, pos, repeat, e2)) {
            return;
          }
          if (button == 1) {
            if (pos) {
              leftButtonDown(cm, pos, repeat, e2);
            } else if (e_target(e2) == display.scroller) {
              e_preventDefault(e2);
            }
          } else if (button == 2) {
            if (pos) {
              extendSelection(cm.doc, pos);
            }
            setTimeout(function() {
              return display.input.focus();
            }, 20);
          } else if (button == 3) {
            if (captureRightClick) {
              cm.display.input.onContextMenu(e2);
            } else {
              delayBlurEvent(cm);
            }
          }
        }
        function handleMappedButton(cm, button, pos, repeat, event) {
          var name = "Click";
          if (repeat == "double") {
            name = "Double" + name;
          } else if (repeat == "triple") {
            name = "Triple" + name;
          }
          name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;
          return dispatchKey(cm, addModifierNames(name, event), event, function(bound) {
            if (typeof bound == "string") {
              bound = commands[bound];
            }
            if (!bound) {
              return false;
            }
            var done = false;
            try {
              if (cm.isReadOnly()) {
                cm.state.suppressEdits = true;
              }
              done = bound(cm, pos) != Pass;
            } finally {
              cm.state.suppressEdits = false;
            }
            return done;
          });
        }
        function configureMouse(cm, repeat, event) {
          var option = cm.getOption("configureMouse");
          var value = option ? option(cm, repeat, event) : {};
          if (value.unit == null) {
            var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
            value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
          }
          if (value.extend == null || cm.doc.extend) {
            value.extend = cm.doc.extend || event.shiftKey;
          }
          if (value.addNew == null) {
            value.addNew = mac ? event.metaKey : event.ctrlKey;
          }
          if (value.moveOnDrag == null) {
            value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);
          }
          return value;
        }
        function leftButtonDown(cm, pos, repeat, event) {
          if (ie) {
            setTimeout(bind3(ensureFocus, cm), 0);
          } else {
            cm.curOp.focus = activeElt();
          }
          var behavior = configureMouse(cm, repeat, event);
          var sel = cm.doc.sel, contained;
          if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {
            leftButtonStartDrag(cm, event, pos, behavior);
          } else {
            leftButtonSelect(cm, event, pos, behavior);
          }
        }
        function leftButtonStartDrag(cm, event, pos, behavior) {
          var display = cm.display, moved = false;
          var dragEnd = operation(cm, function(e2) {
            if (webkit) {
              display.scroller.draggable = false;
            }
            cm.state.draggingText = false;
            if (cm.state.delayingBlurEvent) {
              if (cm.hasFocus()) {
                cm.state.delayingBlurEvent = false;
              } else {
                delayBlurEvent(cm);
              }
            }
            off(display.wrapper.ownerDocument, "mouseup", dragEnd);
            off(display.wrapper.ownerDocument, "mousemove", mouseMove);
            off(display.scroller, "dragstart", dragStart);
            off(display.scroller, "drop", dragEnd);
            if (!moved) {
              e_preventDefault(e2);
              if (!behavior.addNew) {
                extendSelection(cm.doc, pos, null, null, behavior.extend);
              }
              if (webkit && !safari || ie && ie_version == 9) {
                setTimeout(function() {
                  display.wrapper.ownerDocument.body.focus({ preventScroll: true });
                  display.input.focus();
                }, 20);
              } else {
                display.input.focus();
              }
            }
          });
          var mouseMove = function(e2) {
            moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
          };
          var dragStart = function() {
            return moved = true;
          };
          if (webkit) {
            display.scroller.draggable = true;
          }
          cm.state.draggingText = dragEnd;
          dragEnd.copy = !behavior.moveOnDrag;
          on(display.wrapper.ownerDocument, "mouseup", dragEnd);
          on(display.wrapper.ownerDocument, "mousemove", mouseMove);
          on(display.scroller, "dragstart", dragStart);
          on(display.scroller, "drop", dragEnd);
          cm.state.delayingBlurEvent = true;
          setTimeout(function() {
            return display.input.focus();
          }, 20);
          if (display.scroller.dragDrop) {
            display.scroller.dragDrop();
          }
        }
        function rangeForUnit(cm, pos, unit) {
          if (unit == "char") {
            return new Range(pos, pos);
          }
          if (unit == "word") {
            return cm.findWordAt(pos);
          }
          if (unit == "line") {
            return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
          }
          var result = unit(cm, pos);
          return new Range(result.from, result.to);
        }
        function leftButtonSelect(cm, event, start4, behavior) {
          if (ie) {
            delayBlurEvent(cm);
          }
          var display = cm.display, doc = cm.doc;
          e_preventDefault(event);
          var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
          if (behavior.addNew && !behavior.extend) {
            ourIndex = doc.sel.contains(start4);
            if (ourIndex > -1) {
              ourRange = ranges[ourIndex];
            } else {
              ourRange = new Range(start4, start4);
            }
          } else {
            ourRange = doc.sel.primary();
            ourIndex = doc.sel.primIndex;
          }
          if (behavior.unit == "rectangle") {
            if (!behavior.addNew) {
              ourRange = new Range(start4, start4);
            }
            start4 = posFromMouse(cm, event, true, true);
            ourIndex = -1;
          } else {
            var range2 = rangeForUnit(cm, start4, behavior.unit);
            if (behavior.extend) {
              ourRange = extendRange(ourRange, range2.anchor, range2.head, behavior.extend);
            } else {
              ourRange = range2;
            }
          }
          if (!behavior.addNew) {
            ourIndex = 0;
            setSelection(doc, new Selection([ourRange], 0), sel_mouse);
            startSel = doc.sel;
          } else if (ourIndex == -1) {
            ourIndex = ranges.length;
            setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex), { scroll: false, origin: "*mouse" });
          } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
            setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), { scroll: false, origin: "*mouse" });
            startSel = doc.sel;
          } else {
            replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
          }
          var lastPos = start4;
          function extendTo(pos) {
            if (cmp(lastPos, pos) == 0) {
              return;
            }
            lastPos = pos;
            if (behavior.unit == "rectangle") {
              var ranges2 = [], tabSize = cm.options.tabSize;
              var startCol = countColumn(getLine(doc, start4.line).text, start4.ch, tabSize);
              var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
              var left2 = Math.min(startCol, posCol), right2 = Math.max(startCol, posCol);
              for (var line = Math.min(start4.line, pos.line), end2 = Math.min(cm.lastLine(), Math.max(start4.line, pos.line)); line <= end2; line++) {
                var text = getLine(doc, line).text, leftPos = findColumn(text, left2, tabSize);
                if (left2 == right2) {
                  ranges2.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
                } else if (text.length > leftPos) {
                  ranges2.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right2, tabSize))));
                }
              }
              if (!ranges2.length) {
                ranges2.push(new Range(start4, start4));
              }
              setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges2), ourIndex), { origin: "*mouse", scroll: false });
              cm.scrollIntoView(pos);
            } else {
              var oldRange = ourRange;
              var range3 = rangeForUnit(cm, pos, behavior.unit);
              var anchor = oldRange.anchor, head;
              if (cmp(range3.anchor, anchor) > 0) {
                head = range3.head;
                anchor = minPos(oldRange.from(), range3.anchor);
              } else {
                head = range3.anchor;
                anchor = maxPos(oldRange.to(), range3.head);
              }
              var ranges$1 = startSel.ranges.slice(0);
              ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
              setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
            }
          }
          var editorSize = display.wrapper.getBoundingClientRect();
          var counter = 0;
          function extend3(e2) {
            var curCount = ++counter;
            var cur = posFromMouse(cm, e2, true, behavior.unit == "rectangle");
            if (!cur) {
              return;
            }
            if (cmp(cur, lastPos) != 0) {
              cm.curOp.focus = activeElt();
              extendTo(cur);
              var visible = visibleLines(display, doc);
              if (cur.line >= visible.to || cur.line < visible.from) {
                setTimeout(operation(cm, function() {
                  if (counter == curCount) {
                    extend3(e2);
                  }
                }), 150);
              }
            } else {
              var outside = e2.clientY < editorSize.top ? -20 : e2.clientY > editorSize.bottom ? 20 : 0;
              if (outside) {
                setTimeout(operation(cm, function() {
                  if (counter != curCount) {
                    return;
                  }
                  display.scroller.scrollTop += outside;
                  extend3(e2);
                }), 50);
              }
            }
          }
          function done(e2) {
            cm.state.selectingText = false;
            counter = Infinity;
            if (e2) {
              e_preventDefault(e2);
              display.input.focus();
            }
            off(display.wrapper.ownerDocument, "mousemove", move);
            off(display.wrapper.ownerDocument, "mouseup", up);
            doc.history.lastSelOrigin = null;
          }
          var move = operation(cm, function(e2) {
            if (e2.buttons === 0 || !e_button(e2)) {
              done(e2);
            } else {
              extend3(e2);
            }
          });
          var up = operation(cm, done);
          cm.state.selectingText = up;
          on(display.wrapper.ownerDocument, "mousemove", move);
          on(display.wrapper.ownerDocument, "mouseup", up);
        }
        function bidiSimplify(cm, range2) {
          var anchor = range2.anchor;
          var head = range2.head;
          var anchorLine = getLine(cm.doc, anchor.line);
          if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
            return range2;
          }
          var order2 = getOrder(anchorLine);
          if (!order2) {
            return range2;
          }
          var index = getBidiPartAt(order2, anchor.ch, anchor.sticky), part = order2[index];
          if (part.from != anchor.ch && part.to != anchor.ch) {
            return range2;
          }
          var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);
          if (boundary == 0 || boundary == order2.length) {
            return range2;
          }
          var leftSide;
          if (head.line != anchor.line) {
            leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
          } else {
            var headIndex = getBidiPartAt(order2, head.ch, head.sticky);
            var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
            if (headIndex == boundary - 1 || headIndex == boundary) {
              leftSide = dir < 0;
            } else {
              leftSide = dir > 0;
            }
          }
          var usePart = order2[boundary + (leftSide ? -1 : 0)];
          var from = leftSide == (usePart.level == 1);
          var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
          return anchor.ch == ch && anchor.sticky == sticky ? range2 : new Range(new Pos(anchor.line, ch, sticky), head);
        }
        function gutterEvent(cm, e2, type, prevent) {
          var mX, mY;
          if (e2.touches) {
            mX = e2.touches[0].clientX;
            mY = e2.touches[0].clientY;
          } else {
            try {
              mX = e2.clientX;
              mY = e2.clientY;
            } catch (e$1) {
              return false;
            }
          }
          if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
            return false;
          }
          if (prevent) {
            e_preventDefault(e2);
          }
          var display = cm.display;
          var lineBox = display.lineDiv.getBoundingClientRect();
          if (mY > lineBox.bottom || !hasHandler(cm, type)) {
            return e_defaultPrevented(e2);
          }
          mY -= lineBox.top - display.viewOffset;
          for (var i3 = 0; i3 < cm.display.gutterSpecs.length; ++i3) {
            var g2 = display.gutters.childNodes[i3];
            if (g2 && g2.getBoundingClientRect().right >= mX) {
              var line = lineAtHeight(cm.doc, mY);
              var gutter = cm.display.gutterSpecs[i3];
              signal(cm, type, cm, line, gutter.className, e2);
              return e_defaultPrevented(e2);
            }
          }
        }
        function clickInGutter(cm, e2) {
          return gutterEvent(cm, e2, "gutterClick", true);
        }
        function onContextMenu(cm, e2) {
          if (eventInWidget(cm.display, e2) || contextMenuInGutter(cm, e2)) {
            return;
          }
          if (signalDOMEvent(cm, e2, "contextmenu")) {
            return;
          }
          if (!captureRightClick) {
            cm.display.input.onContextMenu(e2);
          }
        }
        function contextMenuInGutter(cm, e2) {
          if (!hasHandler(cm, "gutterContextMenu")) {
            return false;
          }
          return gutterEvent(cm, e2, "gutterContextMenu", false);
        }
        function themeChanged(cm) {
          cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
          clearCaches(cm);
        }
        var Init = { toString: function() {
          return "CodeMirror.Init";
        } };
        var defaults2 = {};
        var optionHandlers = {};
        function defineOptions(CodeMirror4) {
          var optionHandlers2 = CodeMirror4.optionHandlers;
          function option(name, deflt, handle, notOnInit) {
            CodeMirror4.defaults[name] = deflt;
            if (handle) {
              optionHandlers2[name] = notOnInit ? function(cm, val, old) {
                if (old != Init) {
                  handle(cm, val, old);
                }
              } : handle;
            }
          }
          CodeMirror4.defineOption = option;
          CodeMirror4.Init = Init;
          option("value", "", function(cm, val) {
            return cm.setValue(val);
          }, true);
          option("mode", null, function(cm, val) {
            cm.doc.modeOption = val;
            loadMode(cm);
          }, true);
          option("indentUnit", 2, loadMode, true);
          option("indentWithTabs", false);
          option("smartIndent", true);
          option("tabSize", 4, function(cm) {
            resetModeState(cm);
            clearCaches(cm);
            regChange(cm);
          }, true);
          option("lineSeparator", null, function(cm, val) {
            cm.doc.lineSep = val;
            if (!val) {
              return;
            }
            var newBreaks = [], lineNo2 = cm.doc.first;
            cm.doc.iter(function(line) {
              for (var pos = 0; ; ) {
                var found = line.text.indexOf(val, pos);
                if (found == -1) {
                  break;
                }
                pos = found + val.length;
                newBreaks.push(Pos(lineNo2, found));
              }
              lineNo2++;
            });
            for (var i3 = newBreaks.length - 1; i3 >= 0; i3--) {
              replaceRange(cm.doc, val, newBreaks[i3], Pos(newBreaks[i3].line, newBreaks[i3].ch + val.length));
            }
          });
          option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function(cm, val, old) {
            cm.state.specialChars = new RegExp(val.source + (val.test("	") ? "" : "|	"), "g");
            if (old != Init) {
              cm.refresh();
            }
          });
          option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
            return cm.refresh();
          }, true);
          option("electricChars", true);
          option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
            throw new Error("inputStyle can not (yet) be changed in a running editor");
          }, true);
          option("spellcheck", false, function(cm, val) {
            return cm.getInputField().spellcheck = val;
          }, true);
          option("autocorrect", false, function(cm, val) {
            return cm.getInputField().autocorrect = val;
          }, true);
          option("autocapitalize", false, function(cm, val) {
            return cm.getInputField().autocapitalize = val;
          }, true);
          option("rtlMoveVisually", !windows);
          option("wholeLineUpdateBefore", true);
          option("theme", "default", function(cm) {
            themeChanged(cm);
            updateGutters(cm);
          }, true);
          option("keyMap", "default", function(cm, val, old) {
            var next = getKeyMap(val);
            var prev = old != Init && getKeyMap(old);
            if (prev && prev.detach) {
              prev.detach(cm, next);
            }
            if (next.attach) {
              next.attach(cm, prev || null);
            }
          });
          option("extraKeys", null);
          option("configureMouse", null);
          option("lineWrapping", false, wrappingChanged, true);
          option("gutters", [], function(cm, val) {
            cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
            updateGutters(cm);
          }, true);
          option("fixedGutter", true, function(cm, val) {
            cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
            cm.refresh();
          }, true);
          option("coverGutterNextToScrollbar", false, function(cm) {
            return updateScrollbars(cm);
          }, true);
          option("scrollbarStyle", "native", function(cm) {
            initScrollbars(cm);
            updateScrollbars(cm);
            cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
            cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
          }, true);
          option("lineNumbers", false, function(cm, val) {
            cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
            updateGutters(cm);
          }, true);
          option("firstLineNumber", 1, updateGutters, true);
          option("lineNumberFormatter", function(integer) {
            return integer;
          }, updateGutters, true);
          option("showCursorWhenSelecting", false, updateSelection, true);
          option("resetSelectionOnContextMenu", true);
          option("lineWiseCopyCut", true);
          option("pasteLinesPerSelection", true);
          option("selectionsMayTouch", false);
          option("readOnly", false, function(cm, val) {
            if (val == "nocursor") {
              onBlur(cm);
              cm.display.input.blur();
            }
            cm.display.input.readOnlyChanged(val);
          });
          option("screenReaderLabel", null, function(cm, val) {
            val = val === "" ? null : val;
            cm.display.input.screenReaderLabelChanged(val);
          });
          option("disableInput", false, function(cm, val) {
            if (!val) {
              cm.display.input.reset();
            }
          }, true);
          option("dragDrop", true, dragDropChanged);
          option("allowDropFileTypes", null);
          option("cursorBlinkRate", 530);
          option("cursorScrollMargin", 0);
          option("cursorHeight", 1, updateSelection, true);
          option("singleCursorHeightPerLine", true, updateSelection, true);
          option("workTime", 100);
          option("workDelay", 100);
          option("flattenSpans", true, resetModeState, true);
          option("addModeClass", false, resetModeState, true);
          option("pollInterval", 100);
          option("undoDepth", 200, function(cm, val) {
            return cm.doc.history.undoDepth = val;
          });
          option("historyEventDelay", 1250);
          option("viewportMargin", 10, function(cm) {
            return cm.refresh();
          }, true);
          option("maxHighlightLength", 1e4, resetModeState, true);
          option("moveInputWithCursor", true, function(cm, val) {
            if (!val) {
              cm.display.input.resetPosition();
            }
          });
          option("tabindex", null, function(cm, val) {
            return cm.display.input.getField().tabIndex = val || "";
          });
          option("autofocus", null);
          option("direction", "ltr", function(cm, val) {
            return cm.doc.setDirection(val);
          }, true);
          option("phrases", null);
        }
        function dragDropChanged(cm, value, old) {
          var wasOn = old && old != Init;
          if (!value != !wasOn) {
            var funcs = cm.display.dragFunctions;
            var toggle = value ? on : off;
            toggle(cm.display.scroller, "dragstart", funcs.start);
            toggle(cm.display.scroller, "dragenter", funcs.enter);
            toggle(cm.display.scroller, "dragover", funcs.over);
            toggle(cm.display.scroller, "dragleave", funcs.leave);
            toggle(cm.display.scroller, "drop", funcs.drop);
          }
        }
        function wrappingChanged(cm) {
          if (cm.options.lineWrapping) {
            addClass(cm.display.wrapper, "CodeMirror-wrap");
            cm.display.sizer.style.minWidth = "";
            cm.display.sizerWidth = null;
          } else {
            rmClass(cm.display.wrapper, "CodeMirror-wrap");
            findMaxLine(cm);
          }
          estimateLineHeights(cm);
          regChange(cm);
          clearCaches(cm);
          setTimeout(function() {
            return updateScrollbars(cm);
          }, 100);
        }
        function CodeMirror3(place, options) {
          var this$1 = this;
          if (!(this instanceof CodeMirror3)) {
            return new CodeMirror3(place, options);
          }
          this.options = options = options ? copyObj(options) : {};
          copyObj(defaults2, options, false);
          var doc = options.value;
          if (typeof doc == "string") {
            doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction);
          } else if (options.mode) {
            doc.modeOption = options.mode;
          }
          this.doc = doc;
          var input = new CodeMirror3.inputStyles[options.inputStyle](this);
          var display = this.display = new Display(place, doc, input, options);
          display.wrapper.CodeMirror = this;
          themeChanged(this);
          if (options.lineWrapping) {
            this.display.wrapper.className += " CodeMirror-wrap";
          }
          initScrollbars(this);
          this.state = {
            keyMaps: [],
            overlays: [],
            modeGen: 0,
            overwrite: false,
            delayingBlurEvent: false,
            focused: false,
            suppressEdits: false,
            pasteIncoming: -1,
            cutIncoming: -1,
            selectingText: false,
            draggingText: false,
            highlight: new Delayed(),
            keySeq: null,
            specialChars: null
          };
          if (options.autofocus && !mobile) {
            display.input.focus();
          }
          if (ie && ie_version < 11) {
            setTimeout(function() {
              return this$1.display.input.reset(true);
            }, 20);
          }
          registerEventHandlers(this);
          ensureGlobalHandlers();
          startOperation(this);
          this.curOp.forceUpdate = true;
          attachDoc(this, doc);
          if (options.autofocus && !mobile || this.hasFocus()) {
            setTimeout(function() {
              if (this$1.hasFocus() && !this$1.state.focused) {
                onFocus(this$1);
              }
            }, 20);
          } else {
            onBlur(this);
          }
          for (var opt in optionHandlers) {
            if (optionHandlers.hasOwnProperty(opt)) {
              optionHandlers[opt](this, options[opt], Init);
            }
          }
          maybeUpdateLineNumberWidth(this);
          if (options.finishInit) {
            options.finishInit(this);
          }
          for (var i3 = 0; i3 < initHooks.length; ++i3) {
            initHooks[i3](this);
          }
          endOperation(this);
          if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
            display.lineDiv.style.textRendering = "auto";
          }
        }
        CodeMirror3.defaults = defaults2;
        CodeMirror3.optionHandlers = optionHandlers;
        function registerEventHandlers(cm) {
          var d2 = cm.display;
          on(d2.scroller, "mousedown", operation(cm, onMouseDown));
          if (ie && ie_version < 11) {
            on(d2.scroller, "dblclick", operation(cm, function(e2) {
              if (signalDOMEvent(cm, e2)) {
                return;
              }
              var pos = posFromMouse(cm, e2);
              if (!pos || clickInGutter(cm, e2) || eventInWidget(cm.display, e2)) {
                return;
              }
              e_preventDefault(e2);
              var word = cm.findWordAt(pos);
              extendSelection(cm.doc, word.anchor, word.head);
            }));
          } else {
            on(d2.scroller, "dblclick", function(e2) {
              return signalDOMEvent(cm, e2) || e_preventDefault(e2);
            });
          }
          on(d2.scroller, "contextmenu", function(e2) {
            return onContextMenu(cm, e2);
          });
          on(d2.input.getField(), "contextmenu", function(e2) {
            if (!d2.scroller.contains(e2.target)) {
              onContextMenu(cm, e2);
            }
          });
          var touchFinished, prevTouch = { end: 0 };
          function finishTouch() {
            if (d2.activeTouch) {
              touchFinished = setTimeout(function() {
                return d2.activeTouch = null;
              }, 1e3);
              prevTouch = d2.activeTouch;
              prevTouch.end = +new Date();
            }
          }
          function isMouseLikeTouchEvent(e2) {
            if (e2.touches.length != 1) {
              return false;
            }
            var touch = e2.touches[0];
            return touch.radiusX <= 1 && touch.radiusY <= 1;
          }
          function farAway(touch, other) {
            if (other.left == null) {
              return true;
            }
            var dx = other.left - touch.left, dy = other.top - touch.top;
            return dx * dx + dy * dy > 20 * 20;
          }
          on(d2.scroller, "touchstart", function(e2) {
            if (!signalDOMEvent(cm, e2) && !isMouseLikeTouchEvent(e2) && !clickInGutter(cm, e2)) {
              d2.input.ensurePolled();
              clearTimeout(touchFinished);
              var now2 = +new Date();
              d2.activeTouch = {
                start: now2,
                moved: false,
                prev: now2 - prevTouch.end <= 300 ? prevTouch : null
              };
              if (e2.touches.length == 1) {
                d2.activeTouch.left = e2.touches[0].pageX;
                d2.activeTouch.top = e2.touches[0].pageY;
              }
            }
          });
          on(d2.scroller, "touchmove", function() {
            if (d2.activeTouch) {
              d2.activeTouch.moved = true;
            }
          });
          on(d2.scroller, "touchend", function(e2) {
            var touch = d2.activeTouch;
            if (touch && !eventInWidget(d2, e2) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {
              var pos = cm.coordsChar(d2.activeTouch, "page"), range2;
              if (!touch.prev || farAway(touch, touch.prev)) {
                range2 = new Range(pos, pos);
              } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) {
                range2 = cm.findWordAt(pos);
              } else {
                range2 = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
              }
              cm.setSelection(range2.anchor, range2.head);
              cm.focus();
              e_preventDefault(e2);
            }
            finishTouch();
          });
          on(d2.scroller, "touchcancel", finishTouch);
          on(d2.scroller, "scroll", function() {
            if (d2.scroller.clientHeight) {
              updateScrollTop(cm, d2.scroller.scrollTop);
              setScrollLeft(cm, d2.scroller.scrollLeft, true);
              signal(cm, "scroll", cm);
            }
          });
          on(d2.scroller, "mousewheel", function(e2) {
            return onScrollWheel(cm, e2);
          });
          on(d2.scroller, "DOMMouseScroll", function(e2) {
            return onScrollWheel(cm, e2);
          });
          on(d2.wrapper, "scroll", function() {
            return d2.wrapper.scrollTop = d2.wrapper.scrollLeft = 0;
          });
          d2.dragFunctions = {
            enter: function(e2) {
              if (!signalDOMEvent(cm, e2)) {
                e_stop(e2);
              }
            },
            over: function(e2) {
              if (!signalDOMEvent(cm, e2)) {
                onDragOver(cm, e2);
                e_stop(e2);
              }
            },
            start: function(e2) {
              return onDragStart(cm, e2);
            },
            drop: operation(cm, onDrop),
            leave: function(e2) {
              if (!signalDOMEvent(cm, e2)) {
                clearDragCursor(cm);
              }
            }
          };
          var inp = d2.input.getField();
          on(inp, "keyup", function(e2) {
            return onKeyUp.call(cm, e2);
          });
          on(inp, "keydown", operation(cm, onKeyDown2));
          on(inp, "keypress", operation(cm, onKeyPress));
          on(inp, "focus", function(e2) {
            return onFocus(cm, e2);
          });
          on(inp, "blur", function(e2) {
            return onBlur(cm, e2);
          });
        }
        var initHooks = [];
        CodeMirror3.defineInitHook = function(f2) {
          return initHooks.push(f2);
        };
        function indentLine(cm, n2, how, aggressive) {
          var doc = cm.doc, state;
          if (how == null) {
            how = "add";
          }
          if (how == "smart") {
            if (!doc.mode.indent) {
              how = "prev";
            } else {
              state = getContextBefore(cm, n2).state;
            }
          }
          var tabSize = cm.options.tabSize;
          var line = getLine(doc, n2), curSpace = countColumn(line.text, null, tabSize);
          if (line.stateAfter) {
            line.stateAfter = null;
          }
          var curSpaceString = line.text.match(/^\s*/)[0], indentation;
          if (!aggressive && !/\S/.test(line.text)) {
            indentation = 0;
            how = "not";
          } else if (how == "smart") {
            indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
            if (indentation == Pass || indentation > 150) {
              if (!aggressive) {
                return;
              }
              how = "prev";
            }
          }
          if (how == "prev") {
            if (n2 > doc.first) {
              indentation = countColumn(getLine(doc, n2 - 1).text, null, tabSize);
            } else {
              indentation = 0;
            }
          } else if (how == "add") {
            indentation = curSpace + cm.options.indentUnit;
          } else if (how == "subtract") {
            indentation = curSpace - cm.options.indentUnit;
          } else if (typeof how == "number") {
            indentation = curSpace + how;
          }
          indentation = Math.max(0, indentation);
          var indentString = "", pos = 0;
          if (cm.options.indentWithTabs) {
            for (var i3 = Math.floor(indentation / tabSize); i3; --i3) {
              pos += tabSize;
              indentString += "	";
            }
          }
          if (pos < indentation) {
            indentString += spaceStr(indentation - pos);
          }
          if (indentString != curSpaceString) {
            replaceRange(doc, indentString, Pos(n2, 0), Pos(n2, curSpaceString.length), "+input");
            line.stateAfter = null;
            return true;
          } else {
            for (var i$12 = 0; i$12 < doc.sel.ranges.length; i$12++) {
              var range2 = doc.sel.ranges[i$12];
              if (range2.head.line == n2 && range2.head.ch < curSpaceString.length) {
                var pos$1 = Pos(n2, curSpaceString.length);
                replaceOneSelection(doc, i$12, new Range(pos$1, pos$1));
                break;
              }
            }
          }
        }
        var lastCopied = null;
        function setLastCopied(newLastCopied) {
          lastCopied = newLastCopied;
        }
        function applyTextInput(cm, inserted, deleted, sel, origin) {
          var doc = cm.doc;
          cm.display.shift = false;
          if (!sel) {
            sel = doc.sel;
          }
          var recent = +new Date() - 200;
          var paste = origin == "paste" || cm.state.pasteIncoming > recent;
          var textLines = splitLinesAuto(inserted), multiPaste = null;
          if (paste && sel.ranges.length > 1) {
            if (lastCopied && lastCopied.text.join("\n") == inserted) {
              if (sel.ranges.length % lastCopied.text.length == 0) {
                multiPaste = [];
                for (var i3 = 0; i3 < lastCopied.text.length; i3++) {
                  multiPaste.push(doc.splitLines(lastCopied.text[i3]));
                }
              }
            } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
              multiPaste = map(textLines, function(l2) {
                return [l2];
              });
            }
          }
          var updateInput = cm.curOp.updateInput;
          for (var i$12 = sel.ranges.length - 1; i$12 >= 0; i$12--) {
            var range2 = sel.ranges[i$12];
            var from = range2.from(), to = range2.to();
            if (range2.empty()) {
              if (deleted && deleted > 0) {
                from = Pos(from.line, from.ch - deleted);
              } else if (cm.state.overwrite && !paste) {
                to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
              } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n")) {
                from = to = Pos(from.line, 0);
              }
            }
            var changeEvent = {
              from,
              to,
              text: multiPaste ? multiPaste[i$12 % multiPaste.length] : textLines,
              origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")
            };
            makeChange(cm.doc, changeEvent);
            signalLater(cm, "inputRead", cm, changeEvent);
          }
          if (inserted && !paste) {
            triggerElectric(cm, inserted);
          }
          ensureCursorVisible(cm);
          if (cm.curOp.updateInput < 2) {
            cm.curOp.updateInput = updateInput;
          }
          cm.curOp.typing = true;
          cm.state.pasteIncoming = cm.state.cutIncoming = -1;
        }
        function handlePaste(e2, cm) {
          var pasted = e2.clipboardData && e2.clipboardData.getData("Text");
          if (pasted) {
            e2.preventDefault();
            if (!cm.isReadOnly() && !cm.options.disableInput) {
              runInOp(cm, function() {
                return applyTextInput(cm, pasted, 0, null, "paste");
              });
            }
            return true;
          }
        }
        function triggerElectric(cm, inserted) {
          if (!cm.options.electricChars || !cm.options.smartIndent) {
            return;
          }
          var sel = cm.doc.sel;
          for (var i3 = sel.ranges.length - 1; i3 >= 0; i3--) {
            var range2 = sel.ranges[i3];
            if (range2.head.ch > 100 || i3 && sel.ranges[i3 - 1].head.line == range2.head.line) {
              continue;
            }
            var mode = cm.getModeAt(range2.head);
            var indented = false;
            if (mode.electricChars) {
              for (var j2 = 0; j2 < mode.electricChars.length; j2++) {
                if (inserted.indexOf(mode.electricChars.charAt(j2)) > -1) {
                  indented = indentLine(cm, range2.head.line, "smart");
                  break;
                }
              }
            } else if (mode.electricInput) {
              if (mode.electricInput.test(getLine(cm.doc, range2.head.line).text.slice(0, range2.head.ch))) {
                indented = indentLine(cm, range2.head.line, "smart");
              }
            }
            if (indented) {
              signalLater(cm, "electricInput", cm, range2.head.line);
            }
          }
        }
        function copyableRanges(cm) {
          var text = [], ranges = [];
          for (var i3 = 0; i3 < cm.doc.sel.ranges.length; i3++) {
            var line = cm.doc.sel.ranges[i3].head.line;
            var lineRange = { anchor: Pos(line, 0), head: Pos(line + 1, 0) };
            ranges.push(lineRange);
            text.push(cm.getRange(lineRange.anchor, lineRange.head));
          }
          return { text, ranges };
        }
        function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
          field.setAttribute("autocorrect", autocorrect ? "" : "off");
          field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
          field.setAttribute("spellcheck", !!spellcheck);
        }
        function hiddenTextarea() {
          var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
          var div2 = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
          if (webkit) {
            te.style.width = "1000px";
          } else {
            te.setAttribute("wrap", "off");
          }
          if (ios) {
            te.style.border = "1px solid black";
          }
          disableBrowserMagic(te);
          return div2;
        }
        function addEditorMethods(CodeMirror4) {
          var optionHandlers2 = CodeMirror4.optionHandlers;
          var helpers = CodeMirror4.helpers = {};
          CodeMirror4.prototype = {
            constructor: CodeMirror4,
            focus: function() {
              window.focus();
              this.display.input.focus();
            },
            setOption: function(option, value) {
              var options = this.options, old = options[option];
              if (options[option] == value && option != "mode") {
                return;
              }
              options[option] = value;
              if (optionHandlers2.hasOwnProperty(option)) {
                operation(this, optionHandlers2[option])(this, value, old);
              }
              signal(this, "optionChange", this, option);
            },
            getOption: function(option) {
              return this.options[option];
            },
            getDoc: function() {
              return this.doc;
            },
            addKeyMap: function(map2, bottom2) {
              this.state.keyMaps[bottom2 ? "push" : "unshift"](getKeyMap(map2));
            },
            removeKeyMap: function(map2) {
              var maps = this.state.keyMaps;
              for (var i3 = 0; i3 < maps.length; ++i3) {
                if (maps[i3] == map2 || maps[i3].name == map2) {
                  maps.splice(i3, 1);
                  return true;
                }
              }
            },
            addOverlay: methodOp(function(spec, options) {
              var mode = spec.token ? spec : CodeMirror4.getMode(this.options, spec);
              if (mode.startState) {
                throw new Error("Overlays may not be stateful.");
              }
              insertSorted(this.state.overlays, {
                mode,
                modeSpec: spec,
                opaque: options && options.opaque,
                priority: options && options.priority || 0
              }, function(overlay) {
                return overlay.priority;
              });
              this.state.modeGen++;
              regChange(this);
            }),
            removeOverlay: methodOp(function(spec) {
              var overlays = this.state.overlays;
              for (var i3 = 0; i3 < overlays.length; ++i3) {
                var cur = overlays[i3].modeSpec;
                if (cur == spec || typeof spec == "string" && cur.name == spec) {
                  overlays.splice(i3, 1);
                  this.state.modeGen++;
                  regChange(this);
                  return;
                }
              }
            }),
            indentLine: methodOp(function(n2, dir, aggressive) {
              if (typeof dir != "string" && typeof dir != "number") {
                if (dir == null) {
                  dir = this.options.smartIndent ? "smart" : "prev";
                } else {
                  dir = dir ? "add" : "subtract";
                }
              }
              if (isLine(this.doc, n2)) {
                indentLine(this, n2, dir, aggressive);
              }
            }),
            indentSelection: methodOp(function(how) {
              var ranges = this.doc.sel.ranges, end2 = -1;
              for (var i3 = 0; i3 < ranges.length; i3++) {
                var range2 = ranges[i3];
                if (!range2.empty()) {
                  var from = range2.from(), to = range2.to();
                  var start4 = Math.max(end2, from.line);
                  end2 = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
                  for (var j2 = start4; j2 < end2; ++j2) {
                    indentLine(this, j2, how);
                  }
                  var newRanges = this.doc.sel.ranges;
                  if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i3].from().ch > 0) {
                    replaceOneSelection(this.doc, i3, new Range(from, newRanges[i3].to()), sel_dontScroll);
                  }
                } else if (range2.head.line > end2) {
                  indentLine(this, range2.head.line, how, true);
                  end2 = range2.head.line;
                  if (i3 == this.doc.sel.primIndex) {
                    ensureCursorVisible(this);
                  }
                }
              }
            }),
            getTokenAt: function(pos, precise) {
              return takeToken(this, pos, precise);
            },
            getLineTokens: function(line, precise) {
              return takeToken(this, Pos(line), precise, true);
            },
            getTokenTypeAt: function(pos) {
              pos = clipPos(this.doc, pos);
              var styles = getLineStyles(this, getLine(this.doc, pos.line));
              var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
              var type;
              if (ch == 0) {
                type = styles[2];
              } else {
                for (; ; ) {
                  var mid = before + after >> 1;
                  if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {
                    after = mid;
                  } else if (styles[mid * 2 + 1] < ch) {
                    before = mid + 1;
                  } else {
                    type = styles[mid * 2 + 2];
                    break;
                  }
                }
              }
              var cut = type ? type.indexOf("overlay ") : -1;
              return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
            },
            getModeAt: function(pos) {
              var mode = this.doc.mode;
              if (!mode.innerMode) {
                return mode;
              }
              return CodeMirror4.innerMode(mode, this.getTokenAt(pos).state).mode;
            },
            getHelper: function(pos, type) {
              return this.getHelpers(pos, type)[0];
            },
            getHelpers: function(pos, type) {
              var found = [];
              if (!helpers.hasOwnProperty(type)) {
                return found;
              }
              var help = helpers[type], mode = this.getModeAt(pos);
              if (typeof mode[type] == "string") {
                if (help[mode[type]]) {
                  found.push(help[mode[type]]);
                }
              } else if (mode[type]) {
                for (var i3 = 0; i3 < mode[type].length; i3++) {
                  var val = help[mode[type][i3]];
                  if (val) {
                    found.push(val);
                  }
                }
              } else if (mode.helperType && help[mode.helperType]) {
                found.push(help[mode.helperType]);
              } else if (help[mode.name]) {
                found.push(help[mode.name]);
              }
              for (var i$12 = 0; i$12 < help._global.length; i$12++) {
                var cur = help._global[i$12];
                if (cur.pred(mode, this) && indexOf2(found, cur.val) == -1) {
                  found.push(cur.val);
                }
              }
              return found;
            },
            getStateAfter: function(line, precise) {
              var doc = this.doc;
              line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
              return getContextBefore(this, line + 1, precise).state;
            },
            cursorCoords: function(start4, mode) {
              var pos, range2 = this.doc.sel.primary();
              if (start4 == null) {
                pos = range2.head;
              } else if (typeof start4 == "object") {
                pos = clipPos(this.doc, start4);
              } else {
                pos = start4 ? range2.from() : range2.to();
              }
              return cursorCoords(this, pos, mode || "page");
            },
            charCoords: function(pos, mode) {
              return charCoords(this, clipPos(this.doc, pos), mode || "page");
            },
            coordsChar: function(coords, mode) {
              coords = fromCoordSystem(this, coords, mode || "page");
              return coordsChar(this, coords.left, coords.top);
            },
            lineAtHeight: function(height, mode) {
              height = fromCoordSystem(this, { top: height, left: 0 }, mode || "page").top;
              return lineAtHeight(this.doc, height + this.display.viewOffset);
            },
            heightAtLine: function(line, mode, includeWidgets) {
              var end2 = false, lineObj;
              if (typeof line == "number") {
                var last = this.doc.first + this.doc.size - 1;
                if (line < this.doc.first) {
                  line = this.doc.first;
                } else if (line > last) {
                  line = last;
                  end2 = true;
                }
                lineObj = getLine(this.doc, line);
              } else {
                lineObj = line;
              }
              return intoCoordSystem(this, lineObj, { top: 0, left: 0 }, mode || "page", includeWidgets || end2).top + (end2 ? this.doc.height - heightAtLine(lineObj) : 0);
            },
            defaultTextHeight: function() {
              return textHeight(this.display);
            },
            defaultCharWidth: function() {
              return charWidth(this.display);
            },
            getViewport: function() {
              return { from: this.display.viewFrom, to: this.display.viewTo };
            },
            addWidget: function(pos, node, scroll, vert, horiz) {
              var display = this.display;
              pos = cursorCoords(this, clipPos(this.doc, pos));
              var top2 = pos.bottom, left2 = pos.left;
              node.style.position = "absolute";
              node.setAttribute("cm-ignore-events", "true");
              this.display.input.setUneditable(node);
              display.sizer.appendChild(node);
              if (vert == "over") {
                top2 = pos.top;
              } else if (vert == "above" || vert == "near") {
                var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
                if ((vert == "above" || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
                  top2 = pos.top - node.offsetHeight;
                } else if (pos.bottom + node.offsetHeight <= vspace) {
                  top2 = pos.bottom;
                }
                if (left2 + node.offsetWidth > hspace) {
                  left2 = hspace - node.offsetWidth;
                }
              }
              node.style.top = top2 + "px";
              node.style.left = node.style.right = "";
              if (horiz == "right") {
                left2 = display.sizer.clientWidth - node.offsetWidth;
                node.style.right = "0px";
              } else {
                if (horiz == "left") {
                  left2 = 0;
                } else if (horiz == "middle") {
                  left2 = (display.sizer.clientWidth - node.offsetWidth) / 2;
                }
                node.style.left = left2 + "px";
              }
              if (scroll) {
                scrollIntoView(this, { left: left2, top: top2, right: left2 + node.offsetWidth, bottom: top2 + node.offsetHeight });
              }
            },
            triggerOnKeyDown: methodOp(onKeyDown2),
            triggerOnKeyPress: methodOp(onKeyPress),
            triggerOnKeyUp: onKeyUp,
            triggerOnMouseDown: methodOp(onMouseDown),
            execCommand: function(cmd) {
              if (commands.hasOwnProperty(cmd)) {
                return commands[cmd].call(null, this);
              }
            },
            triggerElectric: methodOp(function(text) {
              triggerElectric(this, text);
            }),
            findPosH: function(from, amount, unit, visually) {
              var dir = 1;
              if (amount < 0) {
                dir = -1;
                amount = -amount;
              }
              var cur = clipPos(this.doc, from);
              for (var i3 = 0; i3 < amount; ++i3) {
                cur = findPosH(this.doc, cur, dir, unit, visually);
                if (cur.hitSide) {
                  break;
                }
              }
              return cur;
            },
            moveH: methodOp(function(dir, unit) {
              var this$1 = this;
              this.extendSelectionsBy(function(range2) {
                if (this$1.display.shift || this$1.doc.extend || range2.empty()) {
                  return findPosH(this$1.doc, range2.head, dir, unit, this$1.options.rtlMoveVisually);
                } else {
                  return dir < 0 ? range2.from() : range2.to();
                }
              }, sel_move);
            }),
            deleteH: methodOp(function(dir, unit) {
              var sel = this.doc.sel, doc = this.doc;
              if (sel.somethingSelected()) {
                doc.replaceSelection("", null, "+delete");
              } else {
                deleteNearSelection(this, function(range2) {
                  var other = findPosH(doc, range2.head, dir, unit, false);
                  return dir < 0 ? { from: other, to: range2.head } : { from: range2.head, to: other };
                });
              }
            }),
            findPosV: function(from, amount, unit, goalColumn) {
              var dir = 1, x2 = goalColumn;
              if (amount < 0) {
                dir = -1;
                amount = -amount;
              }
              var cur = clipPos(this.doc, from);
              for (var i3 = 0; i3 < amount; ++i3) {
                var coords = cursorCoords(this, cur, "div");
                if (x2 == null) {
                  x2 = coords.left;
                } else {
                  coords.left = x2;
                }
                cur = findPosV(this, coords, dir, unit);
                if (cur.hitSide) {
                  break;
                }
              }
              return cur;
            },
            moveV: methodOp(function(dir, unit) {
              var this$1 = this;
              var doc = this.doc, goals = [];
              var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
              doc.extendSelectionsBy(function(range2) {
                if (collapse) {
                  return dir < 0 ? range2.from() : range2.to();
                }
                var headPos = cursorCoords(this$1, range2.head, "div");
                if (range2.goalColumn != null) {
                  headPos.left = range2.goalColumn;
                }
                goals.push(headPos.left);
                var pos = findPosV(this$1, headPos, dir, unit);
                if (unit == "page" && range2 == doc.sel.primary()) {
                  addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top);
                }
                return pos;
              }, sel_move);
              if (goals.length) {
                for (var i3 = 0; i3 < doc.sel.ranges.length; i3++) {
                  doc.sel.ranges[i3].goalColumn = goals[i3];
                }
              }
            }),
            findWordAt: function(pos) {
              var doc = this.doc, line = getLine(doc, pos.line).text;
              var start4 = pos.ch, end2 = pos.ch;
              if (line) {
                var helper = this.getHelper(pos, "wordChars");
                if ((pos.sticky == "before" || end2 == line.length) && start4) {
                  --start4;
                } else {
                  ++end2;
                }
                var startChar = line.charAt(start4);
                var check = isWordChar(startChar, helper) ? function(ch) {
                  return isWordChar(ch, helper);
                } : /\s/.test(startChar) ? function(ch) {
                  return /\s/.test(ch);
                } : function(ch) {
                  return !/\s/.test(ch) && !isWordChar(ch);
                };
                while (start4 > 0 && check(line.charAt(start4 - 1))) {
                  --start4;
                }
                while (end2 < line.length && check(line.charAt(end2))) {
                  ++end2;
                }
              }
              return new Range(Pos(pos.line, start4), Pos(pos.line, end2));
            },
            toggleOverwrite: function(value) {
              if (value != null && value == this.state.overwrite) {
                return;
              }
              if (this.state.overwrite = !this.state.overwrite) {
                addClass(this.display.cursorDiv, "CodeMirror-overwrite");
              } else {
                rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
              }
              signal(this, "overwriteToggle", this, this.state.overwrite);
            },
            hasFocus: function() {
              return this.display.input.getField() == activeElt();
            },
            isReadOnly: function() {
              return !!(this.options.readOnly || this.doc.cantEdit);
            },
            scrollTo: methodOp(function(x2, y2) {
              scrollToCoords(this, x2, y2);
            }),
            getScrollInfo: function() {
              var scroller = this.display.scroller;
              return {
                left: scroller.scrollLeft,
                top: scroller.scrollTop,
                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                clientHeight: displayHeight(this),
                clientWidth: displayWidth(this)
              };
            },
            scrollIntoView: methodOp(function(range2, margin) {
              if (range2 == null) {
                range2 = { from: this.doc.sel.primary().head, to: null };
                if (margin == null) {
                  margin = this.options.cursorScrollMargin;
                }
              } else if (typeof range2 == "number") {
                range2 = { from: Pos(range2, 0), to: null };
              } else if (range2.from == null) {
                range2 = { from: range2, to: null };
              }
              if (!range2.to) {
                range2.to = range2.from;
              }
              range2.margin = margin || 0;
              if (range2.from.line != null) {
                scrollToRange(this, range2);
              } else {
                scrollToCoordsRange(this, range2.from, range2.to, range2.margin);
              }
            }),
            setSize: methodOp(function(width, height) {
              var this$1 = this;
              var interpret = function(val) {
                return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
              };
              if (width != null) {
                this.display.wrapper.style.width = interpret(width);
              }
              if (height != null) {
                this.display.wrapper.style.height = interpret(height);
              }
              if (this.options.lineWrapping) {
                clearLineMeasurementCache(this);
              }
              var lineNo2 = this.display.viewFrom;
              this.doc.iter(lineNo2, this.display.viewTo, function(line) {
                if (line.widgets) {
                  for (var i3 = 0; i3 < line.widgets.length; i3++) {
                    if (line.widgets[i3].noHScroll) {
                      regLineChange(this$1, lineNo2, "widget");
                      break;
                    }
                  }
                }
                ++lineNo2;
              });
              this.curOp.forceUpdate = true;
              signal(this, "refresh", this);
            }),
            operation: function(f2) {
              return runInOp(this, f2);
            },
            startOperation: function() {
              return startOperation(this);
            },
            endOperation: function() {
              return endOperation(this);
            },
            refresh: methodOp(function() {
              var oldHeight = this.display.cachedTextHeight;
              regChange(this);
              this.curOp.forceUpdate = true;
              clearCaches(this);
              scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
              updateGutterSpace(this.display);
              if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > 0.5 || this.options.lineWrapping) {
                estimateLineHeights(this);
              }
              signal(this, "refresh", this);
            }),
            swapDoc: methodOp(function(doc) {
              var old = this.doc;
              old.cm = null;
              if (this.state.selectingText) {
                this.state.selectingText();
              }
              attachDoc(this, doc);
              clearCaches(this);
              this.display.input.reset();
              scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
              this.curOp.forceScroll = true;
              signalLater(this, "swapDoc", this, old);
              return old;
            }),
            phrase: function(phraseText) {
              var phrases = this.options.phrases;
              return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
            },
            getInputField: function() {
              return this.display.input.getField();
            },
            getWrapperElement: function() {
              return this.display.wrapper;
            },
            getScrollerElement: function() {
              return this.display.scroller;
            },
            getGutterElement: function() {
              return this.display.gutters;
            }
          };
          eventMixin(CodeMirror4);
          CodeMirror4.registerHelper = function(type, name, value) {
            if (!helpers.hasOwnProperty(type)) {
              helpers[type] = CodeMirror4[type] = { _global: [] };
            }
            helpers[type][name] = value;
          };
          CodeMirror4.registerGlobalHelper = function(type, name, predicate, value) {
            CodeMirror4.registerHelper(type, name, value);
            helpers[type]._global.push({ pred: predicate, val: value });
          };
        }
        function findPosH(doc, pos, dir, unit, visually) {
          var oldPos = pos;
          var origDir = dir;
          var lineObj = getLine(doc, pos.line);
          var lineDir = visually && doc.direction == "rtl" ? -dir : dir;
          function findNextLine() {
            var l2 = pos.line + lineDir;
            if (l2 < doc.first || l2 >= doc.first + doc.size) {
              return false;
            }
            pos = new Pos(l2, pos.ch, pos.sticky);
            return lineObj = getLine(doc, l2);
          }
          function moveOnce(boundToLine) {
            var next;
            if (unit == "codepoint") {
              var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));
              if (isNaN(ch)) {
                next = null;
              } else {
                var astral = dir > 0 ? ch >= 55296 && ch < 56320 : ch >= 56320 && ch < 57343;
                next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
              }
            } else if (visually) {
              next = moveVisually(doc.cm, lineObj, pos, dir);
            } else {
              next = moveLogically(lineObj, pos, dir);
            }
            if (next == null) {
              if (!boundToLine && findNextLine()) {
                pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir);
              } else {
                return false;
              }
            } else {
              pos = next;
            }
            return true;
          }
          if (unit == "char" || unit == "codepoint") {
            moveOnce();
          } else if (unit == "column") {
            moveOnce(true);
          } else if (unit == "word" || unit == "group") {
            var sawType = null, group = unit == "group";
            var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
            for (var first = true; ; first = false) {
              if (dir < 0 && !moveOnce(!first)) {
                break;
              }
              var cur = lineObj.text.charAt(pos.ch) || "\n";
              var type = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";
              if (group && !first && !type) {
                type = "s";
              }
              if (sawType && sawType != type) {
                if (dir < 0) {
                  dir = 1;
                  moveOnce();
                  pos.sticky = "after";
                }
                break;
              }
              if (type) {
                sawType = type;
              }
              if (dir > 0 && !moveOnce(!first)) {
                break;
              }
            }
          }
          var result = skipAtomic(doc, pos, oldPos, origDir, true);
          if (equalCursorPos(oldPos, result)) {
            result.hitSide = true;
          }
          return result;
        }
        function findPosV(cm, pos, dir, unit) {
          var doc = cm.doc, x2 = pos.left, y2;
          if (unit == "page") {
            var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
            var moveAmount = Math.max(pageSize - 0.5 * textHeight(cm.display), 3);
            y2 = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
          } else if (unit == "line") {
            y2 = dir > 0 ? pos.bottom + 3 : pos.top - 3;
          }
          var target;
          for (; ; ) {
            target = coordsChar(cm, x2, y2);
            if (!target.outside) {
              break;
            }
            if (dir < 0 ? y2 <= 0 : y2 >= doc.height) {
              target.hitSide = true;
              break;
            }
            y2 += dir * 5;
          }
          return target;
        }
        var ContentEditableInput = function(cm) {
          this.cm = cm;
          this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
          this.polling = new Delayed();
          this.composing = null;
          this.gracePeriod = false;
          this.readDOMTimeout = null;
        };
        ContentEditableInput.prototype.init = function(display) {
          var this$1 = this;
          var input = this, cm = input.cm;
          var div2 = input.div = display.lineDiv;
          disableBrowserMagic(div2, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);
          function belongsToInput(e2) {
            for (var t2 = e2.target; t2; t2 = t2.parentNode) {
              if (t2 == div2) {
                return true;
              }
              if (/\bCodeMirror-(?:line)?widget\b/.test(t2.className)) {
                break;
              }
            }
            return false;
          }
          on(div2, "paste", function(e2) {
            if (!belongsToInput(e2) || signalDOMEvent(cm, e2) || handlePaste(e2, cm)) {
              return;
            }
            if (ie_version <= 11) {
              setTimeout(operation(cm, function() {
                return this$1.updateFromDOM();
              }), 20);
            }
          });
          on(div2, "compositionstart", function(e2) {
            this$1.composing = { data: e2.data, done: false };
          });
          on(div2, "compositionupdate", function(e2) {
            if (!this$1.composing) {
              this$1.composing = { data: e2.data, done: false };
            }
          });
          on(div2, "compositionend", function(e2) {
            if (this$1.composing) {
              if (e2.data != this$1.composing.data) {
                this$1.readFromDOMSoon();
              }
              this$1.composing.done = true;
            }
          });
          on(div2, "touchstart", function() {
            return input.forceCompositionEnd();
          });
          on(div2, "input", function() {
            if (!this$1.composing) {
              this$1.readFromDOMSoon();
            }
          });
          function onCopyCut(e2) {
            if (!belongsToInput(e2) || signalDOMEvent(cm, e2)) {
              return;
            }
            if (cm.somethingSelected()) {
              setLastCopied({ lineWise: false, text: cm.getSelections() });
              if (e2.type == "cut") {
                cm.replaceSelection("", null, "cut");
              }
            } else if (!cm.options.lineWiseCopyCut) {
              return;
            } else {
              var ranges = copyableRanges(cm);
              setLastCopied({ lineWise: true, text: ranges.text });
              if (e2.type == "cut") {
                cm.operation(function() {
                  cm.setSelections(ranges.ranges, 0, sel_dontScroll);
                  cm.replaceSelection("", null, "cut");
                });
              }
            }
            if (e2.clipboardData) {
              e2.clipboardData.clearData();
              var content = lastCopied.text.join("\n");
              e2.clipboardData.setData("Text", content);
              if (e2.clipboardData.getData("Text") == content) {
                e2.preventDefault();
                return;
              }
            }
            var kludge = hiddenTextarea(), te = kludge.firstChild;
            cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
            te.value = lastCopied.text.join("\n");
            var hadFocus = document.activeElement;
            selectInput(te);
            setTimeout(function() {
              cm.display.lineSpace.removeChild(kludge);
              hadFocus.focus();
              if (hadFocus == div2) {
                input.showPrimarySelection();
              }
            }, 50);
          }
          on(div2, "copy", onCopyCut);
          on(div2, "cut", onCopyCut);
        };
        ContentEditableInput.prototype.screenReaderLabelChanged = function(label) {
          if (label) {
            this.div.setAttribute("aria-label", label);
          } else {
            this.div.removeAttribute("aria-label");
          }
        };
        ContentEditableInput.prototype.prepareSelection = function() {
          var result = prepareSelection(this.cm, false);
          result.focus = document.activeElement == this.div;
          return result;
        };
        ContentEditableInput.prototype.showSelection = function(info, takeFocus) {
          if (!info || !this.cm.display.view.length) {
            return;
          }
          if (info.focus || takeFocus) {
            this.showPrimarySelection();
          }
          this.showMultipleSelections(info);
        };
        ContentEditableInput.prototype.getSelection = function() {
          return this.cm.display.wrapper.ownerDocument.getSelection();
        };
        ContentEditableInput.prototype.showPrimarySelection = function() {
          var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
          var from = prim.from(), to = prim.to();
          if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
            sel.removeAllRanges();
            return;
          }
          var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
          var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
          if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {
            return;
          }
          var view = cm.display.view;
          var start4 = from.line >= cm.display.viewFrom && posToDOM(cm, from) || { node: view[0].measure.map[2], offset: 0 };
          var end2 = to.line < cm.display.viewTo && posToDOM(cm, to);
          if (!end2) {
            var measure = view[view.length - 1].measure;
            var map2 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
            end2 = { node: map2[map2.length - 1], offset: map2[map2.length - 2] - map2[map2.length - 3] };
          }
          if (!start4 || !end2) {
            sel.removeAllRanges();
            return;
          }
          var old = sel.rangeCount && sel.getRangeAt(0), rng;
          try {
            rng = range(start4.node, start4.offset, end2.offset, end2.node);
          } catch (e2) {
          }
          if (rng) {
            if (!gecko && cm.state.focused) {
              sel.collapse(start4.node, start4.offset);
              if (!rng.collapsed) {
                sel.removeAllRanges();
                sel.addRange(rng);
              }
            } else {
              sel.removeAllRanges();
              sel.addRange(rng);
            }
            if (old && sel.anchorNode == null) {
              sel.addRange(old);
            } else if (gecko) {
              this.startGracePeriod();
            }
          }
          this.rememberSelection();
        };
        ContentEditableInput.prototype.startGracePeriod = function() {
          var this$1 = this;
          clearTimeout(this.gracePeriod);
          this.gracePeriod = setTimeout(function() {
            this$1.gracePeriod = false;
            if (this$1.selectionChanged()) {
              this$1.cm.operation(function() {
                return this$1.cm.curOp.selectionChanged = true;
              });
            }
          }, 20);
        };
        ContentEditableInput.prototype.showMultipleSelections = function(info) {
          removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
          removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
        };
        ContentEditableInput.prototype.rememberSelection = function() {
          var sel = this.getSelection();
          this.lastAnchorNode = sel.anchorNode;
          this.lastAnchorOffset = sel.anchorOffset;
          this.lastFocusNode = sel.focusNode;
          this.lastFocusOffset = sel.focusOffset;
        };
        ContentEditableInput.prototype.selectionInEditor = function() {
          var sel = this.getSelection();
          if (!sel.rangeCount) {
            return false;
          }
          var node = sel.getRangeAt(0).commonAncestorContainer;
          return contains2(this.div, node);
        };
        ContentEditableInput.prototype.focus = function() {
          if (this.cm.options.readOnly != "nocursor") {
            if (!this.selectionInEditor() || document.activeElement != this.div) {
              this.showSelection(this.prepareSelection(), true);
            }
            this.div.focus();
          }
        };
        ContentEditableInput.prototype.blur = function() {
          this.div.blur();
        };
        ContentEditableInput.prototype.getField = function() {
          return this.div;
        };
        ContentEditableInput.prototype.supportsTouch = function() {
          return true;
        };
        ContentEditableInput.prototype.receivedFocus = function() {
          var input = this;
          if (this.selectionInEditor()) {
            this.pollSelection();
          } else {
            runInOp(this.cm, function() {
              return input.cm.curOp.selectionChanged = true;
            });
          }
          function poll() {
            if (input.cm.state.focused) {
              input.pollSelection();
              input.polling.set(input.cm.options.pollInterval, poll);
            }
          }
          this.polling.set(this.cm.options.pollInterval, poll);
        };
        ContentEditableInput.prototype.selectionChanged = function() {
          var sel = this.getSelection();
          return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
        };
        ContentEditableInput.prototype.pollSelection = function() {
          if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
            return;
          }
          var sel = this.getSelection(), cm = this.cm;
          if (android && chrome2 && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
            this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs });
            this.blur();
            this.focus();
            return;
          }
          if (this.composing) {
            return;
          }
          this.rememberSelection();
          var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
          var head = domToPos(cm, sel.focusNode, sel.focusOffset);
          if (anchor && head) {
            runInOp(cm, function() {
              setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
              if (anchor.bad || head.bad) {
                cm.curOp.selectionChanged = true;
              }
            });
          }
        };
        ContentEditableInput.prototype.pollContent = function() {
          if (this.readDOMTimeout != null) {
            clearTimeout(this.readDOMTimeout);
            this.readDOMTimeout = null;
          }
          var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
          var from = sel.from(), to = sel.to();
          if (from.ch == 0 && from.line > cm.firstLine()) {
            from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);
          }
          if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
            to = Pos(to.line + 1, 0);
          }
          if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
            return false;
          }
          var fromIndex, fromLine, fromNode;
          if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
            fromLine = lineNo(display.view[0].line);
            fromNode = display.view[0].node;
          } else {
            fromLine = lineNo(display.view[fromIndex].line);
            fromNode = display.view[fromIndex - 1].node.nextSibling;
          }
          var toIndex = findViewIndex(cm, to.line);
          var toLine, toNode;
          if (toIndex == display.view.length - 1) {
            toLine = display.viewTo - 1;
            toNode = display.lineDiv.lastChild;
          } else {
            toLine = lineNo(display.view[toIndex + 1].line) - 1;
            toNode = display.view[toIndex + 1].node.previousSibling;
          }
          if (!fromNode) {
            return false;
          }
          var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
          var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
          while (newText.length > 1 && oldText.length > 1) {
            if (lst(newText) == lst(oldText)) {
              newText.pop();
              oldText.pop();
              toLine--;
            } else if (newText[0] == oldText[0]) {
              newText.shift();
              oldText.shift();
              fromLine++;
            } else {
              break;
            }
          }
          var cutFront = 0, cutEnd = 0;
          var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
          while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
            ++cutFront;
          }
          var newBot = lst(newText), oldBot = lst(oldText);
          var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));
          while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
            ++cutEnd;
          }
          if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
            while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
              cutFront--;
              cutEnd++;
            }
          }
          newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
          newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
          var chFrom = Pos(fromLine, cutFront);
          var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
          if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
            replaceRange(cm.doc, newText, chFrom, chTo, "+input");
            return true;
          }
        };
        ContentEditableInput.prototype.ensurePolled = function() {
          this.forceCompositionEnd();
        };
        ContentEditableInput.prototype.reset = function() {
          this.forceCompositionEnd();
        };
        ContentEditableInput.prototype.forceCompositionEnd = function() {
          if (!this.composing) {
            return;
          }
          clearTimeout(this.readDOMTimeout);
          this.composing = null;
          this.updateFromDOM();
          this.div.blur();
          this.div.focus();
        };
        ContentEditableInput.prototype.readFromDOMSoon = function() {
          var this$1 = this;
          if (this.readDOMTimeout != null) {
            return;
          }
          this.readDOMTimeout = setTimeout(function() {
            this$1.readDOMTimeout = null;
            if (this$1.composing) {
              if (this$1.composing.done) {
                this$1.composing = null;
              } else {
                return;
              }
            }
            this$1.updateFromDOM();
          }, 80);
        };
        ContentEditableInput.prototype.updateFromDOM = function() {
          var this$1 = this;
          if (this.cm.isReadOnly() || !this.pollContent()) {
            runInOp(this.cm, function() {
              return regChange(this$1.cm);
            });
          }
        };
        ContentEditableInput.prototype.setUneditable = function(node) {
          node.contentEditable = "false";
        };
        ContentEditableInput.prototype.onKeyPress = function(e2) {
          if (e2.charCode == 0 || this.composing) {
            return;
          }
          e2.preventDefault();
          if (!this.cm.isReadOnly()) {
            operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e2.charCode == null ? e2.keyCode : e2.charCode), 0);
          }
        };
        ContentEditableInput.prototype.readOnlyChanged = function(val) {
          this.div.contentEditable = String(val != "nocursor");
        };
        ContentEditableInput.prototype.onContextMenu = function() {
        };
        ContentEditableInput.prototype.resetPosition = function() {
        };
        ContentEditableInput.prototype.needsContentAttribute = true;
        function posToDOM(cm, pos) {
          var view = findViewForLine(cm, pos.line);
          if (!view || view.hidden) {
            return null;
          }
          var line = getLine(cm.doc, pos.line);
          var info = mapFromLineView(view, line, pos.line);
          var order2 = getOrder(line, cm.doc.direction), side = "left";
          if (order2) {
            var partPos = getBidiPartAt(order2, pos.ch);
            side = partPos % 2 ? "right" : "left";
          }
          var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
          result.offset = result.collapse == "right" ? result.end : result.start;
          return result;
        }
        function isInGutter(node) {
          for (var scan = node; scan; scan = scan.parentNode) {
            if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
              return true;
            }
          }
          return false;
        }
        function badPos(pos, bad) {
          if (bad) {
            pos.bad = true;
          }
          return pos;
        }
        function domTextBetween(cm, from, to, fromLine, toLine) {
          var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
          function recognizeMarker(id) {
            return function(marker) {
              return marker.id == id;
            };
          }
          function close() {
            if (closing) {
              text += lineSep;
              if (extraLinebreak) {
                text += lineSep;
              }
              closing = extraLinebreak = false;
            }
          }
          function addText(str) {
            if (str) {
              close();
              text += str;
            }
          }
          function walk(node) {
            if (node.nodeType == 1) {
              var cmText = node.getAttribute("cm-text");
              if (cmText) {
                addText(cmText);
                return;
              }
              var markerID = node.getAttribute("cm-marker"), range2;
              if (markerID) {
                var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
                if (found.length && (range2 = found[0].find(0))) {
                  addText(getBetween(cm.doc, range2.from, range2.to).join(lineSep));
                }
                return;
              }
              if (node.getAttribute("contenteditable") == "false") {
                return;
              }
              var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
              if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {
                return;
              }
              if (isBlock) {
                close();
              }
              for (var i3 = 0; i3 < node.childNodes.length; i3++) {
                walk(node.childNodes[i3]);
              }
              if (/^(pre|p)$/i.test(node.nodeName)) {
                extraLinebreak = true;
              }
              if (isBlock) {
                closing = true;
              }
            } else if (node.nodeType == 3) {
              addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
            }
          }
          for (; ; ) {
            walk(from);
            if (from == to) {
              break;
            }
            from = from.nextSibling;
            extraLinebreak = false;
          }
          return text;
        }
        function domToPos(cm, node, offset2) {
          var lineNode;
          if (node == cm.display.lineDiv) {
            lineNode = cm.display.lineDiv.childNodes[offset2];
            if (!lineNode) {
              return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
            }
            node = null;
            offset2 = 0;
          } else {
            for (lineNode = node; ; lineNode = lineNode.parentNode) {
              if (!lineNode || lineNode == cm.display.lineDiv) {
                return null;
              }
              if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
                break;
              }
            }
          }
          for (var i3 = 0; i3 < cm.display.view.length; i3++) {
            var lineView = cm.display.view[i3];
            if (lineView.node == lineNode) {
              return locateNodeInLineView(lineView, node, offset2);
            }
          }
        }
        function locateNodeInLineView(lineView, node, offset2) {
          var wrapper = lineView.text.firstChild, bad = false;
          if (!node || !contains2(wrapper, node)) {
            return badPos(Pos(lineNo(lineView.line), 0), true);
          }
          if (node == wrapper) {
            bad = true;
            node = wrapper.childNodes[offset2];
            offset2 = 0;
            if (!node) {
              var line = lineView.rest ? lst(lineView.rest) : lineView.line;
              return badPos(Pos(lineNo(line), line.text.length), bad);
            }
          }
          var textNode = node.nodeType == 3 ? node : null, topNode = node;
          if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
            textNode = node.firstChild;
            if (offset2) {
              offset2 = textNode.nodeValue.length;
            }
          }
          while (topNode.parentNode != wrapper) {
            topNode = topNode.parentNode;
          }
          var measure = lineView.measure, maps = measure.maps;
          function find(textNode2, topNode2, offset3) {
            for (var i3 = -1; i3 < (maps ? maps.length : 0); i3++) {
              var map2 = i3 < 0 ? measure.map : maps[i3];
              for (var j2 = 0; j2 < map2.length; j2 += 3) {
                var curNode = map2[j2 + 2];
                if (curNode == textNode2 || curNode == topNode2) {
                  var line2 = lineNo(i3 < 0 ? lineView.line : lineView.rest[i3]);
                  var ch = map2[j2] + offset3;
                  if (offset3 < 0 || curNode != textNode2) {
                    ch = map2[j2 + (offset3 ? 1 : 0)];
                  }
                  return Pos(line2, ch);
                }
              }
            }
          }
          var found = find(textNode, topNode, offset2);
          if (found) {
            return badPos(found, bad);
          }
          for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset2 : 0; after; after = after.nextSibling) {
            found = find(after, after.firstChild, 0);
            if (found) {
              return badPos(Pos(found.line, found.ch - dist), bad);
            } else {
              dist += after.textContent.length;
            }
          }
          for (var before = topNode.previousSibling, dist$1 = offset2; before; before = before.previousSibling) {
            found = find(before, before.firstChild, -1);
            if (found) {
              return badPos(Pos(found.line, found.ch + dist$1), bad);
            } else {
              dist$1 += before.textContent.length;
            }
          }
        }
        var TextareaInput = function(cm) {
          this.cm = cm;
          this.prevInput = "";
          this.pollingFast = false;
          this.polling = new Delayed();
          this.hasSelection = false;
          this.composing = null;
        };
        TextareaInput.prototype.init = function(display) {
          var this$1 = this;
          var input = this, cm = this.cm;
          this.createField(display);
          var te = this.textarea;
          display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);
          if (ios) {
            te.style.width = "0px";
          }
          on(te, "input", function() {
            if (ie && ie_version >= 9 && this$1.hasSelection) {
              this$1.hasSelection = null;
            }
            input.poll();
          });
          on(te, "paste", function(e2) {
            if (signalDOMEvent(cm, e2) || handlePaste(e2, cm)) {
              return;
            }
            cm.state.pasteIncoming = +new Date();
            input.fastPoll();
          });
          function prepareCopyCut(e2) {
            if (signalDOMEvent(cm, e2)) {
              return;
            }
            if (cm.somethingSelected()) {
              setLastCopied({ lineWise: false, text: cm.getSelections() });
            } else if (!cm.options.lineWiseCopyCut) {
              return;
            } else {
              var ranges = copyableRanges(cm);
              setLastCopied({ lineWise: true, text: ranges.text });
              if (e2.type == "cut") {
                cm.setSelections(ranges.ranges, null, sel_dontScroll);
              } else {
                input.prevInput = "";
                te.value = ranges.text.join("\n");
                selectInput(te);
              }
            }
            if (e2.type == "cut") {
              cm.state.cutIncoming = +new Date();
            }
          }
          on(te, "cut", prepareCopyCut);
          on(te, "copy", prepareCopyCut);
          on(display.scroller, "paste", function(e2) {
            if (eventInWidget(display, e2) || signalDOMEvent(cm, e2)) {
              return;
            }
            if (!te.dispatchEvent) {
              cm.state.pasteIncoming = +new Date();
              input.focus();
              return;
            }
            var event = new Event("paste");
            event.clipboardData = e2.clipboardData;
            te.dispatchEvent(event);
          });
          on(display.lineSpace, "selectstart", function(e2) {
            if (!eventInWidget(display, e2)) {
              e_preventDefault(e2);
            }
          });
          on(te, "compositionstart", function() {
            var start4 = cm.getCursor("from");
            if (input.composing) {
              input.composing.range.clear();
            }
            input.composing = {
              start: start4,
              range: cm.markText(start4, cm.getCursor("to"), { className: "CodeMirror-composing" })
            };
          });
          on(te, "compositionend", function() {
            if (input.composing) {
              input.poll();
              input.composing.range.clear();
              input.composing = null;
            }
          });
        };
        TextareaInput.prototype.createField = function(_display) {
          this.wrapper = hiddenTextarea();
          this.textarea = this.wrapper.firstChild;
        };
        TextareaInput.prototype.screenReaderLabelChanged = function(label) {
          if (label) {
            this.textarea.setAttribute("aria-label", label);
          } else {
            this.textarea.removeAttribute("aria-label");
          }
        };
        TextareaInput.prototype.prepareSelection = function() {
          var cm = this.cm, display = cm.display, doc = cm.doc;
          var result = prepareSelection(cm);
          if (cm.options.moveInputWithCursor) {
            var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
            var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
            result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
            result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
          }
          return result;
        };
        TextareaInput.prototype.showSelection = function(drawn) {
          var cm = this.cm, display = cm.display;
          removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
          removeChildrenAndAdd(display.selectionDiv, drawn.selection);
          if (drawn.teTop != null) {
            this.wrapper.style.top = drawn.teTop + "px";
            this.wrapper.style.left = drawn.teLeft + "px";
          }
        };
        TextareaInput.prototype.reset = function(typing) {
          if (this.contextMenuPending || this.composing) {
            return;
          }
          var cm = this.cm;
          if (cm.somethingSelected()) {
            this.prevInput = "";
            var content = cm.getSelection();
            this.textarea.value = content;
            if (cm.state.focused) {
              selectInput(this.textarea);
            }
            if (ie && ie_version >= 9) {
              this.hasSelection = content;
            }
          } else if (!typing) {
            this.prevInput = this.textarea.value = "";
            if (ie && ie_version >= 9) {
              this.hasSelection = null;
            }
          }
        };
        TextareaInput.prototype.getField = function() {
          return this.textarea;
        };
        TextareaInput.prototype.supportsTouch = function() {
          return false;
        };
        TextareaInput.prototype.focus = function() {
          if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
            try {
              this.textarea.focus();
            } catch (e2) {
            }
          }
        };
        TextareaInput.prototype.blur = function() {
          this.textarea.blur();
        };
        TextareaInput.prototype.resetPosition = function() {
          this.wrapper.style.top = this.wrapper.style.left = 0;
        };
        TextareaInput.prototype.receivedFocus = function() {
          this.slowPoll();
        };
        TextareaInput.prototype.slowPoll = function() {
          var this$1 = this;
          if (this.pollingFast) {
            return;
          }
          this.polling.set(this.cm.options.pollInterval, function() {
            this$1.poll();
            if (this$1.cm.state.focused) {
              this$1.slowPoll();
            }
          });
        };
        TextareaInput.prototype.fastPoll = function() {
          var missed = false, input = this;
          input.pollingFast = true;
          function p2() {
            var changed = input.poll();
            if (!changed && !missed) {
              missed = true;
              input.polling.set(60, p2);
            } else {
              input.pollingFast = false;
              input.slowPoll();
            }
          }
          input.polling.set(20, p2);
        };
        TextareaInput.prototype.poll = function() {
          var this$1 = this;
          var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
          if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
            return false;
          }
          var text = input.value;
          if (text == prevInput && !cm.somethingSelected()) {
            return false;
          }
          if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) {
            cm.display.input.reset();
            return false;
          }
          if (cm.doc.sel == cm.display.selForContextMenu) {
            var first = text.charCodeAt(0);
            if (first == 8203 && !prevInput) {
              prevInput = "\u200B";
            }
            if (first == 8666) {
              this.reset();
              return this.cm.execCommand("undo");
            }
          }
          var same = 0, l2 = Math.min(prevInput.length, text.length);
          while (same < l2 && prevInput.charCodeAt(same) == text.charCodeAt(same)) {
            ++same;
          }
          runInOp(cm, function() {
            applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? "*compose" : null);
            if (text.length > 1e3 || text.indexOf("\n") > -1) {
              input.value = this$1.prevInput = "";
            } else {
              this$1.prevInput = text;
            }
            if (this$1.composing) {
              this$1.composing.range.clear();
              this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"), { className: "CodeMirror-composing" });
            }
          });
          return true;
        };
        TextareaInput.prototype.ensurePolled = function() {
          if (this.pollingFast && this.poll()) {
            this.pollingFast = false;
          }
        };
        TextareaInput.prototype.onKeyPress = function() {
          if (ie && ie_version >= 9) {
            this.hasSelection = null;
          }
          this.fastPoll();
        };
        TextareaInput.prototype.onContextMenu = function(e2) {
          var input = this, cm = input.cm, display = cm.display, te = input.textarea;
          if (input.contextMenuPending) {
            input.contextMenuPending();
          }
          var pos = posFromMouse(cm, e2), scrollPos = display.scroller.scrollTop;
          if (!pos || presto) {
            return;
          }
          var reset = cm.options.resetSelectionOnContextMenu;
          if (reset && cm.doc.sel.contains(pos) == -1) {
            operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
          }
          var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
          var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
          input.wrapper.style.cssText = "position: static";
          te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e2.clientY - wrapperBox.top - 5) + "px; left: " + (e2.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
          var oldScrollY;
          if (webkit) {
            oldScrollY = window.scrollY;
          }
          display.input.focus();
          if (webkit) {
            window.scrollTo(null, oldScrollY);
          }
          display.input.reset();
          if (!cm.somethingSelected()) {
            te.value = input.prevInput = " ";
          }
          input.contextMenuPending = rehide;
          display.selForContextMenu = cm.doc.sel;
          clearTimeout(display.detectingSelectAll);
          function prepareSelectAllHack() {
            if (te.selectionStart != null) {
              var selected = cm.somethingSelected();
              var extval = "\u200B" + (selected ? te.value : "");
              te.value = "\u21DA";
              te.value = extval;
              input.prevInput = selected ? "" : "\u200B";
              te.selectionStart = 1;
              te.selectionEnd = extval.length;
              display.selForContextMenu = cm.doc.sel;
            }
          }
          function rehide() {
            if (input.contextMenuPending != rehide) {
              return;
            }
            input.contextMenuPending = false;
            input.wrapper.style.cssText = oldWrapperCSS;
            te.style.cssText = oldCSS;
            if (ie && ie_version < 9) {
              display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
            }
            if (te.selectionStart != null) {
              if (!ie || ie && ie_version < 9) {
                prepareSelectAllHack();
              }
              var i3 = 0, poll = function() {
                if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "\u200B") {
                  operation(cm, selectAll)(cm);
                } else if (i3++ < 10) {
                  display.detectingSelectAll = setTimeout(poll, 500);
                } else {
                  display.selForContextMenu = null;
                  display.input.reset();
                }
              };
              display.detectingSelectAll = setTimeout(poll, 200);
            }
          }
          if (ie && ie_version >= 9) {
            prepareSelectAllHack();
          }
          if (captureRightClick) {
            e_stop(e2);
            var mouseup = function() {
              off(window, "mouseup", mouseup);
              setTimeout(rehide, 20);
            };
            on(window, "mouseup", mouseup);
          } else {
            setTimeout(rehide, 50);
          }
        };
        TextareaInput.prototype.readOnlyChanged = function(val) {
          if (!val) {
            this.reset();
          }
          this.textarea.disabled = val == "nocursor";
          this.textarea.readOnly = !!val;
        };
        TextareaInput.prototype.setUneditable = function() {
        };
        TextareaInput.prototype.needsContentAttribute = false;
        function fromTextArea(textarea, options) {
          options = options ? copyObj(options) : {};
          options.value = textarea.value;
          if (!options.tabindex && textarea.tabIndex) {
            options.tabindex = textarea.tabIndex;
          }
          if (!options.placeholder && textarea.placeholder) {
            options.placeholder = textarea.placeholder;
          }
          if (options.autofocus == null) {
            var hasFocus = activeElt();
            options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
          }
          function save() {
            textarea.value = cm.getValue();
          }
          var realSubmit;
          if (textarea.form) {
            on(textarea.form, "submit", save);
            if (!options.leaveSubmitMethodAlone) {
              var form = textarea.form;
              realSubmit = form.submit;
              try {
                var wrappedSubmit = form.submit = function() {
                  save();
                  form.submit = realSubmit;
                  form.submit();
                  form.submit = wrappedSubmit;
                };
              } catch (e2) {
              }
            }
          }
          options.finishInit = function(cm2) {
            cm2.save = save;
            cm2.getTextArea = function() {
              return textarea;
            };
            cm2.toTextArea = function() {
              cm2.toTextArea = isNaN;
              save();
              textarea.parentNode.removeChild(cm2.getWrapperElement());
              textarea.style.display = "";
              if (textarea.form) {
                off(textarea.form, "submit", save);
                if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function") {
                  textarea.form.submit = realSubmit;
                }
              }
            };
          };
          textarea.style.display = "none";
          var cm = CodeMirror3(function(node) {
            return textarea.parentNode.insertBefore(node, textarea.nextSibling);
          }, options);
          return cm;
        }
        function addLegacyProps(CodeMirror4) {
          CodeMirror4.off = off;
          CodeMirror4.on = on;
          CodeMirror4.wheelEventPixels = wheelEventPixels;
          CodeMirror4.Doc = Doc;
          CodeMirror4.splitLines = splitLinesAuto;
          CodeMirror4.countColumn = countColumn;
          CodeMirror4.findColumn = findColumn;
          CodeMirror4.isWordChar = isWordCharBasic;
          CodeMirror4.Pass = Pass;
          CodeMirror4.signal = signal;
          CodeMirror4.Line = Line;
          CodeMirror4.changeEnd = changeEnd;
          CodeMirror4.scrollbarModel = scrollbarModel;
          CodeMirror4.Pos = Pos;
          CodeMirror4.cmpPos = cmp;
          CodeMirror4.modes = modes;
          CodeMirror4.mimeModes = mimeModes;
          CodeMirror4.resolveMode = resolveMode;
          CodeMirror4.getMode = getMode;
          CodeMirror4.modeExtensions = modeExtensions;
          CodeMirror4.extendMode = extendMode;
          CodeMirror4.copyState = copyState;
          CodeMirror4.startState = startState;
          CodeMirror4.innerMode = innerMode;
          CodeMirror4.commands = commands;
          CodeMirror4.keyMap = keyMap;
          CodeMirror4.keyName = keyName;
          CodeMirror4.isModifierKey = isModifierKey;
          CodeMirror4.lookupKey = lookupKey;
          CodeMirror4.normalizeKeyMap = normalizeKeyMap;
          CodeMirror4.StringStream = StringStream;
          CodeMirror4.SharedTextMarker = SharedTextMarker;
          CodeMirror4.TextMarker = TextMarker;
          CodeMirror4.LineWidget = LineWidget;
          CodeMirror4.e_preventDefault = e_preventDefault;
          CodeMirror4.e_stopPropagation = e_stopPropagation;
          CodeMirror4.e_stop = e_stop;
          CodeMirror4.addClass = addClass;
          CodeMirror4.contains = contains2;
          CodeMirror4.rmClass = rmClass;
          CodeMirror4.keyNames = keyNames;
        }
        defineOptions(CodeMirror3);
        addEditorMethods(CodeMirror3);
        var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
        for (var prop in Doc.prototype) {
          if (Doc.prototype.hasOwnProperty(prop) && indexOf2(dontDelegate, prop) < 0) {
            CodeMirror3.prototype[prop] = function(method) {
              return function() {
                return method.apply(this.doc, arguments);
              };
            }(Doc.prototype[prop]);
          }
        }
        eventMixin(Doc);
        CodeMirror3.inputStyles = { "textarea": TextareaInput, "contenteditable": ContentEditableInput };
        CodeMirror3.defineMode = function(name) {
          if (!CodeMirror3.defaults.mode && name != "null") {
            CodeMirror3.defaults.mode = name;
          }
          defineMode.apply(this, arguments);
        };
        CodeMirror3.defineMIME = defineMIME;
        CodeMirror3.defineMode("null", function() {
          return { token: function(stream) {
            return stream.skipToEnd();
          } };
        });
        CodeMirror3.defineMIME("text/plain", "null");
        CodeMirror3.defineExtension = function(name, func) {
          CodeMirror3.prototype[name] = func;
        };
        CodeMirror3.defineDocExtension = function(name, func) {
          Doc.prototype[name] = func;
        };
        CodeMirror3.fromTextArea = fromTextArea;
        addLegacyProps(CodeMirror3);
        CodeMirror3.version = "5.59.3";
        return CodeMirror3;
      });
    }
  });

  // node_modules/codemirror/mode/css/css.js
  var require_css = __commonJS({
    "node_modules/codemirror/mode/css/css.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.defineMode("css", function(config, parserConfig) {
          var inline = parserConfig.inline;
          if (!parserConfig.propertyKeywords)
            parserConfig = CodeMirror3.resolveMode("text/css");
          var indentUnit = config.indentUnit, tokenHooks = parserConfig.tokenHooks, documentTypes2 = parserConfig.documentTypes || {}, mediaTypes2 = parserConfig.mediaTypes || {}, mediaFeatures2 = parserConfig.mediaFeatures || {}, mediaValueKeywords2 = parserConfig.mediaValueKeywords || {}, propertyKeywords2 = parserConfig.propertyKeywords || {}, nonStandardPropertyKeywords2 = parserConfig.nonStandardPropertyKeywords || {}, fontProperties2 = parserConfig.fontProperties || {}, counterDescriptors2 = parserConfig.counterDescriptors || {}, colorKeywords2 = parserConfig.colorKeywords || {}, valueKeywords2 = parserConfig.valueKeywords || {}, allowNested = parserConfig.allowNested, lineComment = parserConfig.lineComment, supportsAtComponent = parserConfig.supportsAtComponent === true, highlightNonStandardPropertyKeywords = config.highlightNonStandardPropertyKeywords !== false;
          var type, override;
          function ret(style, tp) {
            type = tp;
            return style;
          }
          function tokenBase(stream, state) {
            var ch = stream.next();
            if (tokenHooks[ch]) {
              var result = tokenHooks[ch](stream, state);
              if (result !== false)
                return result;
            }
            if (ch == "@") {
              stream.eatWhile(/[\w\\\-]/);
              return ret("def", stream.current());
            } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
              return ret(null, "compare");
            } else if (ch == '"' || ch == "'") {
              state.tokenize = tokenString(ch);
              return state.tokenize(stream, state);
            } else if (ch == "#") {
              stream.eatWhile(/[\w\\\-]/);
              return ret("atom", "hash");
            } else if (ch == "!") {
              stream.match(/^\s*\w*/);
              return ret("keyword", "important");
            } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
              stream.eatWhile(/[\w.%]/);
              return ret("number", "unit");
            } else if (ch === "-") {
              if (/[\d.]/.test(stream.peek())) {
                stream.eatWhile(/[\w.%]/);
                return ret("number", "unit");
              } else if (stream.match(/^-[\w\\\-]*/)) {
                stream.eatWhile(/[\w\\\-]/);
                if (stream.match(/^\s*:/, false))
                  return ret("variable-2", "variable-definition");
                return ret("variable-2", "variable");
              } else if (stream.match(/^\w+-/)) {
                return ret("meta", "meta");
              }
            } else if (/[,+>*\/]/.test(ch)) {
              return ret(null, "select-op");
            } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
              return ret("qualifier", "qualifier");
            } else if (/[:;{}\[\]\(\)]/.test(ch)) {
              return ret(null, ch);
            } else if (stream.match(/^[\w-.]+(?=\()/)) {
              if (/^(url(-prefix)?|domain|regexp)$/i.test(stream.current())) {
                state.tokenize = tokenParenthesized;
              }
              return ret("variable callee", "variable");
            } else if (/[\w\\\-]/.test(ch)) {
              stream.eatWhile(/[\w\\\-]/);
              return ret("property", "word");
            } else {
              return ret(null, null);
            }
          }
          function tokenString(quote) {
            return function(stream, state) {
              var escaped = false, ch;
              while ((ch = stream.next()) != null) {
                if (ch == quote && !escaped) {
                  if (quote == ")")
                    stream.backUp(1);
                  break;
                }
                escaped = !escaped && ch == "\\";
              }
              if (ch == quote || !escaped && quote != ")")
                state.tokenize = null;
              return ret("string", "string");
            };
          }
          function tokenParenthesized(stream, state) {
            stream.next();
            if (!stream.match(/^\s*[\"\')]/, false))
              state.tokenize = tokenString(")");
            else
              state.tokenize = null;
            return ret(null, "(");
          }
          function Context2(type2, indent, prev) {
            this.type = type2;
            this.indent = indent;
            this.prev = prev;
          }
          function pushContext(state, stream, type2, indent) {
            state.context = new Context2(type2, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);
            return type2;
          }
          function popContext(state) {
            if (state.context.prev)
              state.context = state.context.prev;
            return state.context.type;
          }
          function pass(type2, stream, state) {
            return states[state.context.type](type2, stream, state);
          }
          function popAndPass(type2, stream, state, n2) {
            for (var i2 = n2 || 1; i2 > 0; i2--)
              state.context = state.context.prev;
            return pass(type2, stream, state);
          }
          function wordAsValue(stream) {
            var word = stream.current().toLowerCase();
            if (valueKeywords2.hasOwnProperty(word))
              override = "atom";
            else if (colorKeywords2.hasOwnProperty(word))
              override = "keyword";
            else
              override = "variable";
          }
          var states = {};
          states.top = function(type2, stream, state) {
            if (type2 == "{") {
              return pushContext(state, stream, "block");
            } else if (type2 == "}" && state.context.prev) {
              return popContext(state);
            } else if (supportsAtComponent && /@component/i.test(type2)) {
              return pushContext(state, stream, "atComponentBlock");
            } else if (/^@(-moz-)?document$/i.test(type2)) {
              return pushContext(state, stream, "documentTypes");
            } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type2)) {
              return pushContext(state, stream, "atBlock");
            } else if (/^@(font-face|counter-style)/i.test(type2)) {
              state.stateArg = type2;
              return "restricted_atBlock_before";
            } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type2)) {
              return "keyframes";
            } else if (type2 && type2.charAt(0) == "@") {
              return pushContext(state, stream, "at");
            } else if (type2 == "hash") {
              override = "builtin";
            } else if (type2 == "word") {
              override = "tag";
            } else if (type2 == "variable-definition") {
              return "maybeprop";
            } else if (type2 == "interpolation") {
              return pushContext(state, stream, "interpolation");
            } else if (type2 == ":") {
              return "pseudo";
            } else if (allowNested && type2 == "(") {
              return pushContext(state, stream, "parens");
            }
            return state.context.type;
          };
          states.block = function(type2, stream, state) {
            if (type2 == "word") {
              var word = stream.current().toLowerCase();
              if (propertyKeywords2.hasOwnProperty(word)) {
                override = "property";
                return "maybeprop";
              } else if (nonStandardPropertyKeywords2.hasOwnProperty(word)) {
                override = highlightNonStandardPropertyKeywords ? "string-2" : "property";
                return "maybeprop";
              } else if (allowNested) {
                override = stream.match(/^\s*:(?:\s|$)/, false) ? "property" : "tag";
                return "block";
              } else {
                override += " error";
                return "maybeprop";
              }
            } else if (type2 == "meta") {
              return "block";
            } else if (!allowNested && (type2 == "hash" || type2 == "qualifier")) {
              override = "error";
              return "block";
            } else {
              return states.top(type2, stream, state);
            }
          };
          states.maybeprop = function(type2, stream, state) {
            if (type2 == ":")
              return pushContext(state, stream, "prop");
            return pass(type2, stream, state);
          };
          states.prop = function(type2, stream, state) {
            if (type2 == ";")
              return popContext(state);
            if (type2 == "{" && allowNested)
              return pushContext(state, stream, "propBlock");
            if (type2 == "}" || type2 == "{")
              return popAndPass(type2, stream, state);
            if (type2 == "(")
              return pushContext(state, stream, "parens");
            if (type2 == "hash" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {
              override += " error";
            } else if (type2 == "word") {
              wordAsValue(stream);
            } else if (type2 == "interpolation") {
              return pushContext(state, stream, "interpolation");
            }
            return "prop";
          };
          states.propBlock = function(type2, _stream, state) {
            if (type2 == "}")
              return popContext(state);
            if (type2 == "word") {
              override = "property";
              return "maybeprop";
            }
            return state.context.type;
          };
          states.parens = function(type2, stream, state) {
            if (type2 == "{" || type2 == "}")
              return popAndPass(type2, stream, state);
            if (type2 == ")")
              return popContext(state);
            if (type2 == "(")
              return pushContext(state, stream, "parens");
            if (type2 == "interpolation")
              return pushContext(state, stream, "interpolation");
            if (type2 == "word")
              wordAsValue(stream);
            return "parens";
          };
          states.pseudo = function(type2, stream, state) {
            if (type2 == "meta")
              return "pseudo";
            if (type2 == "word") {
              override = "variable-3";
              return state.context.type;
            }
            return pass(type2, stream, state);
          };
          states.documentTypes = function(type2, stream, state) {
            if (type2 == "word" && documentTypes2.hasOwnProperty(stream.current())) {
              override = "tag";
              return state.context.type;
            } else {
              return states.atBlock(type2, stream, state);
            }
          };
          states.atBlock = function(type2, stream, state) {
            if (type2 == "(")
              return pushContext(state, stream, "atBlock_parens");
            if (type2 == "}" || type2 == ";")
              return popAndPass(type2, stream, state);
            if (type2 == "{")
              return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");
            if (type2 == "interpolation")
              return pushContext(state, stream, "interpolation");
            if (type2 == "word") {
              var word = stream.current().toLowerCase();
              if (word == "only" || word == "not" || word == "and" || word == "or")
                override = "keyword";
              else if (mediaTypes2.hasOwnProperty(word))
                override = "attribute";
              else if (mediaFeatures2.hasOwnProperty(word))
                override = "property";
              else if (mediaValueKeywords2.hasOwnProperty(word))
                override = "keyword";
              else if (propertyKeywords2.hasOwnProperty(word))
                override = "property";
              else if (nonStandardPropertyKeywords2.hasOwnProperty(word))
                override = highlightNonStandardPropertyKeywords ? "string-2" : "property";
              else if (valueKeywords2.hasOwnProperty(word))
                override = "atom";
              else if (colorKeywords2.hasOwnProperty(word))
                override = "keyword";
              else
                override = "error";
            }
            return state.context.type;
          };
          states.atComponentBlock = function(type2, stream, state) {
            if (type2 == "}")
              return popAndPass(type2, stream, state);
            if (type2 == "{")
              return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", false);
            if (type2 == "word")
              override = "error";
            return state.context.type;
          };
          states.atBlock_parens = function(type2, stream, state) {
            if (type2 == ")")
              return popContext(state);
            if (type2 == "{" || type2 == "}")
              return popAndPass(type2, stream, state, 2);
            return states.atBlock(type2, stream, state);
          };
          states.restricted_atBlock_before = function(type2, stream, state) {
            if (type2 == "{")
              return pushContext(state, stream, "restricted_atBlock");
            if (type2 == "word" && state.stateArg == "@counter-style") {
              override = "variable";
              return "restricted_atBlock_before";
            }
            return pass(type2, stream, state);
          };
          states.restricted_atBlock = function(type2, stream, state) {
            if (type2 == "}") {
              state.stateArg = null;
              return popContext(state);
            }
            if (type2 == "word") {
              if (state.stateArg == "@font-face" && !fontProperties2.hasOwnProperty(stream.current().toLowerCase()) || state.stateArg == "@counter-style" && !counterDescriptors2.hasOwnProperty(stream.current().toLowerCase()))
                override = "error";
              else
                override = "property";
              return "maybeprop";
            }
            return "restricted_atBlock";
          };
          states.keyframes = function(type2, stream, state) {
            if (type2 == "word") {
              override = "variable";
              return "keyframes";
            }
            if (type2 == "{")
              return pushContext(state, stream, "top");
            return pass(type2, stream, state);
          };
          states.at = function(type2, stream, state) {
            if (type2 == ";")
              return popContext(state);
            if (type2 == "{" || type2 == "}")
              return popAndPass(type2, stream, state);
            if (type2 == "word")
              override = "tag";
            else if (type2 == "hash")
              override = "builtin";
            return "at";
          };
          states.interpolation = function(type2, stream, state) {
            if (type2 == "}")
              return popContext(state);
            if (type2 == "{" || type2 == ";")
              return popAndPass(type2, stream, state);
            if (type2 == "word")
              override = "variable";
            else if (type2 != "variable" && type2 != "(" && type2 != ")")
              override = "error";
            return "interpolation";
          };
          return {
            startState: function(base) {
              return {
                tokenize: null,
                state: inline ? "block" : "top",
                stateArg: null,
                context: new Context2(inline ? "block" : "top", base || 0, null)
              };
            },
            token: function(stream, state) {
              if (!state.tokenize && stream.eatSpace())
                return null;
              var style = (state.tokenize || tokenBase)(stream, state);
              if (style && typeof style == "object") {
                type = style[1];
                style = style[0];
              }
              override = style;
              if (type != "comment")
                state.state = states[state.state](type, stream, state);
              return override;
            },
            indent: function(state, textAfter) {
              var cx = state.context, ch = textAfter && textAfter.charAt(0);
              var indent = cx.indent;
              if (cx.type == "prop" && (ch == "}" || ch == ")"))
                cx = cx.prev;
              if (cx.prev) {
                if (ch == "}" && (cx.type == "block" || cx.type == "top" || cx.type == "interpolation" || cx.type == "restricted_atBlock")) {
                  cx = cx.prev;
                  indent = cx.indent;
                } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") || ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {
                  indent = Math.max(0, cx.indent - indentUnit);
                }
              }
              return indent;
            },
            electricChars: "}",
            blockCommentStart: "/*",
            blockCommentEnd: "*/",
            blockCommentContinue: " * ",
            lineComment,
            fold: "brace"
          };
        });
        function keySet(array) {
          var keys = {};
          for (var i2 = 0; i2 < array.length; ++i2) {
            keys[array[i2].toLowerCase()] = true;
          }
          return keys;
        }
        var documentTypes_ = [
          "domain",
          "regexp",
          "url",
          "url-prefix"
        ], documentTypes = keySet(documentTypes_);
        var mediaTypes_ = [
          "all",
          "aural",
          "braille",
          "handheld",
          "print",
          "projection",
          "screen",
          "tty",
          "tv",
          "embossed"
        ], mediaTypes = keySet(mediaTypes_);
        var mediaFeatures_ = [
          "width",
          "min-width",
          "max-width",
          "height",
          "min-height",
          "max-height",
          "device-width",
          "min-device-width",
          "max-device-width",
          "device-height",
          "min-device-height",
          "max-device-height",
          "aspect-ratio",
          "min-aspect-ratio",
          "max-aspect-ratio",
          "device-aspect-ratio",
          "min-device-aspect-ratio",
          "max-device-aspect-ratio",
          "color",
          "min-color",
          "max-color",
          "color-index",
          "min-color-index",
          "max-color-index",
          "monochrome",
          "min-monochrome",
          "max-monochrome",
          "resolution",
          "min-resolution",
          "max-resolution",
          "scan",
          "grid",
          "orientation",
          "device-pixel-ratio",
          "min-device-pixel-ratio",
          "max-device-pixel-ratio",
          "pointer",
          "any-pointer",
          "hover",
          "any-hover",
          "prefers-color-scheme"
        ], mediaFeatures = keySet(mediaFeatures_);
        var mediaValueKeywords_ = [
          "landscape",
          "portrait",
          "none",
          "coarse",
          "fine",
          "on-demand",
          "hover",
          "interlace",
          "progressive",
          "dark",
          "light"
        ], mediaValueKeywords = keySet(mediaValueKeywords_);
        var propertyKeywords_ = [
          "align-content",
          "align-items",
          "align-self",
          "alignment-adjust",
          "alignment-baseline",
          "all",
          "anchor-point",
          "animation",
          "animation-delay",
          "animation-direction",
          "animation-duration",
          "animation-fill-mode",
          "animation-iteration-count",
          "animation-name",
          "animation-play-state",
          "animation-timing-function",
          "appearance",
          "azimuth",
          "backdrop-filter",
          "backface-visibility",
          "background",
          "background-attachment",
          "background-blend-mode",
          "background-clip",
          "background-color",
          "background-image",
          "background-origin",
          "background-position",
          "background-position-x",
          "background-position-y",
          "background-repeat",
          "background-size",
          "baseline-shift",
          "binding",
          "bleed",
          "block-size",
          "bookmark-label",
          "bookmark-level",
          "bookmark-state",
          "bookmark-target",
          "border",
          "border-bottom",
          "border-bottom-color",
          "border-bottom-left-radius",
          "border-bottom-right-radius",
          "border-bottom-style",
          "border-bottom-width",
          "border-collapse",
          "border-color",
          "border-image",
          "border-image-outset",
          "border-image-repeat",
          "border-image-slice",
          "border-image-source",
          "border-image-width",
          "border-left",
          "border-left-color",
          "border-left-style",
          "border-left-width",
          "border-radius",
          "border-right",
          "border-right-color",
          "border-right-style",
          "border-right-width",
          "border-spacing",
          "border-style",
          "border-top",
          "border-top-color",
          "border-top-left-radius",
          "border-top-right-radius",
          "border-top-style",
          "border-top-width",
          "border-width",
          "bottom",
          "box-decoration-break",
          "box-shadow",
          "box-sizing",
          "break-after",
          "break-before",
          "break-inside",
          "caption-side",
          "caret-color",
          "clear",
          "clip",
          "color",
          "color-profile",
          "column-count",
          "column-fill",
          "column-gap",
          "column-rule",
          "column-rule-color",
          "column-rule-style",
          "column-rule-width",
          "column-span",
          "column-width",
          "columns",
          "contain",
          "content",
          "counter-increment",
          "counter-reset",
          "crop",
          "cue",
          "cue-after",
          "cue-before",
          "cursor",
          "direction",
          "display",
          "dominant-baseline",
          "drop-initial-after-adjust",
          "drop-initial-after-align",
          "drop-initial-before-adjust",
          "drop-initial-before-align",
          "drop-initial-size",
          "drop-initial-value",
          "elevation",
          "empty-cells",
          "fit",
          "fit-position",
          "flex",
          "flex-basis",
          "flex-direction",
          "flex-flow",
          "flex-grow",
          "flex-shrink",
          "flex-wrap",
          "float",
          "float-offset",
          "flow-from",
          "flow-into",
          "font",
          "font-family",
          "font-feature-settings",
          "font-kerning",
          "font-language-override",
          "font-optical-sizing",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-synthesis",
          "font-variant",
          "font-variant-alternates",
          "font-variant-caps",
          "font-variant-east-asian",
          "font-variant-ligatures",
          "font-variant-numeric",
          "font-variant-position",
          "font-variation-settings",
          "font-weight",
          "gap",
          "grid",
          "grid-area",
          "grid-auto-columns",
          "grid-auto-flow",
          "grid-auto-rows",
          "grid-column",
          "grid-column-end",
          "grid-column-gap",
          "grid-column-start",
          "grid-gap",
          "grid-row",
          "grid-row-end",
          "grid-row-gap",
          "grid-row-start",
          "grid-template",
          "grid-template-areas",
          "grid-template-columns",
          "grid-template-rows",
          "hanging-punctuation",
          "height",
          "hyphens",
          "icon",
          "image-orientation",
          "image-rendering",
          "image-resolution",
          "inline-box-align",
          "inset",
          "inset-block",
          "inset-block-end",
          "inset-block-start",
          "inset-inline",
          "inset-inline-end",
          "inset-inline-start",
          "isolation",
          "justify-content",
          "justify-items",
          "justify-self",
          "left",
          "letter-spacing",
          "line-break",
          "line-height",
          "line-height-step",
          "line-stacking",
          "line-stacking-ruby",
          "line-stacking-shift",
          "line-stacking-strategy",
          "list-style",
          "list-style-image",
          "list-style-position",
          "list-style-type",
          "margin",
          "margin-bottom",
          "margin-left",
          "margin-right",
          "margin-top",
          "marks",
          "marquee-direction",
          "marquee-loop",
          "marquee-play-count",
          "marquee-speed",
          "marquee-style",
          "mask-clip",
          "mask-composite",
          "mask-image",
          "mask-mode",
          "mask-origin",
          "mask-position",
          "mask-repeat",
          "mask-size",
          "mask-type",
          "max-block-size",
          "max-height",
          "max-inline-size",
          "max-width",
          "min-block-size",
          "min-height",
          "min-inline-size",
          "min-width",
          "mix-blend-mode",
          "move-to",
          "nav-down",
          "nav-index",
          "nav-left",
          "nav-right",
          "nav-up",
          "object-fit",
          "object-position",
          "offset",
          "offset-anchor",
          "offset-distance",
          "offset-path",
          "offset-position",
          "offset-rotate",
          "opacity",
          "order",
          "orphans",
          "outline",
          "outline-color",
          "outline-offset",
          "outline-style",
          "outline-width",
          "overflow",
          "overflow-style",
          "overflow-wrap",
          "overflow-x",
          "overflow-y",
          "padding",
          "padding-bottom",
          "padding-left",
          "padding-right",
          "padding-top",
          "page",
          "page-break-after",
          "page-break-before",
          "page-break-inside",
          "page-policy",
          "pause",
          "pause-after",
          "pause-before",
          "perspective",
          "perspective-origin",
          "pitch",
          "pitch-range",
          "place-content",
          "place-items",
          "place-self",
          "play-during",
          "position",
          "presentation-level",
          "punctuation-trim",
          "quotes",
          "region-break-after",
          "region-break-before",
          "region-break-inside",
          "region-fragment",
          "rendering-intent",
          "resize",
          "rest",
          "rest-after",
          "rest-before",
          "richness",
          "right",
          "rotate",
          "rotation",
          "rotation-point",
          "row-gap",
          "ruby-align",
          "ruby-overhang",
          "ruby-position",
          "ruby-span",
          "scale",
          "scroll-behavior",
          "scroll-margin",
          "scroll-margin-block",
          "scroll-margin-block-end",
          "scroll-margin-block-start",
          "scroll-margin-bottom",
          "scroll-margin-inline",
          "scroll-margin-inline-end",
          "scroll-margin-inline-start",
          "scroll-margin-left",
          "scroll-margin-right",
          "scroll-margin-top",
          "scroll-padding",
          "scroll-padding-block",
          "scroll-padding-block-end",
          "scroll-padding-block-start",
          "scroll-padding-bottom",
          "scroll-padding-inline",
          "scroll-padding-inline-end",
          "scroll-padding-inline-start",
          "scroll-padding-left",
          "scroll-padding-right",
          "scroll-padding-top",
          "scroll-snap-align",
          "scroll-snap-type",
          "shape-image-threshold",
          "shape-inside",
          "shape-margin",
          "shape-outside",
          "size",
          "speak",
          "speak-as",
          "speak-header",
          "speak-numeral",
          "speak-punctuation",
          "speech-rate",
          "stress",
          "string-set",
          "tab-size",
          "table-layout",
          "target",
          "target-name",
          "target-new",
          "target-position",
          "text-align",
          "text-align-last",
          "text-combine-upright",
          "text-decoration",
          "text-decoration-color",
          "text-decoration-line",
          "text-decoration-skip",
          "text-decoration-skip-ink",
          "text-decoration-style",
          "text-emphasis",
          "text-emphasis-color",
          "text-emphasis-position",
          "text-emphasis-style",
          "text-height",
          "text-indent",
          "text-justify",
          "text-orientation",
          "text-outline",
          "text-overflow",
          "text-rendering",
          "text-shadow",
          "text-size-adjust",
          "text-space-collapse",
          "text-transform",
          "text-underline-position",
          "text-wrap",
          "top",
          "touch-action",
          "transform",
          "transform-origin",
          "transform-style",
          "transition",
          "transition-delay",
          "transition-duration",
          "transition-property",
          "transition-timing-function",
          "translate",
          "unicode-bidi",
          "user-select",
          "vertical-align",
          "visibility",
          "voice-balance",
          "voice-duration",
          "voice-family",
          "voice-pitch",
          "voice-range",
          "voice-rate",
          "voice-stress",
          "voice-volume",
          "volume",
          "white-space",
          "widows",
          "width",
          "will-change",
          "word-break",
          "word-spacing",
          "word-wrap",
          "writing-mode",
          "z-index",
          "clip-path",
          "clip-rule",
          "mask",
          "enable-background",
          "filter",
          "flood-color",
          "flood-opacity",
          "lighting-color",
          "stop-color",
          "stop-opacity",
          "pointer-events",
          "color-interpolation",
          "color-interpolation-filters",
          "color-rendering",
          "fill",
          "fill-opacity",
          "fill-rule",
          "image-rendering",
          "marker",
          "marker-end",
          "marker-mid",
          "marker-start",
          "paint-order",
          "shape-rendering",
          "stroke",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-rendering",
          "baseline-shift",
          "dominant-baseline",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "text-anchor",
          "writing-mode"
        ], propertyKeywords = keySet(propertyKeywords_);
        var nonStandardPropertyKeywords_ = [
          "border-block",
          "border-block-color",
          "border-block-end",
          "border-block-end-color",
          "border-block-end-style",
          "border-block-end-width",
          "border-block-start",
          "border-block-start-color",
          "border-block-start-style",
          "border-block-start-width",
          "border-block-style",
          "border-block-width",
          "border-inline",
          "border-inline-color",
          "border-inline-end",
          "border-inline-end-color",
          "border-inline-end-style",
          "border-inline-end-width",
          "border-inline-start",
          "border-inline-start-color",
          "border-inline-start-style",
          "border-inline-start-width",
          "border-inline-style",
          "border-inline-width",
          "margin-block",
          "margin-block-end",
          "margin-block-start",
          "margin-inline",
          "margin-inline-end",
          "margin-inline-start",
          "padding-block",
          "padding-block-end",
          "padding-block-start",
          "padding-inline",
          "padding-inline-end",
          "padding-inline-start",
          "scroll-snap-stop",
          "scrollbar-3d-light-color",
          "scrollbar-arrow-color",
          "scrollbar-base-color",
          "scrollbar-dark-shadow-color",
          "scrollbar-face-color",
          "scrollbar-highlight-color",
          "scrollbar-shadow-color",
          "scrollbar-track-color",
          "searchfield-cancel-button",
          "searchfield-decoration",
          "searchfield-results-button",
          "searchfield-results-decoration",
          "shape-inside",
          "zoom"
        ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);
        var fontProperties_ = [
          "font-display",
          "font-family",
          "src",
          "unicode-range",
          "font-variant",
          "font-feature-settings",
          "font-stretch",
          "font-weight",
          "font-style"
        ], fontProperties = keySet(fontProperties_);
        var counterDescriptors_ = [
          "additive-symbols",
          "fallback",
          "negative",
          "pad",
          "prefix",
          "range",
          "speak-as",
          "suffix",
          "symbols",
          "system"
        ], counterDescriptors = keySet(counterDescriptors_);
        var colorKeywords_ = [
          "aliceblue",
          "antiquewhite",
          "aqua",
          "aquamarine",
          "azure",
          "beige",
          "bisque",
          "black",
          "blanchedalmond",
          "blue",
          "blueviolet",
          "brown",
          "burlywood",
          "cadetblue",
          "chartreuse",
          "chocolate",
          "coral",
          "cornflowerblue",
          "cornsilk",
          "crimson",
          "cyan",
          "darkblue",
          "darkcyan",
          "darkgoldenrod",
          "darkgray",
          "darkgreen",
          "darkkhaki",
          "darkmagenta",
          "darkolivegreen",
          "darkorange",
          "darkorchid",
          "darkred",
          "darksalmon",
          "darkseagreen",
          "darkslateblue",
          "darkslategray",
          "darkturquoise",
          "darkviolet",
          "deeppink",
          "deepskyblue",
          "dimgray",
          "dodgerblue",
          "firebrick",
          "floralwhite",
          "forestgreen",
          "fuchsia",
          "gainsboro",
          "ghostwhite",
          "gold",
          "goldenrod",
          "gray",
          "grey",
          "green",
          "greenyellow",
          "honeydew",
          "hotpink",
          "indianred",
          "indigo",
          "ivory",
          "khaki",
          "lavender",
          "lavenderblush",
          "lawngreen",
          "lemonchiffon",
          "lightblue",
          "lightcoral",
          "lightcyan",
          "lightgoldenrodyellow",
          "lightgray",
          "lightgreen",
          "lightpink",
          "lightsalmon",
          "lightseagreen",
          "lightskyblue",
          "lightslategray",
          "lightsteelblue",
          "lightyellow",
          "lime",
          "limegreen",
          "linen",
          "magenta",
          "maroon",
          "mediumaquamarine",
          "mediumblue",
          "mediumorchid",
          "mediumpurple",
          "mediumseagreen",
          "mediumslateblue",
          "mediumspringgreen",
          "mediumturquoise",
          "mediumvioletred",
          "midnightblue",
          "mintcream",
          "mistyrose",
          "moccasin",
          "navajowhite",
          "navy",
          "oldlace",
          "olive",
          "olivedrab",
          "orange",
          "orangered",
          "orchid",
          "palegoldenrod",
          "palegreen",
          "paleturquoise",
          "palevioletred",
          "papayawhip",
          "peachpuff",
          "peru",
          "pink",
          "plum",
          "powderblue",
          "purple",
          "rebeccapurple",
          "red",
          "rosybrown",
          "royalblue",
          "saddlebrown",
          "salmon",
          "sandybrown",
          "seagreen",
          "seashell",
          "sienna",
          "silver",
          "skyblue",
          "slateblue",
          "slategray",
          "snow",
          "springgreen",
          "steelblue",
          "tan",
          "teal",
          "thistle",
          "tomato",
          "turquoise",
          "violet",
          "wheat",
          "white",
          "whitesmoke",
          "yellow",
          "yellowgreen"
        ], colorKeywords = keySet(colorKeywords_);
        var valueKeywords_ = [
          "above",
          "absolute",
          "activeborder",
          "additive",
          "activecaption",
          "afar",
          "after-white-space",
          "ahead",
          "alias",
          "all",
          "all-scroll",
          "alphabetic",
          "alternate",
          "always",
          "amharic",
          "amharic-abegede",
          "antialiased",
          "appworkspace",
          "arabic-indic",
          "armenian",
          "asterisks",
          "attr",
          "auto",
          "auto-flow",
          "avoid",
          "avoid-column",
          "avoid-page",
          "avoid-region",
          "axis-pan",
          "background",
          "backwards",
          "baseline",
          "below",
          "bidi-override",
          "binary",
          "bengali",
          "blink",
          "block",
          "block-axis",
          "bold",
          "bolder",
          "border",
          "border-box",
          "both",
          "bottom",
          "break",
          "break-all",
          "break-word",
          "bullets",
          "button",
          "button-bevel",
          "buttonface",
          "buttonhighlight",
          "buttonshadow",
          "buttontext",
          "calc",
          "cambodian",
          "capitalize",
          "caps-lock-indicator",
          "caption",
          "captiontext",
          "caret",
          "cell",
          "center",
          "checkbox",
          "circle",
          "cjk-decimal",
          "cjk-earthly-branch",
          "cjk-heavenly-stem",
          "cjk-ideographic",
          "clear",
          "clip",
          "close-quote",
          "col-resize",
          "collapse",
          "color",
          "color-burn",
          "color-dodge",
          "column",
          "column-reverse",
          "compact",
          "condensed",
          "contain",
          "content",
          "contents",
          "content-box",
          "context-menu",
          "continuous",
          "copy",
          "counter",
          "counters",
          "cover",
          "crop",
          "cross",
          "crosshair",
          "currentcolor",
          "cursive",
          "cyclic",
          "darken",
          "dashed",
          "decimal",
          "decimal-leading-zero",
          "default",
          "default-button",
          "dense",
          "destination-atop",
          "destination-in",
          "destination-out",
          "destination-over",
          "devanagari",
          "difference",
          "disc",
          "discard",
          "disclosure-closed",
          "disclosure-open",
          "document",
          "dot-dash",
          "dot-dot-dash",
          "dotted",
          "double",
          "down",
          "e-resize",
          "ease",
          "ease-in",
          "ease-in-out",
          "ease-out",
          "element",
          "ellipse",
          "ellipsis",
          "embed",
          "end",
          "ethiopic",
          "ethiopic-abegede",
          "ethiopic-abegede-am-et",
          "ethiopic-abegede-gez",
          "ethiopic-abegede-ti-er",
          "ethiopic-abegede-ti-et",
          "ethiopic-halehame-aa-er",
          "ethiopic-halehame-aa-et",
          "ethiopic-halehame-am-et",
          "ethiopic-halehame-gez",
          "ethiopic-halehame-om-et",
          "ethiopic-halehame-sid-et",
          "ethiopic-halehame-so-et",
          "ethiopic-halehame-ti-er",
          "ethiopic-halehame-ti-et",
          "ethiopic-halehame-tig",
          "ethiopic-numeric",
          "ew-resize",
          "exclusion",
          "expanded",
          "extends",
          "extra-condensed",
          "extra-expanded",
          "fantasy",
          "fast",
          "fill",
          "fill-box",
          "fixed",
          "flat",
          "flex",
          "flex-end",
          "flex-start",
          "footnotes",
          "forwards",
          "from",
          "geometricPrecision",
          "georgian",
          "graytext",
          "grid",
          "groove",
          "gujarati",
          "gurmukhi",
          "hand",
          "hangul",
          "hangul-consonant",
          "hard-light",
          "hebrew",
          "help",
          "hidden",
          "hide",
          "higher",
          "highlight",
          "highlighttext",
          "hiragana",
          "hiragana-iroha",
          "horizontal",
          "hsl",
          "hsla",
          "hue",
          "icon",
          "ignore",
          "inactiveborder",
          "inactivecaption",
          "inactivecaptiontext",
          "infinite",
          "infobackground",
          "infotext",
          "inherit",
          "initial",
          "inline",
          "inline-axis",
          "inline-block",
          "inline-flex",
          "inline-grid",
          "inline-table",
          "inset",
          "inside",
          "intrinsic",
          "invert",
          "italic",
          "japanese-formal",
          "japanese-informal",
          "justify",
          "kannada",
          "katakana",
          "katakana-iroha",
          "keep-all",
          "khmer",
          "korean-hangul-formal",
          "korean-hanja-formal",
          "korean-hanja-informal",
          "landscape",
          "lao",
          "large",
          "larger",
          "left",
          "level",
          "lighter",
          "lighten",
          "line-through",
          "linear",
          "linear-gradient",
          "lines",
          "list-item",
          "listbox",
          "listitem",
          "local",
          "logical",
          "loud",
          "lower",
          "lower-alpha",
          "lower-armenian",
          "lower-greek",
          "lower-hexadecimal",
          "lower-latin",
          "lower-norwegian",
          "lower-roman",
          "lowercase",
          "ltr",
          "luminosity",
          "malayalam",
          "manipulation",
          "match",
          "matrix",
          "matrix3d",
          "media-controls-background",
          "media-current-time-display",
          "media-fullscreen-button",
          "media-mute-button",
          "media-play-button",
          "media-return-to-realtime-button",
          "media-rewind-button",
          "media-seek-back-button",
          "media-seek-forward-button",
          "media-slider",
          "media-sliderthumb",
          "media-time-remaining-display",
          "media-volume-slider",
          "media-volume-slider-container",
          "media-volume-sliderthumb",
          "medium",
          "menu",
          "menulist",
          "menulist-button",
          "menulist-text",
          "menulist-textfield",
          "menutext",
          "message-box",
          "middle",
          "min-intrinsic",
          "mix",
          "mongolian",
          "monospace",
          "move",
          "multiple",
          "multiple_mask_images",
          "multiply",
          "myanmar",
          "n-resize",
          "narrower",
          "ne-resize",
          "nesw-resize",
          "no-close-quote",
          "no-drop",
          "no-open-quote",
          "no-repeat",
          "none",
          "normal",
          "not-allowed",
          "nowrap",
          "ns-resize",
          "numbers",
          "numeric",
          "nw-resize",
          "nwse-resize",
          "oblique",
          "octal",
          "opacity",
          "open-quote",
          "optimizeLegibility",
          "optimizeSpeed",
          "oriya",
          "oromo",
          "outset",
          "outside",
          "outside-shape",
          "overlay",
          "overline",
          "padding",
          "padding-box",
          "painted",
          "page",
          "paused",
          "persian",
          "perspective",
          "pinch-zoom",
          "plus-darker",
          "plus-lighter",
          "pointer",
          "polygon",
          "portrait",
          "pre",
          "pre-line",
          "pre-wrap",
          "preserve-3d",
          "progress",
          "push-button",
          "radial-gradient",
          "radio",
          "read-only",
          "read-write",
          "read-write-plaintext-only",
          "rectangle",
          "region",
          "relative",
          "repeat",
          "repeating-linear-gradient",
          "repeating-radial-gradient",
          "repeat-x",
          "repeat-y",
          "reset",
          "reverse",
          "rgb",
          "rgba",
          "ridge",
          "right",
          "rotate",
          "rotate3d",
          "rotateX",
          "rotateY",
          "rotateZ",
          "round",
          "row",
          "row-resize",
          "row-reverse",
          "rtl",
          "run-in",
          "running",
          "s-resize",
          "sans-serif",
          "saturation",
          "scale",
          "scale3d",
          "scaleX",
          "scaleY",
          "scaleZ",
          "screen",
          "scroll",
          "scrollbar",
          "scroll-position",
          "se-resize",
          "searchfield",
          "searchfield-cancel-button",
          "searchfield-decoration",
          "searchfield-results-button",
          "searchfield-results-decoration",
          "self-start",
          "self-end",
          "semi-condensed",
          "semi-expanded",
          "separate",
          "serif",
          "show",
          "sidama",
          "simp-chinese-formal",
          "simp-chinese-informal",
          "single",
          "skew",
          "skewX",
          "skewY",
          "skip-white-space",
          "slide",
          "slider-horizontal",
          "slider-vertical",
          "sliderthumb-horizontal",
          "sliderthumb-vertical",
          "slow",
          "small",
          "small-caps",
          "small-caption",
          "smaller",
          "soft-light",
          "solid",
          "somali",
          "source-atop",
          "source-in",
          "source-out",
          "source-over",
          "space",
          "space-around",
          "space-between",
          "space-evenly",
          "spell-out",
          "square",
          "square-button",
          "start",
          "static",
          "status-bar",
          "stretch",
          "stroke",
          "stroke-box",
          "sub",
          "subpixel-antialiased",
          "svg_masks",
          "super",
          "sw-resize",
          "symbolic",
          "symbols",
          "system-ui",
          "table",
          "table-caption",
          "table-cell",
          "table-column",
          "table-column-group",
          "table-footer-group",
          "table-header-group",
          "table-row",
          "table-row-group",
          "tamil",
          "telugu",
          "text",
          "text-bottom",
          "text-top",
          "textarea",
          "textfield",
          "thai",
          "thick",
          "thin",
          "threeddarkshadow",
          "threedface",
          "threedhighlight",
          "threedlightshadow",
          "threedshadow",
          "tibetan",
          "tigre",
          "tigrinya-er",
          "tigrinya-er-abegede",
          "tigrinya-et",
          "tigrinya-et-abegede",
          "to",
          "top",
          "trad-chinese-formal",
          "trad-chinese-informal",
          "transform",
          "translate",
          "translate3d",
          "translateX",
          "translateY",
          "translateZ",
          "transparent",
          "ultra-condensed",
          "ultra-expanded",
          "underline",
          "unidirectional-pan",
          "unset",
          "up",
          "upper-alpha",
          "upper-armenian",
          "upper-greek",
          "upper-hexadecimal",
          "upper-latin",
          "upper-norwegian",
          "upper-roman",
          "uppercase",
          "urdu",
          "url",
          "var",
          "vertical",
          "vertical-text",
          "view-box",
          "visible",
          "visibleFill",
          "visiblePainted",
          "visibleStroke",
          "visual",
          "w-resize",
          "wait",
          "wave",
          "wider",
          "window",
          "windowframe",
          "windowtext",
          "words",
          "wrap",
          "wrap-reverse",
          "x-large",
          "x-small",
          "xor",
          "xx-large",
          "xx-small"
        ], valueKeywords = keySet(valueKeywords_);
        var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_).concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_).concat(valueKeywords_);
        CodeMirror3.registerHelper("hintWords", "css", allWords);
        function tokenCComment(stream, state) {
          var maybeEnd = false, ch;
          while ((ch = stream.next()) != null) {
            if (maybeEnd && ch == "/") {
              state.tokenize = null;
              break;
            }
            maybeEnd = ch == "*";
          }
          return ["comment", "comment"];
        }
        CodeMirror3.defineMIME("text/css", {
          documentTypes,
          mediaTypes,
          mediaFeatures,
          mediaValueKeywords,
          propertyKeywords,
          nonStandardPropertyKeywords,
          fontProperties,
          counterDescriptors,
          colorKeywords,
          valueKeywords,
          tokenHooks: {
            "/": function(stream, state) {
              if (!stream.eat("*"))
                return false;
              state.tokenize = tokenCComment;
              return tokenCComment(stream, state);
            }
          },
          name: "css"
        });
        CodeMirror3.defineMIME("text/x-scss", {
          mediaTypes,
          mediaFeatures,
          mediaValueKeywords,
          propertyKeywords,
          nonStandardPropertyKeywords,
          colorKeywords,
          valueKeywords,
          fontProperties,
          allowNested: true,
          lineComment: "//",
          tokenHooks: {
            "/": function(stream, state) {
              if (stream.eat("/")) {
                stream.skipToEnd();
                return ["comment", "comment"];
              } else if (stream.eat("*")) {
                state.tokenize = tokenCComment;
                return tokenCComment(stream, state);
              } else {
                return ["operator", "operator"];
              }
            },
            ":": function(stream) {
              if (stream.match(/^\s*\{/, false))
                return [null, null];
              return false;
            },
            "$": function(stream) {
              stream.match(/^[\w-]+/);
              if (stream.match(/^\s*:/, false))
                return ["variable-2", "variable-definition"];
              return ["variable-2", "variable"];
            },
            "#": function(stream) {
              if (!stream.eat("{"))
                return false;
              return [null, "interpolation"];
            }
          },
          name: "css",
          helperType: "scss"
        });
        CodeMirror3.defineMIME("text/x-less", {
          mediaTypes,
          mediaFeatures,
          mediaValueKeywords,
          propertyKeywords,
          nonStandardPropertyKeywords,
          colorKeywords,
          valueKeywords,
          fontProperties,
          allowNested: true,
          lineComment: "//",
          tokenHooks: {
            "/": function(stream, state) {
              if (stream.eat("/")) {
                stream.skipToEnd();
                return ["comment", "comment"];
              } else if (stream.eat("*")) {
                state.tokenize = tokenCComment;
                return tokenCComment(stream, state);
              } else {
                return ["operator", "operator"];
              }
            },
            "@": function(stream) {
              if (stream.eat("{"))
                return [null, "interpolation"];
              if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/i, false))
                return false;
              stream.eatWhile(/[\w\\\-]/);
              if (stream.match(/^\s*:/, false))
                return ["variable-2", "variable-definition"];
              return ["variable-2", "variable"];
            },
            "&": function() {
              return ["atom", "atom"];
            }
          },
          name: "css",
          helperType: "less"
        });
        CodeMirror3.defineMIME("text/x-gss", {
          documentTypes,
          mediaTypes,
          mediaFeatures,
          propertyKeywords,
          nonStandardPropertyKeywords,
          fontProperties,
          counterDescriptors,
          colorKeywords,
          valueKeywords,
          supportsAtComponent: true,
          tokenHooks: {
            "/": function(stream, state) {
              if (!stream.eat("*"))
                return false;
              state.tokenize = tokenCComment;
              return tokenCComment(stream, state);
            }
          },
          name: "css",
          helperType: "gss"
        });
      });
    }
  });

  // node_modules/codemirror/addon/mode/simple.js
  var require_simple = __commonJS({
    "node_modules/codemirror/addon/mode/simple.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.defineSimpleMode = function(name, states) {
          CodeMirror3.defineMode(name, function(config) {
            return CodeMirror3.simpleMode(config, states);
          });
        };
        CodeMirror3.simpleMode = function(config, states) {
          ensureState(states, "start");
          var states_ = {}, meta = states.meta || {}, hasIndentation = false;
          for (var state in states)
            if (state != meta && states.hasOwnProperty(state)) {
              var list = states_[state] = [], orig = states[state];
              for (var i2 = 0; i2 < orig.length; i2++) {
                var data = orig[i2];
                list.push(new Rule(data, states));
                if (data.indent || data.dedent)
                  hasIndentation = true;
              }
            }
          var mode = {
            startState: function() {
              return {
                state: "start",
                pending: null,
                local: null,
                localState: null,
                indent: hasIndentation ? [] : null
              };
            },
            copyState: function(state2) {
              var s2 = {
                state: state2.state,
                pending: state2.pending,
                local: state2.local,
                localState: null,
                indent: state2.indent && state2.indent.slice(0)
              };
              if (state2.localState)
                s2.localState = CodeMirror3.copyState(state2.local.mode, state2.localState);
              if (state2.stack)
                s2.stack = state2.stack.slice(0);
              for (var pers = state2.persistentStates; pers; pers = pers.next)
                s2.persistentStates = {
                  mode: pers.mode,
                  spec: pers.spec,
                  state: pers.state == state2.localState ? s2.localState : CodeMirror3.copyState(pers.mode, pers.state),
                  next: s2.persistentStates
                };
              return s2;
            },
            token: tokenFunction(states_, config),
            innerMode: function(state2) {
              return state2.local && { mode: state2.local.mode, state: state2.localState };
            },
            indent: indentFunction(states_, meta)
          };
          if (meta) {
            for (var prop in meta)
              if (meta.hasOwnProperty(prop))
                mode[prop] = meta[prop];
          }
          return mode;
        };
        function ensureState(states, name) {
          if (!states.hasOwnProperty(name))
            throw new Error("Undefined state " + name + " in simple mode");
        }
        function toRegex(val, caret) {
          if (!val)
            return /(?:)/;
          var flags = "";
          if (val instanceof RegExp) {
            if (val.ignoreCase)
              flags = "i";
            val = val.source;
          } else {
            val = String(val);
          }
          return new RegExp((caret === false ? "" : "^") + "(?:" + val + ")", flags);
        }
        function asToken(val) {
          if (!val)
            return null;
          if (val.apply)
            return val;
          if (typeof val == "string")
            return val.replace(/\./g, " ");
          var result = [];
          for (var i2 = 0; i2 < val.length; i2++)
            result.push(val[i2] && val[i2].replace(/\./g, " "));
          return result;
        }
        function Rule(data, states) {
          if (data.next || data.push)
            ensureState(states, data.next || data.push);
          this.regex = toRegex(data.regex);
          this.token = asToken(data.token);
          this.data = data;
        }
        function tokenFunction(states, config) {
          return function(stream, state) {
            if (state.pending) {
              var pend = state.pending.shift();
              if (state.pending.length == 0)
                state.pending = null;
              stream.pos += pend.text.length;
              return pend.token;
            }
            if (state.local) {
              if (state.local.end && stream.match(state.local.end)) {
                var tok = state.local.endToken || null;
                state.local = state.localState = null;
                return tok;
              } else {
                var tok = state.local.mode.token(stream, state.localState), m2;
                if (state.local.endScan && (m2 = state.local.endScan.exec(stream.current())))
                  stream.pos = stream.start + m2.index;
                return tok;
              }
            }
            var curState = states[state.state];
            for (var i2 = 0; i2 < curState.length; i2++) {
              var rule = curState[i2];
              var matches = (!rule.data.sol || stream.sol()) && stream.match(rule.regex);
              if (matches) {
                if (rule.data.next) {
                  state.state = rule.data.next;
                } else if (rule.data.push) {
                  (state.stack || (state.stack = [])).push(state.state);
                  state.state = rule.data.push;
                } else if (rule.data.pop && state.stack && state.stack.length) {
                  state.state = state.stack.pop();
                }
                if (rule.data.mode)
                  enterLocalMode(config, state, rule.data.mode, rule.token);
                if (rule.data.indent)
                  state.indent.push(stream.indentation() + config.indentUnit);
                if (rule.data.dedent)
                  state.indent.pop();
                var token = rule.token;
                if (token && token.apply)
                  token = token(matches);
                if (matches.length > 2 && rule.token && typeof rule.token != "string") {
                  state.pending = [];
                  for (var j2 = 2; j2 < matches.length; j2++)
                    if (matches[j2])
                      state.pending.push({ text: matches[j2], token: rule.token[j2 - 1] });
                  stream.backUp(matches[0].length - (matches[1] ? matches[1].length : 0));
                  return token[0];
                } else if (token && token.join) {
                  return token[0];
                } else {
                  return token;
                }
              }
            }
            stream.next();
            return null;
          };
        }
        function cmp(a2, b2) {
          if (a2 === b2)
            return true;
          if (!a2 || typeof a2 != "object" || !b2 || typeof b2 != "object")
            return false;
          var props = 0;
          for (var prop in a2)
            if (a2.hasOwnProperty(prop)) {
              if (!b2.hasOwnProperty(prop) || !cmp(a2[prop], b2[prop]))
                return false;
              props++;
            }
          for (var prop in b2)
            if (b2.hasOwnProperty(prop))
              props--;
          return props == 0;
        }
        function enterLocalMode(config, state, spec, token) {
          var pers;
          if (spec.persistent) {
            for (var p2 = state.persistentStates; p2 && !pers; p2 = p2.next)
              if (spec.spec ? cmp(spec.spec, p2.spec) : spec.mode == p2.mode)
                pers = p2;
          }
          var mode = pers ? pers.mode : spec.mode || CodeMirror3.getMode(config, spec.spec);
          var lState = pers ? pers.state : CodeMirror3.startState(mode);
          if (spec.persistent && !pers)
            state.persistentStates = { mode, spec: spec.spec, state: lState, next: state.persistentStates };
          state.localState = lState;
          state.local = {
            mode,
            end: spec.end && toRegex(spec.end),
            endScan: spec.end && spec.forceEnd !== false && toRegex(spec.end, false),
            endToken: token && token.join ? token[token.length - 1] : token
          };
        }
        function indexOf2(val, arr) {
          for (var i2 = 0; i2 < arr.length; i2++)
            if (arr[i2] === val)
              return true;
        }
        function indentFunction(states, meta) {
          return function(state, textAfter, line) {
            if (state.local && state.local.mode.indent)
              return state.local.mode.indent(state.localState, textAfter, line);
            if (state.indent == null || state.local || meta.dontIndentStates && indexOf2(state.state, meta.dontIndentStates) > -1)
              return CodeMirror3.Pass;
            var pos = state.indent.length - 1, rules = states[state.state];
            scan:
              for (; ; ) {
                for (var i2 = 0; i2 < rules.length; i2++) {
                  var rule = rules[i2];
                  if (rule.data.dedent && rule.data.dedentIfLineStart !== false) {
                    var m2 = rule.regex.exec(textAfter);
                    if (m2 && m2[0]) {
                      pos--;
                      if (rule.next || rule.push)
                        rules = states[rule.next || rule.push];
                      textAfter = textAfter.slice(m2[0].length);
                      continue scan;
                    }
                  }
                }
                break;
              }
            return pos < 0 ? 0 : state.indent[pos];
          };
        }
      });
    }
  });

  // node_modules/codemirror/mode/dockerfile/dockerfile.js
  var require_dockerfile = __commonJS({
    "node_modules/codemirror/mode/dockerfile/dockerfile.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror(), require_simple());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror", "../../addon/mode/simple"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        var from = "from";
        var fromRegex = new RegExp("^(\\s*)\\b(" + from + ")\\b", "i");
        var shells = ["run", "cmd", "entrypoint", "shell"];
        var shellsAsArrayRegex = new RegExp("^(\\s*)(" + shells.join("|") + ")(\\s+\\[)", "i");
        var expose = "expose";
        var exposeRegex = new RegExp("^(\\s*)(" + expose + ")(\\s+)", "i");
        var others = [
          "arg",
          "from",
          "maintainer",
          "label",
          "env",
          "add",
          "copy",
          "volume",
          "user",
          "workdir",
          "onbuild",
          "stopsignal",
          "healthcheck",
          "shell"
        ];
        var instructions = [from, expose].concat(shells).concat(others), instructionRegex = "(" + instructions.join("|") + ")", instructionOnlyLine = new RegExp("^(\\s*)" + instructionRegex + "(\\s*)(#.*)?$", "i"), instructionWithArguments = new RegExp("^(\\s*)" + instructionRegex + "(\\s+)", "i");
        CodeMirror3.defineSimpleMode("dockerfile", {
          start: [
            {
              regex: /^\s*#.*$/,
              sol: true,
              token: "comment"
            },
            {
              regex: fromRegex,
              token: [null, "keyword"],
              sol: true,
              next: "from"
            },
            {
              regex: instructionOnlyLine,
              token: [null, "keyword", null, "error"],
              sol: true
            },
            {
              regex: shellsAsArrayRegex,
              token: [null, "keyword", null],
              sol: true,
              next: "array"
            },
            {
              regex: exposeRegex,
              token: [null, "keyword", null],
              sol: true,
              next: "expose"
            },
            {
              regex: instructionWithArguments,
              token: [null, "keyword", null],
              sol: true,
              next: "arguments"
            },
            {
              regex: /./,
              token: null
            }
          ],
          from: [
            {
              regex: /\s*$/,
              token: null,
              next: "start"
            },
            {
              regex: /(\s*)(#.*)$/,
              token: [null, "error"],
              next: "start"
            },
            {
              regex: /(\s*\S+\s+)(as)/i,
              token: [null, "keyword"],
              next: "start"
            },
            {
              token: null,
              next: "start"
            }
          ],
          single: [
            {
              regex: /(?:[^\\']|\\.)/,
              token: "string"
            },
            {
              regex: /'/,
              token: "string",
              pop: true
            }
          ],
          double: [
            {
              regex: /(?:[^\\"]|\\.)/,
              token: "string"
            },
            {
              regex: /"/,
              token: "string",
              pop: true
            }
          ],
          array: [
            {
              regex: /\]/,
              token: null,
              next: "start"
            },
            {
              regex: /"(?:[^\\"]|\\.)*"?/,
              token: "string"
            }
          ],
          expose: [
            {
              regex: /\d+$/,
              token: "number",
              next: "start"
            },
            {
              regex: /[^\d]+$/,
              token: null,
              next: "start"
            },
            {
              regex: /\d+/,
              token: "number"
            },
            {
              regex: /[^\d]+/,
              token: null
            },
            {
              token: null,
              next: "start"
            }
          ],
          arguments: [
            {
              regex: /^\s*#.*$/,
              sol: true,
              token: "comment"
            },
            {
              regex: /"(?:[^\\"]|\\.)*"?$/,
              token: "string",
              next: "start"
            },
            {
              regex: /"/,
              token: "string",
              push: "double"
            },
            {
              regex: /'(?:[^\\']|\\.)*'?$/,
              token: "string",
              next: "start"
            },
            {
              regex: /'/,
              token: "string",
              push: "single"
            },
            {
              regex: /[^#"']+[\\`]$/,
              token: null
            },
            {
              regex: /[^#"']+$/,
              token: null,
              next: "start"
            },
            {
              regex: /[^#"']+/,
              token: null
            },
            {
              token: null,
              next: "start"
            }
          ],
          meta: {
            lineComment: "#"
          }
        });
        CodeMirror3.defineMIME("text/x-dockerfile", "dockerfile");
      });
    }
  });

  // node_modules/codemirror/mode/xml/xml.js
  var require_xml = __commonJS({
    "node_modules/codemirror/mode/xml/xml.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        var htmlConfig = {
          autoSelfClosers: {
            "area": true,
            "base": true,
            "br": true,
            "col": true,
            "command": true,
            "embed": true,
            "frame": true,
            "hr": true,
            "img": true,
            "input": true,
            "keygen": true,
            "link": true,
            "meta": true,
            "param": true,
            "source": true,
            "track": true,
            "wbr": true,
            "menuitem": true
          },
          implicitlyClosed: {
            "dd": true,
            "li": true,
            "optgroup": true,
            "option": true,
            "p": true,
            "rp": true,
            "rt": true,
            "tbody": true,
            "td": true,
            "tfoot": true,
            "th": true,
            "tr": true
          },
          contextGrabbers: {
            "dd": { "dd": true, "dt": true },
            "dt": { "dd": true, "dt": true },
            "li": { "li": true },
            "option": { "option": true, "optgroup": true },
            "optgroup": { "optgroup": true },
            "p": {
              "address": true,
              "article": true,
              "aside": true,
              "blockquote": true,
              "dir": true,
              "div": true,
              "dl": true,
              "fieldset": true,
              "footer": true,
              "form": true,
              "h1": true,
              "h2": true,
              "h3": true,
              "h4": true,
              "h5": true,
              "h6": true,
              "header": true,
              "hgroup": true,
              "hr": true,
              "menu": true,
              "nav": true,
              "ol": true,
              "p": true,
              "pre": true,
              "section": true,
              "table": true,
              "ul": true
            },
            "rp": { "rp": true, "rt": true },
            "rt": { "rp": true, "rt": true },
            "tbody": { "tbody": true, "tfoot": true },
            "td": { "td": true, "th": true },
            "tfoot": { "tbody": true },
            "th": { "td": true, "th": true },
            "thead": { "tbody": true, "tfoot": true },
            "tr": { "tr": true }
          },
          doNotIndent: { "pre": true },
          allowUnquoted: true,
          allowMissing: true,
          caseFold: true
        };
        var xmlConfig = {
          autoSelfClosers: {},
          implicitlyClosed: {},
          contextGrabbers: {},
          doNotIndent: {},
          allowUnquoted: false,
          allowMissing: false,
          allowMissingTagName: false,
          caseFold: false
        };
        CodeMirror3.defineMode("xml", function(editorConf, config_) {
          var indentUnit = editorConf.indentUnit;
          var config = {};
          var defaults2 = config_.htmlMode ? htmlConfig : xmlConfig;
          for (var prop in defaults2)
            config[prop] = defaults2[prop];
          for (var prop in config_)
            config[prop] = config_[prop];
          var type, setStyle2;
          function inText(stream, state) {
            function chain(parser) {
              state.tokenize = parser;
              return parser(stream, state);
            }
            var ch = stream.next();
            if (ch == "<") {
              if (stream.eat("!")) {
                if (stream.eat("[")) {
                  if (stream.match("CDATA["))
                    return chain(inBlock("atom", "]]>"));
                  else
                    return null;
                } else if (stream.match("--")) {
                  return chain(inBlock("comment", "-->"));
                } else if (stream.match("DOCTYPE", true, true)) {
                  stream.eatWhile(/[\w\._\-]/);
                  return chain(doctype(1));
                } else {
                  return null;
                }
              } else if (stream.eat("?")) {
                stream.eatWhile(/[\w\._\-]/);
                state.tokenize = inBlock("meta", "?>");
                return "meta";
              } else {
                type = stream.eat("/") ? "closeTag" : "openTag";
                state.tokenize = inTag;
                return "tag bracket";
              }
            } else if (ch == "&") {
              var ok;
              if (stream.eat("#")) {
                if (stream.eat("x")) {
                  ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
                } else {
                  ok = stream.eatWhile(/[\d]/) && stream.eat(";");
                }
              } else {
                ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
              }
              return ok ? "atom" : "error";
            } else {
              stream.eatWhile(/[^&<]/);
              return null;
            }
          }
          inText.isInText = true;
          function inTag(stream, state) {
            var ch = stream.next();
            if (ch == ">" || ch == "/" && stream.eat(">")) {
              state.tokenize = inText;
              type = ch == ">" ? "endTag" : "selfcloseTag";
              return "tag bracket";
            } else if (ch == "=") {
              type = "equals";
              return null;
            } else if (ch == "<") {
              state.tokenize = inText;
              state.state = baseState;
              state.tagName = state.tagStart = null;
              var next = state.tokenize(stream, state);
              return next ? next + " tag error" : "tag error";
            } else if (/[\'\"]/.test(ch)) {
              state.tokenize = inAttribute(ch);
              state.stringStartCol = stream.column();
              return state.tokenize(stream, state);
            } else {
              stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
              return "word";
            }
          }
          function inAttribute(quote) {
            var closure = function(stream, state) {
              while (!stream.eol()) {
                if (stream.next() == quote) {
                  state.tokenize = inTag;
                  break;
                }
              }
              return "string";
            };
            closure.isInAttribute = true;
            return closure;
          }
          function inBlock(style, terminator) {
            return function(stream, state) {
              while (!stream.eol()) {
                if (stream.match(terminator)) {
                  state.tokenize = inText;
                  break;
                }
                stream.next();
              }
              return style;
            };
          }
          function doctype(depth) {
            return function(stream, state) {
              var ch;
              while ((ch = stream.next()) != null) {
                if (ch == "<") {
                  state.tokenize = doctype(depth + 1);
                  return state.tokenize(stream, state);
                } else if (ch == ">") {
                  if (depth == 1) {
                    state.tokenize = inText;
                    break;
                  } else {
                    state.tokenize = doctype(depth - 1);
                    return state.tokenize(stream, state);
                  }
                }
              }
              return "meta";
            };
          }
          function Context2(state, tagName, startOfLine) {
            this.prev = state.context;
            this.tagName = tagName || "";
            this.indent = state.indented;
            this.startOfLine = startOfLine;
            if (config.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent)
              this.noIndent = true;
          }
          function popContext(state) {
            if (state.context)
              state.context = state.context.prev;
          }
          function maybePopContext(state, nextTagName) {
            var parentTagName;
            while (true) {
              if (!state.context) {
                return;
              }
              parentTagName = state.context.tagName;
              if (!config.contextGrabbers.hasOwnProperty(parentTagName) || !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
                return;
              }
              popContext(state);
            }
          }
          function baseState(type2, stream, state) {
            if (type2 == "openTag") {
              state.tagStart = stream.column();
              return tagNameState;
            } else if (type2 == "closeTag") {
              return closeTagNameState;
            } else {
              return baseState;
            }
          }
          function tagNameState(type2, stream, state) {
            if (type2 == "word") {
              state.tagName = stream.current();
              setStyle2 = "tag";
              return attrState;
            } else if (config.allowMissingTagName && type2 == "endTag") {
              setStyle2 = "tag bracket";
              return attrState(type2, stream, state);
            } else {
              setStyle2 = "error";
              return tagNameState;
            }
          }
          function closeTagNameState(type2, stream, state) {
            if (type2 == "word") {
              var tagName = stream.current();
              if (state.context && state.context.tagName != tagName && config.implicitlyClosed.hasOwnProperty(state.context.tagName))
                popContext(state);
              if (state.context && state.context.tagName == tagName || config.matchClosing === false) {
                setStyle2 = "tag";
                return closeState;
              } else {
                setStyle2 = "tag error";
                return closeStateErr;
              }
            } else if (config.allowMissingTagName && type2 == "endTag") {
              setStyle2 = "tag bracket";
              return closeState(type2, stream, state);
            } else {
              setStyle2 = "error";
              return closeStateErr;
            }
          }
          function closeState(type2, _stream, state) {
            if (type2 != "endTag") {
              setStyle2 = "error";
              return closeState;
            }
            popContext(state);
            return baseState;
          }
          function closeStateErr(type2, stream, state) {
            setStyle2 = "error";
            return closeState(type2, stream, state);
          }
          function attrState(type2, _stream, state) {
            if (type2 == "word") {
              setStyle2 = "attribute";
              return attrEqState;
            } else if (type2 == "endTag" || type2 == "selfcloseTag") {
              var tagName = state.tagName, tagStart = state.tagStart;
              state.tagName = state.tagStart = null;
              if (type2 == "selfcloseTag" || config.autoSelfClosers.hasOwnProperty(tagName)) {
                maybePopContext(state, tagName);
              } else {
                maybePopContext(state, tagName);
                state.context = new Context2(state, tagName, tagStart == state.indented);
              }
              return baseState;
            }
            setStyle2 = "error";
            return attrState;
          }
          function attrEqState(type2, stream, state) {
            if (type2 == "equals")
              return attrValueState;
            if (!config.allowMissing)
              setStyle2 = "error";
            return attrState(type2, stream, state);
          }
          function attrValueState(type2, stream, state) {
            if (type2 == "string")
              return attrContinuedState;
            if (type2 == "word" && config.allowUnquoted) {
              setStyle2 = "string";
              return attrState;
            }
            setStyle2 = "error";
            return attrState(type2, stream, state);
          }
          function attrContinuedState(type2, stream, state) {
            if (type2 == "string")
              return attrContinuedState;
            return attrState(type2, stream, state);
          }
          return {
            startState: function(baseIndent) {
              var state = {
                tokenize: inText,
                state: baseState,
                indented: baseIndent || 0,
                tagName: null,
                tagStart: null,
                context: null
              };
              if (baseIndent != null)
                state.baseIndent = baseIndent;
              return state;
            },
            token: function(stream, state) {
              if (!state.tagName && stream.sol())
                state.indented = stream.indentation();
              if (stream.eatSpace())
                return null;
              type = null;
              var style = state.tokenize(stream, state);
              if ((style || type) && style != "comment") {
                setStyle2 = null;
                state.state = state.state(type || style, stream, state);
                if (setStyle2)
                  style = setStyle2 == "error" ? style + " error" : setStyle2;
              }
              return style;
            },
            indent: function(state, textAfter, fullLine) {
              var context = state.context;
              if (state.tokenize.isInAttribute) {
                if (state.tagStart == state.indented)
                  return state.stringStartCol + 1;
                else
                  return state.indented + indentUnit;
              }
              if (context && context.noIndent)
                return CodeMirror3.Pass;
              if (state.tokenize != inTag && state.tokenize != inText)
                return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
              if (state.tagName) {
                if (config.multilineTagIndentPastTag !== false)
                  return state.tagStart + state.tagName.length + 2;
                else
                  return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
              }
              if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter))
                return 0;
              var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
              if (tagAfter && tagAfter[1]) {
                while (context) {
                  if (context.tagName == tagAfter[2]) {
                    context = context.prev;
                    break;
                  } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {
                    context = context.prev;
                  } else {
                    break;
                  }
                }
              } else if (tagAfter) {
                while (context) {
                  var grabbers = config.contextGrabbers[context.tagName];
                  if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))
                    context = context.prev;
                  else
                    break;
                }
              }
              while (context && context.prev && !context.startOfLine)
                context = context.prev;
              if (context)
                return context.indent + indentUnit;
              else
                return state.baseIndent || 0;
            },
            electricInput: /<\/[\s\w:]+>$/,
            blockCommentStart: "<!--",
            blockCommentEnd: "-->",
            configuration: config.htmlMode ? "html" : "xml",
            helperType: config.htmlMode ? "html" : "xml",
            skipAttribute: function(state) {
              if (state.state == attrValueState)
                state.state = attrState;
            },
            xmlCurrentTag: function(state) {
              return state.tagName ? { name: state.tagName, close: state.type == "closeTag" } : null;
            },
            xmlCurrentContext: function(state) {
              var context = [];
              for (var cx = state.context; cx; cx = cx.prev)
                context.push(cx.tagName);
              return context.reverse();
            }
          };
        });
        CodeMirror3.defineMIME("text/xml", "xml");
        CodeMirror3.defineMIME("application/xml", "xml");
        if (!CodeMirror3.mimeModes.hasOwnProperty("text/html"))
          CodeMirror3.defineMIME("text/html", { name: "xml", htmlMode: true });
      });
    }
  });

  // node_modules/codemirror/mode/javascript/javascript.js
  var require_javascript = __commonJS({
    "node_modules/codemirror/mode/javascript/javascript.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.defineMode("javascript", function(config, parserConfig) {
          var indentUnit = config.indentUnit;
          var statementIndent = parserConfig.statementIndent;
          var jsonldMode = parserConfig.jsonld;
          var jsonMode = parserConfig.json || jsonldMode;
          var isTS = parserConfig.typescript;
          var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;
          var keywords = function() {
            function kw(type2) {
              return { type: type2, style: "keyword" };
            }
            var A2 = kw("keyword a"), B = kw("keyword b"), C2 = kw("keyword c"), D = kw("keyword d");
            var operator = kw("operator"), atom = { type: "atom", style: "atom" };
            return {
              "if": kw("if"),
              "while": A2,
              "with": A2,
              "else": B,
              "do": B,
              "try": B,
              "finally": B,
              "return": D,
              "break": D,
              "continue": D,
              "new": kw("new"),
              "delete": C2,
              "void": C2,
              "throw": C2,
              "debugger": kw("debugger"),
              "var": kw("var"),
              "const": kw("var"),
              "let": kw("var"),
              "function": kw("function"),
              "catch": kw("catch"),
              "for": kw("for"),
              "switch": kw("switch"),
              "case": kw("case"),
              "default": kw("default"),
              "in": operator,
              "typeof": operator,
              "instanceof": operator,
              "true": atom,
              "false": atom,
              "null": atom,
              "undefined": atom,
              "NaN": atom,
              "Infinity": atom,
              "this": kw("this"),
              "class": kw("class"),
              "super": kw("atom"),
              "yield": C2,
              "export": kw("export"),
              "import": kw("import"),
              "extends": C2,
              "await": C2
            };
          }();
          var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
          var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
          function readRegexp(stream) {
            var escaped = false, next, inSet = false;
            while ((next = stream.next()) != null) {
              if (!escaped) {
                if (next == "/" && !inSet)
                  return;
                if (next == "[")
                  inSet = true;
                else if (inSet && next == "]")
                  inSet = false;
              }
              escaped = !escaped && next == "\\";
            }
          }
          var type, content;
          function ret(tp, style, cont2) {
            type = tp;
            content = cont2;
            return style;
          }
          function tokenBase(stream, state) {
            var ch = stream.next();
            if (ch == '"' || ch == "'") {
              state.tokenize = tokenString(ch);
              return state.tokenize(stream, state);
            } else if (ch == "." && stream.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) {
              return ret("number", "number");
            } else if (ch == "." && stream.match("..")) {
              return ret("spread", "meta");
            } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
              return ret(ch);
            } else if (ch == "=" && stream.eat(">")) {
              return ret("=>", "operator");
            } else if (ch == "0" && stream.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {
              return ret("number", "number");
            } else if (/\d/.test(ch)) {
              stream.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/);
              return ret("number", "number");
            } else if (ch == "/") {
              if (stream.eat("*")) {
                state.tokenize = tokenComment;
                return tokenComment(stream, state);
              } else if (stream.eat("/")) {
                stream.skipToEnd();
                return ret("comment", "comment");
              } else if (expressionAllowed(stream, state, 1)) {
                readRegexp(stream);
                stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
                return ret("regexp", "string-2");
              } else {
                stream.eat("=");
                return ret("operator", "operator", stream.current());
              }
            } else if (ch == "`") {
              state.tokenize = tokenQuasi;
              return tokenQuasi(stream, state);
            } else if (ch == "#" && stream.peek() == "!") {
              stream.skipToEnd();
              return ret("meta", "meta");
            } else if (ch == "#" && stream.eatWhile(wordRE)) {
              return ret("variable", "property");
            } else if (ch == "<" && stream.match("!--") || ch == "-" && stream.match("->") && !/\S/.test(stream.string.slice(0, stream.start))) {
              stream.skipToEnd();
              return ret("comment", "comment");
            } else if (isOperatorChar.test(ch)) {
              if (ch != ">" || !state.lexical || state.lexical.type != ">") {
                if (stream.eat("=")) {
                  if (ch == "!" || ch == "=")
                    stream.eat("=");
                } else if (/[<>*+\-|&?]/.test(ch)) {
                  stream.eat(ch);
                  if (ch == ">")
                    stream.eat(ch);
                }
              }
              if (ch == "?" && stream.eat("."))
                return ret(".");
              return ret("operator", "operator", stream.current());
            } else if (wordRE.test(ch)) {
              stream.eatWhile(wordRE);
              var word = stream.current();
              if (state.lastType != ".") {
                if (keywords.propertyIsEnumerable(word)) {
                  var kw = keywords[word];
                  return ret(kw.type, kw.style, word);
                }
                if (word == "async" && stream.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, false))
                  return ret("async", "keyword", word);
              }
              return ret("variable", "variable", word);
            }
          }
          function tokenString(quote) {
            return function(stream, state) {
              var escaped = false, next;
              if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {
                state.tokenize = tokenBase;
                return ret("jsonld-keyword", "meta");
              }
              while ((next = stream.next()) != null) {
                if (next == quote && !escaped)
                  break;
                escaped = !escaped && next == "\\";
              }
              if (!escaped)
                state.tokenize = tokenBase;
              return ret("string", "string");
            };
          }
          function tokenComment(stream, state) {
            var maybeEnd = false, ch;
            while (ch = stream.next()) {
              if (ch == "/" && maybeEnd) {
                state.tokenize = tokenBase;
                break;
              }
              maybeEnd = ch == "*";
            }
            return ret("comment", "comment");
          }
          function tokenQuasi(stream, state) {
            var escaped = false, next;
            while ((next = stream.next()) != null) {
              if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
                state.tokenize = tokenBase;
                break;
              }
              escaped = !escaped && next == "\\";
            }
            return ret("quasi", "string-2", stream.current());
          }
          var brackets = "([{}])";
          function findFatArrow(stream, state) {
            if (state.fatArrowAt)
              state.fatArrowAt = null;
            var arrow2 = stream.string.indexOf("=>", stream.start);
            if (arrow2 < 0)
              return;
            if (isTS) {
              var m2 = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow2));
              if (m2)
                arrow2 = m2.index;
            }
            var depth = 0, sawSomething = false;
            for (var pos = arrow2 - 1; pos >= 0; --pos) {
              var ch = stream.string.charAt(pos);
              var bracket = brackets.indexOf(ch);
              if (bracket >= 0 && bracket < 3) {
                if (!depth) {
                  ++pos;
                  break;
                }
                if (--depth == 0) {
                  if (ch == "(")
                    sawSomething = true;
                  break;
                }
              } else if (bracket >= 3 && bracket < 6) {
                ++depth;
              } else if (wordRE.test(ch)) {
                sawSomething = true;
              } else if (/["'\/`]/.test(ch)) {
                for (; ; --pos) {
                  if (pos == 0)
                    return;
                  var next = stream.string.charAt(pos - 1);
                  if (next == ch && stream.string.charAt(pos - 2) != "\\") {
                    pos--;
                    break;
                  }
                }
              } else if (sawSomething && !depth) {
                ++pos;
                break;
              }
            }
            if (sawSomething && !depth)
              state.fatArrowAt = pos;
          }
          var atomicTypes = { "atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true };
          function JSLexical(indented, column, type2, align, prev, info) {
            this.indented = indented;
            this.column = column;
            this.type = type2;
            this.prev = prev;
            this.info = info;
            if (align != null)
              this.align = align;
          }
          function inScope(state, varname) {
            for (var v2 = state.localVars; v2; v2 = v2.next)
              if (v2.name == varname)
                return true;
            for (var cx2 = state.context; cx2; cx2 = cx2.prev) {
              for (var v2 = cx2.vars; v2; v2 = v2.next)
                if (v2.name == varname)
                  return true;
            }
          }
          function parseJS(state, style, type2, content2, stream) {
            var cc = state.cc;
            cx.state = state;
            cx.stream = stream;
            cx.marked = null, cx.cc = cc;
            cx.style = style;
            if (!state.lexical.hasOwnProperty("align"))
              state.lexical.align = true;
            while (true) {
              var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
              if (combinator(type2, content2)) {
                while (cc.length && cc[cc.length - 1].lex)
                  cc.pop()();
                if (cx.marked)
                  return cx.marked;
                if (type2 == "variable" && inScope(state, content2))
                  return "variable-2";
                return style;
              }
            }
          }
          var cx = { state: null, column: null, marked: null, cc: null };
          function pass() {
            for (var i2 = arguments.length - 1; i2 >= 0; i2--)
              cx.cc.push(arguments[i2]);
          }
          function cont() {
            pass.apply(null, arguments);
            return true;
          }
          function inList(name, list) {
            for (var v2 = list; v2; v2 = v2.next)
              if (v2.name == name)
                return true;
            return false;
          }
          function register(varname) {
            var state = cx.state;
            cx.marked = "def";
            if (state.context) {
              if (state.lexical.info == "var" && state.context && state.context.block) {
                var newContext = registerVarScoped(varname, state.context);
                if (newContext != null) {
                  state.context = newContext;
                  return;
                }
              } else if (!inList(varname, state.localVars)) {
                state.localVars = new Var(varname, state.localVars);
                return;
              }
            }
            if (parserConfig.globalVars && !inList(varname, state.globalVars))
              state.globalVars = new Var(varname, state.globalVars);
          }
          function registerVarScoped(varname, context) {
            if (!context) {
              return null;
            } else if (context.block) {
              var inner = registerVarScoped(varname, context.prev);
              if (!inner)
                return null;
              if (inner == context.prev)
                return context;
              return new Context2(inner, context.vars, true);
            } else if (inList(varname, context.vars)) {
              return context;
            } else {
              return new Context2(context.prev, new Var(varname, context.vars), false);
            }
          }
          function isModifier(name) {
            return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly";
          }
          function Context2(prev, vars, block2) {
            this.prev = prev;
            this.vars = vars;
            this.block = block2;
          }
          function Var(name, next) {
            this.name = name;
            this.next = next;
          }
          var defaultVars = new Var("this", new Var("arguments", null));
          function pushcontext() {
            cx.state.context = new Context2(cx.state.context, cx.state.localVars, false);
            cx.state.localVars = defaultVars;
          }
          function pushblockcontext() {
            cx.state.context = new Context2(cx.state.context, cx.state.localVars, true);
            cx.state.localVars = null;
          }
          function popcontext() {
            cx.state.localVars = cx.state.context.vars;
            cx.state.context = cx.state.context.prev;
          }
          popcontext.lex = true;
          function pushlex(type2, info) {
            var result = function() {
              var state = cx.state, indent = state.indented;
              if (state.lexical.type == "stat")
                indent = state.lexical.indented;
              else
                for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
                  indent = outer.indented;
              state.lexical = new JSLexical(indent, cx.stream.column(), type2, null, state.lexical, info);
            };
            result.lex = true;
            return result;
          }
          function poplex() {
            var state = cx.state;
            if (state.lexical.prev) {
              if (state.lexical.type == ")")
                state.indented = state.lexical.indented;
              state.lexical = state.lexical.prev;
            }
          }
          poplex.lex = true;
          function expect(wanted) {
            function exp(type2) {
              if (type2 == wanted)
                return cont();
              else if (wanted == ";" || type2 == "}" || type2 == ")" || type2 == "]")
                return pass();
              else
                return cont(exp);
            }
            ;
            return exp;
          }
          function statement(type2, value) {
            if (type2 == "var")
              return cont(pushlex("vardef", value), vardef, expect(";"), poplex);
            if (type2 == "keyword a")
              return cont(pushlex("form"), parenExpr, statement, poplex);
            if (type2 == "keyword b")
              return cont(pushlex("form"), statement, poplex);
            if (type2 == "keyword d")
              return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
            if (type2 == "debugger")
              return cont(expect(";"));
            if (type2 == "{")
              return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);
            if (type2 == ";")
              return cont();
            if (type2 == "if") {
              if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
                cx.state.cc.pop()();
              return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
            }
            if (type2 == "function")
              return cont(functiondef);
            if (type2 == "for")
              return cont(pushlex("form"), forspec, statement, poplex);
            if (type2 == "class" || isTS && value == "interface") {
              cx.marked = "keyword";
              return cont(pushlex("form", type2 == "class" ? type2 : value), className, poplex);
            }
            if (type2 == "variable") {
              if (isTS && value == "declare") {
                cx.marked = "keyword";
                return cont(statement);
              } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
                cx.marked = "keyword";
                if (value == "enum")
                  return cont(enumdef);
                else if (value == "type")
                  return cont(typename, expect("operator"), typeexpr, expect(";"));
                else
                  return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex);
              } else if (isTS && value == "namespace") {
                cx.marked = "keyword";
                return cont(pushlex("form"), expression, statement, poplex);
              } else if (isTS && value == "abstract") {
                cx.marked = "keyword";
                return cont(statement);
              } else {
                return cont(pushlex("stat"), maybelabel);
              }
            }
            if (type2 == "switch")
              return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext, block, poplex, poplex, popcontext);
            if (type2 == "case")
              return cont(expression, expect(":"));
            if (type2 == "default")
              return cont(expect(":"));
            if (type2 == "catch")
              return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
            if (type2 == "export")
              return cont(pushlex("stat"), afterExport, poplex);
            if (type2 == "import")
              return cont(pushlex("stat"), afterImport, poplex);
            if (type2 == "async")
              return cont(statement);
            if (value == "@")
              return cont(expression, statement);
            return pass(pushlex("stat"), expression, expect(";"), poplex);
          }
          function maybeCatchBinding(type2) {
            if (type2 == "(")
              return cont(funarg, expect(")"));
          }
          function expression(type2, value) {
            return expressionInner(type2, value, false);
          }
          function expressionNoComma(type2, value) {
            return expressionInner(type2, value, true);
          }
          function parenExpr(type2) {
            if (type2 != "(")
              return pass();
            return cont(pushlex(")"), maybeexpression, expect(")"), poplex);
          }
          function expressionInner(type2, value, noComma) {
            if (cx.state.fatArrowAt == cx.stream.start) {
              var body = noComma ? arrowBodyNoComma : arrowBody;
              if (type2 == "(")
                return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
              else if (type2 == "variable")
                return pass(pushcontext, pattern, expect("=>"), body, popcontext);
            }
            var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
            if (atomicTypes.hasOwnProperty(type2))
              return cont(maybeop);
            if (type2 == "function")
              return cont(functiondef, maybeop);
            if (type2 == "class" || isTS && value == "interface") {
              cx.marked = "keyword";
              return cont(pushlex("form"), classExpression, poplex);
            }
            if (type2 == "keyword c" || type2 == "async")
              return cont(noComma ? expressionNoComma : expression);
            if (type2 == "(")
              return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
            if (type2 == "operator" || type2 == "spread")
              return cont(noComma ? expressionNoComma : expression);
            if (type2 == "[")
              return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
            if (type2 == "{")
              return contCommasep(objprop, "}", null, maybeop);
            if (type2 == "quasi")
              return pass(quasi, maybeop);
            if (type2 == "new")
              return cont(maybeTarget(noComma));
            if (type2 == "import")
              return cont(expression);
            return cont();
          }
          function maybeexpression(type2) {
            if (type2.match(/[;\}\)\],]/))
              return pass();
            return pass(expression);
          }
          function maybeoperatorComma(type2, value) {
            if (type2 == ",")
              return cont(maybeexpression);
            return maybeoperatorNoComma(type2, value, false);
          }
          function maybeoperatorNoComma(type2, value, noComma) {
            var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
            var expr = noComma == false ? expression : expressionNoComma;
            if (type2 == "=>")
              return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
            if (type2 == "operator") {
              if (/\+\+|--/.test(value) || isTS && value == "!")
                return cont(me);
              if (isTS && value == "<" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, false))
                return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
              if (value == "?")
                return cont(expression, expect(":"), expr);
              return cont(expr);
            }
            if (type2 == "quasi") {
              return pass(quasi, me);
            }
            if (type2 == ";")
              return;
            if (type2 == "(")
              return contCommasep(expressionNoComma, ")", "call", me);
            if (type2 == ".")
              return cont(property, me);
            if (type2 == "[")
              return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
            if (isTS && value == "as") {
              cx.marked = "keyword";
              return cont(typeexpr, me);
            }
            if (type2 == "regexp") {
              cx.state.lastType = cx.marked = "operator";
              cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);
              return cont(expr);
            }
          }
          function quasi(type2, value) {
            if (type2 != "quasi")
              return pass();
            if (value.slice(value.length - 2) != "${")
              return cont(quasi);
            return cont(expression, continueQuasi);
          }
          function continueQuasi(type2) {
            if (type2 == "}") {
              cx.marked = "string-2";
              cx.state.tokenize = tokenQuasi;
              return cont(quasi);
            }
          }
          function arrowBody(type2) {
            findFatArrow(cx.stream, cx.state);
            return pass(type2 == "{" ? statement : expression);
          }
          function arrowBodyNoComma(type2) {
            findFatArrow(cx.stream, cx.state);
            return pass(type2 == "{" ? statement : expressionNoComma);
          }
          function maybeTarget(noComma) {
            return function(type2) {
              if (type2 == ".")
                return cont(noComma ? targetNoComma : target);
              else if (type2 == "variable" && isTS)
                return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);
              else
                return pass(noComma ? expressionNoComma : expression);
            };
          }
          function target(_2, value) {
            if (value == "target") {
              cx.marked = "keyword";
              return cont(maybeoperatorComma);
            }
          }
          function targetNoComma(_2, value) {
            if (value == "target") {
              cx.marked = "keyword";
              return cont(maybeoperatorNoComma);
            }
          }
          function maybelabel(type2) {
            if (type2 == ":")
              return cont(poplex, statement);
            return pass(maybeoperatorComma, expect(";"), poplex);
          }
          function property(type2) {
            if (type2 == "variable") {
              cx.marked = "property";
              return cont();
            }
          }
          function objprop(type2, value) {
            if (type2 == "async") {
              cx.marked = "property";
              return cont(objprop);
            } else if (type2 == "variable" || cx.style == "keyword") {
              cx.marked = "property";
              if (value == "get" || value == "set")
                return cont(getterSetter);
              var m2;
              if (isTS && cx.state.fatArrowAt == cx.stream.start && (m2 = cx.stream.match(/^\s*:\s*/, false)))
                cx.state.fatArrowAt = cx.stream.pos + m2[0].length;
              return cont(afterprop);
            } else if (type2 == "number" || type2 == "string") {
              cx.marked = jsonldMode ? "property" : cx.style + " property";
              return cont(afterprop);
            } else if (type2 == "jsonld-keyword") {
              return cont(afterprop);
            } else if (isTS && isModifier(value)) {
              cx.marked = "keyword";
              return cont(objprop);
            } else if (type2 == "[") {
              return cont(expression, maybetype, expect("]"), afterprop);
            } else if (type2 == "spread") {
              return cont(expressionNoComma, afterprop);
            } else if (value == "*") {
              cx.marked = "keyword";
              return cont(objprop);
            } else if (type2 == ":") {
              return pass(afterprop);
            }
          }
          function getterSetter(type2) {
            if (type2 != "variable")
              return pass(afterprop);
            cx.marked = "property";
            return cont(functiondef);
          }
          function afterprop(type2) {
            if (type2 == ":")
              return cont(expressionNoComma);
            if (type2 == "(")
              return pass(functiondef);
          }
          function commasep(what, end2, sep) {
            function proceed(type2, value) {
              if (sep ? sep.indexOf(type2) > -1 : type2 == ",") {
                var lex = cx.state.lexical;
                if (lex.info == "call")
                  lex.pos = (lex.pos || 0) + 1;
                return cont(function(type3, value2) {
                  if (type3 == end2 || value2 == end2)
                    return pass();
                  return pass(what);
                }, proceed);
              }
              if (type2 == end2 || value == end2)
                return cont();
              if (sep && sep.indexOf(";") > -1)
                return pass(what);
              return cont(expect(end2));
            }
            return function(type2, value) {
              if (type2 == end2 || value == end2)
                return cont();
              return pass(what, proceed);
            };
          }
          function contCommasep(what, end2, info) {
            for (var i2 = 3; i2 < arguments.length; i2++)
              cx.cc.push(arguments[i2]);
            return cont(pushlex(end2, info), commasep(what, end2), poplex);
          }
          function block(type2) {
            if (type2 == "}")
              return cont();
            return pass(statement, block);
          }
          function maybetype(type2, value) {
            if (isTS) {
              if (type2 == ":")
                return cont(typeexpr);
              if (value == "?")
                return cont(maybetype);
            }
          }
          function maybetypeOrIn(type2, value) {
            if (isTS && (type2 == ":" || value == "in"))
              return cont(typeexpr);
          }
          function mayberettype(type2) {
            if (isTS && type2 == ":") {
              if (cx.stream.match(/^\s*\w+\s+is\b/, false))
                return cont(expression, isKW, typeexpr);
              else
                return cont(typeexpr);
            }
          }
          function isKW(_2, value) {
            if (value == "is") {
              cx.marked = "keyword";
              return cont();
            }
          }
          function typeexpr(type2, value) {
            if (value == "keyof" || value == "typeof" || value == "infer") {
              cx.marked = "keyword";
              return cont(value == "typeof" ? expressionNoComma : typeexpr);
            }
            if (type2 == "variable" || value == "void") {
              cx.marked = "type";
              return cont(afterType);
            }
            if (value == "|" || value == "&")
              return cont(typeexpr);
            if (type2 == "string" || type2 == "number" || type2 == "atom")
              return cont(afterType);
            if (type2 == "[")
              return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType);
            if (type2 == "{")
              return cont(pushlex("}"), typeprops, poplex, afterType);
            if (type2 == "(")
              return cont(commasep(typearg, ")"), maybeReturnType, afterType);
            if (type2 == "<")
              return cont(commasep(typeexpr, ">"), typeexpr);
          }
          function maybeReturnType(type2) {
            if (type2 == "=>")
              return cont(typeexpr);
          }
          function typeprops(type2) {
            if (type2.match(/[\}\)\]]/))
              return cont();
            if (type2 == "," || type2 == ";")
              return cont(typeprops);
            return pass(typeprop, typeprops);
          }
          function typeprop(type2, value) {
            if (type2 == "variable" || cx.style == "keyword") {
              cx.marked = "property";
              return cont(typeprop);
            } else if (value == "?" || type2 == "number" || type2 == "string") {
              return cont(typeprop);
            } else if (type2 == ":") {
              return cont(typeexpr);
            } else if (type2 == "[") {
              return cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop);
            } else if (type2 == "(") {
              return pass(functiondecl, typeprop);
            } else if (!type2.match(/[;\}\)\],]/)) {
              return cont();
            }
          }
          function typearg(type2, value) {
            if (type2 == "variable" && cx.stream.match(/^\s*[?:]/, false) || value == "?")
              return cont(typearg);
            if (type2 == ":")
              return cont(typeexpr);
            if (type2 == "spread")
              return cont(typearg);
            return pass(typeexpr);
          }
          function afterType(type2, value) {
            if (value == "<")
              return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
            if (value == "|" || type2 == "." || value == "&")
              return cont(typeexpr);
            if (type2 == "[")
              return cont(typeexpr, expect("]"), afterType);
            if (value == "extends" || value == "implements") {
              cx.marked = "keyword";
              return cont(typeexpr);
            }
            if (value == "?")
              return cont(typeexpr, expect(":"), typeexpr);
          }
          function maybeTypeArgs(_2, value) {
            if (value == "<")
              return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
          }
          function typeparam() {
            return pass(typeexpr, maybeTypeDefault);
          }
          function maybeTypeDefault(_2, value) {
            if (value == "=")
              return cont(typeexpr);
          }
          function vardef(_2, value) {
            if (value == "enum") {
              cx.marked = "keyword";
              return cont(enumdef);
            }
            return pass(pattern, maybetype, maybeAssign, vardefCont);
          }
          function pattern(type2, value) {
            if (isTS && isModifier(value)) {
              cx.marked = "keyword";
              return cont(pattern);
            }
            if (type2 == "variable") {
              register(value);
              return cont();
            }
            if (type2 == "spread")
              return cont(pattern);
            if (type2 == "[")
              return contCommasep(eltpattern, "]");
            if (type2 == "{")
              return contCommasep(proppattern, "}");
          }
          function proppattern(type2, value) {
            if (type2 == "variable" && !cx.stream.match(/^\s*:/, false)) {
              register(value);
              return cont(maybeAssign);
            }
            if (type2 == "variable")
              cx.marked = "property";
            if (type2 == "spread")
              return cont(pattern);
            if (type2 == "}")
              return pass();
            if (type2 == "[")
              return cont(expression, expect("]"), expect(":"), proppattern);
            return cont(expect(":"), pattern, maybeAssign);
          }
          function eltpattern() {
            return pass(pattern, maybeAssign);
          }
          function maybeAssign(_type, value) {
            if (value == "=")
              return cont(expressionNoComma);
          }
          function vardefCont(type2) {
            if (type2 == ",")
              return cont(vardef);
          }
          function maybeelse(type2, value) {
            if (type2 == "keyword b" && value == "else")
              return cont(pushlex("form", "else"), statement, poplex);
          }
          function forspec(type2, value) {
            if (value == "await")
              return cont(forspec);
            if (type2 == "(")
              return cont(pushlex(")"), forspec1, poplex);
          }
          function forspec1(type2) {
            if (type2 == "var")
              return cont(vardef, forspec2);
            if (type2 == "variable")
              return cont(forspec2);
            return pass(forspec2);
          }
          function forspec2(type2, value) {
            if (type2 == ")")
              return cont();
            if (type2 == ";")
              return cont(forspec2);
            if (value == "in" || value == "of") {
              cx.marked = "keyword";
              return cont(expression, forspec2);
            }
            return pass(expression, forspec2);
          }
          function functiondef(type2, value) {
            if (value == "*") {
              cx.marked = "keyword";
              return cont(functiondef);
            }
            if (type2 == "variable") {
              register(value);
              return cont(functiondef);
            }
            if (type2 == "(")
              return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
            if (isTS && value == "<")
              return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef);
          }
          function functiondecl(type2, value) {
            if (value == "*") {
              cx.marked = "keyword";
              return cont(functiondecl);
            }
            if (type2 == "variable") {
              register(value);
              return cont(functiondecl);
            }
            if (type2 == "(")
              return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
            if (isTS && value == "<")
              return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl);
          }
          function typename(type2, value) {
            if (type2 == "keyword" || type2 == "variable") {
              cx.marked = "type";
              return cont(typename);
            } else if (value == "<") {
              return cont(pushlex(">"), commasep(typeparam, ">"), poplex);
            }
          }
          function funarg(type2, value) {
            if (value == "@")
              cont(expression, funarg);
            if (type2 == "spread")
              return cont(funarg);
            if (isTS && isModifier(value)) {
              cx.marked = "keyword";
              return cont(funarg);
            }
            if (isTS && type2 == "this")
              return cont(maybetype, maybeAssign);
            return pass(pattern, maybetype, maybeAssign);
          }
          function classExpression(type2, value) {
            if (type2 == "variable")
              return className(type2, value);
            return classNameAfter(type2, value);
          }
          function className(type2, value) {
            if (type2 == "variable") {
              register(value);
              return cont(classNameAfter);
            }
          }
          function classNameAfter(type2, value) {
            if (value == "<")
              return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter);
            if (value == "extends" || value == "implements" || isTS && type2 == ",") {
              if (value == "implements")
                cx.marked = "keyword";
              return cont(isTS ? typeexpr : expression, classNameAfter);
            }
            if (type2 == "{")
              return cont(pushlex("}"), classBody, poplex);
          }
          function classBody(type2, value) {
            if (type2 == "async" || type2 == "variable" && (value == "static" || value == "get" || value == "set" || isTS && isModifier(value)) && cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false)) {
              cx.marked = "keyword";
              return cont(classBody);
            }
            if (type2 == "variable" || cx.style == "keyword") {
              cx.marked = "property";
              return cont(classfield, classBody);
            }
            if (type2 == "number" || type2 == "string")
              return cont(classfield, classBody);
            if (type2 == "[")
              return cont(expression, maybetype, expect("]"), classfield, classBody);
            if (value == "*") {
              cx.marked = "keyword";
              return cont(classBody);
            }
            if (isTS && type2 == "(")
              return pass(functiondecl, classBody);
            if (type2 == ";" || type2 == ",")
              return cont(classBody);
            if (type2 == "}")
              return cont();
            if (value == "@")
              return cont(expression, classBody);
          }
          function classfield(type2, value) {
            if (value == "?")
              return cont(classfield);
            if (type2 == ":")
              return cont(typeexpr, maybeAssign);
            if (value == "=")
              return cont(expressionNoComma);
            var context = cx.state.lexical.prev, isInterface = context && context.info == "interface";
            return pass(isInterface ? functiondecl : functiondef);
          }
          function afterExport(type2, value) {
            if (value == "*") {
              cx.marked = "keyword";
              return cont(maybeFrom, expect(";"));
            }
            if (value == "default") {
              cx.marked = "keyword";
              return cont(expression, expect(";"));
            }
            if (type2 == "{")
              return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
            return pass(statement);
          }
          function exportField(type2, value) {
            if (value == "as") {
              cx.marked = "keyword";
              return cont(expect("variable"));
            }
            if (type2 == "variable")
              return pass(expressionNoComma, exportField);
          }
          function afterImport(type2) {
            if (type2 == "string")
              return cont();
            if (type2 == "(")
              return pass(expression);
            return pass(importSpec, maybeMoreImports, maybeFrom);
          }
          function importSpec(type2, value) {
            if (type2 == "{")
              return contCommasep(importSpec, "}");
            if (type2 == "variable")
              register(value);
            if (value == "*")
              cx.marked = "keyword";
            return cont(maybeAs);
          }
          function maybeMoreImports(type2) {
            if (type2 == ",")
              return cont(importSpec, maybeMoreImports);
          }
          function maybeAs(_type, value) {
            if (value == "as") {
              cx.marked = "keyword";
              return cont(importSpec);
            }
          }
          function maybeFrom(_type, value) {
            if (value == "from") {
              cx.marked = "keyword";
              return cont(expression);
            }
          }
          function arrayLiteral(type2) {
            if (type2 == "]")
              return cont();
            return pass(commasep(expressionNoComma, "]"));
          }
          function enumdef() {
            return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex);
          }
          function enummember() {
            return pass(pattern, maybeAssign);
          }
          function isContinuedStatement(state, textAfter) {
            return state.lastType == "operator" || state.lastType == "," || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));
          }
          function expressionAllowed(stream, state, backUp) {
            return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) || state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));
          }
          return {
            startState: function(basecolumn) {
              var state = {
                tokenize: tokenBase,
                lastType: "sof",
                cc: [],
                lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
                localVars: parserConfig.localVars,
                context: parserConfig.localVars && new Context2(null, null, false),
                indented: basecolumn || 0
              };
              if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
                state.globalVars = parserConfig.globalVars;
              return state;
            },
            token: function(stream, state) {
              if (stream.sol()) {
                if (!state.lexical.hasOwnProperty("align"))
                  state.lexical.align = false;
                state.indented = stream.indentation();
                findFatArrow(stream, state);
              }
              if (state.tokenize != tokenComment && stream.eatSpace())
                return null;
              var style = state.tokenize(stream, state);
              if (type == "comment")
                return style;
              state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
              return parseJS(state, style, type, content, stream);
            },
            indent: function(state, textAfter) {
              if (state.tokenize == tokenComment || state.tokenize == tokenQuasi)
                return CodeMirror3.Pass;
              if (state.tokenize != tokenBase)
                return 0;
              var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top2;
              if (!/^\s*else\b/.test(textAfter))
                for (var i2 = state.cc.length - 1; i2 >= 0; --i2) {
                  var c2 = state.cc[i2];
                  if (c2 == poplex)
                    lexical = lexical.prev;
                  else if (c2 != maybeelse)
                    break;
                }
              while ((lexical.type == "stat" || lexical.type == "form") && (firstChar == "}" || (top2 = state.cc[state.cc.length - 1]) && (top2 == maybeoperatorComma || top2 == maybeoperatorNoComma) && !/^[,\.=+\-*:?[\(]/.test(textAfter)))
                lexical = lexical.prev;
              if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
                lexical = lexical.prev;
              var type2 = lexical.type, closing = firstChar == type2;
              if (type2 == "vardef")
                return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);
              else if (type2 == "form" && firstChar == "{")
                return lexical.indented;
              else if (type2 == "form")
                return lexical.indented + indentUnit;
              else if (type2 == "stat")
                return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
              else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
                return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
              else if (lexical.align)
                return lexical.column + (closing ? 0 : 1);
              else
                return lexical.indented + (closing ? 0 : indentUnit);
            },
            electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
            blockCommentStart: jsonMode ? null : "/*",
            blockCommentEnd: jsonMode ? null : "*/",
            blockCommentContinue: jsonMode ? null : " * ",
            lineComment: jsonMode ? null : "//",
            fold: "brace",
            closeBrackets: "()[]{}''\"\"``",
            helperType: jsonMode ? "json" : "javascript",
            jsonldMode,
            jsonMode,
            expressionAllowed,
            skipExpression: function(state) {
              var top2 = state.cc[state.cc.length - 1];
              if (top2 == expression || top2 == expressionNoComma)
                state.cc.pop();
            }
          };
        });
        CodeMirror3.registerHelper("wordChars", "javascript", /[\w$]/);
        CodeMirror3.defineMIME("text/javascript", "javascript");
        CodeMirror3.defineMIME("text/ecmascript", "javascript");
        CodeMirror3.defineMIME("application/javascript", "javascript");
        CodeMirror3.defineMIME("application/x-javascript", "javascript");
        CodeMirror3.defineMIME("application/ecmascript", "javascript");
        CodeMirror3.defineMIME("application/json", { name: "javascript", json: true });
        CodeMirror3.defineMIME("application/x-json", { name: "javascript", json: true });
        CodeMirror3.defineMIME("application/manifest+json", { name: "javascript", json: true });
        CodeMirror3.defineMIME("application/ld+json", { name: "javascript", jsonld: true });
        CodeMirror3.defineMIME("text/typescript", { name: "javascript", typescript: true });
        CodeMirror3.defineMIME("application/typescript", { name: "javascript", typescript: true });
      });
    }
  });

  // node_modules/codemirror/mode/htmlmixed/htmlmixed.js
  var require_htmlmixed = __commonJS({
    "node_modules/codemirror/mode/htmlmixed/htmlmixed.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror(), require_xml(), require_javascript(), require_css());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror", "../xml/xml", "../javascript/javascript", "../css/css"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        var defaultTags = {
          script: [
            ["lang", /(javascript|babel)/i, "javascript"],
            ["type", /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, "javascript"],
            ["type", /./, "text/plain"],
            [null, null, "javascript"]
          ],
          style: [
            ["lang", /^css$/i, "css"],
            ["type", /^(text\/)?(x-)?(stylesheet|css)$/i, "css"],
            ["type", /./, "text/plain"],
            [null, null, "css"]
          ]
        };
        function maybeBackup(stream, pat, style) {
          var cur = stream.current(), close = cur.search(pat);
          if (close > -1) {
            stream.backUp(cur.length - close);
          } else if (cur.match(/<\/?$/)) {
            stream.backUp(cur.length);
            if (!stream.match(pat, false))
              stream.match(cur);
          }
          return style;
        }
        var attrRegexpCache = {};
        function getAttrRegexp(attr) {
          var regexp = attrRegexpCache[attr];
          if (regexp)
            return regexp;
          return attrRegexpCache[attr] = new RegExp("\\s+" + attr + `\\s*=\\s*('|")?([^'"]+)('|")?\\s*`);
        }
        function getAttrValue(text, attr) {
          var match = text.match(getAttrRegexp(attr));
          return match ? /^\s*(.*?)\s*$/.exec(match[2])[1] : "";
        }
        function getTagRegexp(tagName, anchored) {
          return new RegExp((anchored ? "^" : "") + "</s*" + tagName + "s*>", "i");
        }
        function addTags(from, to) {
          for (var tag in from) {
            var dest = to[tag] || (to[tag] = []);
            var source = from[tag];
            for (var i2 = source.length - 1; i2 >= 0; i2--)
              dest.unshift(source[i2]);
          }
        }
        function findMatchingMode(tagInfo, tagText) {
          for (var i2 = 0; i2 < tagInfo.length; i2++) {
            var spec = tagInfo[i2];
            if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0])))
              return spec[2];
          }
        }
        CodeMirror3.defineMode("htmlmixed", function(config, parserConfig) {
          var htmlMode = CodeMirror3.getMode(config, {
            name: "xml",
            htmlMode: true,
            multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,
            multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag,
            allowMissingTagName: parserConfig.allowMissingTagName
          });
          var tags = {};
          var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;
          addTags(defaultTags, tags);
          if (configTags)
            addTags(configTags, tags);
          if (configScript)
            for (var i2 = configScript.length - 1; i2 >= 0; i2--)
              tags.script.unshift(["type", configScript[i2].matches, configScript[i2].mode]);
          function html(stream, state) {
            var style = htmlMode.token(stream, state.htmlState), tag = /\btag\b/.test(style), tagName;
            if (tag && !/[<>\s\/]/.test(stream.current()) && (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) && tags.hasOwnProperty(tagName)) {
              state.inTag = tagName + " ";
            } else if (state.inTag && tag && />$/.test(stream.current())) {
              var inTag = /^([\S]+) (.*)/.exec(state.inTag);
              state.inTag = null;
              var modeSpec = stream.current() == ">" && findMatchingMode(tags[inTag[1]], inTag[2]);
              var mode = CodeMirror3.getMode(config, modeSpec);
              var endTagA = getTagRegexp(inTag[1], true), endTag = getTagRegexp(inTag[1], false);
              state.token = function(stream2, state2) {
                if (stream2.match(endTagA, false)) {
                  state2.token = html;
                  state2.localState = state2.localMode = null;
                  return null;
                }
                return maybeBackup(stream2, endTag, state2.localMode.token(stream2, state2.localState));
              };
              state.localMode = mode;
              state.localState = CodeMirror3.startState(mode, htmlMode.indent(state.htmlState, "", ""));
            } else if (state.inTag) {
              state.inTag += stream.current();
              if (stream.eol())
                state.inTag += " ";
            }
            return style;
          }
          ;
          return {
            startState: function() {
              var state = CodeMirror3.startState(htmlMode);
              return { token: html, inTag: null, localMode: null, localState: null, htmlState: state };
            },
            copyState: function(state) {
              var local;
              if (state.localState) {
                local = CodeMirror3.copyState(state.localMode, state.localState);
              }
              return {
                token: state.token,
                inTag: state.inTag,
                localMode: state.localMode,
                localState: local,
                htmlState: CodeMirror3.copyState(htmlMode, state.htmlState)
              };
            },
            token: function(stream, state) {
              return state.token(stream, state);
            },
            indent: function(state, textAfter, line) {
              if (!state.localMode || /^\s*<\//.test(textAfter))
                return htmlMode.indent(state.htmlState, textAfter, line);
              else if (state.localMode.indent)
                return state.localMode.indent(state.localState, textAfter, line);
              else
                return CodeMirror3.Pass;
            },
            innerMode: function(state) {
              return { state: state.localState || state.htmlState, mode: state.localMode || htmlMode };
            }
          };
        }, "xml", "javascript", "css");
        CodeMirror3.defineMIME("text/html", "htmlmixed");
      });
    }
  });

  // node_modules/codemirror/mode/meta.js
  var require_meta = __commonJS({
    "node_modules/codemirror/mode/meta.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror());
        else if (typeof define == "function" && define.amd)
          define(["../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.modeInfo = [
          { name: "APL", mime: "text/apl", mode: "apl", ext: ["dyalog", "apl"] },
          { name: "PGP", mimes: ["application/pgp", "application/pgp-encrypted", "application/pgp-keys", "application/pgp-signature"], mode: "asciiarmor", ext: ["asc", "pgp", "sig"] },
          { name: "ASN.1", mime: "text/x-ttcn-asn", mode: "asn.1", ext: ["asn", "asn1"] },
          { name: "Asterisk", mime: "text/x-asterisk", mode: "asterisk", file: /^extensions\.conf$/i },
          { name: "Brainfuck", mime: "text/x-brainfuck", mode: "brainfuck", ext: ["b", "bf"] },
          { name: "C", mime: "text/x-csrc", mode: "clike", ext: ["c", "h", "ino"] },
          { name: "C++", mime: "text/x-c++src", mode: "clike", ext: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"], alias: ["cpp"] },
          { name: "Cobol", mime: "text/x-cobol", mode: "cobol", ext: ["cob", "cpy"] },
          { name: "C#", mime: "text/x-csharp", mode: "clike", ext: ["cs"], alias: ["csharp", "cs"] },
          { name: "Clojure", mime: "text/x-clojure", mode: "clojure", ext: ["clj", "cljc", "cljx"] },
          { name: "ClojureScript", mime: "text/x-clojurescript", mode: "clojure", ext: ["cljs"] },
          { name: "Closure Stylesheets (GSS)", mime: "text/x-gss", mode: "css", ext: ["gss"] },
          { name: "CMake", mime: "text/x-cmake", mode: "cmake", ext: ["cmake", "cmake.in"], file: /^CMakeLists\.txt$/ },
          { name: "CoffeeScript", mimes: ["application/vnd.coffeescript", "text/coffeescript", "text/x-coffeescript"], mode: "coffeescript", ext: ["coffee"], alias: ["coffee", "coffee-script"] },
          { name: "Common Lisp", mime: "text/x-common-lisp", mode: "commonlisp", ext: ["cl", "lisp", "el"], alias: ["lisp"] },
          { name: "Cypher", mime: "application/x-cypher-query", mode: "cypher", ext: ["cyp", "cypher"] },
          { name: "Cython", mime: "text/x-cython", mode: "python", ext: ["pyx", "pxd", "pxi"] },
          { name: "Crystal", mime: "text/x-crystal", mode: "crystal", ext: ["cr"] },
          { name: "CSS", mime: "text/css", mode: "css", ext: ["css"] },
          { name: "CQL", mime: "text/x-cassandra", mode: "sql", ext: ["cql"] },
          { name: "D", mime: "text/x-d", mode: "d", ext: ["d"] },
          { name: "Dart", mimes: ["application/dart", "text/x-dart"], mode: "dart", ext: ["dart"] },
          { name: "diff", mime: "text/x-diff", mode: "diff", ext: ["diff", "patch"] },
          { name: "Django", mime: "text/x-django", mode: "django" },
          { name: "Dockerfile", mime: "text/x-dockerfile", mode: "dockerfile", file: /^Dockerfile$/ },
          { name: "DTD", mime: "application/xml-dtd", mode: "dtd", ext: ["dtd"] },
          { name: "Dylan", mime: "text/x-dylan", mode: "dylan", ext: ["dylan", "dyl", "intr"] },
          { name: "EBNF", mime: "text/x-ebnf", mode: "ebnf" },
          { name: "ECL", mime: "text/x-ecl", mode: "ecl", ext: ["ecl"] },
          { name: "edn", mime: "application/edn", mode: "clojure", ext: ["edn"] },
          { name: "Eiffel", mime: "text/x-eiffel", mode: "eiffel", ext: ["e"] },
          { name: "Elm", mime: "text/x-elm", mode: "elm", ext: ["elm"] },
          { name: "Embedded JavaScript", mime: "application/x-ejs", mode: "htmlembedded", ext: ["ejs"] },
          { name: "Embedded Ruby", mime: "application/x-erb", mode: "htmlembedded", ext: ["erb"] },
          { name: "Erlang", mime: "text/x-erlang", mode: "erlang", ext: ["erl"] },
          { name: "Esper", mime: "text/x-esper", mode: "sql" },
          { name: "Factor", mime: "text/x-factor", mode: "factor", ext: ["factor"] },
          { name: "FCL", mime: "text/x-fcl", mode: "fcl" },
          { name: "Forth", mime: "text/x-forth", mode: "forth", ext: ["forth", "fth", "4th"] },
          { name: "Fortran", mime: "text/x-fortran", mode: "fortran", ext: ["f", "for", "f77", "f90", "f95"] },
          { name: "F#", mime: "text/x-fsharp", mode: "mllike", ext: ["fs"], alias: ["fsharp"] },
          { name: "Gas", mime: "text/x-gas", mode: "gas", ext: ["s"] },
          { name: "Gherkin", mime: "text/x-feature", mode: "gherkin", ext: ["feature"] },
          { name: "GitHub Flavored Markdown", mime: "text/x-gfm", mode: "gfm", file: /^(readme|contributing|history)\.md$/i },
          { name: "Go", mime: "text/x-go", mode: "go", ext: ["go"] },
          { name: "Groovy", mime: "text/x-groovy", mode: "groovy", ext: ["groovy", "gradle"], file: /^Jenkinsfile$/ },
          { name: "HAML", mime: "text/x-haml", mode: "haml", ext: ["haml"] },
          { name: "Haskell", mime: "text/x-haskell", mode: "haskell", ext: ["hs"] },
          { name: "Haskell (Literate)", mime: "text/x-literate-haskell", mode: "haskell-literate", ext: ["lhs"] },
          { name: "Haxe", mime: "text/x-haxe", mode: "haxe", ext: ["hx"] },
          { name: "HXML", mime: "text/x-hxml", mode: "haxe", ext: ["hxml"] },
          { name: "ASP.NET", mime: "application/x-aspx", mode: "htmlembedded", ext: ["aspx"], alias: ["asp", "aspx"] },
          { name: "HTML", mime: "text/html", mode: "htmlmixed", ext: ["html", "htm", "handlebars", "hbs"], alias: ["xhtml"] },
          { name: "HTTP", mime: "message/http", mode: "http" },
          { name: "IDL", mime: "text/x-idl", mode: "idl", ext: ["pro"] },
          { name: "Pug", mime: "text/x-pug", mode: "pug", ext: ["jade", "pug"], alias: ["jade"] },
          { name: "Java", mime: "text/x-java", mode: "clike", ext: ["java"] },
          { name: "Java Server Pages", mime: "application/x-jsp", mode: "htmlembedded", ext: ["jsp"], alias: ["jsp"] },
          {
            name: "JavaScript",
            mimes: ["text/javascript", "text/ecmascript", "application/javascript", "application/x-javascript", "application/ecmascript"],
            mode: "javascript",
            ext: ["js"],
            alias: ["ecmascript", "js", "node"]
          },
          { name: "JSON", mimes: ["application/json", "application/x-json"], mode: "javascript", ext: ["json", "map"], alias: ["json5"] },
          { name: "JSON-LD", mime: "application/ld+json", mode: "javascript", ext: ["jsonld"], alias: ["jsonld"] },
          { name: "JSX", mime: "text/jsx", mode: "jsx", ext: ["jsx"] },
          { name: "Jinja2", mime: "text/jinja2", mode: "jinja2", ext: ["j2", "jinja", "jinja2"] },
          { name: "Julia", mime: "text/x-julia", mode: "julia", ext: ["jl"] },
          { name: "Kotlin", mime: "text/x-kotlin", mode: "clike", ext: ["kt"] },
          { name: "LESS", mime: "text/x-less", mode: "css", ext: ["less"] },
          { name: "LiveScript", mime: "text/x-livescript", mode: "livescript", ext: ["ls"], alias: ["ls"] },
          { name: "Lua", mime: "text/x-lua", mode: "lua", ext: ["lua"] },
          { name: "Markdown", mime: "text/x-markdown", mode: "markdown", ext: ["markdown", "md", "mkd"] },
          { name: "mIRC", mime: "text/mirc", mode: "mirc" },
          { name: "MariaDB SQL", mime: "text/x-mariadb", mode: "sql" },
          { name: "Mathematica", mime: "text/x-mathematica", mode: "mathematica", ext: ["m", "nb", "wl", "wls"] },
          { name: "Modelica", mime: "text/x-modelica", mode: "modelica", ext: ["mo"] },
          { name: "MUMPS", mime: "text/x-mumps", mode: "mumps", ext: ["mps"] },
          { name: "MS SQL", mime: "text/x-mssql", mode: "sql" },
          { name: "mbox", mime: "application/mbox", mode: "mbox", ext: ["mbox"] },
          { name: "MySQL", mime: "text/x-mysql", mode: "sql" },
          { name: "Nginx", mime: "text/x-nginx-conf", mode: "nginx", file: /nginx.*\.conf$/i },
          { name: "NSIS", mime: "text/x-nsis", mode: "nsis", ext: ["nsh", "nsi"] },
          {
            name: "NTriples",
            mimes: ["application/n-triples", "application/n-quads", "text/n-triples"],
            mode: "ntriples",
            ext: ["nt", "nq"]
          },
          { name: "Objective-C", mime: "text/x-objectivec", mode: "clike", ext: ["m"], alias: ["objective-c", "objc"] },
          { name: "Objective-C++", mime: "text/x-objectivec++", mode: "clike", ext: ["mm"], alias: ["objective-c++", "objc++"] },
          { name: "OCaml", mime: "text/x-ocaml", mode: "mllike", ext: ["ml", "mli", "mll", "mly"] },
          { name: "Octave", mime: "text/x-octave", mode: "octave", ext: ["m"] },
          { name: "Oz", mime: "text/x-oz", mode: "oz", ext: ["oz"] },
          { name: "Pascal", mime: "text/x-pascal", mode: "pascal", ext: ["p", "pas"] },
          { name: "PEG.js", mime: "null", mode: "pegjs", ext: ["jsonld"] },
          { name: "Perl", mime: "text/x-perl", mode: "perl", ext: ["pl", "pm"] },
          { name: "PHP", mimes: ["text/x-php", "application/x-httpd-php", "application/x-httpd-php-open"], mode: "php", ext: ["php", "php3", "php4", "php5", "php7", "phtml"] },
          { name: "Pig", mime: "text/x-pig", mode: "pig", ext: ["pig"] },
          { name: "Plain Text", mime: "text/plain", mode: "null", ext: ["txt", "text", "conf", "def", "list", "log"] },
          { name: "PLSQL", mime: "text/x-plsql", mode: "sql", ext: ["pls"] },
          { name: "PostgreSQL", mime: "text/x-pgsql", mode: "sql" },
          { name: "PowerShell", mime: "application/x-powershell", mode: "powershell", ext: ["ps1", "psd1", "psm1"] },
          { name: "Properties files", mime: "text/x-properties", mode: "properties", ext: ["properties", "ini", "in"], alias: ["ini", "properties"] },
          { name: "ProtoBuf", mime: "text/x-protobuf", mode: "protobuf", ext: ["proto"] },
          { name: "Python", mime: "text/x-python", mode: "python", ext: ["BUILD", "bzl", "py", "pyw"], file: /^(BUCK|BUILD)$/ },
          { name: "Puppet", mime: "text/x-puppet", mode: "puppet", ext: ["pp"] },
          { name: "Q", mime: "text/x-q", mode: "q", ext: ["q"] },
          { name: "R", mime: "text/x-rsrc", mode: "r", ext: ["r", "R"], alias: ["rscript"] },
          { name: "reStructuredText", mime: "text/x-rst", mode: "rst", ext: ["rst"], alias: ["rst"] },
          { name: "RPM Changes", mime: "text/x-rpm-changes", mode: "rpm" },
          { name: "RPM Spec", mime: "text/x-rpm-spec", mode: "rpm", ext: ["spec"] },
          { name: "Ruby", mime: "text/x-ruby", mode: "ruby", ext: ["rb"], alias: ["jruby", "macruby", "rake", "rb", "rbx"] },
          { name: "Rust", mime: "text/x-rustsrc", mode: "rust", ext: ["rs"] },
          { name: "SAS", mime: "text/x-sas", mode: "sas", ext: ["sas"] },
          { name: "Sass", mime: "text/x-sass", mode: "sass", ext: ["sass"] },
          { name: "Scala", mime: "text/x-scala", mode: "clike", ext: ["scala"] },
          { name: "Scheme", mime: "text/x-scheme", mode: "scheme", ext: ["scm", "ss"] },
          { name: "SCSS", mime: "text/x-scss", mode: "css", ext: ["scss"] },
          { name: "Shell", mimes: ["text/x-sh", "application/x-sh"], mode: "shell", ext: ["sh", "ksh", "bash"], alias: ["bash", "sh", "zsh"], file: /^PKGBUILD$/ },
          { name: "Sieve", mime: "application/sieve", mode: "sieve", ext: ["siv", "sieve"] },
          { name: "Slim", mimes: ["text/x-slim", "application/x-slim"], mode: "slim", ext: ["slim"] },
          { name: "Smalltalk", mime: "text/x-stsrc", mode: "smalltalk", ext: ["st"] },
          { name: "Smarty", mime: "text/x-smarty", mode: "smarty", ext: ["tpl"] },
          { name: "Solr", mime: "text/x-solr", mode: "solr" },
          { name: "SML", mime: "text/x-sml", mode: "mllike", ext: ["sml", "sig", "fun", "smackspec"] },
          { name: "Soy", mime: "text/x-soy", mode: "soy", ext: ["soy"], alias: ["closure template"] },
          { name: "SPARQL", mime: "application/sparql-query", mode: "sparql", ext: ["rq", "sparql"], alias: ["sparul"] },
          { name: "Spreadsheet", mime: "text/x-spreadsheet", mode: "spreadsheet", alias: ["excel", "formula"] },
          { name: "SQL", mime: "text/x-sql", mode: "sql", ext: ["sql"] },
          { name: "SQLite", mime: "text/x-sqlite", mode: "sql" },
          { name: "Squirrel", mime: "text/x-squirrel", mode: "clike", ext: ["nut"] },
          { name: "Stylus", mime: "text/x-styl", mode: "stylus", ext: ["styl"] },
          { name: "Swift", mime: "text/x-swift", mode: "swift", ext: ["swift"] },
          { name: "sTeX", mime: "text/x-stex", mode: "stex" },
          { name: "LaTeX", mime: "text/x-latex", mode: "stex", ext: ["text", "ltx", "tex"], alias: ["tex"] },
          { name: "SystemVerilog", mime: "text/x-systemverilog", mode: "verilog", ext: ["v", "sv", "svh"] },
          { name: "Tcl", mime: "text/x-tcl", mode: "tcl", ext: ["tcl"] },
          { name: "Textile", mime: "text/x-textile", mode: "textile", ext: ["textile"] },
          { name: "TiddlyWiki", mime: "text/x-tiddlywiki", mode: "tiddlywiki" },
          { name: "Tiki wiki", mime: "text/tiki", mode: "tiki" },
          { name: "TOML", mime: "text/x-toml", mode: "toml", ext: ["toml"] },
          { name: "Tornado", mime: "text/x-tornado", mode: "tornado" },
          { name: "troff", mime: "text/troff", mode: "troff", ext: ["1", "2", "3", "4", "5", "6", "7", "8", "9"] },
          { name: "TTCN", mime: "text/x-ttcn", mode: "ttcn", ext: ["ttcn", "ttcn3", "ttcnpp"] },
          { name: "TTCN_CFG", mime: "text/x-ttcn-cfg", mode: "ttcn-cfg", ext: ["cfg"] },
          { name: "Turtle", mime: "text/turtle", mode: "turtle", ext: ["ttl"] },
          { name: "TypeScript", mime: "application/typescript", mode: "javascript", ext: ["ts"], alias: ["ts"] },
          { name: "TypeScript-JSX", mime: "text/typescript-jsx", mode: "jsx", ext: ["tsx"], alias: ["tsx"] },
          { name: "Twig", mime: "text/x-twig", mode: "twig" },
          { name: "Web IDL", mime: "text/x-webidl", mode: "webidl", ext: ["webidl"] },
          { name: "VB.NET", mime: "text/x-vb", mode: "vb", ext: ["vb"] },
          { name: "VBScript", mime: "text/vbscript", mode: "vbscript", ext: ["vbs"] },
          { name: "Velocity", mime: "text/velocity", mode: "velocity", ext: ["vtl"] },
          { name: "Verilog", mime: "text/x-verilog", mode: "verilog", ext: ["v"] },
          { name: "VHDL", mime: "text/x-vhdl", mode: "vhdl", ext: ["vhd", "vhdl"] },
          { name: "Vue.js Component", mimes: ["script/x-vue", "text/x-vue"], mode: "vue", ext: ["vue"] },
          { name: "XML", mimes: ["application/xml", "text/xml"], mode: "xml", ext: ["xml", "xsl", "xsd", "svg"], alias: ["rss", "wsdl", "xsd"] },
          { name: "XQuery", mime: "application/xquery", mode: "xquery", ext: ["xy", "xquery"] },
          { name: "Yacas", mime: "text/x-yacas", mode: "yacas", ext: ["ys"] },
          { name: "YAML", mimes: ["text/x-yaml", "text/yaml"], mode: "yaml", ext: ["yaml", "yml"], alias: ["yml"] },
          { name: "Z80", mime: "text/x-z80", mode: "z80", ext: ["z80"] },
          { name: "mscgen", mime: "text/x-mscgen", mode: "mscgen", ext: ["mscgen", "mscin", "msc"] },
          { name: "xu", mime: "text/x-xu", mode: "mscgen", ext: ["xu"] },
          { name: "msgenny", mime: "text/x-msgenny", mode: "mscgen", ext: ["msgenny"] },
          { name: "WebAssembly", mime: "text/webassembly", mode: "wast", ext: ["wat", "wast"] }
        ];
        for (var i2 = 0; i2 < CodeMirror3.modeInfo.length; i2++) {
          var info = CodeMirror3.modeInfo[i2];
          if (info.mimes)
            info.mime = info.mimes[0];
        }
        CodeMirror3.findModeByMIME = function(mime) {
          mime = mime.toLowerCase();
          for (var i3 = 0; i3 < CodeMirror3.modeInfo.length; i3++) {
            var info2 = CodeMirror3.modeInfo[i3];
            if (info2.mime == mime)
              return info2;
            if (info2.mimes) {
              for (var j2 = 0; j2 < info2.mimes.length; j2++)
                if (info2.mimes[j2] == mime)
                  return info2;
            }
          }
          if (/\+xml$/.test(mime))
            return CodeMirror3.findModeByMIME("application/xml");
          if (/\+json$/.test(mime))
            return CodeMirror3.findModeByMIME("application/json");
        };
        CodeMirror3.findModeByExtension = function(ext) {
          ext = ext.toLowerCase();
          for (var i3 = 0; i3 < CodeMirror3.modeInfo.length; i3++) {
            var info2 = CodeMirror3.modeInfo[i3];
            if (info2.ext) {
              for (var j2 = 0; j2 < info2.ext.length; j2++)
                if (info2.ext[j2] == ext)
                  return info2;
            }
          }
        };
        CodeMirror3.findModeByFileName = function(filename) {
          for (var i3 = 0; i3 < CodeMirror3.modeInfo.length; i3++) {
            var info2 = CodeMirror3.modeInfo[i3];
            if (info2.file && info2.file.test(filename))
              return info2;
          }
          var dot = filename.lastIndexOf(".");
          var ext = dot > -1 && filename.substring(dot + 1, filename.length);
          if (ext)
            return CodeMirror3.findModeByExtension(ext);
        };
        CodeMirror3.findModeByName = function(name) {
          name = name.toLowerCase();
          for (var i3 = 0; i3 < CodeMirror3.modeInfo.length; i3++) {
            var info2 = CodeMirror3.modeInfo[i3];
            if (info2.name.toLowerCase() == name)
              return info2;
            if (info2.alias) {
              for (var j2 = 0; j2 < info2.alias.length; j2++)
                if (info2.alias[j2].toLowerCase() == name)
                  return info2;
            }
          }
        };
      });
    }
  });

  // node_modules/codemirror/mode/markdown/markdown.js
  var require_markdown = __commonJS({
    "node_modules/codemirror/mode/markdown/markdown.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror(), require_xml(), require_meta());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror", "../xml/xml", "../meta"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.defineMode("markdown", function(cmCfg, modeCfg) {
          var htmlMode = CodeMirror3.getMode(cmCfg, "text/html");
          var htmlModeMissing = htmlMode.name == "null";
          function getMode(name) {
            if (CodeMirror3.findModeByName) {
              var found = CodeMirror3.findModeByName(name);
              if (found)
                name = found.mime || found.mimes[0];
            }
            var mode2 = CodeMirror3.getMode(cmCfg, name);
            return mode2.name == "null" ? null : mode2;
          }
          if (modeCfg.highlightFormatting === void 0)
            modeCfg.highlightFormatting = false;
          if (modeCfg.maxBlockquoteDepth === void 0)
            modeCfg.maxBlockquoteDepth = 0;
          if (modeCfg.taskLists === void 0)
            modeCfg.taskLists = false;
          if (modeCfg.strikethrough === void 0)
            modeCfg.strikethrough = false;
          if (modeCfg.emoji === void 0)
            modeCfg.emoji = false;
          if (modeCfg.fencedCodeBlockHighlighting === void 0)
            modeCfg.fencedCodeBlockHighlighting = true;
          if (modeCfg.fencedCodeBlockDefaultMode === void 0)
            modeCfg.fencedCodeBlockDefaultMode = "text/plain";
          if (modeCfg.xml === void 0)
            modeCfg.xml = true;
          if (modeCfg.tokenTypeOverrides === void 0)
            modeCfg.tokenTypeOverrides = {};
          var tokenTypes = {
            header: "header",
            code: "comment",
            quote: "quote",
            list1: "variable-2",
            list2: "variable-3",
            list3: "keyword",
            hr: "hr",
            image: "image",
            imageAltText: "image-alt-text",
            imageMarker: "image-marker",
            formatting: "formatting",
            linkInline: "link",
            linkEmail: "link",
            linkText: "link",
            linkHref: "string",
            em: "em",
            strong: "strong",
            strikethrough: "strikethrough",
            emoji: "builtin"
          };
          for (var tokenType in tokenTypes) {
            if (tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType]) {
              tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];
            }
          }
          var hrRE = /^([*\-_])(?:\s*\1){2,}\s*$/, listRE = /^(?:[*\-+]|^[0-9]+([.)]))\s+/, taskListRE = /^\[(x| )\](?=\s)/i, atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/, setextHeaderRE = /^ {0,3}(?:\={1,}|-{2,})\s*$/, textRE = /^[^#!\[\]*_\\<>` "'(~:]+/, fencedCodeRE = /^(~~~+|```+)[ \t]*([\w\/+#-]*)[^\n`]*$/, linkDefRE = /^\s*\[[^\]]+?\]:.*$/, punctuation = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/, expandedTab = "    ";
          function switchInline(stream, state, f2) {
            state.f = state.inline = f2;
            return f2(stream, state);
          }
          function switchBlock(stream, state, f2) {
            state.f = state.block = f2;
            return f2(stream, state);
          }
          function lineIsEmpty(line) {
            return !line || !/\S/.test(line.string);
          }
          function blankLine(state) {
            state.linkTitle = false;
            state.linkHref = false;
            state.linkText = false;
            state.em = false;
            state.strong = false;
            state.strikethrough = false;
            state.quote = 0;
            state.indentedCode = false;
            if (state.f == htmlBlock) {
              var exit = htmlModeMissing;
              if (!exit) {
                var inner = CodeMirror3.innerMode(htmlMode, state.htmlState);
                exit = inner.mode.name == "xml" && inner.state.tagStart === null && (!inner.state.context && inner.state.tokenize.isInText);
              }
              if (exit) {
                state.f = inlineNormal;
                state.block = blockNormal;
                state.htmlState = null;
              }
            }
            state.trailingSpace = 0;
            state.trailingSpaceNewLine = false;
            state.prevLine = state.thisLine;
            state.thisLine = { stream: null };
            return null;
          }
          function blockNormal(stream, state) {
            var firstTokenOnLine = stream.column() === state.indentation;
            var prevLineLineIsEmpty = lineIsEmpty(state.prevLine.stream);
            var prevLineIsIndentedCode = state.indentedCode;
            var prevLineIsHr = state.prevLine.hr;
            var prevLineIsList = state.list !== false;
            var maxNonCodeIndentation = (state.listStack[state.listStack.length - 1] || 0) + 3;
            state.indentedCode = false;
            var lineIndentation = state.indentation;
            if (state.indentationDiff === null) {
              state.indentationDiff = state.indentation;
              if (prevLineIsList) {
                state.list = null;
                while (lineIndentation < state.listStack[state.listStack.length - 1]) {
                  state.listStack.pop();
                  if (state.listStack.length) {
                    state.indentation = state.listStack[state.listStack.length - 1];
                  } else {
                    state.list = false;
                  }
                }
                if (state.list !== false) {
                  state.indentationDiff = lineIndentation - state.listStack[state.listStack.length - 1];
                }
              }
            }
            var allowsInlineContinuation = !prevLineLineIsEmpty && !prevLineIsHr && !state.prevLine.header && (!prevLineIsList || !prevLineIsIndentedCode) && !state.prevLine.fencedCodeEnd;
            var isHr = (state.list === false || prevLineIsHr || prevLineLineIsEmpty) && state.indentation <= maxNonCodeIndentation && stream.match(hrRE);
            var match = null;
            if (state.indentationDiff >= 4 && (prevLineIsIndentedCode || state.prevLine.fencedCodeEnd || state.prevLine.header || prevLineLineIsEmpty)) {
              stream.skipToEnd();
              state.indentedCode = true;
              return tokenTypes.code;
            } else if (stream.eatSpace()) {
              return null;
            } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(atxHeaderRE)) && match[1].length <= 6) {
              state.quote = 0;
              state.header = match[1].length;
              state.thisLine.header = true;
              if (modeCfg.highlightFormatting)
                state.formatting = "header";
              state.f = state.inline;
              return getType(state);
            } else if (state.indentation <= maxNonCodeIndentation && stream.eat(">")) {
              state.quote = firstTokenOnLine ? 1 : state.quote + 1;
              if (modeCfg.highlightFormatting)
                state.formatting = "quote";
              stream.eatSpace();
              return getType(state);
            } else if (!isHr && !state.setext && firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(listRE))) {
              var listType = match[1] ? "ol" : "ul";
              state.indentation = lineIndentation + stream.current().length;
              state.list = true;
              state.quote = 0;
              state.listStack.push(state.indentation);
              state.em = false;
              state.strong = false;
              state.code = false;
              state.strikethrough = false;
              if (modeCfg.taskLists && stream.match(taskListRE, false)) {
                state.taskList = true;
              }
              state.f = state.inline;
              if (modeCfg.highlightFormatting)
                state.formatting = ["list", "list-" + listType];
              return getType(state);
            } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(fencedCodeRE, true))) {
              state.quote = 0;
              state.fencedEndRE = new RegExp(match[1] + "+ *$");
              state.localMode = modeCfg.fencedCodeBlockHighlighting && getMode(match[2] || modeCfg.fencedCodeBlockDefaultMode);
              if (state.localMode)
                state.localState = CodeMirror3.startState(state.localMode);
              state.f = state.block = local;
              if (modeCfg.highlightFormatting)
                state.formatting = "code-block";
              state.code = -1;
              return getType(state);
            } else if (state.setext || (!allowsInlineContinuation || !prevLineIsList) && !state.quote && state.list === false && !state.code && !isHr && !linkDefRE.test(stream.string) && (match = stream.lookAhead(1)) && (match = match.match(setextHeaderRE))) {
              if (!state.setext) {
                state.header = match[0].charAt(0) == "=" ? 1 : 2;
                state.setext = state.header;
              } else {
                state.header = state.setext;
                state.setext = 0;
                stream.skipToEnd();
                if (modeCfg.highlightFormatting)
                  state.formatting = "header";
              }
              state.thisLine.header = true;
              state.f = state.inline;
              return getType(state);
            } else if (isHr) {
              stream.skipToEnd();
              state.hr = true;
              state.thisLine.hr = true;
              return tokenTypes.hr;
            } else if (stream.peek() === "[") {
              return switchInline(stream, state, footnoteLink);
            }
            return switchInline(stream, state, state.inline);
          }
          function htmlBlock(stream, state) {
            var style = htmlMode.token(stream, state.htmlState);
            if (!htmlModeMissing) {
              var inner = CodeMirror3.innerMode(htmlMode, state.htmlState);
              if (inner.mode.name == "xml" && inner.state.tagStart === null && (!inner.state.context && inner.state.tokenize.isInText) || state.md_inside && stream.current().indexOf(">") > -1) {
                state.f = inlineNormal;
                state.block = blockNormal;
                state.htmlState = null;
              }
            }
            return style;
          }
          function local(stream, state) {
            var currListInd = state.listStack[state.listStack.length - 1] || 0;
            var hasExitedList = state.indentation < currListInd;
            var maxFencedEndInd = currListInd + 3;
            if (state.fencedEndRE && state.indentation <= maxFencedEndInd && (hasExitedList || stream.match(state.fencedEndRE))) {
              if (modeCfg.highlightFormatting)
                state.formatting = "code-block";
              var returnType;
              if (!hasExitedList)
                returnType = getType(state);
              state.localMode = state.localState = null;
              state.block = blockNormal;
              state.f = inlineNormal;
              state.fencedEndRE = null;
              state.code = 0;
              state.thisLine.fencedCodeEnd = true;
              if (hasExitedList)
                return switchBlock(stream, state, state.block);
              return returnType;
            } else if (state.localMode) {
              return state.localMode.token(stream, state.localState);
            } else {
              stream.skipToEnd();
              return tokenTypes.code;
            }
          }
          function getType(state) {
            var styles = [];
            if (state.formatting) {
              styles.push(tokenTypes.formatting);
              if (typeof state.formatting === "string")
                state.formatting = [state.formatting];
              for (var i2 = 0; i2 < state.formatting.length; i2++) {
                styles.push(tokenTypes.formatting + "-" + state.formatting[i2]);
                if (state.formatting[i2] === "header") {
                  styles.push(tokenTypes.formatting + "-" + state.formatting[i2] + "-" + state.header);
                }
                if (state.formatting[i2] === "quote") {
                  if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
                    styles.push(tokenTypes.formatting + "-" + state.formatting[i2] + "-" + state.quote);
                  } else {
                    styles.push("error");
                  }
                }
              }
            }
            if (state.taskOpen) {
              styles.push("meta");
              return styles.length ? styles.join(" ") : null;
            }
            if (state.taskClosed) {
              styles.push("property");
              return styles.length ? styles.join(" ") : null;
            }
            if (state.linkHref) {
              styles.push(tokenTypes.linkHref, "url");
            } else {
              if (state.strong) {
                styles.push(tokenTypes.strong);
              }
              if (state.em) {
                styles.push(tokenTypes.em);
              }
              if (state.strikethrough) {
                styles.push(tokenTypes.strikethrough);
              }
              if (state.emoji) {
                styles.push(tokenTypes.emoji);
              }
              if (state.linkText) {
                styles.push(tokenTypes.linkText);
              }
              if (state.code) {
                styles.push(tokenTypes.code);
              }
              if (state.image) {
                styles.push(tokenTypes.image);
              }
              if (state.imageAltText) {
                styles.push(tokenTypes.imageAltText, "link");
              }
              if (state.imageMarker) {
                styles.push(tokenTypes.imageMarker);
              }
            }
            if (state.header) {
              styles.push(tokenTypes.header, tokenTypes.header + "-" + state.header);
            }
            if (state.quote) {
              styles.push(tokenTypes.quote);
              if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
                styles.push(tokenTypes.quote + "-" + state.quote);
              } else {
                styles.push(tokenTypes.quote + "-" + modeCfg.maxBlockquoteDepth);
              }
            }
            if (state.list !== false) {
              var listMod = (state.listStack.length - 1) % 3;
              if (!listMod) {
                styles.push(tokenTypes.list1);
              } else if (listMod === 1) {
                styles.push(tokenTypes.list2);
              } else {
                styles.push(tokenTypes.list3);
              }
            }
            if (state.trailingSpaceNewLine) {
              styles.push("trailing-space-new-line");
            } else if (state.trailingSpace) {
              styles.push("trailing-space-" + (state.trailingSpace % 2 ? "a" : "b"));
            }
            return styles.length ? styles.join(" ") : null;
          }
          function handleText(stream, state) {
            if (stream.match(textRE, true)) {
              return getType(state);
            }
            return void 0;
          }
          function inlineNormal(stream, state) {
            var style = state.text(stream, state);
            if (typeof style !== "undefined")
              return style;
            if (state.list) {
              state.list = null;
              return getType(state);
            }
            if (state.taskList) {
              var taskOpen = stream.match(taskListRE, true)[1] === " ";
              if (taskOpen)
                state.taskOpen = true;
              else
                state.taskClosed = true;
              if (modeCfg.highlightFormatting)
                state.formatting = "task";
              state.taskList = false;
              return getType(state);
            }
            state.taskOpen = false;
            state.taskClosed = false;
            if (state.header && stream.match(/^#+$/, true)) {
              if (modeCfg.highlightFormatting)
                state.formatting = "header";
              return getType(state);
            }
            var ch = stream.next();
            if (state.linkTitle) {
              state.linkTitle = false;
              var matchCh = ch;
              if (ch === "(") {
                matchCh = ")";
              }
              matchCh = (matchCh + "").replace(/([.?*+^\[\]\\(){}|-])/g, "\\$1");
              var regex = "^\\s*(?:[^" + matchCh + "\\\\]+|\\\\\\\\|\\\\.)" + matchCh;
              if (stream.match(new RegExp(regex), true)) {
                return tokenTypes.linkHref;
              }
            }
            if (ch === "`") {
              var previousFormatting = state.formatting;
              if (modeCfg.highlightFormatting)
                state.formatting = "code";
              stream.eatWhile("`");
              var count = stream.current().length;
              if (state.code == 0 && (!state.quote || count == 1)) {
                state.code = count;
                return getType(state);
              } else if (count == state.code) {
                var t2 = getType(state);
                state.code = 0;
                return t2;
              } else {
                state.formatting = previousFormatting;
                return getType(state);
              }
            } else if (state.code) {
              return getType(state);
            }
            if (ch === "\\") {
              stream.next();
              if (modeCfg.highlightFormatting) {
                var type = getType(state);
                var formattingEscape = tokenTypes.formatting + "-escape";
                return type ? type + " " + formattingEscape : formattingEscape;
              }
            }
            if (ch === "!" && stream.match(/\[[^\]]*\] ?(?:\(|\[)/, false)) {
              state.imageMarker = true;
              state.image = true;
              if (modeCfg.highlightFormatting)
                state.formatting = "image";
              return getType(state);
            }
            if (ch === "[" && state.imageMarker && stream.match(/[^\]]*\](\(.*?\)| ?\[.*?\])/, false)) {
              state.imageMarker = false;
              state.imageAltText = true;
              if (modeCfg.highlightFormatting)
                state.formatting = "image";
              return getType(state);
            }
            if (ch === "]" && state.imageAltText) {
              if (modeCfg.highlightFormatting)
                state.formatting = "image";
              var type = getType(state);
              state.imageAltText = false;
              state.image = false;
              state.inline = state.f = linkHref;
              return type;
            }
            if (ch === "[" && !state.image) {
              if (state.linkText && stream.match(/^.*?\]/))
                return getType(state);
              state.linkText = true;
              if (modeCfg.highlightFormatting)
                state.formatting = "link";
              return getType(state);
            }
            if (ch === "]" && state.linkText) {
              if (modeCfg.highlightFormatting)
                state.formatting = "link";
              var type = getType(state);
              state.linkText = false;
              state.inline = state.f = stream.match(/\(.*?\)| ?\[.*?\]/, false) ? linkHref : inlineNormal;
              return type;
            }
            if (ch === "<" && stream.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, false)) {
              state.f = state.inline = linkInline;
              if (modeCfg.highlightFormatting)
                state.formatting = "link";
              var type = getType(state);
              if (type) {
                type += " ";
              } else {
                type = "";
              }
              return type + tokenTypes.linkInline;
            }
            if (ch === "<" && stream.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, false)) {
              state.f = state.inline = linkInline;
              if (modeCfg.highlightFormatting)
                state.formatting = "link";
              var type = getType(state);
              if (type) {
                type += " ";
              } else {
                type = "";
              }
              return type + tokenTypes.linkEmail;
            }
            if (modeCfg.xml && ch === "<" && stream.match(/^(!--|\?|!\[CDATA\[|[a-z][a-z0-9-]*(?:\s+[a-z_:.\-]+(?:\s*=\s*[^>]+)?)*\s*(?:>|$))/i, false)) {
              var end2 = stream.string.indexOf(">", stream.pos);
              if (end2 != -1) {
                var atts = stream.string.substring(stream.start, end2);
                if (/markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(atts))
                  state.md_inside = true;
              }
              stream.backUp(1);
              state.htmlState = CodeMirror3.startState(htmlMode);
              return switchBlock(stream, state, htmlBlock);
            }
            if (modeCfg.xml && ch === "<" && stream.match(/^\/\w*?>/)) {
              state.md_inside = false;
              return "tag";
            } else if (ch === "*" || ch === "_") {
              var len = 1, before = stream.pos == 1 ? " " : stream.string.charAt(stream.pos - 2);
              while (len < 3 && stream.eat(ch))
                len++;
              var after = stream.peek() || " ";
              var leftFlanking = !/\s/.test(after) && (!punctuation.test(after) || /\s/.test(before) || punctuation.test(before));
              var rightFlanking = !/\s/.test(before) && (!punctuation.test(before) || /\s/.test(after) || punctuation.test(after));
              var setEm = null, setStrong = null;
              if (len % 2) {
                if (!state.em && leftFlanking && (ch === "*" || !rightFlanking || punctuation.test(before)))
                  setEm = true;
                else if (state.em == ch && rightFlanking && (ch === "*" || !leftFlanking || punctuation.test(after)))
                  setEm = false;
              }
              if (len > 1) {
                if (!state.strong && leftFlanking && (ch === "*" || !rightFlanking || punctuation.test(before)))
                  setStrong = true;
                else if (state.strong == ch && rightFlanking && (ch === "*" || !leftFlanking || punctuation.test(after)))
                  setStrong = false;
              }
              if (setStrong != null || setEm != null) {
                if (modeCfg.highlightFormatting)
                  state.formatting = setEm == null ? "strong" : setStrong == null ? "em" : "strong em";
                if (setEm === true)
                  state.em = ch;
                if (setStrong === true)
                  state.strong = ch;
                var t2 = getType(state);
                if (setEm === false)
                  state.em = false;
                if (setStrong === false)
                  state.strong = false;
                return t2;
              }
            } else if (ch === " ") {
              if (stream.eat("*") || stream.eat("_")) {
                if (stream.peek() === " ") {
                  return getType(state);
                } else {
                  stream.backUp(1);
                }
              }
            }
            if (modeCfg.strikethrough) {
              if (ch === "~" && stream.eatWhile(ch)) {
                if (state.strikethrough) {
                  if (modeCfg.highlightFormatting)
                    state.formatting = "strikethrough";
                  var t2 = getType(state);
                  state.strikethrough = false;
                  return t2;
                } else if (stream.match(/^[^\s]/, false)) {
                  state.strikethrough = true;
                  if (modeCfg.highlightFormatting)
                    state.formatting = "strikethrough";
                  return getType(state);
                }
              } else if (ch === " ") {
                if (stream.match("~~", true)) {
                  if (stream.peek() === " ") {
                    return getType(state);
                  } else {
                    stream.backUp(2);
                  }
                }
              }
            }
            if (modeCfg.emoji && ch === ":" && stream.match(/^(?:[a-z_\d+][a-z_\d+-]*|\-[a-z_\d+][a-z_\d+-]*):/)) {
              state.emoji = true;
              if (modeCfg.highlightFormatting)
                state.formatting = "emoji";
              var retType = getType(state);
              state.emoji = false;
              return retType;
            }
            if (ch === " ") {
              if (stream.match(/^ +$/, false)) {
                state.trailingSpace++;
              } else if (state.trailingSpace) {
                state.trailingSpaceNewLine = true;
              }
            }
            return getType(state);
          }
          function linkInline(stream, state) {
            var ch = stream.next();
            if (ch === ">") {
              state.f = state.inline = inlineNormal;
              if (modeCfg.highlightFormatting)
                state.formatting = "link";
              var type = getType(state);
              if (type) {
                type += " ";
              } else {
                type = "";
              }
              return type + tokenTypes.linkInline;
            }
            stream.match(/^[^>]+/, true);
            return tokenTypes.linkInline;
          }
          function linkHref(stream, state) {
            if (stream.eatSpace()) {
              return null;
            }
            var ch = stream.next();
            if (ch === "(" || ch === "[") {
              state.f = state.inline = getLinkHrefInside(ch === "(" ? ")" : "]");
              if (modeCfg.highlightFormatting)
                state.formatting = "link-string";
              state.linkHref = true;
              return getType(state);
            }
            return "error";
          }
          var linkRE = {
            ")": /^(?:[^\\\(\)]|\\.|\((?:[^\\\(\)]|\\.)*\))*?(?=\))/,
            "]": /^(?:[^\\\[\]]|\\.|\[(?:[^\\\[\]]|\\.)*\])*?(?=\])/
          };
          function getLinkHrefInside(endChar) {
            return function(stream, state) {
              var ch = stream.next();
              if (ch === endChar) {
                state.f = state.inline = inlineNormal;
                if (modeCfg.highlightFormatting)
                  state.formatting = "link-string";
                var returnState = getType(state);
                state.linkHref = false;
                return returnState;
              }
              stream.match(linkRE[endChar]);
              state.linkHref = true;
              return getType(state);
            };
          }
          function footnoteLink(stream, state) {
            if (stream.match(/^([^\]\\]|\\.)*\]:/, false)) {
              state.f = footnoteLinkInside;
              stream.next();
              if (modeCfg.highlightFormatting)
                state.formatting = "link";
              state.linkText = true;
              return getType(state);
            }
            return switchInline(stream, state, inlineNormal);
          }
          function footnoteLinkInside(stream, state) {
            if (stream.match("]:", true)) {
              state.f = state.inline = footnoteUrl;
              if (modeCfg.highlightFormatting)
                state.formatting = "link";
              var returnType = getType(state);
              state.linkText = false;
              return returnType;
            }
            stream.match(/^([^\]\\]|\\.)+/, true);
            return tokenTypes.linkText;
          }
          function footnoteUrl(stream, state) {
            if (stream.eatSpace()) {
              return null;
            }
            stream.match(/^[^\s]+/, true);
            if (stream.peek() === void 0) {
              state.linkTitle = true;
            } else {
              stream.match(/^(?:\s+(?:"(?:[^"\\]|\\\\|\\.)+"|'(?:[^'\\]|\\\\|\\.)+'|\((?:[^)\\]|\\.)+\)))?/, true);
            }
            state.f = state.inline = inlineNormal;
            return tokenTypes.linkHref + " url";
          }
          var mode = {
            startState: function() {
              return {
                f: blockNormal,
                prevLine: { stream: null },
                thisLine: { stream: null },
                block: blockNormal,
                htmlState: null,
                indentation: 0,
                inline: inlineNormal,
                text: handleText,
                formatting: false,
                linkText: false,
                linkHref: false,
                linkTitle: false,
                code: 0,
                em: false,
                strong: false,
                header: 0,
                setext: 0,
                hr: false,
                taskList: false,
                list: false,
                listStack: [],
                quote: 0,
                trailingSpace: 0,
                trailingSpaceNewLine: false,
                strikethrough: false,
                emoji: false,
                fencedEndRE: null
              };
            },
            copyState: function(s2) {
              return {
                f: s2.f,
                prevLine: s2.prevLine,
                thisLine: s2.thisLine,
                block: s2.block,
                htmlState: s2.htmlState && CodeMirror3.copyState(htmlMode, s2.htmlState),
                indentation: s2.indentation,
                localMode: s2.localMode,
                localState: s2.localMode ? CodeMirror3.copyState(s2.localMode, s2.localState) : null,
                inline: s2.inline,
                text: s2.text,
                formatting: false,
                linkText: s2.linkText,
                linkTitle: s2.linkTitle,
                linkHref: s2.linkHref,
                code: s2.code,
                em: s2.em,
                strong: s2.strong,
                strikethrough: s2.strikethrough,
                emoji: s2.emoji,
                header: s2.header,
                setext: s2.setext,
                hr: s2.hr,
                taskList: s2.taskList,
                list: s2.list,
                listStack: s2.listStack.slice(0),
                quote: s2.quote,
                indentedCode: s2.indentedCode,
                trailingSpace: s2.trailingSpace,
                trailingSpaceNewLine: s2.trailingSpaceNewLine,
                md_inside: s2.md_inside,
                fencedEndRE: s2.fencedEndRE
              };
            },
            token: function(stream, state) {
              state.formatting = false;
              if (stream != state.thisLine.stream) {
                state.header = 0;
                state.hr = false;
                if (stream.match(/^\s*$/, true)) {
                  blankLine(state);
                  return null;
                }
                state.prevLine = state.thisLine;
                state.thisLine = { stream };
                state.taskList = false;
                state.trailingSpace = 0;
                state.trailingSpaceNewLine = false;
                if (!state.localState) {
                  state.f = state.block;
                  if (state.f != htmlBlock) {
                    var indentation = stream.match(/^\s*/, true)[0].replace(/\t/g, expandedTab).length;
                    state.indentation = indentation;
                    state.indentationDiff = null;
                    if (indentation > 0)
                      return null;
                  }
                }
              }
              return state.f(stream, state);
            },
            innerMode: function(state) {
              if (state.block == htmlBlock)
                return { state: state.htmlState, mode: htmlMode };
              if (state.localState)
                return { state: state.localState, mode: state.localMode };
              return { state, mode };
            },
            indent: function(state, textAfter, line) {
              if (state.block == htmlBlock && htmlMode.indent)
                return htmlMode.indent(state.htmlState, textAfter, line);
              if (state.localState && state.localMode.indent)
                return state.localMode.indent(state.localState, textAfter, line);
              return CodeMirror3.Pass;
            },
            blankLine,
            getType,
            blockCommentStart: "<!--",
            blockCommentEnd: "-->",
            closeBrackets: "()[]{}''\"\"``",
            fold: "markdown"
          };
          return mode;
        }, "xml");
        CodeMirror3.defineMIME("text/markdown", "markdown");
        CodeMirror3.defineMIME("text/x-markdown", "markdown");
      });
    }
  });

  // node_modules/codemirror/mode/nginx/nginx.js
  var require_nginx = __commonJS({
    "node_modules/codemirror/mode/nginx/nginx.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.defineMode("nginx", function(config) {
          function words(str) {
            var obj = {}, words2 = str.split(" ");
            for (var i2 = 0; i2 < words2.length; ++i2)
              obj[words2[i2]] = true;
            return obj;
          }
          var keywords = words("break return rewrite set accept_mutex accept_mutex_delay access_log add_after_body add_before_body add_header addition_types aio alias allow ancient_browser ancient_browser_value auth_basic auth_basic_user_file auth_http auth_http_header auth_http_timeout autoindex autoindex_exact_size autoindex_localtime charset charset_types client_body_buffer_size client_body_in_file_only client_body_in_single_buffer client_body_temp_path client_body_timeout client_header_buffer_size client_header_timeout client_max_body_size connection_pool_size create_full_put_path daemon dav_access dav_methods debug_connection debug_points default_type degradation degrade deny devpoll_changes devpoll_events directio directio_alignment empty_gif env epoll_events error_log eventport_events expires fastcgi_bind fastcgi_buffer_size fastcgi_buffers fastcgi_busy_buffers_size fastcgi_cache fastcgi_cache_key fastcgi_cache_methods fastcgi_cache_min_uses fastcgi_cache_path fastcgi_cache_use_stale fastcgi_cache_valid fastcgi_catch_stderr fastcgi_connect_timeout fastcgi_hide_header fastcgi_ignore_client_abort fastcgi_ignore_headers fastcgi_index fastcgi_intercept_errors fastcgi_max_temp_file_size fastcgi_next_upstream fastcgi_param fastcgi_pass_header fastcgi_pass_request_body fastcgi_pass_request_headers fastcgi_read_timeout fastcgi_send_lowat fastcgi_send_timeout fastcgi_split_path_info fastcgi_store fastcgi_store_access fastcgi_temp_file_write_size fastcgi_temp_path fastcgi_upstream_fail_timeout fastcgi_upstream_max_fails flv geoip_city geoip_country google_perftools_profiles gzip gzip_buffers gzip_comp_level gzip_disable gzip_hash gzip_http_version gzip_min_length gzip_no_buffer gzip_proxied gzip_static gzip_types gzip_vary gzip_window if_modified_since ignore_invalid_headers image_filter image_filter_buffer image_filter_jpeg_quality image_filter_transparency imap_auth imap_capabilities imap_client_buffer index ip_hash keepalive_requests keepalive_timeout kqueue_changes kqueue_events large_client_header_buffers limit_conn limit_conn_log_level limit_rate limit_rate_after limit_req limit_req_log_level limit_req_zone limit_zone lingering_time lingering_timeout lock_file log_format log_not_found log_subrequest map_hash_bucket_size map_hash_max_size master_process memcached_bind memcached_buffer_size memcached_connect_timeout memcached_next_upstream memcached_read_timeout memcached_send_timeout memcached_upstream_fail_timeout memcached_upstream_max_fails merge_slashes min_delete_depth modern_browser modern_browser_value msie_padding msie_refresh multi_accept open_file_cache open_file_cache_errors open_file_cache_events open_file_cache_min_uses open_file_cache_valid open_log_file_cache output_buffers override_charset perl perl_modules perl_require perl_set pid pop3_auth pop3_capabilities port_in_redirect postpone_gzipping postpone_output protocol proxy proxy_bind proxy_buffer proxy_buffer_size proxy_buffering proxy_buffers proxy_busy_buffers_size proxy_cache proxy_cache_key proxy_cache_methods proxy_cache_min_uses proxy_cache_path proxy_cache_use_stale proxy_cache_valid proxy_connect_timeout proxy_headers_hash_bucket_size proxy_headers_hash_max_size proxy_hide_header proxy_ignore_client_abort proxy_ignore_headers proxy_intercept_errors proxy_max_temp_file_size proxy_method proxy_next_upstream proxy_pass_error_message proxy_pass_header proxy_pass_request_body proxy_pass_request_headers proxy_read_timeout proxy_redirect proxy_send_lowat proxy_send_timeout proxy_set_body proxy_set_header proxy_ssl_session_reuse proxy_store proxy_store_access proxy_temp_file_write_size proxy_temp_path proxy_timeout proxy_upstream_fail_timeout proxy_upstream_max_fails random_index read_ahead real_ip_header recursive_error_pages request_pool_size reset_timedout_connection resolver resolver_timeout rewrite_log rtsig_overflow_events rtsig_overflow_test rtsig_overflow_threshold rtsig_signo satisfy secure_link_secret send_lowat send_timeout sendfile sendfile_max_chunk server_name_in_redirect server_names_hash_bucket_size server_names_hash_max_size server_tokens set_real_ip_from smtp_auth smtp_capabilities smtp_client_buffer smtp_greeting_delay so_keepalive source_charset ssi ssi_ignore_recycled_buffers ssi_min_file_chunk ssi_silent_errors ssi_types ssi_value_length ssl ssl_certificate ssl_certificate_key ssl_ciphers ssl_client_certificate ssl_crl ssl_dhparam ssl_engine ssl_prefer_server_ciphers ssl_protocols ssl_session_cache ssl_session_timeout ssl_verify_client ssl_verify_depth starttls stub_status sub_filter sub_filter_once sub_filter_types tcp_nodelay tcp_nopush thread_stack_size timeout timer_resolution types_hash_bucket_size types_hash_max_size underscores_in_headers uninitialized_variable_warn use user userid userid_domain userid_expires userid_mark userid_name userid_p3p userid_path userid_service valid_referers variables_hash_bucket_size variables_hash_max_size worker_connections worker_cpu_affinity worker_priority worker_processes worker_rlimit_core worker_rlimit_nofile worker_rlimit_sigpending worker_threads working_directory xclient xml_entities xslt_stylesheet xslt_typesdrew@li229-23");
          var keywords_block = words("http mail events server types location upstream charset_map limit_except if geo map");
          var keywords_important = words("include root server server_name listen internal proxy_pass memcached_pass fastcgi_pass try_files");
          var indentUnit = config.indentUnit, type;
          function ret(style, tp) {
            type = tp;
            return style;
          }
          function tokenBase(stream, state) {
            stream.eatWhile(/[\w\$_]/);
            var cur = stream.current();
            if (keywords.propertyIsEnumerable(cur)) {
              return "keyword";
            } else if (keywords_block.propertyIsEnumerable(cur)) {
              return "variable-2";
            } else if (keywords_important.propertyIsEnumerable(cur)) {
              return "string-2";
            }
            var ch = stream.next();
            if (ch == "@") {
              stream.eatWhile(/[\w\\\-]/);
              return ret("meta", stream.current());
            } else if (ch == "/" && stream.eat("*")) {
              state.tokenize = tokenCComment;
              return tokenCComment(stream, state);
            } else if (ch == "<" && stream.eat("!")) {
              state.tokenize = tokenSGMLComment;
              return tokenSGMLComment(stream, state);
            } else if (ch == "=")
              ret(null, "compare");
            else if ((ch == "~" || ch == "|") && stream.eat("="))
              return ret(null, "compare");
            else if (ch == '"' || ch == "'") {
              state.tokenize = tokenString(ch);
              return state.tokenize(stream, state);
            } else if (ch == "#") {
              stream.skipToEnd();
              return ret("comment", "comment");
            } else if (ch == "!") {
              stream.match(/^\s*\w*/);
              return ret("keyword", "important");
            } else if (/\d/.test(ch)) {
              stream.eatWhile(/[\w.%]/);
              return ret("number", "unit");
            } else if (/[,.+>*\/]/.test(ch)) {
              return ret(null, "select-op");
            } else if (/[;{}:\[\]]/.test(ch)) {
              return ret(null, ch);
            } else {
              stream.eatWhile(/[\w\\\-]/);
              return ret("variable", "variable");
            }
          }
          function tokenCComment(stream, state) {
            var maybeEnd = false, ch;
            while ((ch = stream.next()) != null) {
              if (maybeEnd && ch == "/") {
                state.tokenize = tokenBase;
                break;
              }
              maybeEnd = ch == "*";
            }
            return ret("comment", "comment");
          }
          function tokenSGMLComment(stream, state) {
            var dashes = 0, ch;
            while ((ch = stream.next()) != null) {
              if (dashes >= 2 && ch == ">") {
                state.tokenize = tokenBase;
                break;
              }
              dashes = ch == "-" ? dashes + 1 : 0;
            }
            return ret("comment", "comment");
          }
          function tokenString(quote) {
            return function(stream, state) {
              var escaped = false, ch;
              while ((ch = stream.next()) != null) {
                if (ch == quote && !escaped)
                  break;
                escaped = !escaped && ch == "\\";
              }
              if (!escaped)
                state.tokenize = tokenBase;
              return ret("string", "string");
            };
          }
          return {
            startState: function(base) {
              return {
                tokenize: tokenBase,
                baseIndent: base || 0,
                stack: []
              };
            },
            token: function(stream, state) {
              if (stream.eatSpace())
                return null;
              type = null;
              var style = state.tokenize(stream, state);
              var context = state.stack[state.stack.length - 1];
              if (type == "hash" && context == "rule")
                style = "atom";
              else if (style == "variable") {
                if (context == "rule")
                  style = "number";
                else if (!context || context == "@media{")
                  style = "tag";
              }
              if (context == "rule" && /^[\{\};]$/.test(type))
                state.stack.pop();
              if (type == "{") {
                if (context == "@media")
                  state.stack[state.stack.length - 1] = "@media{";
                else
                  state.stack.push("{");
              } else if (type == "}")
                state.stack.pop();
              else if (type == "@media")
                state.stack.push("@media");
              else if (context == "{" && type != "comment")
                state.stack.push("rule");
              return style;
            },
            indent: function(state, textAfter) {
              var n2 = state.stack.length;
              if (/^\}/.test(textAfter))
                n2 -= state.stack[state.stack.length - 1] == "rule" ? 2 : 1;
              return state.baseIndent + n2 * indentUnit;
            },
            electricChars: "}"
          };
        });
        CodeMirror3.defineMIME("text/x-nginx-conf", "nginx");
      });
    }
  });

  // node_modules/codemirror/mode/clike/clike.js
  var require_clike = __commonJS({
    "node_modules/codemirror/mode/clike/clike.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        function Context2(indented, column, type, info, align, prev) {
          this.indented = indented;
          this.column = column;
          this.type = type;
          this.info = info;
          this.align = align;
          this.prev = prev;
        }
        function pushContext(state, col, type, info) {
          var indent = state.indented;
          if (state.context && state.context.type == "statement" && type != "statement")
            indent = state.context.indented;
          return state.context = new Context2(indent, col, type, info, null, state.context);
        }
        function popContext(state) {
          var t2 = state.context.type;
          if (t2 == ")" || t2 == "]" || t2 == "}")
            state.indented = state.context.indented;
          return state.context = state.context.prev;
        }
        function typeBefore(stream, state, pos) {
          if (state.prevToken == "variable" || state.prevToken == "type")
            return true;
          if (/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(stream.string.slice(0, pos)))
            return true;
          if (state.typeAtEndOfLine && stream.column() == stream.indentation())
            return true;
        }
        function isTopScope(context) {
          for (; ; ) {
            if (!context || context.type == "top")
              return true;
            if (context.type == "}" && context.prev.info != "namespace")
              return false;
            context = context.prev;
          }
        }
        CodeMirror3.defineMode("clike", function(config, parserConfig) {
          var indentUnit = config.indentUnit, statementIndentUnit = parserConfig.statementIndentUnit || indentUnit, dontAlignCalls = parserConfig.dontAlignCalls, keywords = parserConfig.keywords || {}, types = parserConfig.types || {}, builtin = parserConfig.builtin || {}, blockKeywords = parserConfig.blockKeywords || {}, defKeywords = parserConfig.defKeywords || {}, atoms = parserConfig.atoms || {}, hooks = parserConfig.hooks || {}, multiLineStrings = parserConfig.multiLineStrings, indentStatements = parserConfig.indentStatements !== false, indentSwitch = parserConfig.indentSwitch !== false, namespaceSeparator = parserConfig.namespaceSeparator, isPunctuationChar = parserConfig.isPunctuationChar || /[\[\]{}\(\),;\:\.]/, numberStart = parserConfig.numberStart || /[\d\.]/, number = parserConfig.number || /^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i, isOperatorChar = parserConfig.isOperatorChar || /[+\-*&%=<>!?|\/]/, isIdentifierChar = parserConfig.isIdentifierChar || /[\w\$_\xa1-\uffff]/, isReservedIdentifier = parserConfig.isReservedIdentifier || false;
          var curPunc, isDefKeyword;
          function tokenBase(stream, state) {
            var ch = stream.next();
            if (hooks[ch]) {
              var result = hooks[ch](stream, state);
              if (result !== false)
                return result;
            }
            if (ch == '"' || ch == "'") {
              state.tokenize = tokenString(ch);
              return state.tokenize(stream, state);
            }
            if (numberStart.test(ch)) {
              stream.backUp(1);
              if (stream.match(number))
                return "number";
              stream.next();
            }
            if (isPunctuationChar.test(ch)) {
              curPunc = ch;
              return null;
            }
            if (ch == "/") {
              if (stream.eat("*")) {
                state.tokenize = tokenComment;
                return tokenComment(stream, state);
              }
              if (stream.eat("/")) {
                stream.skipToEnd();
                return "comment";
              }
            }
            if (isOperatorChar.test(ch)) {
              while (!stream.match(/^\/[\/*]/, false) && stream.eat(isOperatorChar)) {
              }
              return "operator";
            }
            stream.eatWhile(isIdentifierChar);
            if (namespaceSeparator)
              while (stream.match(namespaceSeparator))
                stream.eatWhile(isIdentifierChar);
            var cur = stream.current();
            if (contains2(keywords, cur)) {
              if (contains2(blockKeywords, cur))
                curPunc = "newstatement";
              if (contains2(defKeywords, cur))
                isDefKeyword = true;
              return "keyword";
            }
            if (contains2(types, cur))
              return "type";
            if (contains2(builtin, cur) || isReservedIdentifier && isReservedIdentifier(cur)) {
              if (contains2(blockKeywords, cur))
                curPunc = "newstatement";
              return "builtin";
            }
            if (contains2(atoms, cur))
              return "atom";
            return "variable";
          }
          function tokenString(quote) {
            return function(stream, state) {
              var escaped = false, next, end2 = false;
              while ((next = stream.next()) != null) {
                if (next == quote && !escaped) {
                  end2 = true;
                  break;
                }
                escaped = !escaped && next == "\\";
              }
              if (end2 || !(escaped || multiLineStrings))
                state.tokenize = null;
              return "string";
            };
          }
          function tokenComment(stream, state) {
            var maybeEnd = false, ch;
            while (ch = stream.next()) {
              if (ch == "/" && maybeEnd) {
                state.tokenize = null;
                break;
              }
              maybeEnd = ch == "*";
            }
            return "comment";
          }
          function maybeEOL(stream, state) {
            if (parserConfig.typeFirstDefinitions && stream.eol() && isTopScope(state.context))
              state.typeAtEndOfLine = typeBefore(stream, state, stream.pos);
          }
          return {
            startState: function(basecolumn) {
              return {
                tokenize: null,
                context: new Context2((basecolumn || 0) - indentUnit, 0, "top", null, false),
                indented: 0,
                startOfLine: true,
                prevToken: null
              };
            },
            token: function(stream, state) {
              var ctx = state.context;
              if (stream.sol()) {
                if (ctx.align == null)
                  ctx.align = false;
                state.indented = stream.indentation();
                state.startOfLine = true;
              }
              if (stream.eatSpace()) {
                maybeEOL(stream, state);
                return null;
              }
              curPunc = isDefKeyword = null;
              var style = (state.tokenize || tokenBase)(stream, state);
              if (style == "comment" || style == "meta")
                return style;
              if (ctx.align == null)
                ctx.align = true;
              if (curPunc == ";" || curPunc == ":" || curPunc == "," && stream.match(/^\s*(?:\/\/.*)?$/, false))
                while (state.context.type == "statement")
                  popContext(state);
              else if (curPunc == "{")
                pushContext(state, stream.column(), "}");
              else if (curPunc == "[")
                pushContext(state, stream.column(), "]");
              else if (curPunc == "(")
                pushContext(state, stream.column(), ")");
              else if (curPunc == "}") {
                while (ctx.type == "statement")
                  ctx = popContext(state);
                if (ctx.type == "}")
                  ctx = popContext(state);
                while (ctx.type == "statement")
                  ctx = popContext(state);
              } else if (curPunc == ctx.type)
                popContext(state);
              else if (indentStatements && ((ctx.type == "}" || ctx.type == "top") && curPunc != ";" || ctx.type == "statement" && curPunc == "newstatement")) {
                pushContext(state, stream.column(), "statement", stream.current());
              }
              if (style == "variable" && (state.prevToken == "def" || parserConfig.typeFirstDefinitions && typeBefore(stream, state, stream.start) && isTopScope(state.context) && stream.match(/^\s*\(/, false)))
                style = "def";
              if (hooks.token) {
                var result = hooks.token(stream, state, style);
                if (result !== void 0)
                  style = result;
              }
              if (style == "def" && parserConfig.styleDefs === false)
                style = "variable";
              state.startOfLine = false;
              state.prevToken = isDefKeyword ? "def" : style || curPunc;
              maybeEOL(stream, state);
              return style;
            },
            indent: function(state, textAfter) {
              if (state.tokenize != tokenBase && state.tokenize != null || state.typeAtEndOfLine)
                return CodeMirror3.Pass;
              var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);
              var closing = firstChar == ctx.type;
              if (ctx.type == "statement" && firstChar == "}")
                ctx = ctx.prev;
              if (parserConfig.dontIndentStatements)
                while (ctx.type == "statement" && parserConfig.dontIndentStatements.test(ctx.info))
                  ctx = ctx.prev;
              if (hooks.indent) {
                var hook = hooks.indent(state, ctx, textAfter, indentUnit);
                if (typeof hook == "number")
                  return hook;
              }
              var switchBlock = ctx.prev && ctx.prev.info == "switch";
              if (parserConfig.allmanIndentation && /[{(]/.test(firstChar)) {
                while (ctx.type != "top" && ctx.type != "}")
                  ctx = ctx.prev;
                return ctx.indented;
              }
              if (ctx.type == "statement")
                return ctx.indented + (firstChar == "{" ? 0 : statementIndentUnit);
              if (ctx.align && (!dontAlignCalls || ctx.type != ")"))
                return ctx.column + (closing ? 0 : 1);
              if (ctx.type == ")" && !closing)
                return ctx.indented + statementIndentUnit;
              return ctx.indented + (closing ? 0 : indentUnit) + (!closing && switchBlock && !/^(?:case|default)\b/.test(textAfter) ? indentUnit : 0);
            },
            electricInput: indentSwitch ? /^\s*(?:case .*?:|default:|\{\}?|\})$/ : /^\s*[{}]$/,
            blockCommentStart: "/*",
            blockCommentEnd: "*/",
            blockCommentContinue: " * ",
            lineComment: "//",
            fold: "brace"
          };
        });
        function words(str) {
          var obj = {}, words2 = str.split(" ");
          for (var i2 = 0; i2 < words2.length; ++i2)
            obj[words2[i2]] = true;
          return obj;
        }
        function contains2(words2, word) {
          if (typeof words2 === "function") {
            return words2(word);
          } else {
            return words2.propertyIsEnumerable(word);
          }
        }
        var cKeywords = "auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile inline restrict asm fortran";
        var cppKeywords = "alignas alignof and and_eq audit axiom bitand bitor catch class compl concept constexpr const_cast decltype delete dynamic_cast explicit export final friend import module mutable namespace new noexcept not not_eq operator or or_eq override private protected public reinterpret_cast requires static_assert static_cast template this thread_local throw try typeid typename using virtual xor xor_eq";
        var objCKeywords = "bycopy byref in inout oneway out self super atomic nonatomic retain copy readwrite readonly strong weak assign typeof nullable nonnull null_resettable _cmd @interface @implementation @end @protocol @encode @property @synthesize @dynamic @class @public @package @private @protected @required @optional @try @catch @finally @import @selector @encode @defs @synchronized @autoreleasepool @compatibility_alias @available";
        var objCBuiltins = "FOUNDATION_EXPORT FOUNDATION_EXTERN NS_INLINE NS_FORMAT_FUNCTION  NS_RETURNS_RETAINEDNS_ERROR_ENUM NS_RETURNS_NOT_RETAINED NS_RETURNS_INNER_POINTER NS_DESIGNATED_INITIALIZER NS_ENUM NS_OPTIONS NS_REQUIRES_NIL_TERMINATION NS_ASSUME_NONNULL_BEGIN NS_ASSUME_NONNULL_END NS_SWIFT_NAME NS_REFINED_FOR_SWIFT";
        var basicCTypes = words("int long char short double float unsigned signed void bool");
        var basicObjCTypes = words("SEL instancetype id Class Protocol BOOL");
        function cTypes(identifier) {
          return contains2(basicCTypes, identifier) || /.+_t$/.test(identifier);
        }
        function objCTypes(identifier) {
          return cTypes(identifier) || contains2(basicObjCTypes, identifier);
        }
        var cBlockKeywords = "case do else for if switch while struct enum union";
        var cDefKeywords = "struct enum union";
        function cppHook(stream, state) {
          if (!state.startOfLine)
            return false;
          for (var ch, next = null; ch = stream.peek(); ) {
            if (ch == "\\" && stream.match(/^.$/)) {
              next = cppHook;
              break;
            } else if (ch == "/" && stream.match(/^\/[\/\*]/, false)) {
              break;
            }
            stream.next();
          }
          state.tokenize = next;
          return "meta";
        }
        function pointerHook(_stream, state) {
          if (state.prevToken == "type")
            return "type";
          return false;
        }
        function cIsReservedIdentifier(token) {
          if (!token || token.length < 2)
            return false;
          if (token[0] != "_")
            return false;
          return token[1] == "_" || token[1] !== token[1].toLowerCase();
        }
        function cpp14Literal(stream) {
          stream.eatWhile(/[\w\.']/);
          return "number";
        }
        function cpp11StringHook(stream, state) {
          stream.backUp(1);
          if (stream.match(/^(?:R|u8R|uR|UR|LR)/)) {
            var match = stream.match(/^"([^\s\\()]{0,16})\(/);
            if (!match) {
              return false;
            }
            state.cpp11RawStringDelim = match[1];
            state.tokenize = tokenRawString;
            return tokenRawString(stream, state);
          }
          if (stream.match(/^(?:u8|u|U|L)/)) {
            if (stream.match(/^["']/, false)) {
              return "string";
            }
            return false;
          }
          stream.next();
          return false;
        }
        function cppLooksLikeConstructor(word) {
          var lastTwo = /(\w+)::~?(\w+)$/.exec(word);
          return lastTwo && lastTwo[1] == lastTwo[2];
        }
        function tokenAtString(stream, state) {
          var next;
          while ((next = stream.next()) != null) {
            if (next == '"' && !stream.eat('"')) {
              state.tokenize = null;
              break;
            }
          }
          return "string";
        }
        function tokenRawString(stream, state) {
          var delim = state.cpp11RawStringDelim.replace(/[^\w\s]/g, "\\$&");
          var match = stream.match(new RegExp(".*?\\)" + delim + '"'));
          if (match)
            state.tokenize = null;
          else
            stream.skipToEnd();
          return "string";
        }
        function def(mimes, mode) {
          if (typeof mimes == "string")
            mimes = [mimes];
          var words2 = [];
          function add3(obj) {
            if (obj) {
              for (var prop in obj)
                if (obj.hasOwnProperty(prop))
                  words2.push(prop);
            }
          }
          add3(mode.keywords);
          add3(mode.types);
          add3(mode.builtin);
          add3(mode.atoms);
          if (words2.length) {
            mode.helperType = mimes[0];
            CodeMirror3.registerHelper("hintWords", mimes[0], words2);
          }
          for (var i2 = 0; i2 < mimes.length; ++i2)
            CodeMirror3.defineMIME(mimes[i2], mode);
        }
        def(["text/x-csrc", "text/x-c", "text/x-chdr"], {
          name: "clike",
          keywords: words(cKeywords),
          types: cTypes,
          blockKeywords: words(cBlockKeywords),
          defKeywords: words(cDefKeywords),
          typeFirstDefinitions: true,
          atoms: words("NULL true false"),
          isReservedIdentifier: cIsReservedIdentifier,
          hooks: {
            "#": cppHook,
            "*": pointerHook
          },
          modeProps: { fold: ["brace", "include"] }
        });
        def(["text/x-c++src", "text/x-c++hdr"], {
          name: "clike",
          keywords: words(cKeywords + " " + cppKeywords),
          types: cTypes,
          blockKeywords: words(cBlockKeywords + " class try catch"),
          defKeywords: words(cDefKeywords + " class namespace"),
          typeFirstDefinitions: true,
          atoms: words("true false NULL nullptr"),
          dontIndentStatements: /^template$/,
          isIdentifierChar: /[\w\$_~\xa1-\uffff]/,
          isReservedIdentifier: cIsReservedIdentifier,
          hooks: {
            "#": cppHook,
            "*": pointerHook,
            "u": cpp11StringHook,
            "U": cpp11StringHook,
            "L": cpp11StringHook,
            "R": cpp11StringHook,
            "0": cpp14Literal,
            "1": cpp14Literal,
            "2": cpp14Literal,
            "3": cpp14Literal,
            "4": cpp14Literal,
            "5": cpp14Literal,
            "6": cpp14Literal,
            "7": cpp14Literal,
            "8": cpp14Literal,
            "9": cpp14Literal,
            token: function(stream, state, style) {
              if (style == "variable" && stream.peek() == "(" && (state.prevToken == ";" || state.prevToken == null || state.prevToken == "}") && cppLooksLikeConstructor(stream.current()))
                return "def";
            }
          },
          namespaceSeparator: "::",
          modeProps: { fold: ["brace", "include"] }
        });
        def("text/x-java", {
          name: "clike",
          keywords: words("abstract assert break case catch class const continue default do else enum extends final finally for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),
          types: words("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),
          blockKeywords: words("catch class do else finally for if switch try while"),
          defKeywords: words("class interface enum @interface"),
          typeFirstDefinitions: true,
          atoms: words("true false null"),
          number: /^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,
          hooks: {
            "@": function(stream) {
              if (stream.match("interface", false))
                return false;
              stream.eatWhile(/[\w\$_]/);
              return "meta";
            }
          },
          modeProps: { fold: ["brace", "import"] }
        });
        def("text/x-csharp", {
          name: "clike",
          keywords: words("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),
          types: words("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),
          blockKeywords: words("catch class do else finally for foreach if struct switch try while"),
          defKeywords: words("class interface namespace struct var"),
          typeFirstDefinitions: true,
          atoms: words("true false null"),
          hooks: {
            "@": function(stream, state) {
              if (stream.eat('"')) {
                state.tokenize = tokenAtString;
                return tokenAtString(stream, state);
              }
              stream.eatWhile(/[\w\$_]/);
              return "meta";
            }
          }
        });
        function tokenTripleString(stream, state) {
          var escaped = false;
          while (!stream.eol()) {
            if (!escaped && stream.match('"""')) {
              state.tokenize = null;
              break;
            }
            escaped = stream.next() == "\\" && !escaped;
          }
          return "string";
        }
        function tokenNestedComment(depth) {
          return function(stream, state) {
            var ch;
            while (ch = stream.next()) {
              if (ch == "*" && stream.eat("/")) {
                if (depth == 1) {
                  state.tokenize = null;
                  break;
                } else {
                  state.tokenize = tokenNestedComment(depth - 1);
                  return state.tokenize(stream, state);
                }
              } else if (ch == "/" && stream.eat("*")) {
                state.tokenize = tokenNestedComment(depth + 1);
                return state.tokenize(stream, state);
              }
            }
            return "comment";
          };
        }
        def("text/x-scala", {
          name: "clike",
          keywords: words("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),
          types: words("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),
          multiLineStrings: true,
          blockKeywords: words("catch class enum do else finally for forSome if match switch try while"),
          defKeywords: words("class enum def object package trait type val var"),
          atoms: words("true false null"),
          indentStatements: false,
          indentSwitch: false,
          isOperatorChar: /[+\-*&%=<>!?|\/#:@]/,
          hooks: {
            "@": function(stream) {
              stream.eatWhile(/[\w\$_]/);
              return "meta";
            },
            '"': function(stream, state) {
              if (!stream.match('""'))
                return false;
              state.tokenize = tokenTripleString;
              return state.tokenize(stream, state);
            },
            "'": function(stream) {
              stream.eatWhile(/[\w\$_\xa1-\uffff]/);
              return "atom";
            },
            "=": function(stream, state) {
              var cx = state.context;
              if (cx.type == "}" && cx.align && stream.eat(">")) {
                state.context = new Context2(cx.indented, cx.column, cx.type, cx.info, null, cx.prev);
                return "operator";
              } else {
                return false;
              }
            },
            "/": function(stream, state) {
              if (!stream.eat("*"))
                return false;
              state.tokenize = tokenNestedComment(1);
              return state.tokenize(stream, state);
            }
          },
          modeProps: { closeBrackets: { pairs: '()[]{}""', triples: '"' } }
        });
        function tokenKotlinString(tripleString) {
          return function(stream, state) {
            var escaped = false, next, end2 = false;
            while (!stream.eol()) {
              if (!tripleString && !escaped && stream.match('"')) {
                end2 = true;
                break;
              }
              if (tripleString && stream.match('"""')) {
                end2 = true;
                break;
              }
              next = stream.next();
              if (!escaped && next == "$" && stream.match("{"))
                stream.skipTo("}");
              escaped = !escaped && next == "\\" && !tripleString;
            }
            if (end2 || !tripleString)
              state.tokenize = null;
            return "string";
          };
        }
        def("text/x-kotlin", {
          name: "clike",
          keywords: words("package as typealias class interface this super val operator var fun for is in This throw return annotation break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend actual expect setparam"),
          types: words("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void Annotation Any BooleanArray ByteArray Char CharArray DeprecationLevel DoubleArray Enum FloatArray Function Int IntArray Lazy LazyThreadSafetyMode LongArray Nothing ShortArray Unit"),
          intendSwitch: false,
          indentStatements: false,
          multiLineStrings: true,
          number: /^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+(\.\d+)?|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,
          blockKeywords: words("catch class do else finally for if where try while enum"),
          defKeywords: words("class val var object interface fun"),
          atoms: words("true false null this"),
          hooks: {
            "@": function(stream) {
              stream.eatWhile(/[\w\$_]/);
              return "meta";
            },
            "*": function(_stream, state) {
              return state.prevToken == "." ? "variable" : "operator";
            },
            '"': function(stream, state) {
              state.tokenize = tokenKotlinString(stream.match('""'));
              return state.tokenize(stream, state);
            },
            "/": function(stream, state) {
              if (!stream.eat("*"))
                return false;
              state.tokenize = tokenNestedComment(1);
              return state.tokenize(stream, state);
            },
            indent: function(state, ctx, textAfter, indentUnit) {
              var firstChar = textAfter && textAfter.charAt(0);
              if ((state.prevToken == "}" || state.prevToken == ")") && textAfter == "")
                return state.indented;
              if (state.prevToken == "operator" && textAfter != "}" && state.context.type != "}" || state.prevToken == "variable" && firstChar == "." || (state.prevToken == "}" || state.prevToken == ")") && firstChar == ".")
                return indentUnit * 2 + ctx.indented;
              if (ctx.align && ctx.type == "}")
                return ctx.indented + (state.context.type == (textAfter || "").charAt(0) ? 0 : indentUnit);
            }
          },
          modeProps: { closeBrackets: { triples: '"' } }
        });
        def(["x-shader/x-vertex", "x-shader/x-fragment"], {
          name: "clike",
          keywords: words("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),
          types: words("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),
          blockKeywords: words("for while do if else struct"),
          builtin: words("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),
          atoms: words("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TextureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),
          indentSwitch: false,
          hooks: { "#": cppHook },
          modeProps: { fold: ["brace", "include"] }
        });
        def("text/x-nesc", {
          name: "clike",
          keywords: words(cKeywords + " as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),
          types: cTypes,
          blockKeywords: words(cBlockKeywords),
          atoms: words("null true false"),
          hooks: { "#": cppHook },
          modeProps: { fold: ["brace", "include"] }
        });
        def("text/x-objectivec", {
          name: "clike",
          keywords: words(cKeywords + " " + objCKeywords),
          types: objCTypes,
          builtin: words(objCBuiltins),
          blockKeywords: words(cBlockKeywords + " @synthesize @try @catch @finally @autoreleasepool @synchronized"),
          defKeywords: words(cDefKeywords + " @interface @implementation @protocol @class"),
          dontIndentStatements: /^@.*$/,
          typeFirstDefinitions: true,
          atoms: words("YES NO NULL Nil nil true false nullptr"),
          isReservedIdentifier: cIsReservedIdentifier,
          hooks: {
            "#": cppHook,
            "*": pointerHook
          },
          modeProps: { fold: ["brace", "include"] }
        });
        def("text/x-objectivec++", {
          name: "clike",
          keywords: words(cKeywords + " " + objCKeywords + " " + cppKeywords),
          types: objCTypes,
          builtin: words(objCBuiltins),
          blockKeywords: words(cBlockKeywords + " @synthesize @try @catch @finally @autoreleasepool @synchronized class try catch"),
          defKeywords: words(cDefKeywords + " @interface @implementation @protocol @class class namespace"),
          dontIndentStatements: /^@.*$|^template$/,
          typeFirstDefinitions: true,
          atoms: words("YES NO NULL Nil nil true false nullptr"),
          isReservedIdentifier: cIsReservedIdentifier,
          hooks: {
            "#": cppHook,
            "*": pointerHook,
            "u": cpp11StringHook,
            "U": cpp11StringHook,
            "L": cpp11StringHook,
            "R": cpp11StringHook,
            "0": cpp14Literal,
            "1": cpp14Literal,
            "2": cpp14Literal,
            "3": cpp14Literal,
            "4": cpp14Literal,
            "5": cpp14Literal,
            "6": cpp14Literal,
            "7": cpp14Literal,
            "8": cpp14Literal,
            "9": cpp14Literal,
            token: function(stream, state, style) {
              if (style == "variable" && stream.peek() == "(" && (state.prevToken == ";" || state.prevToken == null || state.prevToken == "}") && cppLooksLikeConstructor(stream.current()))
                return "def";
            }
          },
          namespaceSeparator: "::",
          modeProps: { fold: ["brace", "include"] }
        });
        def("text/x-squirrel", {
          name: "clike",
          keywords: words("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),
          types: cTypes,
          blockKeywords: words("case catch class else for foreach if switch try while"),
          defKeywords: words("function local class"),
          typeFirstDefinitions: true,
          atoms: words("true false null"),
          hooks: { "#": cppHook },
          modeProps: { fold: ["brace", "include"] }
        });
        var stringTokenizer = null;
        function tokenCeylonString(type) {
          return function(stream, state) {
            var escaped = false, next, end2 = false;
            while (!stream.eol()) {
              if (!escaped && stream.match('"') && (type == "single" || stream.match('""'))) {
                end2 = true;
                break;
              }
              if (!escaped && stream.match("``")) {
                stringTokenizer = tokenCeylonString(type);
                end2 = true;
                break;
              }
              next = stream.next();
              escaped = type == "single" && !escaped && next == "\\";
            }
            if (end2)
              state.tokenize = null;
            return "string";
          };
        }
        def("text/x-ceylon", {
          name: "clike",
          keywords: words("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),
          types: function(word) {
            var first = word.charAt(0);
            return first === first.toUpperCase() && first !== first.toLowerCase();
          },
          blockKeywords: words("case catch class dynamic else finally for function if interface module new object switch try while"),
          defKeywords: words("class dynamic function interface module object package value"),
          builtin: words("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),
          isPunctuationChar: /[\[\]{}\(\),;\:\.`]/,
          isOperatorChar: /[+\-*&%=<>!?|^~:\/]/,
          numberStart: /[\d#$]/,
          number: /^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,
          multiLineStrings: true,
          typeFirstDefinitions: true,
          atoms: words("true false null larger smaller equal empty finished"),
          indentSwitch: false,
          styleDefs: false,
          hooks: {
            "@": function(stream) {
              stream.eatWhile(/[\w\$_]/);
              return "meta";
            },
            '"': function(stream, state) {
              state.tokenize = tokenCeylonString(stream.match('""') ? "triple" : "single");
              return state.tokenize(stream, state);
            },
            "`": function(stream, state) {
              if (!stringTokenizer || !stream.match("`"))
                return false;
              state.tokenize = stringTokenizer;
              stringTokenizer = null;
              return state.tokenize(stream, state);
            },
            "'": function(stream) {
              stream.eatWhile(/[\w\$_\xa1-\uffff]/);
              return "atom";
            },
            token: function(_stream, state, style) {
              if ((style == "variable" || style == "type") && state.prevToken == ".") {
                return "variable-2";
              }
            }
          },
          modeProps: {
            fold: ["brace", "import"],
            closeBrackets: { triples: '"' }
          }
        });
      });
    }
  });

  // node_modules/codemirror/mode/php/php.js
  var require_php = __commonJS({
    "node_modules/codemirror/mode/php/php.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror(), require_htmlmixed(), require_clike());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror", "../htmlmixed/htmlmixed", "../clike/clike"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        function keywords(str) {
          var obj = {}, words = str.split(" ");
          for (var i2 = 0; i2 < words.length; ++i2)
            obj[words[i2]] = true;
          return obj;
        }
        function matchSequence(list, end2, escapes) {
          if (list.length == 0)
            return phpString(end2);
          return function(stream, state) {
            var patterns = list[0];
            for (var i2 = 0; i2 < patterns.length; i2++)
              if (stream.match(patterns[i2][0])) {
                state.tokenize = matchSequence(list.slice(1), end2);
                return patterns[i2][1];
              }
            state.tokenize = phpString(end2, escapes);
            return "string";
          };
        }
        function phpString(closing, escapes) {
          return function(stream, state) {
            return phpString_(stream, state, closing, escapes);
          };
        }
        function phpString_(stream, state, closing, escapes) {
          if (escapes !== false && stream.match("${", false) || stream.match("{$", false)) {
            state.tokenize = null;
            return "string";
          }
          if (escapes !== false && stream.match(/^\$[a-zA-Z_][a-zA-Z0-9_]*/)) {
            if (stream.match("[", false)) {
              state.tokenize = matchSequence([
                [["[", null]],
                [
                  [/\d[\w\.]*/, "number"],
                  [/\$[a-zA-Z_][a-zA-Z0-9_]*/, "variable-2"],
                  [/[\w\$]+/, "variable"]
                ],
                [["]", null]]
              ], closing, escapes);
            }
            if (stream.match(/^->\w/, false)) {
              state.tokenize = matchSequence([
                [["->", null]],
                [[/[\w]+/, "variable"]]
              ], closing, escapes);
            }
            return "variable-2";
          }
          var escaped = false;
          while (!stream.eol() && (escaped || escapes === false || !stream.match("{$", false) && !stream.match(/^(\$[a-zA-Z_][a-zA-Z0-9_]*|\$\{)/, false))) {
            if (!escaped && stream.match(closing)) {
              state.tokenize = null;
              state.tokStack.pop();
              state.tokStack.pop();
              break;
            }
            escaped = stream.next() == "\\" && !escaped;
          }
          return "string";
        }
        var phpKeywords = "abstract and array as break case catch class clone const continue declare default do else elseif enddeclare endfor endforeach endif endswitch endwhile extends final for foreach function global goto if implements interface instanceof namespace new or private protected public static switch throw trait try use var while xor die echo empty exit eval include include_once isset list require require_once return print unset __halt_compiler self static parent yield insteadof finally";
        var phpAtoms = "true false null TRUE FALSE NULL __CLASS__ __DIR__ __FILE__ __LINE__ __METHOD__ __FUNCTION__ __NAMESPACE__ __TRAIT__";
        var phpBuiltin = "func_num_args func_get_arg func_get_args strlen strcmp strncmp strcasecmp strncasecmp each error_reporting define defined trigger_error user_error set_error_handler restore_error_handler get_declared_classes get_loaded_extensions extension_loaded get_extension_funcs debug_backtrace constant bin2hex hex2bin sleep usleep time mktime gmmktime strftime gmstrftime strtotime date gmdate getdate localtime checkdate flush wordwrap htmlspecialchars htmlentities html_entity_decode md5 md5_file crc32 getimagesize image_type_to_mime_type phpinfo phpversion phpcredits strnatcmp strnatcasecmp substr_count strspn strcspn strtok strtoupper strtolower strpos strrpos strrev hebrev hebrevc nl2br basename dirname pathinfo stripslashes stripcslashes strstr stristr strrchr str_shuffle str_word_count strcoll substr substr_replace quotemeta ucfirst ucwords strtr addslashes addcslashes rtrim str_replace str_repeat count_chars chunk_split trim ltrim strip_tags similar_text explode implode setlocale localeconv parse_str str_pad chop strchr sprintf printf vprintf vsprintf sscanf fscanf parse_url urlencode urldecode rawurlencode rawurldecode readlink linkinfo link unlink exec system escapeshellcmd escapeshellarg passthru shell_exec proc_open proc_close rand srand getrandmax mt_rand mt_srand mt_getrandmax base64_decode base64_encode abs ceil floor round is_finite is_nan is_infinite bindec hexdec octdec decbin decoct dechex base_convert number_format fmod ip2long long2ip getenv putenv getopt microtime gettimeofday getrusage uniqid quoted_printable_decode set_time_limit get_cfg_var magic_quotes_runtime set_magic_quotes_runtime get_magic_quotes_gpc get_magic_quotes_runtime import_request_variables error_log serialize unserialize memory_get_usage var_dump var_export debug_zval_dump print_r highlight_file show_source highlight_string ini_get ini_get_all ini_set ini_alter ini_restore get_include_path set_include_path restore_include_path setcookie header headers_sent connection_aborted connection_status ignore_user_abort parse_ini_file is_uploaded_file move_uploaded_file intval floatval doubleval strval gettype settype is_null is_resource is_bool is_long is_float is_int is_integer is_double is_real is_numeric is_string is_array is_object is_scalar ereg ereg_replace eregi eregi_replace split spliti join sql_regcase dl pclose popen readfile rewind rmdir umask fclose feof fgetc fgets fgetss fread fopen fpassthru ftruncate fstat fseek ftell fflush fwrite fputs mkdir rename copy tempnam tmpfile file file_get_contents file_put_contents stream_select stream_context_create stream_context_set_params stream_context_set_option stream_context_get_options stream_filter_prepend stream_filter_append fgetcsv flock get_meta_tags stream_set_write_buffer set_file_buffer set_socket_blocking stream_set_blocking socket_set_blocking stream_get_meta_data stream_register_wrapper stream_wrapper_register stream_set_timeout socket_set_timeout socket_get_status realpath fnmatch fsockopen pfsockopen pack unpack get_browser crypt opendir closedir chdir getcwd rewinddir readdir dir glob fileatime filectime filegroup fileinode filemtime fileowner fileperms filesize filetype file_exists is_writable is_writeable is_readable is_executable is_file is_dir is_link stat lstat chown touch clearstatcache mail ob_start ob_flush ob_clean ob_end_flush ob_end_clean ob_get_flush ob_get_clean ob_get_length ob_get_level ob_get_status ob_get_contents ob_implicit_flush ob_list_handlers ksort krsort natsort natcasesort asort arsort sort rsort usort uasort uksort shuffle array_walk count end prev next reset current key min max in_array array_search extract compact array_fill range array_multisort array_push array_pop array_shift array_unshift array_splice array_slice array_merge array_merge_recursive array_keys array_values array_count_values array_reverse array_reduce array_pad array_flip array_change_key_case array_rand array_unique array_intersect array_intersect_assoc array_diff array_diff_assoc array_sum array_filter array_map array_chunk array_key_exists array_intersect_key array_combine array_column pos sizeof key_exists assert assert_options version_compare ftok str_rot13 aggregate session_name session_module_name session_save_path session_id session_regenerate_id session_decode session_register session_unregister session_is_registered session_encode session_start session_destroy session_unset session_set_save_handler session_cache_limiter session_cache_expire session_set_cookie_params session_get_cookie_params session_write_close preg_match preg_match_all preg_replace preg_replace_callback preg_split preg_quote preg_grep overload ctype_alnum ctype_alpha ctype_cntrl ctype_digit ctype_lower ctype_graph ctype_print ctype_punct ctype_space ctype_upper ctype_xdigit virtual apache_request_headers apache_note apache_lookup_uri apache_child_terminate apache_setenv apache_response_headers apache_get_version getallheaders mysql_connect mysql_pconnect mysql_close mysql_select_db mysql_create_db mysql_drop_db mysql_query mysql_unbuffered_query mysql_db_query mysql_list_dbs mysql_list_tables mysql_list_fields mysql_list_processes mysql_error mysql_errno mysql_affected_rows mysql_insert_id mysql_result mysql_num_rows mysql_num_fields mysql_fetch_row mysql_fetch_array mysql_fetch_assoc mysql_fetch_object mysql_data_seek mysql_fetch_lengths mysql_fetch_field mysql_field_seek mysql_free_result mysql_field_name mysql_field_table mysql_field_len mysql_field_type mysql_field_flags mysql_escape_string mysql_real_escape_string mysql_stat mysql_thread_id mysql_client_encoding mysql_get_client_info mysql_get_host_info mysql_get_proto_info mysql_get_server_info mysql_info mysql mysql_fieldname mysql_fieldtable mysql_fieldlen mysql_fieldtype mysql_fieldflags mysql_selectdb mysql_createdb mysql_dropdb mysql_freeresult mysql_numfields mysql_numrows mysql_listdbs mysql_listtables mysql_listfields mysql_db_name mysql_dbname mysql_tablename mysql_table_name pg_connect pg_pconnect pg_close pg_connection_status pg_connection_busy pg_connection_reset pg_host pg_dbname pg_port pg_tty pg_options pg_ping pg_query pg_send_query pg_cancel_query pg_fetch_result pg_fetch_row pg_fetch_assoc pg_fetch_array pg_fetch_object pg_fetch_all pg_affected_rows pg_get_result pg_result_seek pg_result_status pg_free_result pg_last_oid pg_num_rows pg_num_fields pg_field_name pg_field_num pg_field_size pg_field_type pg_field_prtlen pg_field_is_null pg_get_notify pg_get_pid pg_result_error pg_last_error pg_last_notice pg_put_line pg_end_copy pg_copy_to pg_copy_from pg_trace pg_untrace pg_lo_create pg_lo_unlink pg_lo_open pg_lo_close pg_lo_read pg_lo_write pg_lo_read_all pg_lo_import pg_lo_export pg_lo_seek pg_lo_tell pg_escape_string pg_escape_bytea pg_unescape_bytea pg_client_encoding pg_set_client_encoding pg_meta_data pg_convert pg_insert pg_update pg_delete pg_select pg_exec pg_getlastoid pg_cmdtuples pg_errormessage pg_numrows pg_numfields pg_fieldname pg_fieldsize pg_fieldtype pg_fieldnum pg_fieldprtlen pg_fieldisnull pg_freeresult pg_result pg_loreadall pg_locreate pg_lounlink pg_loopen pg_loclose pg_loread pg_lowrite pg_loimport pg_loexport http_response_code get_declared_traits getimagesizefromstring socket_import_stream stream_set_chunk_size trait_exists header_register_callback class_uses session_status session_register_shutdown echo print global static exit array empty eval isset unset die include require include_once require_once json_decode json_encode json_last_error json_last_error_msg curl_close curl_copy_handle curl_errno curl_error curl_escape curl_exec curl_file_create curl_getinfo curl_init curl_multi_add_handle curl_multi_close curl_multi_exec curl_multi_getcontent curl_multi_info_read curl_multi_init curl_multi_remove_handle curl_multi_select curl_multi_setopt curl_multi_strerror curl_pause curl_reset curl_setopt_array curl_setopt curl_share_close curl_share_init curl_share_setopt curl_strerror curl_unescape curl_version mysqli_affected_rows mysqli_autocommit mysqli_change_user mysqli_character_set_name mysqli_close mysqli_commit mysqli_connect_errno mysqli_connect_error mysqli_connect mysqli_data_seek mysqli_debug mysqli_dump_debug_info mysqli_errno mysqli_error_list mysqli_error mysqli_fetch_all mysqli_fetch_array mysqli_fetch_assoc mysqli_fetch_field_direct mysqli_fetch_field mysqli_fetch_fields mysqli_fetch_lengths mysqli_fetch_object mysqli_fetch_row mysqli_field_count mysqli_field_seek mysqli_field_tell mysqli_free_result mysqli_get_charset mysqli_get_client_info mysqli_get_client_stats mysqli_get_client_version mysqli_get_connection_stats mysqli_get_host_info mysqli_get_proto_info mysqli_get_server_info mysqli_get_server_version mysqli_info mysqli_init mysqli_insert_id mysqli_kill mysqli_more_results mysqli_multi_query mysqli_next_result mysqli_num_fields mysqli_num_rows mysqli_options mysqli_ping mysqli_prepare mysqli_query mysqli_real_connect mysqli_real_escape_string mysqli_real_query mysqli_reap_async_query mysqli_refresh mysqli_rollback mysqli_select_db mysqli_set_charset mysqli_set_local_infile_default mysqli_set_local_infile_handler mysqli_sqlstate mysqli_ssl_set mysqli_stat mysqli_stmt_init mysqli_store_result mysqli_thread_id mysqli_thread_safe mysqli_use_result mysqli_warning_count";
        CodeMirror3.registerHelper("hintWords", "php", [phpKeywords, phpAtoms, phpBuiltin].join(" ").split(" "));
        CodeMirror3.registerHelper("wordChars", "php", /[\w$]/);
        var phpConfig = {
          name: "clike",
          helperType: "php",
          keywords: keywords(phpKeywords),
          blockKeywords: keywords("catch do else elseif for foreach if switch try while finally"),
          defKeywords: keywords("class function interface namespace trait"),
          atoms: keywords(phpAtoms),
          builtin: keywords(phpBuiltin),
          multiLineStrings: true,
          hooks: {
            "$": function(stream) {
              stream.eatWhile(/[\w\$_]/);
              return "variable-2";
            },
            "<": function(stream, state) {
              var before;
              if (before = stream.match(/^<<\s*/)) {
                var quoted = stream.eat(/['"]/);
                stream.eatWhile(/[\w\.]/);
                var delim = stream.current().slice(before[0].length + (quoted ? 2 : 1));
                if (quoted)
                  stream.eat(quoted);
                if (delim) {
                  (state.tokStack || (state.tokStack = [])).push(delim, 0);
                  state.tokenize = phpString(delim, quoted != "'");
                  return "string";
                }
              }
              return false;
            },
            "#": function(stream) {
              while (!stream.eol() && !stream.match("?>", false))
                stream.next();
              return "comment";
            },
            "/": function(stream) {
              if (stream.eat("/")) {
                while (!stream.eol() && !stream.match("?>", false))
                  stream.next();
                return "comment";
              }
              return false;
            },
            '"': function(_stream, state) {
              (state.tokStack || (state.tokStack = [])).push('"', 0);
              state.tokenize = phpString('"');
              return "string";
            },
            "{": function(_stream, state) {
              if (state.tokStack && state.tokStack.length)
                state.tokStack[state.tokStack.length - 1]++;
              return false;
            },
            "}": function(_stream, state) {
              if (state.tokStack && state.tokStack.length > 0 && !--state.tokStack[state.tokStack.length - 1]) {
                state.tokenize = phpString(state.tokStack[state.tokStack.length - 2]);
              }
              return false;
            }
          }
        };
        CodeMirror3.defineMode("php", function(config, parserConfig) {
          var htmlMode = CodeMirror3.getMode(config, parserConfig && parserConfig.htmlMode || "text/html");
          var phpMode = CodeMirror3.getMode(config, phpConfig);
          function dispatch3(stream, state) {
            var isPHP = state.curMode == phpMode;
            if (stream.sol() && state.pending && state.pending != '"' && state.pending != "'")
              state.pending = null;
            if (!isPHP) {
              if (stream.match(/^<\?\w*/)) {
                state.curMode = phpMode;
                if (!state.php)
                  state.php = CodeMirror3.startState(phpMode, htmlMode.indent(state.html, "", ""));
                state.curState = state.php;
                return "meta";
              }
              if (state.pending == '"' || state.pending == "'") {
                while (!stream.eol() && stream.next() != state.pending) {
                }
                var style = "string";
              } else if (state.pending && stream.pos < state.pending.end) {
                stream.pos = state.pending.end;
                var style = state.pending.style;
              } else {
                var style = htmlMode.token(stream, state.curState);
              }
              if (state.pending)
                state.pending = null;
              var cur = stream.current(), openPHP = cur.search(/<\?/), m2;
              if (openPHP != -1) {
                if (style == "string" && (m2 = cur.match(/[\'\"]$/)) && !/\?>/.test(cur))
                  state.pending = m2[0];
                else
                  state.pending = { end: stream.pos, style };
                stream.backUp(cur.length - openPHP);
              }
              return style;
            } else if (isPHP && state.php.tokenize == null && stream.match("?>")) {
              state.curMode = htmlMode;
              state.curState = state.html;
              if (!state.php.context.prev)
                state.php = null;
              return "meta";
            } else {
              return phpMode.token(stream, state.curState);
            }
          }
          return {
            startState: function() {
              var html = CodeMirror3.startState(htmlMode);
              var php = parserConfig.startOpen ? CodeMirror3.startState(phpMode) : null;
              return {
                html,
                php,
                curMode: parserConfig.startOpen ? phpMode : htmlMode,
                curState: parserConfig.startOpen ? php : html,
                pending: null
              };
            },
            copyState: function(state) {
              var html = state.html, htmlNew = CodeMirror3.copyState(htmlMode, html), php = state.php, phpNew = php && CodeMirror3.copyState(phpMode, php), cur;
              if (state.curMode == htmlMode)
                cur = htmlNew;
              else
                cur = phpNew;
              return {
                html: htmlNew,
                php: phpNew,
                curMode: state.curMode,
                curState: cur,
                pending: state.pending
              };
            },
            token: dispatch3,
            indent: function(state, textAfter, line) {
              if (state.curMode != phpMode && /^\s*<\//.test(textAfter) || state.curMode == phpMode && /^\?>/.test(textAfter))
                return htmlMode.indent(state.html, textAfter, line);
              return state.curMode.indent(state.curState, textAfter, line);
            },
            blockCommentStart: "/*",
            blockCommentEnd: "*/",
            lineComment: "//",
            innerMode: function(state) {
              return { state: state.curState, mode: state.curMode };
            }
          };
        }, "htmlmixed", "clike");
        CodeMirror3.defineMIME("application/x-httpd-php", "php");
        CodeMirror3.defineMIME("application/x-httpd-php-open", { name: "php", startOpen: true });
        CodeMirror3.defineMIME("text/x-php", phpConfig);
      });
    }
  });

  // node_modules/codemirror/mode/ruby/ruby.js
  var require_ruby = __commonJS({
    "node_modules/codemirror/mode/ruby/ruby.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        function wordObj(words) {
          var o2 = {};
          for (var i2 = 0, e2 = words.length; i2 < e2; ++i2)
            o2[words[i2]] = true;
          return o2;
        }
        var keywordList = [
          "alias",
          "and",
          "BEGIN",
          "begin",
          "break",
          "case",
          "class",
          "def",
          "defined?",
          "do",
          "else",
          "elsif",
          "END",
          "end",
          "ensure",
          "false",
          "for",
          "if",
          "in",
          "module",
          "next",
          "not",
          "or",
          "redo",
          "rescue",
          "retry",
          "return",
          "self",
          "super",
          "then",
          "true",
          "undef",
          "unless",
          "until",
          "when",
          "while",
          "yield",
          "nil",
          "raise",
          "throw",
          "catch",
          "fail",
          "loop",
          "callcc",
          "caller",
          "lambda",
          "proc",
          "public",
          "protected",
          "private",
          "require",
          "load",
          "require_relative",
          "extend",
          "autoload",
          "__END__",
          "__FILE__",
          "__LINE__",
          "__dir__"
        ], keywords = wordObj(keywordList);
        var indentWords = wordObj([
          "def",
          "class",
          "case",
          "for",
          "while",
          "until",
          "module",
          "then",
          "catch",
          "loop",
          "proc",
          "begin"
        ]);
        var dedentWords = wordObj(["end", "until"]);
        var opening = { "[": "]", "{": "}", "(": ")" };
        var closing = { "]": "[", "}": "{", ")": "(" };
        CodeMirror3.defineMode("ruby", function(config) {
          var curPunc;
          function chain(newtok, stream, state) {
            state.tokenize.push(newtok);
            return newtok(stream, state);
          }
          function tokenBase(stream, state) {
            if (stream.sol() && stream.match("=begin") && stream.eol()) {
              state.tokenize.push(readBlockComment);
              return "comment";
            }
            if (stream.eatSpace())
              return null;
            var ch = stream.next(), m2;
            if (ch == "`" || ch == "'" || ch == '"') {
              return chain(readQuoted(ch, "string", ch == '"' || ch == "`"), stream, state);
            } else if (ch == "/") {
              if (regexpAhead(stream))
                return chain(readQuoted(ch, "string-2", true), stream, state);
              else
                return "operator";
            } else if (ch == "%") {
              var style = "string", embed = true;
              if (stream.eat("s"))
                style = "atom";
              else if (stream.eat(/[WQ]/))
                style = "string";
              else if (stream.eat(/[r]/))
                style = "string-2";
              else if (stream.eat(/[wxq]/)) {
                style = "string";
                embed = false;
              }
              var delim = stream.eat(/[^\w\s=]/);
              if (!delim)
                return "operator";
              if (opening.propertyIsEnumerable(delim))
                delim = opening[delim];
              return chain(readQuoted(delim, style, embed, true), stream, state);
            } else if (ch == "#") {
              stream.skipToEnd();
              return "comment";
            } else if (ch == "<" && (m2 = stream.match(/^<([-~])[\`\"\']?([a-zA-Z_?]\w*)[\`\"\']?(?:;|$)/))) {
              return chain(readHereDoc(m2[2], m2[1]), stream, state);
            } else if (ch == "0") {
              if (stream.eat("x"))
                stream.eatWhile(/[\da-fA-F]/);
              else if (stream.eat("b"))
                stream.eatWhile(/[01]/);
              else
                stream.eatWhile(/[0-7]/);
              return "number";
            } else if (/\d/.test(ch)) {
              stream.match(/^[\d_]*(?:\.[\d_]+)?(?:[eE][+\-]?[\d_]+)?/);
              return "number";
            } else if (ch == "?") {
              while (stream.match(/^\\[CM]-/)) {
              }
              if (stream.eat("\\"))
                stream.eatWhile(/\w/);
              else
                stream.next();
              return "string";
            } else if (ch == ":") {
              if (stream.eat("'"))
                return chain(readQuoted("'", "atom", false), stream, state);
              if (stream.eat('"'))
                return chain(readQuoted('"', "atom", true), stream, state);
              if (stream.eat(/[\<\>]/)) {
                stream.eat(/[\<\>]/);
                return "atom";
              }
              if (stream.eat(/[\+\-\*\/\&\|\:\!]/)) {
                return "atom";
              }
              if (stream.eat(/[a-zA-Z$@_\xa1-\uffff]/)) {
                stream.eatWhile(/[\w$\xa1-\uffff]/);
                stream.eat(/[\?\!\=]/);
                return "atom";
              }
              return "operator";
            } else if (ch == "@" && stream.match(/^@?[a-zA-Z_\xa1-\uffff]/)) {
              stream.eat("@");
              stream.eatWhile(/[\w\xa1-\uffff]/);
              return "variable-2";
            } else if (ch == "$") {
              if (stream.eat(/[a-zA-Z_]/)) {
                stream.eatWhile(/[\w]/);
              } else if (stream.eat(/\d/)) {
                stream.eat(/\d/);
              } else {
                stream.next();
              }
              return "variable-3";
            } else if (/[a-zA-Z_\xa1-\uffff]/.test(ch)) {
              stream.eatWhile(/[\w\xa1-\uffff]/);
              stream.eat(/[\?\!]/);
              if (stream.eat(":"))
                return "atom";
              return "ident";
            } else if (ch == "|" && (state.varList || state.lastTok == "{" || state.lastTok == "do")) {
              curPunc = "|";
              return null;
            } else if (/[\(\)\[\]{}\\;]/.test(ch)) {
              curPunc = ch;
              return null;
            } else if (ch == "-" && stream.eat(">")) {
              return "arrow";
            } else if (/[=+\-\/*:\.^%<>~|]/.test(ch)) {
              var more = stream.eatWhile(/[=+\-\/*:\.^%<>~|]/);
              if (ch == "." && !more)
                curPunc = ".";
              return "operator";
            } else {
              return null;
            }
          }
          function regexpAhead(stream) {
            var start4 = stream.pos, depth = 0, next, found = false, escaped = false;
            while ((next = stream.next()) != null) {
              if (!escaped) {
                if ("[{(".indexOf(next) > -1) {
                  depth++;
                } else if ("]})".indexOf(next) > -1) {
                  depth--;
                  if (depth < 0)
                    break;
                } else if (next == "/" && depth == 0) {
                  found = true;
                  break;
                }
                escaped = next == "\\";
              } else {
                escaped = false;
              }
            }
            stream.backUp(stream.pos - start4);
            return found;
          }
          function tokenBaseUntilBrace(depth) {
            if (!depth)
              depth = 1;
            return function(stream, state) {
              if (stream.peek() == "}") {
                if (depth == 1) {
                  state.tokenize.pop();
                  return state.tokenize[state.tokenize.length - 1](stream, state);
                } else {
                  state.tokenize[state.tokenize.length - 1] = tokenBaseUntilBrace(depth - 1);
                }
              } else if (stream.peek() == "{") {
                state.tokenize[state.tokenize.length - 1] = tokenBaseUntilBrace(depth + 1);
              }
              return tokenBase(stream, state);
            };
          }
          function tokenBaseOnce() {
            var alreadyCalled = false;
            return function(stream, state) {
              if (alreadyCalled) {
                state.tokenize.pop();
                return state.tokenize[state.tokenize.length - 1](stream, state);
              }
              alreadyCalled = true;
              return tokenBase(stream, state);
            };
          }
          function readQuoted(quote, style, embed, unescaped) {
            return function(stream, state) {
              var escaped = false, ch;
              if (state.context.type === "read-quoted-paused") {
                state.context = state.context.prev;
                stream.eat("}");
              }
              while ((ch = stream.next()) != null) {
                if (ch == quote && (unescaped || !escaped)) {
                  state.tokenize.pop();
                  break;
                }
                if (embed && ch == "#" && !escaped) {
                  if (stream.eat("{")) {
                    if (quote == "}") {
                      state.context = { prev: state.context, type: "read-quoted-paused" };
                    }
                    state.tokenize.push(tokenBaseUntilBrace());
                    break;
                  } else if (/[@\$]/.test(stream.peek())) {
                    state.tokenize.push(tokenBaseOnce());
                    break;
                  }
                }
                escaped = !escaped && ch == "\\";
              }
              return style;
            };
          }
          function readHereDoc(phrase, mayIndent) {
            return function(stream, state) {
              if (mayIndent)
                stream.eatSpace();
              if (stream.match(phrase))
                state.tokenize.pop();
              else
                stream.skipToEnd();
              return "string";
            };
          }
          function readBlockComment(stream, state) {
            if (stream.sol() && stream.match("=end") && stream.eol())
              state.tokenize.pop();
            stream.skipToEnd();
            return "comment";
          }
          return {
            startState: function() {
              return {
                tokenize: [tokenBase],
                indented: 0,
                context: { type: "top", indented: -config.indentUnit },
                continuedLine: false,
                lastTok: null,
                varList: false
              };
            },
            token: function(stream, state) {
              curPunc = null;
              if (stream.sol())
                state.indented = stream.indentation();
              var style = state.tokenize[state.tokenize.length - 1](stream, state), kwtype;
              var thisTok = curPunc;
              if (style == "ident") {
                var word = stream.current();
                style = state.lastTok == "." ? "property" : keywords.propertyIsEnumerable(stream.current()) ? "keyword" : /^[A-Z]/.test(word) ? "tag" : state.lastTok == "def" || state.lastTok == "class" || state.varList ? "def" : "variable";
                if (style == "keyword") {
                  thisTok = word;
                  if (indentWords.propertyIsEnumerable(word))
                    kwtype = "indent";
                  else if (dedentWords.propertyIsEnumerable(word))
                    kwtype = "dedent";
                  else if ((word == "if" || word == "unless") && stream.column() == stream.indentation())
                    kwtype = "indent";
                  else if (word == "do" && state.context.indented < state.indented)
                    kwtype = "indent";
                }
              }
              if (curPunc || style && style != "comment")
                state.lastTok = thisTok;
              if (curPunc == "|")
                state.varList = !state.varList;
              if (kwtype == "indent" || /[\(\[\{]/.test(curPunc))
                state.context = { prev: state.context, type: curPunc || style, indented: state.indented };
              else if ((kwtype == "dedent" || /[\)\]\}]/.test(curPunc)) && state.context.prev)
                state.context = state.context.prev;
              if (stream.eol())
                state.continuedLine = curPunc == "\\" || style == "operator";
              return style;
            },
            indent: function(state, textAfter) {
              if (state.tokenize[state.tokenize.length - 1] != tokenBase)
                return CodeMirror3.Pass;
              var firstChar = textAfter && textAfter.charAt(0);
              var ct = state.context;
              var closed = ct.type == closing[firstChar] || ct.type == "keyword" && /^(?:end|until|else|elsif|when|rescue)\b/.test(textAfter);
              return ct.indented + (closed ? 0 : config.indentUnit) + (state.continuedLine ? config.indentUnit : 0);
            },
            electricInput: /^\s*(?:end|rescue|elsif|else|\})$/,
            lineComment: "#",
            fold: "indent"
          };
        });
        CodeMirror3.defineMIME("text/x-ruby", "ruby");
        CodeMirror3.registerHelper("hintWords", "ruby", keywordList);
      });
    }
  });

  // node_modules/codemirror/mode/sass/sass.js
  var require_sass = __commonJS({
    "node_modules/codemirror/mode/sass/sass.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror(), require_css());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror", "../css/css"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.defineMode("sass", function(config) {
          var cssMode = CodeMirror3.mimeModes["text/css"];
          var propertyKeywords = cssMode.propertyKeywords || {}, colorKeywords = cssMode.colorKeywords || {}, valueKeywords = cssMode.valueKeywords || {}, fontProperties = cssMode.fontProperties || {};
          function tokenRegexp(words) {
            return new RegExp("^" + words.join("|"));
          }
          var keywords = ["true", "false", "null", "auto"];
          var keywordsRegexp = new RegExp("^" + keywords.join("|"));
          var operators = [
            "\\(",
            "\\)",
            "=",
            ">",
            "<",
            "==",
            ">=",
            "<=",
            "\\+",
            "-",
            "\\!=",
            "/",
            "\\*",
            "%",
            "and",
            "or",
            "not",
            ";",
            "\\{",
            "\\}",
            ":"
          ];
          var opRegexp = tokenRegexp(operators);
          var pseudoElementsRegexp = /^::?[a-zA-Z_][\w\-]*/;
          var word;
          function isEndLine(stream) {
            return !stream.peek() || stream.match(/\s+$/, false);
          }
          function urlTokens(stream, state) {
            var ch = stream.peek();
            if (ch === ")") {
              stream.next();
              state.tokenizer = tokenBase;
              return "operator";
            } else if (ch === "(") {
              stream.next();
              stream.eatSpace();
              return "operator";
            } else if (ch === "'" || ch === '"') {
              state.tokenizer = buildStringTokenizer(stream.next());
              return "string";
            } else {
              state.tokenizer = buildStringTokenizer(")", false);
              return "string";
            }
          }
          function comment(indentation, multiLine) {
            return function(stream, state) {
              if (stream.sol() && stream.indentation() <= indentation) {
                state.tokenizer = tokenBase;
                return tokenBase(stream, state);
              }
              if (multiLine && stream.skipTo("*/")) {
                stream.next();
                stream.next();
                state.tokenizer = tokenBase;
              } else {
                stream.skipToEnd();
              }
              return "comment";
            };
          }
          function buildStringTokenizer(quote, greedy) {
            if (greedy == null) {
              greedy = true;
            }
            function stringTokenizer(stream, state) {
              var nextChar = stream.next();
              var peekChar = stream.peek();
              var previousChar = stream.string.charAt(stream.pos - 2);
              var endingString = nextChar !== "\\" && peekChar === quote || nextChar === quote && previousChar !== "\\";
              if (endingString) {
                if (nextChar !== quote && greedy) {
                  stream.next();
                }
                if (isEndLine(stream)) {
                  state.cursorHalf = 0;
                }
                state.tokenizer = tokenBase;
                return "string";
              } else if (nextChar === "#" && peekChar === "{") {
                state.tokenizer = buildInterpolationTokenizer(stringTokenizer);
                stream.next();
                return "operator";
              } else {
                return "string";
              }
            }
            return stringTokenizer;
          }
          function buildInterpolationTokenizer(currentTokenizer) {
            return function(stream, state) {
              if (stream.peek() === "}") {
                stream.next();
                state.tokenizer = currentTokenizer;
                return "operator";
              } else {
                return tokenBase(stream, state);
              }
            };
          }
          function indent(state) {
            if (state.indentCount == 0) {
              state.indentCount++;
              var lastScopeOffset = state.scopes[0].offset;
              var currentOffset = lastScopeOffset + config.indentUnit;
              state.scopes.unshift({ offset: currentOffset });
            }
          }
          function dedent(state) {
            if (state.scopes.length == 1)
              return;
            state.scopes.shift();
          }
          function tokenBase(stream, state) {
            var ch = stream.peek();
            if (stream.match("/*")) {
              state.tokenizer = comment(stream.indentation(), true);
              return state.tokenizer(stream, state);
            }
            if (stream.match("//")) {
              state.tokenizer = comment(stream.indentation(), false);
              return state.tokenizer(stream, state);
            }
            if (stream.match("#{")) {
              state.tokenizer = buildInterpolationTokenizer(tokenBase);
              return "operator";
            }
            if (ch === '"' || ch === "'") {
              stream.next();
              state.tokenizer = buildStringTokenizer(ch);
              return "string";
            }
            if (!state.cursorHalf) {
              if (ch === "-") {
                if (stream.match(/^-\w+-/)) {
                  return "meta";
                }
              }
              if (ch === ".") {
                stream.next();
                if (stream.match(/^[\w-]+/)) {
                  indent(state);
                  return "qualifier";
                } else if (stream.peek() === "#") {
                  indent(state);
                  return "tag";
                }
              }
              if (ch === "#") {
                stream.next();
                if (stream.match(/^[\w-]+/)) {
                  indent(state);
                  return "builtin";
                }
                if (stream.peek() === "#") {
                  indent(state);
                  return "tag";
                }
              }
              if (ch === "$") {
                stream.next();
                stream.eatWhile(/[\w-]/);
                return "variable-2";
              }
              if (stream.match(/^-?[0-9\.]+/))
                return "number";
              if (stream.match(/^(px|em|in)\b/))
                return "unit";
              if (stream.match(keywordsRegexp))
                return "keyword";
              if (stream.match(/^url/) && stream.peek() === "(") {
                state.tokenizer = urlTokens;
                return "atom";
              }
              if (ch === "=") {
                if (stream.match(/^=[\w-]+/)) {
                  indent(state);
                  return "meta";
                }
              }
              if (ch === "+") {
                if (stream.match(/^\+[\w-]+/)) {
                  return "variable-3";
                }
              }
              if (ch === "@") {
                if (stream.match("@extend")) {
                  if (!stream.match(/\s*[\w]/))
                    dedent(state);
                }
              }
              if (stream.match(/^@(else if|if|media|else|for|each|while|mixin|function)/)) {
                indent(state);
                return "def";
              }
              if (ch === "@") {
                stream.next();
                stream.eatWhile(/[\w-]/);
                return "def";
              }
              if (stream.eatWhile(/[\w-]/)) {
                if (stream.match(/ *: *[\w-\+\$#!\("']/, false)) {
                  word = stream.current().toLowerCase();
                  var prop = state.prevProp + "-" + word;
                  if (propertyKeywords.hasOwnProperty(prop)) {
                    return "property";
                  } else if (propertyKeywords.hasOwnProperty(word)) {
                    state.prevProp = word;
                    return "property";
                  } else if (fontProperties.hasOwnProperty(word)) {
                    return "property";
                  }
                  return "tag";
                } else if (stream.match(/ *:/, false)) {
                  indent(state);
                  state.cursorHalf = 1;
                  state.prevProp = stream.current().toLowerCase();
                  return "property";
                } else if (stream.match(/ *,/, false)) {
                  return "tag";
                } else {
                  indent(state);
                  return "tag";
                }
              }
              if (ch === ":") {
                if (stream.match(pseudoElementsRegexp)) {
                  return "variable-3";
                }
                stream.next();
                state.cursorHalf = 1;
                return "operator";
              }
            } else {
              if (ch === "#") {
                stream.next();
                if (stream.match(/[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/)) {
                  if (isEndLine(stream)) {
                    state.cursorHalf = 0;
                  }
                  return "number";
                }
              }
              if (stream.match(/^-?[0-9\.]+/)) {
                if (isEndLine(stream)) {
                  state.cursorHalf = 0;
                }
                return "number";
              }
              if (stream.match(/^(px|em|in)\b/)) {
                if (isEndLine(stream)) {
                  state.cursorHalf = 0;
                }
                return "unit";
              }
              if (stream.match(keywordsRegexp)) {
                if (isEndLine(stream)) {
                  state.cursorHalf = 0;
                }
                return "keyword";
              }
              if (stream.match(/^url/) && stream.peek() === "(") {
                state.tokenizer = urlTokens;
                if (isEndLine(stream)) {
                  state.cursorHalf = 0;
                }
                return "atom";
              }
              if (ch === "$") {
                stream.next();
                stream.eatWhile(/[\w-]/);
                if (isEndLine(stream)) {
                  state.cursorHalf = 0;
                }
                return "variable-2";
              }
              if (ch === "!") {
                stream.next();
                state.cursorHalf = 0;
                return stream.match(/^[\w]+/) ? "keyword" : "operator";
              }
              if (stream.match(opRegexp)) {
                if (isEndLine(stream)) {
                  state.cursorHalf = 0;
                }
                return "operator";
              }
              if (stream.eatWhile(/[\w-]/)) {
                if (isEndLine(stream)) {
                  state.cursorHalf = 0;
                }
                word = stream.current().toLowerCase();
                if (valueKeywords.hasOwnProperty(word)) {
                  return "atom";
                } else if (colorKeywords.hasOwnProperty(word)) {
                  return "keyword";
                } else if (propertyKeywords.hasOwnProperty(word)) {
                  state.prevProp = stream.current().toLowerCase();
                  return "property";
                } else {
                  return "tag";
                }
              }
              if (isEndLine(stream)) {
                state.cursorHalf = 0;
                return null;
              }
            }
            if (stream.match(opRegexp))
              return "operator";
            stream.next();
            return null;
          }
          function tokenLexer(stream, state) {
            if (stream.sol())
              state.indentCount = 0;
            var style = state.tokenizer(stream, state);
            var current = stream.current();
            if (current === "@return" || current === "}") {
              dedent(state);
            }
            if (style !== null) {
              var startOfToken = stream.pos - current.length;
              var withCurrentIndent = startOfToken + config.indentUnit * state.indentCount;
              var newScopes = [];
              for (var i2 = 0; i2 < state.scopes.length; i2++) {
                var scope = state.scopes[i2];
                if (scope.offset <= withCurrentIndent)
                  newScopes.push(scope);
              }
              state.scopes = newScopes;
            }
            return style;
          }
          return {
            startState: function() {
              return {
                tokenizer: tokenBase,
                scopes: [{ offset: 0, type: "sass" }],
                indentCount: 0,
                cursorHalf: 0,
                definedVars: [],
                definedMixins: []
              };
            },
            token: function(stream, state) {
              var style = tokenLexer(stream, state);
              state.lastToken = { style, content: stream.current() };
              return style;
            },
            indent: function(state) {
              return state.scopes[0].offset;
            }
          };
        }, "css");
        CodeMirror3.defineMIME("text/x-sass", "sass");
      });
    }
  });

  // node_modules/codemirror/mode/shell/shell.js
  var require_shell = __commonJS({
    "node_modules/codemirror/mode/shell/shell.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.defineMode("shell", function() {
          var words = {};
          function define2(style, dict) {
            for (var i2 = 0; i2 < dict.length; i2++) {
              words[dict[i2]] = style;
            }
          }
          ;
          var commonAtoms = ["true", "false"];
          var commonKeywords = [
            "if",
            "then",
            "do",
            "else",
            "elif",
            "while",
            "until",
            "for",
            "in",
            "esac",
            "fi",
            "fin",
            "fil",
            "done",
            "exit",
            "set",
            "unset",
            "export",
            "function"
          ];
          var commonCommands = [
            "ab",
            "awk",
            "bash",
            "beep",
            "cat",
            "cc",
            "cd",
            "chown",
            "chmod",
            "chroot",
            "clear",
            "cp",
            "curl",
            "cut",
            "diff",
            "echo",
            "find",
            "gawk",
            "gcc",
            "get",
            "git",
            "grep",
            "hg",
            "kill",
            "killall",
            "ln",
            "ls",
            "make",
            "mkdir",
            "openssl",
            "mv",
            "nc",
            "nl",
            "node",
            "npm",
            "ping",
            "ps",
            "restart",
            "rm",
            "rmdir",
            "sed",
            "service",
            "sh",
            "shopt",
            "shred",
            "source",
            "sort",
            "sleep",
            "ssh",
            "start",
            "stop",
            "su",
            "sudo",
            "svn",
            "tee",
            "telnet",
            "top",
            "touch",
            "vi",
            "vim",
            "wall",
            "wc",
            "wget",
            "who",
            "write",
            "yes",
            "zsh"
          ];
          CodeMirror3.registerHelper("hintWords", "shell", commonAtoms.concat(commonKeywords, commonCommands));
          define2("atom", commonAtoms);
          define2("keyword", commonKeywords);
          define2("builtin", commonCommands);
          function tokenBase(stream, state) {
            if (stream.eatSpace())
              return null;
            var sol = stream.sol();
            var ch = stream.next();
            if (ch === "\\") {
              stream.next();
              return null;
            }
            if (ch === "'" || ch === '"' || ch === "`") {
              state.tokens.unshift(tokenString(ch, ch === "`" ? "quote" : "string"));
              return tokenize2(stream, state);
            }
            if (ch === "#") {
              if (sol && stream.eat("!")) {
                stream.skipToEnd();
                return "meta";
              }
              stream.skipToEnd();
              return "comment";
            }
            if (ch === "$") {
              state.tokens.unshift(tokenDollar);
              return tokenize2(stream, state);
            }
            if (ch === "+" || ch === "=") {
              return "operator";
            }
            if (ch === "-") {
              stream.eat("-");
              stream.eatWhile(/\w/);
              return "attribute";
            }
            if (ch == "<") {
              if (stream.match("<<"))
                return "operator";
              var heredoc = stream.match(/^<-?\s*['"]?([^'"]*)['"]?/);
              if (heredoc) {
                state.tokens.unshift(tokenHeredoc(heredoc[1]));
                return "string-2";
              }
            }
            if (/\d/.test(ch)) {
              stream.eatWhile(/\d/);
              if (stream.eol() || !/\w/.test(stream.peek())) {
                return "number";
              }
            }
            stream.eatWhile(/[\w-]/);
            var cur = stream.current();
            if (stream.peek() === "=" && /\w+/.test(cur))
              return "def";
            return words.hasOwnProperty(cur) ? words[cur] : null;
          }
          function tokenString(quote, style) {
            var close = quote == "(" ? ")" : quote == "{" ? "}" : quote;
            return function(stream, state) {
              var next, escaped = false;
              while ((next = stream.next()) != null) {
                if (next === close && !escaped) {
                  state.tokens.shift();
                  break;
                } else if (next === "$" && !escaped && quote !== "'" && stream.peek() != close) {
                  escaped = true;
                  stream.backUp(1);
                  state.tokens.unshift(tokenDollar);
                  break;
                } else if (!escaped && quote !== close && next === quote) {
                  state.tokens.unshift(tokenString(quote, style));
                  return tokenize2(stream, state);
                } else if (!escaped && /['"]/.test(next) && !/['"]/.test(quote)) {
                  state.tokens.unshift(tokenStringStart(next, "string"));
                  stream.backUp(1);
                  break;
                }
                escaped = !escaped && next === "\\";
              }
              return style;
            };
          }
          ;
          function tokenStringStart(quote, style) {
            return function(stream, state) {
              state.tokens[0] = tokenString(quote, style);
              stream.next();
              return tokenize2(stream, state);
            };
          }
          var tokenDollar = function(stream, state) {
            if (state.tokens.length > 1)
              stream.eat("$");
            var ch = stream.next();
            if (/['"({]/.test(ch)) {
              state.tokens[0] = tokenString(ch, ch == "(" ? "quote" : ch == "{" ? "def" : "string");
              return tokenize2(stream, state);
            }
            if (!/\d/.test(ch))
              stream.eatWhile(/\w/);
            state.tokens.shift();
            return "def";
          };
          function tokenHeredoc(delim) {
            return function(stream, state) {
              if (stream.sol() && stream.string == delim)
                state.tokens.shift();
              stream.skipToEnd();
              return "string-2";
            };
          }
          function tokenize2(stream, state) {
            return (state.tokens[0] || tokenBase)(stream, state);
          }
          ;
          return {
            startState: function() {
              return { tokens: [] };
            },
            token: function(stream, state) {
              return tokenize2(stream, state);
            },
            closeBrackets: "()[]{}''\"\"``",
            lineComment: "#",
            fold: "brace"
          };
        });
        CodeMirror3.defineMIME("text/x-sh", "shell");
        CodeMirror3.defineMIME("application/x-sh", "shell");
      });
    }
  });

  // node_modules/codemirror/mode/sql/sql.js
  var require_sql = __commonJS({
    "node_modules/codemirror/mode/sql/sql.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.defineMode("sql", function(config, parserConfig) {
          var client = parserConfig.client || {}, atoms = parserConfig.atoms || { "false": true, "true": true, "null": true }, builtin = parserConfig.builtin || set(defaultBuiltin), keywords = parserConfig.keywords || set(sqlKeywords), operatorChars = parserConfig.operatorChars || /^[*+\-%<>!=&|~^\/]/, support = parserConfig.support || {}, hooks = parserConfig.hooks || {}, dateSQL = parserConfig.dateSQL || { "date": true, "time": true, "timestamp": true }, backslashStringEscapes = parserConfig.backslashStringEscapes !== false, brackets = parserConfig.brackets || /^[\{}\(\)\[\]]/, punctuation = parserConfig.punctuation || /^[;.,:]/;
          function tokenBase(stream, state) {
            var ch = stream.next();
            if (hooks[ch]) {
              var result = hooks[ch](stream, state);
              if (result !== false)
                return result;
            }
            if (support.hexNumber && (ch == "0" && stream.match(/^[xX][0-9a-fA-F]+/) || (ch == "x" || ch == "X") && stream.match(/^'[0-9a-fA-F]+'/))) {
              return "number";
            } else if (support.binaryNumber && ((ch == "b" || ch == "B") && stream.match(/^'[01]+'/) || ch == "0" && stream.match(/^b[01]+/))) {
              return "number";
            } else if (ch.charCodeAt(0) > 47 && ch.charCodeAt(0) < 58) {
              stream.match(/^[0-9]*(\.[0-9]+)?([eE][-+]?[0-9]+)?/);
              support.decimallessFloat && stream.match(/^\.(?!\.)/);
              return "number";
            } else if (ch == "?" && (stream.eatSpace() || stream.eol() || stream.eat(";"))) {
              return "variable-3";
            } else if (ch == "'" || ch == '"' && support.doubleQuote) {
              state.tokenize = tokenLiteral(ch);
              return state.tokenize(stream, state);
            } else if ((support.nCharCast && (ch == "n" || ch == "N") || support.charsetCast && ch == "_" && stream.match(/[a-z][a-z0-9]*/i)) && (stream.peek() == "'" || stream.peek() == '"')) {
              return "keyword";
            } else if (support.escapeConstant && (ch == "e" || ch == "E") && (stream.peek() == "'" || stream.peek() == '"' && support.doubleQuote)) {
              state.tokenize = function(stream2, state2) {
                return (state2.tokenize = tokenLiteral(stream2.next(), true))(stream2, state2);
              };
              return "keyword";
            } else if (support.commentSlashSlash && ch == "/" && stream.eat("/")) {
              stream.skipToEnd();
              return "comment";
            } else if (support.commentHash && ch == "#" || ch == "-" && stream.eat("-") && (!support.commentSpaceRequired || stream.eat(" "))) {
              stream.skipToEnd();
              return "comment";
            } else if (ch == "/" && stream.eat("*")) {
              state.tokenize = tokenComment(1);
              return state.tokenize(stream, state);
            } else if (ch == ".") {
              if (support.zerolessFloat && stream.match(/^(?:\d+(?:e[+-]?\d+)?)/i))
                return "number";
              if (stream.match(/^\.+/))
                return null;
              if (support.ODBCdotTable && stream.match(/^[\w\d_$#]+/))
                return "variable-2";
            } else if (operatorChars.test(ch)) {
              stream.eatWhile(operatorChars);
              return "operator";
            } else if (brackets.test(ch)) {
              return "bracket";
            } else if (punctuation.test(ch)) {
              stream.eatWhile(punctuation);
              return "punctuation";
            } else if (ch == "{" && (stream.match(/^( )*(d|D|t|T|ts|TS)( )*'[^']*'( )*}/) || stream.match(/^( )*(d|D|t|T|ts|TS)( )*"[^"]*"( )*}/))) {
              return "number";
            } else {
              stream.eatWhile(/^[_\w\d]/);
              var word = stream.current().toLowerCase();
              if (dateSQL.hasOwnProperty(word) && (stream.match(/^( )+'[^']*'/) || stream.match(/^( )+"[^"]*"/)))
                return "number";
              if (atoms.hasOwnProperty(word))
                return "atom";
              if (builtin.hasOwnProperty(word))
                return "builtin";
              if (keywords.hasOwnProperty(word))
                return "keyword";
              if (client.hasOwnProperty(word))
                return "string-2";
              return null;
            }
          }
          function tokenLiteral(quote, backslashEscapes) {
            return function(stream, state) {
              var escaped = false, ch;
              while ((ch = stream.next()) != null) {
                if (ch == quote && !escaped) {
                  state.tokenize = tokenBase;
                  break;
                }
                escaped = (backslashStringEscapes || backslashEscapes) && !escaped && ch == "\\";
              }
              return "string";
            };
          }
          function tokenComment(depth) {
            return function(stream, state) {
              var m2 = stream.match(/^.*?(\/\*|\*\/)/);
              if (!m2)
                stream.skipToEnd();
              else if (m2[1] == "/*")
                state.tokenize = tokenComment(depth + 1);
              else if (depth > 1)
                state.tokenize = tokenComment(depth - 1);
              else
                state.tokenize = tokenBase;
              return "comment";
            };
          }
          function pushContext(stream, state, type) {
            state.context = {
              prev: state.context,
              indent: stream.indentation(),
              col: stream.column(),
              type
            };
          }
          function popContext(state) {
            state.indent = state.context.indent;
            state.context = state.context.prev;
          }
          return {
            startState: function() {
              return { tokenize: tokenBase, context: null };
            },
            token: function(stream, state) {
              if (stream.sol()) {
                if (state.context && state.context.align == null)
                  state.context.align = false;
              }
              if (state.tokenize == tokenBase && stream.eatSpace())
                return null;
              var style = state.tokenize(stream, state);
              if (style == "comment")
                return style;
              if (state.context && state.context.align == null)
                state.context.align = true;
              var tok = stream.current();
              if (tok == "(")
                pushContext(stream, state, ")");
              else if (tok == "[")
                pushContext(stream, state, "]");
              else if (state.context && state.context.type == tok)
                popContext(state);
              return style;
            },
            indent: function(state, textAfter) {
              var cx = state.context;
              if (!cx)
                return CodeMirror3.Pass;
              var closing = textAfter.charAt(0) == cx.type;
              if (cx.align)
                return cx.col + (closing ? 0 : 1);
              else
                return cx.indent + (closing ? 0 : config.indentUnit);
            },
            blockCommentStart: "/*",
            blockCommentEnd: "*/",
            lineComment: support.commentSlashSlash ? "//" : support.commentHash ? "#" : "--",
            closeBrackets: "()[]{}''\"\"``"
          };
        });
        function hookIdentifier(stream) {
          var ch;
          while ((ch = stream.next()) != null) {
            if (ch == "`" && !stream.eat("`"))
              return "variable-2";
          }
          stream.backUp(stream.current().length - 1);
          return stream.eatWhile(/\w/) ? "variable-2" : null;
        }
        function hookIdentifierDoublequote(stream) {
          var ch;
          while ((ch = stream.next()) != null) {
            if (ch == '"' && !stream.eat('"'))
              return "variable-2";
          }
          stream.backUp(stream.current().length - 1);
          return stream.eatWhile(/\w/) ? "variable-2" : null;
        }
        function hookVar(stream) {
          if (stream.eat("@")) {
            stream.match("session.");
            stream.match("local.");
            stream.match("global.");
          }
          if (stream.eat("'")) {
            stream.match(/^.*'/);
            return "variable-2";
          } else if (stream.eat('"')) {
            stream.match(/^.*"/);
            return "variable-2";
          } else if (stream.eat("`")) {
            stream.match(/^.*`/);
            return "variable-2";
          } else if (stream.match(/^[0-9a-zA-Z$\.\_]+/)) {
            return "variable-2";
          }
          return null;
        }
        ;
        function hookClient(stream) {
          if (stream.eat("N")) {
            return "atom";
          }
          return stream.match(/^[a-zA-Z.#!?]/) ? "variable-2" : null;
        }
        var sqlKeywords = "alter and as asc between by count create delete desc distinct drop from group having in insert into is join like not on or order select set table union update values where limit ";
        function set(str) {
          var obj = {}, words = str.split(" ");
          for (var i2 = 0; i2 < words.length; ++i2)
            obj[words[i2]] = true;
          return obj;
        }
        var defaultBuiltin = "bool boolean bit blob enum long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision real date datetime year unsigned signed decimal numeric";
        CodeMirror3.defineMIME("text/x-sql", {
          name: "sql",
          keywords: set(sqlKeywords + "begin"),
          builtin: set(defaultBuiltin),
          atoms: set("false true null unknown"),
          dateSQL: set("date time timestamp"),
          support: set("ODBCdotTable doubleQuote binaryNumber hexNumber")
        });
        CodeMirror3.defineMIME("text/x-mssql", {
          name: "sql",
          client: set("$partition binary_checksum checksum connectionproperty context_info current_request_id error_line error_message error_number error_procedure error_severity error_state formatmessage get_filestream_transaction_context getansinull host_id host_name isnull isnumeric min_active_rowversion newid newsequentialid rowcount_big xact_state object_id"),
          keywords: set(sqlKeywords + "begin trigger proc view index for add constraint key primary foreign collate clustered nonclustered declare exec go if use index holdlock nolock nowait paglock readcommitted readcommittedlock readpast readuncommitted repeatableread rowlock serializable snapshot tablock tablockx updlock with"),
          builtin: set("bigint numeric bit smallint decimal smallmoney int tinyint money float real char varchar text nchar nvarchar ntext binary varbinary image cursor timestamp hierarchyid uniqueidentifier sql_variant xml table "),
          atoms: set("is not null like and or in left right between inner outer join all any some cross unpivot pivot exists"),
          operatorChars: /^[*+\-%<>!=^\&|\/]/,
          brackets: /^[\{}\(\)]/,
          punctuation: /^[;.,:/]/,
          backslashStringEscapes: false,
          dateSQL: set("date datetimeoffset datetime2 smalldatetime datetime time"),
          hooks: {
            "@": hookVar
          }
        });
        CodeMirror3.defineMIME("text/x-mysql", {
          name: "sql",
          client: set("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),
          keywords: set(sqlKeywords + "accessible action add after algorithm all analyze asensitive at authors auto_increment autocommit avg avg_row_length before binary binlog both btree cache call cascade cascaded case catalog_name chain change changed character check checkpoint checksum class_origin client_statistics close coalesce code collate collation collations column columns comment commit committed completion concurrent condition connection consistent constraint contains continue contributors convert cross current current_date current_time current_timestamp current_user cursor data database databases day_hour day_microsecond day_minute day_second deallocate dec declare default delay_key_write delayed delimiter des_key_file describe deterministic dev_pop dev_samp deviance diagnostics directory disable discard distinctrow div dual dumpfile each elseif enable enclosed end ends engine engines enum errors escape escaped even event events every execute exists exit explain extended fast fetch field fields first flush for force foreign found_rows full fulltext function general get global grant grants group group_concat handler hash help high_priority hosts hour_microsecond hour_minute hour_second if ignore ignore_server_ids import index index_statistics infile inner innodb inout insensitive insert_method install interval invoker isolation iterate key keys kill language last leading leave left level limit linear lines list load local localtime localtimestamp lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters match max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modifies modify mutex mysql_errno natural next no no_write_to_binlog offline offset one online open optimize option optionally out outer outfile pack_keys parser partition partitions password phase plugin plugins prepare preserve prev primary privileges procedure processlist profile profiles purge query quick range read read_write reads real rebuild recover references regexp relaylog release remove rename reorganize repair repeatable replace require resignal restrict resume return returns revoke right rlike rollback rollup row row_format rtree savepoint schedule schema schema_name schemas second_microsecond security sensitive separator serializable server session share show signal slave slow smallint snapshot soname spatial specific sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result sqlexception sqlstate sqlwarning ssl start starting starts status std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace temporary terminated to trailing transaction trigger triggers truncate uncommitted undo uninstall unique unlock upgrade usage use use_frm user user_resources user_statistics using utc_date utc_time utc_timestamp value variables varying view views warnings when while with work write xa xor year_month zerofill begin do then else loop repeat"),
          builtin: set("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision date datetime year unsigned signed numeric"),
          atoms: set("false true null unknown"),
          operatorChars: /^[*+\-%<>!=&|^]/,
          dateSQL: set("date time timestamp"),
          support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber doubleQuote nCharCast charsetCast commentHash commentSpaceRequired"),
          hooks: {
            "@": hookVar,
            "`": hookIdentifier,
            "\\": hookClient
          }
        });
        CodeMirror3.defineMIME("text/x-mariadb", {
          name: "sql",
          client: set("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),
          keywords: set(sqlKeywords + "accessible action add after algorithm all always analyze asensitive at authors auto_increment autocommit avg avg_row_length before binary binlog both btree cache call cascade cascaded case catalog_name chain change changed character check checkpoint checksum class_origin client_statistics close coalesce code collate collation collations column columns comment commit committed completion concurrent condition connection consistent constraint contains continue contributors convert cross current current_date current_time current_timestamp current_user cursor data database databases day_hour day_microsecond day_minute day_second deallocate dec declare default delay_key_write delayed delimiter des_key_file describe deterministic dev_pop dev_samp deviance diagnostics directory disable discard distinctrow div dual dumpfile each elseif enable enclosed end ends engine engines enum errors escape escaped even event events every execute exists exit explain extended fast fetch field fields first flush for force foreign found_rows full fulltext function general generated get global grant grants group groupby_concat handler hard hash help high_priority hosts hour_microsecond hour_minute hour_second if ignore ignore_server_ids import index index_statistics infile inner innodb inout insensitive insert_method install interval invoker isolation iterate key keys kill language last leading leave left level limit linear lines list load local localtime localtimestamp lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters match max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modifies modify mutex mysql_errno natural next no no_write_to_binlog offline offset one online open optimize option optionally out outer outfile pack_keys parser partition partitions password persistent phase plugin plugins prepare preserve prev primary privileges procedure processlist profile profiles purge query quick range read read_write reads real rebuild recover references regexp relaylog release remove rename reorganize repair repeatable replace require resignal restrict resume return returns revoke right rlike rollback rollup row row_format rtree savepoint schedule schema schema_name schemas second_microsecond security sensitive separator serializable server session share show shutdown signal slave slow smallint snapshot soft soname spatial specific sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result sqlexception sqlstate sqlwarning ssl start starting starts status std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace temporary terminated to trailing transaction trigger triggers truncate uncommitted undo uninstall unique unlock upgrade usage use use_frm user user_resources user_statistics using utc_date utc_time utc_timestamp value variables varying view views virtual warnings when while with work write xa xor year_month zerofill begin do then else loop repeat"),
          builtin: set("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision date datetime year unsigned signed numeric"),
          atoms: set("false true null unknown"),
          operatorChars: /^[*+\-%<>!=&|^]/,
          dateSQL: set("date time timestamp"),
          support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber doubleQuote nCharCast charsetCast commentHash commentSpaceRequired"),
          hooks: {
            "@": hookVar,
            "`": hookIdentifier,
            "\\": hookClient
          }
        });
        CodeMirror3.defineMIME("text/x-sqlite", {
          name: "sql",
          client: set("auth backup bail binary changes check clone databases dbinfo dump echo eqp exit explain fullschema headers help import imposter indexes iotrace limit lint load log mode nullvalue once open output print prompt quit read restore save scanstats schema separator session shell show stats system tables testcase timeout timer trace vfsinfo vfslist vfsname width"),
          keywords: set(sqlKeywords + "abort action add after all analyze attach autoincrement before begin cascade case cast check collate column commit conflict constraint cross current_date current_time current_timestamp database default deferrable deferred detach each else end escape except exclusive exists explain fail for foreign full glob if ignore immediate index indexed initially inner instead intersect isnull key left limit match natural no notnull null of offset outer plan pragma primary query raise recursive references regexp reindex release rename replace restrict right rollback row savepoint temp temporary then to transaction trigger unique using vacuum view virtual when with without"),
          builtin: set("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text clob bigint int int2 int8 integer float double char varchar date datetime year unsigned signed numeric real"),
          atoms: set("null current_date current_time current_timestamp"),
          operatorChars: /^[*+\-%<>!=&|/~]/,
          dateSQL: set("date time timestamp datetime"),
          support: set("decimallessFloat zerolessFloat"),
          identifierQuote: '"',
          hooks: {
            "@": hookVar,
            ":": hookVar,
            "?": hookVar,
            "$": hookVar,
            '"': hookIdentifierDoublequote,
            "`": hookIdentifier
          }
        });
        CodeMirror3.defineMIME("text/x-cassandra", {
          name: "sql",
          client: {},
          keywords: set("add all allow alter and any apply as asc authorize batch begin by clustering columnfamily compact consistency count create custom delete desc distinct drop each_quorum exists filtering from grant if in index insert into key keyspace keyspaces level limit local_one local_quorum modify nan norecursive nosuperuser not of on one order password permission permissions primary quorum rename revoke schema select set storage superuser table three to token truncate ttl two type unlogged update use user users using values where with writetime"),
          builtin: set("ascii bigint blob boolean counter decimal double float frozen inet int list map static text timestamp timeuuid tuple uuid varchar varint"),
          atoms: set("false true infinity NaN"),
          operatorChars: /^[<>=]/,
          dateSQL: {},
          support: set("commentSlashSlash decimallessFloat"),
          hooks: {}
        });
        CodeMirror3.defineMIME("text/x-plsql", {
          name: "sql",
          client: set("appinfo arraysize autocommit autoprint autorecovery autotrace blockterminator break btitle cmdsep colsep compatibility compute concat copycommit copytypecheck define describe echo editfile embedded escape exec execute feedback flagger flush heading headsep instance linesize lno loboffset logsource long longchunksize markup native newpage numformat numwidth pagesize pause pno recsep recsepchar release repfooter repheader serveroutput shiftinout show showmode size spool sqlblanklines sqlcase sqlcode sqlcontinue sqlnumber sqlpluscompatibility sqlprefix sqlprompt sqlterminator suffix tab term termout time timing trimout trimspool ttitle underline verify version wrap"),
          keywords: set("abort accept access add all alter and any array arraylen as asc assert assign at attributes audit authorization avg base_table begin between binary_integer body boolean by case cast char char_base check close cluster clusters colauth column comment commit compress connect connected constant constraint crash create current currval cursor data_base database date dba deallocate debugoff debugon decimal declare default definition delay delete desc digits dispose distinct do drop else elseif elsif enable end entry escape exception exception_init exchange exclusive exists exit external fast fetch file for force form from function generic goto grant group having identified if immediate in increment index indexes indicator initial initrans insert interface intersect into is key level library like limited local lock log logging long loop master maxextents maxtrans member minextents minus mislabel mode modify multiset new next no noaudit nocompress nologging noparallel not nowait number_base object of off offline on online only open option or order out package parallel partition pctfree pctincrease pctused pls_integer positive positiven pragma primary prior private privileges procedure public raise range raw read rebuild record ref references refresh release rename replace resource restrict return returning returns reverse revoke rollback row rowid rowlabel rownum rows run savepoint schema segment select separate session set share snapshot some space split sql start statement storage subtype successful synonym tabauth table tables tablespace task terminate then to trigger truncate type union unique unlimited unrecoverable unusable update use using validate value values variable view views when whenever where while with work"),
          builtin: set("abs acos add_months ascii asin atan atan2 average bfile bfilename bigserial bit blob ceil character chartorowid chr clob concat convert cos cosh count dec decode deref dual dump dup_val_on_index empty error exp false float floor found glb greatest hextoraw initcap instr instrb int integer isopen last_day least length lengthb ln lower lpad ltrim lub make_ref max min mlslabel mod months_between natural naturaln nchar nclob new_time next_day nextval nls_charset_decl_len nls_charset_id nls_charset_name nls_initcap nls_lower nls_sort nls_upper nlssort no_data_found notfound null number numeric nvarchar2 nvl others power rawtohex real reftohex round rowcount rowidtochar rowtype rpad rtrim serial sign signtype sin sinh smallint soundex sqlcode sqlerrm sqrt stddev string substr substrb sum sysdate tan tanh to_char text to_date to_label to_multi_byte to_number to_single_byte translate true trunc uid unlogged upper user userenv varchar varchar2 variance varying vsize xml"),
          operatorChars: /^[*\/+\-%<>!=~]/,
          dateSQL: set("date time timestamp"),
          support: set("doubleQuote nCharCast zerolessFloat binaryNumber hexNumber")
        });
        CodeMirror3.defineMIME("text/x-hive", {
          name: "sql",
          keywords: set("select alter $elem$ $key$ $value$ add after all analyze and archive as asc before between binary both bucket buckets by cascade case cast change cluster clustered clusterstatus collection column columns comment compute concatenate continue create cross cursor data database databases dbproperties deferred delete delimited desc describe directory disable distinct distribute drop else enable end escaped exclusive exists explain export extended external fetch fields fileformat first format formatted from full function functions grant group having hold_ddltime idxproperties if import in index indexes inpath inputdriver inputformat insert intersect into is items join keys lateral left like limit lines load local location lock locks mapjoin materialized minus msck no_drop nocompress not of offline on option or order out outer outputdriver outputformat overwrite partition partitioned partitions percent plus preserve procedure purge range rcfile read readonly reads rebuild recordreader recordwriter recover reduce regexp rename repair replace restrict revoke right rlike row schema schemas semi sequencefile serde serdeproperties set shared show show_database sort sorted ssl statistics stored streamtable table tables tablesample tblproperties temporary terminated textfile then tmp to touch transform trigger unarchive undo union uniquejoin unlock update use using utc utc_tmestamp view when where while with admin authorization char compact compactions conf cube current current_date current_timestamp day decimal defined dependency directories elem_type exchange file following for grouping hour ignore inner interval jar less logical macro minute month more none noscan over owner partialscan preceding pretty principals protection reload rewrite role roles rollup rows second server sets skewed transactions truncate unbounded unset uri user values window year"),
          builtin: set("bool boolean long timestamp tinyint smallint bigint int float double date datetime unsigned string array struct map uniontype key_type utctimestamp value_type varchar"),
          atoms: set("false true null unknown"),
          operatorChars: /^[*+\-%<>!=]/,
          dateSQL: set("date timestamp"),
          support: set("ODBCdotTable doubleQuote binaryNumber hexNumber")
        });
        CodeMirror3.defineMIME("text/x-pgsql", {
          name: "sql",
          client: set("source"),
          keywords: set(sqlKeywords + "a abort abs absent absolute access according action ada add admin after aggregate alias all allocate also alter always analyse analyze and any are array array_agg array_max_cardinality as asc asensitive assert assertion assignment asymmetric at atomic attach attribute attributes authorization avg backward base64 before begin begin_frame begin_partition bernoulli between bigint binary bit bit_length blob blocked bom boolean both breadth by c cache call called cardinality cascade cascaded case cast catalog catalog_name ceil ceiling chain char char_length character character_length character_set_catalog character_set_name character_set_schema characteristics characters check checkpoint class class_origin clob close cluster coalesce cobol collate collation collation_catalog collation_name collation_schema collect column column_name columns command_function command_function_code comment comments commit committed concurrently condition condition_number configuration conflict connect connection connection_name constant constraint constraint_catalog constraint_name constraint_schema constraints constructor contains content continue control conversion convert copy corr corresponding cost count covar_pop covar_samp create cross csv cube cume_dist current current_catalog current_date current_default_transform_group current_path current_role current_row current_schema current_time current_timestamp current_transform_group_for_type current_user cursor cursor_name cycle data database datalink datatype date datetime_interval_code datetime_interval_precision day db deallocate debug dec decimal declare default defaults deferrable deferred defined definer degree delete delimiter delimiters dense_rank depends depth deref derived desc describe descriptor detach detail deterministic diagnostics dictionary disable discard disconnect dispatch distinct dlnewcopy dlpreviouscopy dlurlcomplete dlurlcompleteonly dlurlcompletewrite dlurlpath dlurlpathonly dlurlpathwrite dlurlscheme dlurlserver dlvalue do document domain double drop dump dynamic dynamic_function dynamic_function_code each element else elseif elsif empty enable encoding encrypted end end_frame end_partition endexec enforced enum equals errcode error escape event every except exception exclude excluding exclusive exec execute exists exit exp explain expression extension external extract false family fetch file filter final first first_value flag float floor following for force foreach foreign fortran forward found frame_row free freeze from fs full function functions fusion g general generated get global go goto grant granted greatest group grouping groups handler having header hex hierarchy hint hold hour id identity if ignore ilike immediate immediately immutable implementation implicit import in include including increment indent index indexes indicator info inherit inherits initially inline inner inout input insensitive insert instance instantiable instead int integer integrity intersect intersection interval into invoker is isnull isolation join k key key_member key_type label lag language large last last_value lateral lead leading leakproof least left length level library like like_regex limit link listen ln load local localtime localtimestamp location locator lock locked log logged loop lower m map mapping match matched materialized max max_cardinality maxvalue member merge message message_length message_octet_length message_text method min minute minvalue mod mode modifies module month more move multiset mumps name names namespace national natural nchar nclob nesting new next nfc nfd nfkc nfkd nil no none normalize normalized not nothing notice notify notnull nowait nth_value ntile null nullable nullif nulls number numeric object occurrences_regex octet_length octets of off offset oids old on only open operator option options or order ordering ordinality others out outer output over overlaps overlay overriding owned owner p pad parallel parameter parameter_mode parameter_name parameter_ordinal_position parameter_specific_catalog parameter_specific_name parameter_specific_schema parser partial partition pascal passing passthrough password path percent percent_rank percentile_cont percentile_disc perform period permission pg_context pg_datatype_name pg_exception_context pg_exception_detail pg_exception_hint placing plans pli policy portion position position_regex power precedes preceding precision prepare prepared preserve primary print_strict_params prior privileges procedural procedure procedures program public publication query quote raise range rank read reads real reassign recheck recovery recursive ref references referencing refresh regr_avgx regr_avgy regr_count regr_intercept regr_r2 regr_slope regr_sxx regr_sxy regr_syy reindex relative release rename repeatable replace replica requiring reset respect restart restore restrict result result_oid return returned_cardinality returned_length returned_octet_length returned_sqlstate returning returns reverse revoke right role rollback rollup routine routine_catalog routine_name routine_schema routines row row_count row_number rows rowtype rule savepoint scale schema schema_name schemas scope scope_catalog scope_name scope_schema scroll search second section security select selective self sensitive sequence sequences serializable server server_name session session_user set setof sets share show similar simple size skip slice smallint snapshot some source space specific specific_name specifictype sql sqlcode sqlerror sqlexception sqlstate sqlwarning sqrt stable stacked standalone start state statement static statistics stddev_pop stddev_samp stdin stdout storage strict strip structure style subclass_origin submultiset subscription substring substring_regex succeeds sum symmetric sysid system system_time system_user t table table_name tables tablesample tablespace temp template temporary text then ties time timestamp timezone_hour timezone_minute to token top_level_count trailing transaction transaction_active transactions_committed transactions_rolled_back transform transforms translate translate_regex translation treat trigger trigger_catalog trigger_name trigger_schema trim trim_array true truncate trusted type types uescape unbounded uncommitted under unencrypted union unique unknown unlink unlisten unlogged unnamed unnest until untyped update upper uri usage use_column use_variable user user_defined_type_catalog user_defined_type_code user_defined_type_name user_defined_type_schema using vacuum valid validate validator value value_of values var_pop var_samp varbinary varchar variable_conflict variadic varying verbose version versioning view views volatile warning when whenever where while whitespace width_bucket window with within without work wrapper write xml xmlagg xmlattributes xmlbinary xmlcast xmlcomment xmlconcat xmldeclaration xmldocument xmlelement xmlexists xmlforest xmliterate xmlnamespaces xmlparse xmlpi xmlquery xmlroot xmlschema xmlserialize xmltable xmltext xmlvalidate year yes zone"),
          builtin: set("bigint int8 bigserial serial8 bit varying varbit boolean bool box bytea character char varchar cidr circle date double precision float8 inet integer int int4 interval json jsonb line lseg macaddr macaddr8 money numeric decimal path pg_lsn point polygon real float4 smallint int2 smallserial serial2 serial serial4 text time without zone with timetz timestamp timestamptz tsquery tsvector txid_snapshot uuid xml"),
          atoms: set("false true null unknown"),
          operatorChars: /^[*\/+\-%<>!=&|^\/#@?~]/,
          backslashStringEscapes: false,
          dateSQL: set("date time timestamp"),
          support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber nCharCast charsetCast escapeConstant")
        });
        CodeMirror3.defineMIME("text/x-gql", {
          name: "sql",
          keywords: set("ancestor and asc by contains desc descendant distinct from group has in is limit offset on order select superset where"),
          atoms: set("false true"),
          builtin: set("blob datetime first key __key__ string integer double boolean null"),
          operatorChars: /^[*+\-%<>!=]/
        });
        CodeMirror3.defineMIME("text/x-gpsql", {
          name: "sql",
          client: set("source"),
          keywords: set("abort absolute access action active add admin after aggregate all also alter always analyse analyze and any array as asc assertion assignment asymmetric at authorization backward before begin between bigint binary bit boolean both by cache called cascade cascaded case cast chain char character characteristics check checkpoint class close cluster coalesce codegen collate column comment commit committed concurrency concurrently configuration connection constraint constraints contains content continue conversion copy cost cpu_rate_limit create createdb createexttable createrole createuser cross csv cube current current_catalog current_date current_role current_schema current_time current_timestamp current_user cursor cycle data database day deallocate dec decimal declare decode default defaults deferrable deferred definer delete delimiter delimiters deny desc dictionary disable discard distinct distributed do document domain double drop dxl each else enable encoding encrypted end enum errors escape every except exchange exclude excluding exclusive execute exists explain extension external extract false family fetch fields filespace fill filter first float following for force foreign format forward freeze from full function global grant granted greatest group group_id grouping handler hash having header hold host hour identity if ignore ilike immediate immutable implicit in including inclusive increment index indexes inherit inherits initially inline inner inout input insensitive insert instead int integer intersect interval into invoker is isnull isolation join key language large last leading least left level like limit list listen load local localtime localtimestamp location lock log login mapping master match maxvalue median merge minute minvalue missing mode modifies modify month move name names national natural nchar new newline next no nocreatedb nocreateexttable nocreaterole nocreateuser noinherit nologin none noovercommit nosuperuser not nothing notify notnull nowait null nullif nulls numeric object of off offset oids old on only operator option options or order ordered others out outer over overcommit overlaps overlay owned owner parser partial partition partitions passing password percent percentile_cont percentile_disc placing plans position preceding precision prepare prepared preserve primary prior privileges procedural procedure protocol queue quote randomly range read readable reads real reassign recheck recursive ref references reindex reject relative release rename repeatable replace replica reset resource restart restrict returning returns revoke right role rollback rollup rootpartition row rows rule savepoint scatter schema scroll search second security segment select sequence serializable session session_user set setof sets share show similar simple smallint some split sql stable standalone start statement statistics stdin stdout storage strict strip subpartition subpartitions substring superuser symmetric sysid system table tablespace temp template temporary text then threshold ties time timestamp to trailing transaction treat trigger trim true truncate trusted type unbounded uncommitted unencrypted union unique unknown unlisten until update user using vacuum valid validation validator value values varchar variadic varying verbose version view volatile web when where whitespace window with within without work writable write xml xmlattributes xmlconcat xmlelement xmlexists xmlforest xmlparse xmlpi xmlroot xmlserialize year yes zone"),
          builtin: set("bigint int8 bigserial serial8 bit varying varbit boolean bool box bytea character char varchar cidr circle date double precision float float8 inet integer int int4 interval json jsonb line lseg macaddr macaddr8 money numeric decimal path pg_lsn point polygon real float4 smallint int2 smallserial serial2 serial serial4 text time without zone with timetz timestamp timestamptz tsquery tsvector txid_snapshot uuid xml"),
          atoms: set("false true null unknown"),
          operatorChars: /^[*+\-%<>!=&|^\/#@?~]/,
          dateSQL: set("date time timestamp"),
          support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber nCharCast charsetCast")
        });
        CodeMirror3.defineMIME("text/x-sparksql", {
          name: "sql",
          keywords: set("add after all alter analyze and anti archive array as asc at between bucket buckets by cache cascade case cast change clear cluster clustered codegen collection column columns comment commit compact compactions compute concatenate cost create cross cube current current_date current_timestamp database databases data dbproperties defined delete delimited deny desc describe dfs directories distinct distribute drop else end escaped except exchange exists explain export extended external false fields fileformat first following for format formatted from full function functions global grant group grouping having if ignore import in index indexes inner inpath inputformat insert intersect interval into is items join keys last lateral lazy left like limit lines list load local location lock locks logical macro map minus msck natural no not null nulls of on optimize option options or order out outer outputformat over overwrite partition partitioned partitions percent preceding principals purge range recordreader recordwriter recover reduce refresh regexp rename repair replace reset restrict revoke right rlike role roles rollback rollup row rows schema schemas select semi separated serde serdeproperties set sets show skewed sort sorted start statistics stored stratify struct table tables tablesample tblproperties temp temporary terminated then to touch transaction transactions transform true truncate unarchive unbounded uncache union unlock unset use using values view when where window with"),
          builtin: set("tinyint smallint int bigint boolean float double string binary timestamp decimal array map struct uniontype delimited serde sequencefile textfile rcfile inputformat outputformat"),
          atoms: set("false true null"),
          operatorChars: /^[*\/+\-%<>!=~&|^]/,
          dateSQL: set("date time timestamp"),
          support: set("ODBCdotTable doubleQuote zerolessFloat")
        });
        CodeMirror3.defineMIME("text/x-esper", {
          name: "sql",
          client: set("source"),
          keywords: set("alter and as asc between by count create delete desc distinct drop from group having in insert into is join like not on or order select set table union update values where limit after all and as at asc avedev avg between by case cast coalesce count create current_timestamp day days delete define desc distinct else end escape events every exists false first from full group having hour hours in inner insert instanceof into irstream is istream join last lastweekday left limit like max match_recognize matches median measures metadatasql min minute minutes msec millisecond milliseconds not null offset on or order outer output partition pattern prev prior regexp retain-union retain-intersection right rstream sec second seconds select set some snapshot sql stddev sum then true unidirectional until update variable weekday when where window"),
          builtin: {},
          atoms: set("false true null"),
          operatorChars: /^[*+\-%<>!=&|^\/#@?~]/,
          dateSQL: set("time"),
          support: set("decimallessFloat zerolessFloat binaryNumber hexNumber")
        });
      });
    }
  });

  // node_modules/codemirror/addon/mode/overlay.js
  var require_overlay = __commonJS({
    "node_modules/codemirror/addon/mode/overlay.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.overlayMode = function(base, overlay, combine) {
          return {
            startState: function() {
              return {
                base: CodeMirror3.startState(base),
                overlay: CodeMirror3.startState(overlay),
                basePos: 0,
                baseCur: null,
                overlayPos: 0,
                overlayCur: null,
                streamSeen: null
              };
            },
            copyState: function(state) {
              return {
                base: CodeMirror3.copyState(base, state.base),
                overlay: CodeMirror3.copyState(overlay, state.overlay),
                basePos: state.basePos,
                baseCur: null,
                overlayPos: state.overlayPos,
                overlayCur: null
              };
            },
            token: function(stream, state) {
              if (stream != state.streamSeen || Math.min(state.basePos, state.overlayPos) < stream.start) {
                state.streamSeen = stream;
                state.basePos = state.overlayPos = stream.start;
              }
              if (stream.start == state.basePos) {
                state.baseCur = base.token(stream, state.base);
                state.basePos = stream.pos;
              }
              if (stream.start == state.overlayPos) {
                stream.pos = stream.start;
                state.overlayCur = overlay.token(stream, state.overlay);
                state.overlayPos = stream.pos;
              }
              stream.pos = Math.min(state.basePos, state.overlayPos);
              if (state.overlayCur == null)
                return state.baseCur;
              else if (state.baseCur != null && state.overlay.combineTokens || combine && state.overlay.combineTokens == null)
                return state.baseCur + " " + state.overlayCur;
              else
                return state.overlayCur;
            },
            indent: base.indent && function(state, textAfter, line) {
              return base.indent(state.base, textAfter, line);
            },
            electricChars: base.electricChars,
            innerMode: function(state) {
              return { state: state.base, mode: base };
            },
            blankLine: function(state) {
              var baseToken, overlayToken;
              if (base.blankLine)
                baseToken = base.blankLine(state.base);
              if (overlay.blankLine)
                overlayToken = overlay.blankLine(state.overlay);
              return overlayToken == null ? baseToken : combine && baseToken != null ? baseToken + " " + overlayToken : overlayToken;
            }
          };
        };
      });
    }
  });

  // node_modules/codemirror/mode/coffeescript/coffeescript.js
  var require_coffeescript = __commonJS({
    "node_modules/codemirror/mode/coffeescript/coffeescript.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.defineMode("coffeescript", function(conf, parserConf) {
          var ERRORCLASS = "error";
          function wordRegexp(words) {
            return new RegExp("^((" + words.join(")|(") + "))\\b");
          }
          var operators = /^(?:->|=>|\+[+=]?|-[\-=]?|\*[\*=]?|\/[\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\|=?|\^=?|\~|!|\?|(or|and|\|\||&&|\?)=)/;
          var delimiters = /^(?:[()\[\]{},:`=;]|\.\.?\.?)/;
          var identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;
          var atProp = /^@[_A-Za-z$][_A-Za-z$0-9]*/;
          var wordOperators = wordRegexp([
            "and",
            "or",
            "not",
            "is",
            "isnt",
            "in",
            "instanceof",
            "typeof"
          ]);
          var indentKeywords = [
            "for",
            "while",
            "loop",
            "if",
            "unless",
            "else",
            "switch",
            "try",
            "catch",
            "finally",
            "class"
          ];
          var commonKeywords = [
            "break",
            "by",
            "continue",
            "debugger",
            "delete",
            "do",
            "in",
            "of",
            "new",
            "return",
            "then",
            "this",
            "@",
            "throw",
            "when",
            "until",
            "extends"
          ];
          var keywords = wordRegexp(indentKeywords.concat(commonKeywords));
          indentKeywords = wordRegexp(indentKeywords);
          var stringPrefixes = /^('{3}|\"{3}|['\"])/;
          var regexPrefixes = /^(\/{3}|\/)/;
          var commonConstants = ["Infinity", "NaN", "undefined", "null", "true", "false", "on", "off", "yes", "no"];
          var constants = wordRegexp(commonConstants);
          function tokenBase(stream, state) {
            if (stream.sol()) {
              if (state.scope.align === null)
                state.scope.align = false;
              var scopeOffset = state.scope.offset;
              if (stream.eatSpace()) {
                var lineOffset = stream.indentation();
                if (lineOffset > scopeOffset && state.scope.type == "coffee") {
                  return "indent";
                } else if (lineOffset < scopeOffset) {
                  return "dedent";
                }
                return null;
              } else {
                if (scopeOffset > 0) {
                  dedent(stream, state);
                }
              }
            }
            if (stream.eatSpace()) {
              return null;
            }
            var ch = stream.peek();
            if (stream.match("####")) {
              stream.skipToEnd();
              return "comment";
            }
            if (stream.match("###")) {
              state.tokenize = longComment;
              return state.tokenize(stream, state);
            }
            if (ch === "#") {
              stream.skipToEnd();
              return "comment";
            }
            if (stream.match(/^-?[0-9\.]/, false)) {
              var floatLiteral = false;
              if (stream.match(/^-?\d*\.\d+(e[\+\-]?\d+)?/i)) {
                floatLiteral = true;
              }
              if (stream.match(/^-?\d+\.\d*/)) {
                floatLiteral = true;
              }
              if (stream.match(/^-?\.\d+/)) {
                floatLiteral = true;
              }
              if (floatLiteral) {
                if (stream.peek() == ".") {
                  stream.backUp(1);
                }
                return "number";
              }
              var intLiteral = false;
              if (stream.match(/^-?0x[0-9a-f]+/i)) {
                intLiteral = true;
              }
              if (stream.match(/^-?[1-9]\d*(e[\+\-]?\d+)?/)) {
                intLiteral = true;
              }
              if (stream.match(/^-?0(?![\dx])/i)) {
                intLiteral = true;
              }
              if (intLiteral) {
                return "number";
              }
            }
            if (stream.match(stringPrefixes)) {
              state.tokenize = tokenFactory(stream.current(), false, "string");
              return state.tokenize(stream, state);
            }
            if (stream.match(regexPrefixes)) {
              if (stream.current() != "/" || stream.match(/^.*\//, false)) {
                state.tokenize = tokenFactory(stream.current(), true, "string-2");
                return state.tokenize(stream, state);
              } else {
                stream.backUp(1);
              }
            }
            if (stream.match(operators) || stream.match(wordOperators)) {
              return "operator";
            }
            if (stream.match(delimiters)) {
              return "punctuation";
            }
            if (stream.match(constants)) {
              return "atom";
            }
            if (stream.match(atProp) || state.prop && stream.match(identifiers)) {
              return "property";
            }
            if (stream.match(keywords)) {
              return "keyword";
            }
            if (stream.match(identifiers)) {
              return "variable";
            }
            stream.next();
            return ERRORCLASS;
          }
          function tokenFactory(delimiter, singleline, outclass) {
            return function(stream, state) {
              while (!stream.eol()) {
                stream.eatWhile(/[^'"\/\\]/);
                if (stream.eat("\\")) {
                  stream.next();
                  if (singleline && stream.eol()) {
                    return outclass;
                  }
                } else if (stream.match(delimiter)) {
                  state.tokenize = tokenBase;
                  return outclass;
                } else {
                  stream.eat(/['"\/]/);
                }
              }
              if (singleline) {
                if (parserConf.singleLineStringErrors) {
                  outclass = ERRORCLASS;
                } else {
                  state.tokenize = tokenBase;
                }
              }
              return outclass;
            };
          }
          function longComment(stream, state) {
            while (!stream.eol()) {
              stream.eatWhile(/[^#]/);
              if (stream.match("###")) {
                state.tokenize = tokenBase;
                break;
              }
              stream.eatWhile("#");
            }
            return "comment";
          }
          function indent(stream, state, type) {
            type = type || "coffee";
            var offset2 = 0, align = false, alignOffset = null;
            for (var scope = state.scope; scope; scope = scope.prev) {
              if (scope.type === "coffee" || scope.type == "}") {
                offset2 = scope.offset + conf.indentUnit;
                break;
              }
            }
            if (type !== "coffee") {
              align = null;
              alignOffset = stream.column() + stream.current().length;
            } else if (state.scope.align) {
              state.scope.align = false;
            }
            state.scope = {
              offset: offset2,
              type,
              prev: state.scope,
              align,
              alignOffset
            };
          }
          function dedent(stream, state) {
            if (!state.scope.prev)
              return;
            if (state.scope.type === "coffee") {
              var _indent = stream.indentation();
              var matched = false;
              for (var scope = state.scope; scope; scope = scope.prev) {
                if (_indent === scope.offset) {
                  matched = true;
                  break;
                }
              }
              if (!matched) {
                return true;
              }
              while (state.scope.prev && state.scope.offset !== _indent) {
                state.scope = state.scope.prev;
              }
              return false;
            } else {
              state.scope = state.scope.prev;
              return false;
            }
          }
          function tokenLexer(stream, state) {
            var style = state.tokenize(stream, state);
            var current = stream.current();
            if (current === "return") {
              state.dedent = true;
            }
            if ((current === "->" || current === "=>") && stream.eol() || style === "indent") {
              indent(stream, state);
            }
            var delimiter_index = "[({".indexOf(current);
            if (delimiter_index !== -1) {
              indent(stream, state, "])}".slice(delimiter_index, delimiter_index + 1));
            }
            if (indentKeywords.exec(current)) {
              indent(stream, state);
            }
            if (current == "then") {
              dedent(stream, state);
            }
            if (style === "dedent") {
              if (dedent(stream, state)) {
                return ERRORCLASS;
              }
            }
            delimiter_index = "])}".indexOf(current);
            if (delimiter_index !== -1) {
              while (state.scope.type == "coffee" && state.scope.prev)
                state.scope = state.scope.prev;
              if (state.scope.type == current)
                state.scope = state.scope.prev;
            }
            if (state.dedent && stream.eol()) {
              if (state.scope.type == "coffee" && state.scope.prev)
                state.scope = state.scope.prev;
              state.dedent = false;
            }
            return style;
          }
          var external = {
            startState: function(basecolumn) {
              return {
                tokenize: tokenBase,
                scope: { offset: basecolumn || 0, type: "coffee", prev: null, align: false },
                prop: false,
                dedent: 0
              };
            },
            token: function(stream, state) {
              var fillAlign = state.scope.align === null && state.scope;
              if (fillAlign && stream.sol())
                fillAlign.align = false;
              var style = tokenLexer(stream, state);
              if (style && style != "comment") {
                if (fillAlign)
                  fillAlign.align = true;
                state.prop = style == "punctuation" && stream.current() == ".";
              }
              return style;
            },
            indent: function(state, text) {
              if (state.tokenize != tokenBase)
                return 0;
              var scope = state.scope;
              var closer = text && "])}".indexOf(text.charAt(0)) > -1;
              if (closer)
                while (scope.type == "coffee" && scope.prev)
                  scope = scope.prev;
              var closes = closer && scope.type === text.charAt(0);
              if (scope.align)
                return scope.alignOffset - (closes ? 1 : 0);
              else
                return (closes ? scope.prev : scope).offset;
            },
            lineComment: "#",
            fold: "indent"
          };
          return external;
        });
        CodeMirror3.defineMIME("application/vnd.coffeescript", "coffeescript");
        CodeMirror3.defineMIME("text/x-coffeescript", "coffeescript");
        CodeMirror3.defineMIME("text/coffeescript", "coffeescript");
      });
    }
  });

  // node_modules/codemirror/mode/stylus/stylus.js
  var require_stylus = __commonJS({
    "node_modules/codemirror/mode/stylus/stylus.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.defineMode("stylus", function(config) {
          var indentUnit = config.indentUnit, indentUnitString = "", tagKeywords = keySet(tagKeywords_), tagVariablesRegexp = /^(a|b|i|s|col|em)$/i, propertyKeywords = keySet(propertyKeywords_), nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_), valueKeywords = keySet(valueKeywords_), colorKeywords = keySet(colorKeywords_), documentTypes = keySet(documentTypes_), documentTypesRegexp = wordRegexp(documentTypes_), mediaFeatures = keySet(mediaFeatures_), mediaTypes = keySet(mediaTypes_), fontProperties = keySet(fontProperties_), operatorsRegexp = /^\s*([.]{2,3}|&&|\|\||\*\*|[?!=:]?=|[-+*\/%<>]=?|\?:|\~)/, wordOperatorKeywordsRegexp = wordRegexp(wordOperatorKeywords_), blockKeywords = keySet(blockKeywords_), vendorPrefixesRegexp = new RegExp(/^\-(moz|ms|o|webkit)-/i), commonAtoms = keySet(commonAtoms_), firstWordMatch = "", states = {}, ch, style, type, override;
          while (indentUnitString.length < indentUnit)
            indentUnitString += " ";
          function tokenBase(stream, state) {
            firstWordMatch = stream.string.match(/(^[\w-]+\s*=\s*$)|(^\s*[\w-]+\s*=\s*[\w-])|(^\s*(\.|#|@|\$|\&|\[|\d|\+|::?|\{|\>|~|\/)?\s*[\w-]*([a-z0-9-]|\*|\/\*)(\(|,)?)/);
            state.context.line.firstWord = firstWordMatch ? firstWordMatch[0].replace(/^\s*/, "") : "";
            state.context.line.indent = stream.indentation();
            ch = stream.peek();
            if (stream.match("//")) {
              stream.skipToEnd();
              return ["comment", "comment"];
            }
            if (stream.match("/*")) {
              state.tokenize = tokenCComment;
              return tokenCComment(stream, state);
            }
            if (ch == '"' || ch == "'") {
              stream.next();
              state.tokenize = tokenString(ch);
              return state.tokenize(stream, state);
            }
            if (ch == "@") {
              stream.next();
              stream.eatWhile(/[\w\\-]/);
              return ["def", stream.current()];
            }
            if (ch == "#") {
              stream.next();
              if (stream.match(/^[0-9a-f]{3}([0-9a-f]([0-9a-f]{2}){0,2})?\b(?!-)/i)) {
                return ["atom", "atom"];
              }
              if (stream.match(/^[a-z][\w-]*/i)) {
                return ["builtin", "hash"];
              }
            }
            if (stream.match(vendorPrefixesRegexp)) {
              return ["meta", "vendor-prefixes"];
            }
            if (stream.match(/^-?[0-9]?\.?[0-9]/)) {
              stream.eatWhile(/[a-z%]/i);
              return ["number", "unit"];
            }
            if (ch == "!") {
              stream.next();
              return [stream.match(/^(important|optional)/i) ? "keyword" : "operator", "important"];
            }
            if (ch == "." && stream.match(/^\.[a-z][\w-]*/i)) {
              return ["qualifier", "qualifier"];
            }
            if (stream.match(documentTypesRegexp)) {
              if (stream.peek() == "(")
                state.tokenize = tokenParenthesized;
              return ["property", "word"];
            }
            if (stream.match(/^[a-z][\w-]*\(/i)) {
              stream.backUp(1);
              return ["keyword", "mixin"];
            }
            if (stream.match(/^(\+|-)[a-z][\w-]*\(/i)) {
              stream.backUp(1);
              return ["keyword", "block-mixin"];
            }
            if (stream.string.match(/^\s*&/) && stream.match(/^[-_]+[a-z][\w-]*/)) {
              return ["qualifier", "qualifier"];
            }
            if (stream.match(/^(\/|&)(-|_|:|\.|#|[a-z])/)) {
              stream.backUp(1);
              return ["variable-3", "reference"];
            }
            if (stream.match(/^&{1}\s*$/)) {
              return ["variable-3", "reference"];
            }
            if (stream.match(wordOperatorKeywordsRegexp)) {
              return ["operator", "operator"];
            }
            if (stream.match(/^\$?[-_]*[a-z0-9]+[\w-]*/i)) {
              if (stream.match(/^(\.|\[)[\w-\'\"\]]+/i, false)) {
                if (!wordIsTag(stream.current())) {
                  stream.match(".");
                  return ["variable-2", "variable-name"];
                }
              }
              return ["variable-2", "word"];
            }
            if (stream.match(operatorsRegexp)) {
              return ["operator", stream.current()];
            }
            if (/[:;,{}\[\]\(\)]/.test(ch)) {
              stream.next();
              return [null, ch];
            }
            stream.next();
            return [null, null];
          }
          function tokenCComment(stream, state) {
            var maybeEnd = false, ch2;
            while ((ch2 = stream.next()) != null) {
              if (maybeEnd && ch2 == "/") {
                state.tokenize = null;
                break;
              }
              maybeEnd = ch2 == "*";
            }
            return ["comment", "comment"];
          }
          function tokenString(quote) {
            return function(stream, state) {
              var escaped = false, ch2;
              while ((ch2 = stream.next()) != null) {
                if (ch2 == quote && !escaped) {
                  if (quote == ")")
                    stream.backUp(1);
                  break;
                }
                escaped = !escaped && ch2 == "\\";
              }
              if (ch2 == quote || !escaped && quote != ")")
                state.tokenize = null;
              return ["string", "string"];
            };
          }
          function tokenParenthesized(stream, state) {
            stream.next();
            if (!stream.match(/\s*[\"\')]/, false))
              state.tokenize = tokenString(")");
            else
              state.tokenize = null;
            return [null, "("];
          }
          function Context2(type2, indent, prev, line) {
            this.type = type2;
            this.indent = indent;
            this.prev = prev;
            this.line = line || { firstWord: "", indent: 0 };
          }
          function pushContext(state, stream, type2, indent) {
            indent = indent >= 0 ? indent : indentUnit;
            state.context = new Context2(type2, stream.indentation() + indent, state.context);
            return type2;
          }
          function popContext(state, currentIndent) {
            var contextIndent = state.context.indent - indentUnit;
            currentIndent = currentIndent || false;
            state.context = state.context.prev;
            if (currentIndent)
              state.context.indent = contextIndent;
            return state.context.type;
          }
          function pass(type2, stream, state) {
            return states[state.context.type](type2, stream, state);
          }
          function popAndPass(type2, stream, state, n2) {
            for (var i2 = n2 || 1; i2 > 0; i2--)
              state.context = state.context.prev;
            return pass(type2, stream, state);
          }
          function wordIsTag(word) {
            return word.toLowerCase() in tagKeywords;
          }
          function wordIsProperty(word) {
            word = word.toLowerCase();
            return word in propertyKeywords || word in fontProperties;
          }
          function wordIsBlock(word) {
            return word.toLowerCase() in blockKeywords;
          }
          function wordIsVendorPrefix(word) {
            return word.toLowerCase().match(vendorPrefixesRegexp);
          }
          function wordAsValue(word) {
            var wordLC = word.toLowerCase();
            var override2 = "variable-2";
            if (wordIsTag(word))
              override2 = "tag";
            else if (wordIsBlock(word))
              override2 = "block-keyword";
            else if (wordIsProperty(word))
              override2 = "property";
            else if (wordLC in valueKeywords || wordLC in commonAtoms)
              override2 = "atom";
            else if (wordLC == "return" || wordLC in colorKeywords)
              override2 = "keyword";
            else if (word.match(/^[A-Z]/))
              override2 = "string";
            return override2;
          }
          function typeIsBlock(type2, stream) {
            return endOfLine(stream) && (type2 == "{" || type2 == "]" || type2 == "hash" || type2 == "qualifier") || type2 == "block-mixin";
          }
          function typeIsInterpolation(type2, stream) {
            return type2 == "{" && stream.match(/^\s*\$?[\w-]+/i, false);
          }
          function typeIsPseudo(type2, stream) {
            return type2 == ":" && stream.match(/^[a-z-]+/, false);
          }
          function startOfLine(stream) {
            return stream.sol() || stream.string.match(new RegExp("^\\s*" + escapeRegExp(stream.current())));
          }
          function endOfLine(stream) {
            return stream.eol() || stream.match(/^\s*$/, false);
          }
          function firstWordOfLine(line) {
            var re = /^\s*[-_]*[a-z0-9]+[\w-]*/i;
            var result = typeof line == "string" ? line.match(re) : line.string.match(re);
            return result ? result[0].replace(/^\s*/, "") : "";
          }
          states.block = function(type2, stream, state) {
            if (type2 == "comment" && startOfLine(stream) || type2 == "," && endOfLine(stream) || type2 == "mixin") {
              return pushContext(state, stream, "block", 0);
            }
            if (typeIsInterpolation(type2, stream)) {
              return pushContext(state, stream, "interpolation");
            }
            if (endOfLine(stream) && type2 == "]") {
              if (!/^\s*(\.|#|:|\[|\*|&)/.test(stream.string) && !wordIsTag(firstWordOfLine(stream))) {
                return pushContext(state, stream, "block", 0);
              }
            }
            if (typeIsBlock(type2, stream)) {
              return pushContext(state, stream, "block");
            }
            if (type2 == "}" && endOfLine(stream)) {
              return pushContext(state, stream, "block", 0);
            }
            if (type2 == "variable-name") {
              if (stream.string.match(/^\s?\$[\w-\.\[\]\'\"]+$/) || wordIsBlock(firstWordOfLine(stream))) {
                return pushContext(state, stream, "variableName");
              } else {
                return pushContext(state, stream, "variableName", 0);
              }
            }
            if (type2 == "=") {
              if (!endOfLine(stream) && !wordIsBlock(firstWordOfLine(stream))) {
                return pushContext(state, stream, "block", 0);
              }
              return pushContext(state, stream, "block");
            }
            if (type2 == "*") {
              if (endOfLine(stream) || stream.match(/\s*(,|\.|#|\[|:|{)/, false)) {
                override = "tag";
                return pushContext(state, stream, "block");
              }
            }
            if (typeIsPseudo(type2, stream)) {
              return pushContext(state, stream, "pseudo");
            }
            if (/@(font-face|media|supports|(-moz-)?document)/.test(type2)) {
              return pushContext(state, stream, endOfLine(stream) ? "block" : "atBlock");
            }
            if (/@(-(moz|ms|o|webkit)-)?keyframes$/.test(type2)) {
              return pushContext(state, stream, "keyframes");
            }
            if (/@extends?/.test(type2)) {
              return pushContext(state, stream, "extend", 0);
            }
            if (type2 && type2.charAt(0) == "@") {
              if (stream.indentation() > 0 && wordIsProperty(stream.current().slice(1))) {
                override = "variable-2";
                return "block";
              }
              if (/(@import|@require|@charset)/.test(type2)) {
                return pushContext(state, stream, "block", 0);
              }
              return pushContext(state, stream, "block");
            }
            if (type2 == "reference" && endOfLine(stream)) {
              return pushContext(state, stream, "block");
            }
            if (type2 == "(") {
              return pushContext(state, stream, "parens");
            }
            if (type2 == "vendor-prefixes") {
              return pushContext(state, stream, "vendorPrefixes");
            }
            if (type2 == "word") {
              var word = stream.current();
              override = wordAsValue(word);
              if (override == "property") {
                if (startOfLine(stream)) {
                  return pushContext(state, stream, "block", 0);
                } else {
                  override = "atom";
                  return "block";
                }
              }
              if (override == "tag") {
                if (/embed|menu|pre|progress|sub|table/.test(word)) {
                  if (wordIsProperty(firstWordOfLine(stream))) {
                    override = "atom";
                    return "block";
                  }
                }
                if (stream.string.match(new RegExp("\\[\\s*" + word + "|" + word + "\\s*\\]"))) {
                  override = "atom";
                  return "block";
                }
                if (tagVariablesRegexp.test(word)) {
                  if (startOfLine(stream) && stream.string.match(/=/) || !startOfLine(stream) && !stream.string.match(/^(\s*\.|#|\&|\[|\/|>|\*)/) && !wordIsTag(firstWordOfLine(stream))) {
                    override = "variable-2";
                    if (wordIsBlock(firstWordOfLine(stream)))
                      return "block";
                    return pushContext(state, stream, "block", 0);
                  }
                }
                if (endOfLine(stream))
                  return pushContext(state, stream, "block");
              }
              if (override == "block-keyword") {
                override = "keyword";
                if (stream.current(/(if|unless)/) && !startOfLine(stream)) {
                  return "block";
                }
                return pushContext(state, stream, "block");
              }
              if (word == "return")
                return pushContext(state, stream, "block", 0);
              if (override == "variable-2" && stream.string.match(/^\s?\$[\w-\.\[\]\'\"]+$/)) {
                return pushContext(state, stream, "block");
              }
            }
            return state.context.type;
          };
          states.parens = function(type2, stream, state) {
            if (type2 == "(")
              return pushContext(state, stream, "parens");
            if (type2 == ")") {
              if (state.context.prev.type == "parens") {
                return popContext(state);
              }
              if (stream.string.match(/^[a-z][\w-]*\(/i) && endOfLine(stream) || wordIsBlock(firstWordOfLine(stream)) || /(\.|#|:|\[|\*|&|>|~|\+|\/)/.test(firstWordOfLine(stream)) || !stream.string.match(/^-?[a-z][\w-\.\[\]\'\"]*\s*=/) && wordIsTag(firstWordOfLine(stream))) {
                return pushContext(state, stream, "block");
              }
              if (stream.string.match(/^[\$-]?[a-z][\w-\.\[\]\'\"]*\s*=/) || stream.string.match(/^\s*(\(|\)|[0-9])/) || stream.string.match(/^\s+[a-z][\w-]*\(/i) || stream.string.match(/^\s+[\$-]?[a-z]/i)) {
                return pushContext(state, stream, "block", 0);
              }
              if (endOfLine(stream))
                return pushContext(state, stream, "block");
              else
                return pushContext(state, stream, "block", 0);
            }
            if (type2 && type2.charAt(0) == "@" && wordIsProperty(stream.current().slice(1))) {
              override = "variable-2";
            }
            if (type2 == "word") {
              var word = stream.current();
              override = wordAsValue(word);
              if (override == "tag" && tagVariablesRegexp.test(word)) {
                override = "variable-2";
              }
              if (override == "property" || word == "to")
                override = "atom";
            }
            if (type2 == "variable-name") {
              return pushContext(state, stream, "variableName");
            }
            if (typeIsPseudo(type2, stream)) {
              return pushContext(state, stream, "pseudo");
            }
            return state.context.type;
          };
          states.vendorPrefixes = function(type2, stream, state) {
            if (type2 == "word") {
              override = "property";
              return pushContext(state, stream, "block", 0);
            }
            return popContext(state);
          };
          states.pseudo = function(type2, stream, state) {
            if (!wordIsProperty(firstWordOfLine(stream.string))) {
              stream.match(/^[a-z-]+/);
              override = "variable-3";
              if (endOfLine(stream))
                return pushContext(state, stream, "block");
              return popContext(state);
            }
            return popAndPass(type2, stream, state);
          };
          states.atBlock = function(type2, stream, state) {
            if (type2 == "(")
              return pushContext(state, stream, "atBlock_parens");
            if (typeIsBlock(type2, stream)) {
              return pushContext(state, stream, "block");
            }
            if (typeIsInterpolation(type2, stream)) {
              return pushContext(state, stream, "interpolation");
            }
            if (type2 == "word") {
              var word = stream.current().toLowerCase();
              if (/^(only|not|and|or)$/.test(word))
                override = "keyword";
              else if (documentTypes.hasOwnProperty(word))
                override = "tag";
              else if (mediaTypes.hasOwnProperty(word))
                override = "attribute";
              else if (mediaFeatures.hasOwnProperty(word))
                override = "property";
              else if (nonStandardPropertyKeywords.hasOwnProperty(word))
                override = "string-2";
              else
                override = wordAsValue(stream.current());
              if (override == "tag" && endOfLine(stream)) {
                return pushContext(state, stream, "block");
              }
            }
            if (type2 == "operator" && /^(not|and|or)$/.test(stream.current())) {
              override = "keyword";
            }
            return state.context.type;
          };
          states.atBlock_parens = function(type2, stream, state) {
            if (type2 == "{" || type2 == "}")
              return state.context.type;
            if (type2 == ")") {
              if (endOfLine(stream))
                return pushContext(state, stream, "block");
              else
                return pushContext(state, stream, "atBlock");
            }
            if (type2 == "word") {
              var word = stream.current().toLowerCase();
              override = wordAsValue(word);
              if (/^(max|min)/.test(word))
                override = "property";
              if (override == "tag") {
                tagVariablesRegexp.test(word) ? override = "variable-2" : override = "atom";
              }
              return state.context.type;
            }
            return states.atBlock(type2, stream, state);
          };
          states.keyframes = function(type2, stream, state) {
            if (stream.indentation() == "0" && (type2 == "}" && startOfLine(stream) || type2 == "]" || type2 == "hash" || type2 == "qualifier" || wordIsTag(stream.current()))) {
              return popAndPass(type2, stream, state);
            }
            if (type2 == "{")
              return pushContext(state, stream, "keyframes");
            if (type2 == "}") {
              if (startOfLine(stream))
                return popContext(state, true);
              else
                return pushContext(state, stream, "keyframes");
            }
            if (type2 == "unit" && /^[0-9]+\%$/.test(stream.current())) {
              return pushContext(state, stream, "keyframes");
            }
            if (type2 == "word") {
              override = wordAsValue(stream.current());
              if (override == "block-keyword") {
                override = "keyword";
                return pushContext(state, stream, "keyframes");
              }
            }
            if (/@(font-face|media|supports|(-moz-)?document)/.test(type2)) {
              return pushContext(state, stream, endOfLine(stream) ? "block" : "atBlock");
            }
            if (type2 == "mixin") {
              return pushContext(state, stream, "block", 0);
            }
            return state.context.type;
          };
          states.interpolation = function(type2, stream, state) {
            if (type2 == "{")
              popContext(state) && pushContext(state, stream, "block");
            if (type2 == "}") {
              if (stream.string.match(/^\s*(\.|#|:|\[|\*|&|>|~|\+|\/)/i) || stream.string.match(/^\s*[a-z]/i) && wordIsTag(firstWordOfLine(stream))) {
                return pushContext(state, stream, "block");
              }
              if (!stream.string.match(/^(\{|\s*\&)/) || stream.match(/\s*[\w-]/, false)) {
                return pushContext(state, stream, "block", 0);
              }
              return pushContext(state, stream, "block");
            }
            if (type2 == "variable-name") {
              return pushContext(state, stream, "variableName", 0);
            }
            if (type2 == "word") {
              override = wordAsValue(stream.current());
              if (override == "tag")
                override = "atom";
            }
            return state.context.type;
          };
          states.extend = function(type2, stream, state) {
            if (type2 == "[" || type2 == "=")
              return "extend";
            if (type2 == "]")
              return popContext(state);
            if (type2 == "word") {
              override = wordAsValue(stream.current());
              return "extend";
            }
            return popContext(state);
          };
          states.variableName = function(type2, stream, state) {
            if (type2 == "string" || type2 == "[" || type2 == "]" || stream.current().match(/^(\.|\$)/)) {
              if (stream.current().match(/^\.[\w-]+/i))
                override = "variable-2";
              return "variableName";
            }
            return popAndPass(type2, stream, state);
          };
          return {
            startState: function(base) {
              return {
                tokenize: null,
                state: "block",
                context: new Context2("block", base || 0, null)
              };
            },
            token: function(stream, state) {
              if (!state.tokenize && stream.eatSpace())
                return null;
              style = (state.tokenize || tokenBase)(stream, state);
              if (style && typeof style == "object") {
                type = style[1];
                style = style[0];
              }
              override = style;
              state.state = states[state.state](type, stream, state);
              return override;
            },
            indent: function(state, textAfter, line) {
              var cx = state.context, ch2 = textAfter && textAfter.charAt(0), indent = cx.indent, lineFirstWord = firstWordOfLine(textAfter), lineIndent = line.match(/^\s*/)[0].replace(/\t/g, indentUnitString).length, prevLineFirstWord = state.context.prev ? state.context.prev.line.firstWord : "", prevLineIndent = state.context.prev ? state.context.prev.line.indent : lineIndent;
              if (cx.prev && (ch2 == "}" && (cx.type == "block" || cx.type == "atBlock" || cx.type == "keyframes") || ch2 == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") || ch2 == "{" && cx.type == "at")) {
                indent = cx.indent - indentUnit;
              } else if (!/(\})/.test(ch2)) {
                if (/@|\$|\d/.test(ch2) || /^\{/.test(textAfter) || /^\s*\/(\/|\*)/.test(textAfter) || /^\s*\/\*/.test(prevLineFirstWord) || /^\s*[\w-\.\[\]\'\"]+\s*(\?|:|\+)?=/i.test(textAfter) || /^(\+|-)?[a-z][\w-]*\(/i.test(textAfter) || /^return/.test(textAfter) || wordIsBlock(lineFirstWord)) {
                  indent = lineIndent;
                } else if (/(\.|#|:|\[|\*|&|>|~|\+|\/)/.test(ch2) || wordIsTag(lineFirstWord)) {
                  if (/\,\s*$/.test(prevLineFirstWord)) {
                    indent = prevLineIndent;
                  } else if (/^\s+/.test(line) && (/(\.|#|:|\[|\*|&|>|~|\+|\/)/.test(prevLineFirstWord) || wordIsTag(prevLineFirstWord))) {
                    indent = lineIndent <= prevLineIndent ? prevLineIndent : prevLineIndent + indentUnit;
                  } else {
                    indent = lineIndent;
                  }
                } else if (!/,\s*$/.test(line) && (wordIsVendorPrefix(lineFirstWord) || wordIsProperty(lineFirstWord))) {
                  if (wordIsBlock(prevLineFirstWord)) {
                    indent = lineIndent <= prevLineIndent ? prevLineIndent : prevLineIndent + indentUnit;
                  } else if (/^\{/.test(prevLineFirstWord)) {
                    indent = lineIndent <= prevLineIndent ? lineIndent : prevLineIndent + indentUnit;
                  } else if (wordIsVendorPrefix(prevLineFirstWord) || wordIsProperty(prevLineFirstWord)) {
                    indent = lineIndent >= prevLineIndent ? prevLineIndent : lineIndent;
                  } else if (/^(\.|#|:|\[|\*|&|@|\+|\-|>|~|\/)/.test(prevLineFirstWord) || /=\s*$/.test(prevLineFirstWord) || wordIsTag(prevLineFirstWord) || /^\$[\w-\.\[\]\'\"]/.test(prevLineFirstWord)) {
                    indent = prevLineIndent + indentUnit;
                  } else {
                    indent = lineIndent;
                  }
                }
              }
              return indent;
            },
            electricChars: "}",
            blockCommentStart: "/*",
            blockCommentEnd: "*/",
            blockCommentContinue: " * ",
            lineComment: "//",
            fold: "indent"
          };
        });
        var tagKeywords_ = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "bgsound", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "nobr", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "var", "video"];
        var documentTypes_ = ["domain", "regexp", "url-prefix", "url"];
        var mediaTypes_ = ["all", "aural", "braille", "handheld", "print", "projection", "screen", "tty", "tv", "embossed"];
        var mediaFeatures_ = ["width", "min-width", "max-width", "height", "min-height", "max-height", "device-width", "min-device-width", "max-device-width", "device-height", "min-device-height", "max-device-height", "aspect-ratio", "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio", "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color", "max-color", "color-index", "min-color-index", "max-color-index", "monochrome", "min-monochrome", "max-monochrome", "resolution", "min-resolution", "max-resolution", "scan", "grid"];
        var propertyKeywords_ = ["align-content", "align-items", "align-self", "alignment-adjust", "alignment-baseline", "anchor-point", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "appearance", "azimuth", "backface-visibility", "background", "background-attachment", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "baseline-shift", "binding", "bleed", "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target", "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "clear", "clip", "color", "color-profile", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "content", "counter-increment", "counter-reset", "crop", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "dominant-baseline", "drop-initial-after-adjust", "drop-initial-after-align", "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size", "drop-initial-value", "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings", "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-weight", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-position", "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-start", "grid-row", "grid-row-end", "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "inline-box-align", "justify-content", "left", "letter-spacing", "line-break", "line-height", "line-stacking", "line-stacking-ruby", "line-stacking-shift", "line-stacking-strategy", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marker-offset", "marks", "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed", "marquee-style", "max-height", "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "object-fit", "object-position", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before", "page-break-inside", "page-policy", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pitch", "pitch-range", "play-during", "position", "presentation-level", "punctuation-trim", "quotes", "region-break-after", "region-break-before", "region-break-inside", "region-fragment", "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness", "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang", "ruby-position", "ruby-span", "shape-image-threshold", "shape-inside", "shape-margin", "shape-outside", "size", "speak", "speak-as", "speak-header", "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set", "tab-size", "table-layout", "target", "target-name", "target-new", "target-position", "text-align", "text-align-last", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-skip", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-height", "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow", "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position", "text-wrap", "top", "transform", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "unicode-bidi", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "volume", "white-space", "widows", "width", "will-change", "word-break", "word-spacing", "word-wrap", "z-index", "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color", "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events", "color-interpolation", "color-interpolation-filters", "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering", "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering", "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal", "glyph-orientation-vertical", "text-anchor", "writing-mode", "font-smoothing", "osx-font-smoothing"];
        var nonStandardPropertyKeywords_ = ["scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color", "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color", "scrollbar-3d-light-color", "scrollbar-track-color", "shape-inside", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "zoom"];
        var fontProperties_ = ["font-family", "src", "unicode-range", "font-variant", "font-feature-settings", "font-stretch", "font-weight", "font-style"];
        var colorKeywords_ = ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"];
        var valueKeywords_ = ["above", "absolute", "activeborder", "additive", "activecaption", "afar", "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate", "always", "amharic", "amharic-abegede", "antialiased", "appworkspace", "arabic-indic", "armenian", "asterisks", "attr", "auto", "avoid", "avoid-column", "avoid-page", "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary", "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box", "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "cambodian", "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle", "cjk-decimal", "cjk-earthly-branch", "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote", "col-resize", "collapse", "column", "compact", "condensed", "contain", "content", "contents", "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop", "cross", "crosshair", "currentcolor", "cursive", "cyclic", "dashed", "decimal", "decimal-leading-zero", "default", "default-button", "destination-atop", "destination-in", "destination-out", "destination-over", "devanagari", "disc", "discard", "disclosure-closed", "disclosure-open", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede", "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er", "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er", "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et", "ethiopic-halehame-gez", "ethiopic-halehame-om-et", "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et", "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig", "ethiopic-numeric", "ew-resize", "expanded", "extends", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "flex", "footnotes", "forwards", "from", "geometricPrecision", "georgian", "graytext", "groove", "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hebrew", "help", "hidden", "hide", "higher", "highlight", "highlighttext", "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "icon", "ignore", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-flex", "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "japanese-formal", "japanese-informal", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer", "korean-hangul-formal", "korean-hanja-formal", "korean-hanja-informal", "landscape", "lao", "large", "larger", "left", "level", "lighter", "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian", "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian", "lower-roman", "lowercase", "ltr", "malayalam", "match", "matrix", "matrix3d", "media-controls-background", "media-current-time-display", "media-fullscreen-button", "media-mute-button", "media-play-button", "media-return-to-realtime-button", "media-rewind-button", "media-seek-back-button", "media-seek-forward-button", "media-slider", "media-sliderthumb", "media-time-remaining-display", "media-volume-slider", "media-volume-slider-container", "media-volume-sliderthumb", "medium", "menu", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic", "mix", "mongolian", "monospace", "move", "multiple", "myanmar", "n-resize", "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap", "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "octal", "open-quote", "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset", "outside", "outside-shape", "overlay", "overline", "padding", "padding-box", "painted", "page", "paused", "persian", "perspective", "plus-darker", "plus-lighter", "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radial-gradient", "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region", "relative", "repeat", "repeating-linear-gradient", "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY", "rotateZ", "round", "row-resize", "rtl", "run-in", "running", "s-resize", "sans-serif", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "scroll", "scrollbar", "scroll-position", "se-resize", "searchfield", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama", "simp-chinese-formal", "simp-chinese-informal", "single", "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal", "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps", "small-caption", "smaller", "solid", "somali", "source-atop", "source-in", "source-out", "source-over", "space", "spell-out", "square", "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub", "subpixel-antialiased", "super", "sw-resize", "symbolic", "symbols", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "tamil", "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai", "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er", "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top", "trad-chinese-formal", "trad-chinese-informal", "translate", "translate3d", "translateX", "translateY", "translateZ", "transparent", "ultra-condensed", "ultra-expanded", "underline", "up", "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal", "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url", "var", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe", "windowtext", "words", "x-large", "x-small", "xor", "xx-large", "xx-small", "bicubic", "optimizespeed", "grayscale", "row", "row-reverse", "wrap", "wrap-reverse", "column-reverse", "flex-start", "flex-end", "space-between", "space-around", "unset"];
        var wordOperatorKeywords_ = ["in", "and", "or", "not", "is not", "is a", "is", "isnt", "defined", "if unless"], blockKeywords_ = ["for", "if", "else", "unless", "from", "to"], commonAtoms_ = ["null", "true", "false", "href", "title", "type", "not-allowed", "readonly", "disabled"], commonDef_ = ["@font-face", "@keyframes", "@media", "@viewport", "@page", "@host", "@supports", "@block", "@css"];
        var hintWords = tagKeywords_.concat(documentTypes_, mediaTypes_, mediaFeatures_, propertyKeywords_, nonStandardPropertyKeywords_, colorKeywords_, valueKeywords_, fontProperties_, wordOperatorKeywords_, blockKeywords_, commonAtoms_, commonDef_);
        function wordRegexp(words) {
          words = words.sort(function(a2, b2) {
            return b2 > a2;
          });
          return new RegExp("^((" + words.join(")|(") + "))\\b");
        }
        function keySet(array) {
          var keys = {};
          for (var i2 = 0; i2 < array.length; ++i2)
            keys[array[i2]] = true;
          return keys;
        }
        function escapeRegExp(text) {
          return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
        }
        CodeMirror3.registerHelper("hintWords", "stylus", hintWords);
        CodeMirror3.defineMIME("text/x-styl", "stylus");
      });
    }
  });

  // node_modules/codemirror/mode/pug/pug.js
  var require_pug = __commonJS({
    "node_modules/codemirror/mode/pug/pug.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror(), require_javascript(), require_css(), require_htmlmixed());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror", "../javascript/javascript", "../css/css", "../htmlmixed/htmlmixed"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.defineMode("pug", function(config) {
          var KEYWORD = "keyword";
          var DOCTYPE = "meta";
          var ID = "builtin";
          var CLASS = "qualifier";
          var ATTRS_NEST = {
            "{": "}",
            "(": ")",
            "[": "]"
          };
          var jsMode = CodeMirror3.getMode(config, "javascript");
          function State() {
            this.javaScriptLine = false;
            this.javaScriptLineExcludesColon = false;
            this.javaScriptArguments = false;
            this.javaScriptArgumentsDepth = 0;
            this.isInterpolating = false;
            this.interpolationNesting = 0;
            this.jsState = CodeMirror3.startState(jsMode);
            this.restOfLine = "";
            this.isIncludeFiltered = false;
            this.isEach = false;
            this.lastTag = "";
            this.scriptType = "";
            this.isAttrs = false;
            this.attrsNest = [];
            this.inAttributeName = true;
            this.attributeIsType = false;
            this.attrValue = "";
            this.indentOf = Infinity;
            this.indentToken = "";
            this.innerMode = null;
            this.innerState = null;
            this.innerModeForLine = false;
          }
          State.prototype.copy = function() {
            var res = new State();
            res.javaScriptLine = this.javaScriptLine;
            res.javaScriptLineExcludesColon = this.javaScriptLineExcludesColon;
            res.javaScriptArguments = this.javaScriptArguments;
            res.javaScriptArgumentsDepth = this.javaScriptArgumentsDepth;
            res.isInterpolating = this.isInterpolating;
            res.interpolationNesting = this.interpolationNesting;
            res.jsState = CodeMirror3.copyState(jsMode, this.jsState);
            res.innerMode = this.innerMode;
            if (this.innerMode && this.innerState) {
              res.innerState = CodeMirror3.copyState(this.innerMode, this.innerState);
            }
            res.restOfLine = this.restOfLine;
            res.isIncludeFiltered = this.isIncludeFiltered;
            res.isEach = this.isEach;
            res.lastTag = this.lastTag;
            res.scriptType = this.scriptType;
            res.isAttrs = this.isAttrs;
            res.attrsNest = this.attrsNest.slice();
            res.inAttributeName = this.inAttributeName;
            res.attributeIsType = this.attributeIsType;
            res.attrValue = this.attrValue;
            res.indentOf = this.indentOf;
            res.indentToken = this.indentToken;
            res.innerModeForLine = this.innerModeForLine;
            return res;
          };
          function javaScript(stream, state) {
            if (stream.sol()) {
              state.javaScriptLine = false;
              state.javaScriptLineExcludesColon = false;
            }
            if (state.javaScriptLine) {
              if (state.javaScriptLineExcludesColon && stream.peek() === ":") {
                state.javaScriptLine = false;
                state.javaScriptLineExcludesColon = false;
                return;
              }
              var tok = jsMode.token(stream, state.jsState);
              if (stream.eol())
                state.javaScriptLine = false;
              return tok || true;
            }
          }
          function javaScriptArguments(stream, state) {
            if (state.javaScriptArguments) {
              if (state.javaScriptArgumentsDepth === 0 && stream.peek() !== "(") {
                state.javaScriptArguments = false;
                return;
              }
              if (stream.peek() === "(") {
                state.javaScriptArgumentsDepth++;
              } else if (stream.peek() === ")") {
                state.javaScriptArgumentsDepth--;
              }
              if (state.javaScriptArgumentsDepth === 0) {
                state.javaScriptArguments = false;
                return;
              }
              var tok = jsMode.token(stream, state.jsState);
              return tok || true;
            }
          }
          function yieldStatement(stream) {
            if (stream.match(/^yield\b/)) {
              return "keyword";
            }
          }
          function doctype(stream) {
            if (stream.match(/^(?:doctype) *([^\n]+)?/)) {
              return DOCTYPE;
            }
          }
          function interpolation(stream, state) {
            if (stream.match("#{")) {
              state.isInterpolating = true;
              state.interpolationNesting = 0;
              return "punctuation";
            }
          }
          function interpolationContinued(stream, state) {
            if (state.isInterpolating) {
              if (stream.peek() === "}") {
                state.interpolationNesting--;
                if (state.interpolationNesting < 0) {
                  stream.next();
                  state.isInterpolating = false;
                  return "punctuation";
                }
              } else if (stream.peek() === "{") {
                state.interpolationNesting++;
              }
              return jsMode.token(stream, state.jsState) || true;
            }
          }
          function caseStatement(stream, state) {
            if (stream.match(/^case\b/)) {
              state.javaScriptLine = true;
              return KEYWORD;
            }
          }
          function when(stream, state) {
            if (stream.match(/^when\b/)) {
              state.javaScriptLine = true;
              state.javaScriptLineExcludesColon = true;
              return KEYWORD;
            }
          }
          function defaultStatement(stream) {
            if (stream.match(/^default\b/)) {
              return KEYWORD;
            }
          }
          function extendsStatement(stream, state) {
            if (stream.match(/^extends?\b/)) {
              state.restOfLine = "string";
              return KEYWORD;
            }
          }
          function append(stream, state) {
            if (stream.match(/^append\b/)) {
              state.restOfLine = "variable";
              return KEYWORD;
            }
          }
          function prepend(stream, state) {
            if (stream.match(/^prepend\b/)) {
              state.restOfLine = "variable";
              return KEYWORD;
            }
          }
          function block(stream, state) {
            if (stream.match(/^block\b *(?:(prepend|append)\b)?/)) {
              state.restOfLine = "variable";
              return KEYWORD;
            }
          }
          function include(stream, state) {
            if (stream.match(/^include\b/)) {
              state.restOfLine = "string";
              return KEYWORD;
            }
          }
          function includeFiltered(stream, state) {
            if (stream.match(/^include:([a-zA-Z0-9\-]+)/, false) && stream.match("include")) {
              state.isIncludeFiltered = true;
              return KEYWORD;
            }
          }
          function includeFilteredContinued(stream, state) {
            if (state.isIncludeFiltered) {
              var tok = filter2(stream, state);
              state.isIncludeFiltered = false;
              state.restOfLine = "string";
              return tok;
            }
          }
          function mixin(stream, state) {
            if (stream.match(/^mixin\b/)) {
              state.javaScriptLine = true;
              return KEYWORD;
            }
          }
          function call(stream, state) {
            if (stream.match(/^\+([-\w]+)/)) {
              if (!stream.match(/^\( *[-\w]+ *=/, false)) {
                state.javaScriptArguments = true;
                state.javaScriptArgumentsDepth = 0;
              }
              return "variable";
            }
            if (stream.match("+#{", false)) {
              stream.next();
              state.mixinCallAfter = true;
              return interpolation(stream, state);
            }
          }
          function callArguments(stream, state) {
            if (state.mixinCallAfter) {
              state.mixinCallAfter = false;
              if (!stream.match(/^\( *[-\w]+ *=/, false)) {
                state.javaScriptArguments = true;
                state.javaScriptArgumentsDepth = 0;
              }
              return true;
            }
          }
          function conditional(stream, state) {
            if (stream.match(/^(if|unless|else if|else)\b/)) {
              state.javaScriptLine = true;
              return KEYWORD;
            }
          }
          function each(stream, state) {
            if (stream.match(/^(- *)?(each|for)\b/)) {
              state.isEach = true;
              return KEYWORD;
            }
          }
          function eachContinued(stream, state) {
            if (state.isEach) {
              if (stream.match(/^ in\b/)) {
                state.javaScriptLine = true;
                state.isEach = false;
                return KEYWORD;
              } else if (stream.sol() || stream.eol()) {
                state.isEach = false;
              } else if (stream.next()) {
                while (!stream.match(/^ in\b/, false) && stream.next())
                  ;
                return "variable";
              }
            }
          }
          function whileStatement(stream, state) {
            if (stream.match(/^while\b/)) {
              state.javaScriptLine = true;
              return KEYWORD;
            }
          }
          function tag(stream, state) {
            var captures;
            if (captures = stream.match(/^(\w(?:[-:\w]*\w)?)\/?/)) {
              state.lastTag = captures[1].toLowerCase();
              if (state.lastTag === "script") {
                state.scriptType = "application/javascript";
              }
              return "tag";
            }
          }
          function filter2(stream, state) {
            if (stream.match(/^:([\w\-]+)/)) {
              var innerMode2;
              if (config && config.innerModes) {
                innerMode2 = config.innerModes(stream.current().substring(1));
              }
              if (!innerMode2) {
                innerMode2 = stream.current().substring(1);
              }
              if (typeof innerMode2 === "string") {
                innerMode2 = CodeMirror3.getMode(config, innerMode2);
              }
              setInnerMode(stream, state, innerMode2);
              return "atom";
            }
          }
          function code3(stream, state) {
            if (stream.match(/^(!?=|-)/)) {
              state.javaScriptLine = true;
              return "punctuation";
            }
          }
          function id(stream) {
            if (stream.match(/^#([\w-]+)/)) {
              return ID;
            }
          }
          function className(stream) {
            if (stream.match(/^\.([\w-]+)/)) {
              return CLASS;
            }
          }
          function attrs(stream, state) {
            if (stream.peek() == "(") {
              stream.next();
              state.isAttrs = true;
              state.attrsNest = [];
              state.inAttributeName = true;
              state.attrValue = "";
              state.attributeIsType = false;
              return "punctuation";
            }
          }
          function attrsContinued(stream, state) {
            if (state.isAttrs) {
              if (ATTRS_NEST[stream.peek()]) {
                state.attrsNest.push(ATTRS_NEST[stream.peek()]);
              }
              if (state.attrsNest[state.attrsNest.length - 1] === stream.peek()) {
                state.attrsNest.pop();
              } else if (stream.eat(")")) {
                state.isAttrs = false;
                return "punctuation";
              }
              if (state.inAttributeName && stream.match(/^[^=,\)!]+/)) {
                if (stream.peek() === "=" || stream.peek() === "!") {
                  state.inAttributeName = false;
                  state.jsState = CodeMirror3.startState(jsMode);
                  if (state.lastTag === "script" && stream.current().trim().toLowerCase() === "type") {
                    state.attributeIsType = true;
                  } else {
                    state.attributeIsType = false;
                  }
                }
                return "attribute";
              }
              var tok = jsMode.token(stream, state.jsState);
              if (state.attributeIsType && tok === "string") {
                state.scriptType = stream.current().toString();
              }
              if (state.attrsNest.length === 0 && (tok === "string" || tok === "variable" || tok === "keyword")) {
                try {
                  Function("", "var x " + state.attrValue.replace(/,\s*$/, "").replace(/^!/, ""));
                  state.inAttributeName = true;
                  state.attrValue = "";
                  stream.backUp(stream.current().length);
                  return attrsContinued(stream, state);
                } catch (ex) {
                }
              }
              state.attrValue += stream.current();
              return tok || true;
            }
          }
          function attributesBlock(stream, state) {
            if (stream.match(/^&attributes\b/)) {
              state.javaScriptArguments = true;
              state.javaScriptArgumentsDepth = 0;
              return "keyword";
            }
          }
          function indent(stream) {
            if (stream.sol() && stream.eatSpace()) {
              return "indent";
            }
          }
          function comment(stream, state) {
            if (stream.match(/^ *\/\/(-)?([^\n]*)/)) {
              state.indentOf = stream.indentation();
              state.indentToken = "comment";
              return "comment";
            }
          }
          function colon(stream) {
            if (stream.match(/^: */)) {
              return "colon";
            }
          }
          function text(stream, state) {
            if (stream.match(/^(?:\| ?| )([^\n]+)/)) {
              return "string";
            }
            if (stream.match(/^(<[^\n]*)/, false)) {
              setInnerMode(stream, state, "htmlmixed");
              state.innerModeForLine = true;
              return innerMode(stream, state, true);
            }
          }
          function dot(stream, state) {
            if (stream.eat(".")) {
              var innerMode2 = null;
              if (state.lastTag === "script" && state.scriptType.toLowerCase().indexOf("javascript") != -1) {
                innerMode2 = state.scriptType.toLowerCase().replace(/"|'/g, "");
              } else if (state.lastTag === "style") {
                innerMode2 = "css";
              }
              setInnerMode(stream, state, innerMode2);
              return "dot";
            }
          }
          function fail(stream) {
            stream.next();
            return null;
          }
          function setInnerMode(stream, state, mode) {
            mode = CodeMirror3.mimeModes[mode] || mode;
            mode = config.innerModes ? config.innerModes(mode) || mode : mode;
            mode = CodeMirror3.mimeModes[mode] || mode;
            mode = CodeMirror3.getMode(config, mode);
            state.indentOf = stream.indentation();
            if (mode && mode.name !== "null") {
              state.innerMode = mode;
            } else {
              state.indentToken = "string";
            }
          }
          function innerMode(stream, state, force) {
            if (stream.indentation() > state.indentOf || state.innerModeForLine && !stream.sol() || force) {
              if (state.innerMode) {
                if (!state.innerState) {
                  state.innerState = state.innerMode.startState ? CodeMirror3.startState(state.innerMode, stream.indentation()) : {};
                }
                return stream.hideFirstChars(state.indentOf + 2, function() {
                  return state.innerMode.token(stream, state.innerState) || true;
                });
              } else {
                stream.skipToEnd();
                return state.indentToken;
              }
            } else if (stream.sol()) {
              state.indentOf = Infinity;
              state.indentToken = null;
              state.innerMode = null;
              state.innerState = null;
            }
          }
          function restOfLine(stream, state) {
            if (stream.sol()) {
              state.restOfLine = "";
            }
            if (state.restOfLine) {
              stream.skipToEnd();
              var tok = state.restOfLine;
              state.restOfLine = "";
              return tok;
            }
          }
          function startState() {
            return new State();
          }
          function copyState(state) {
            return state.copy();
          }
          function nextToken(stream, state) {
            var tok = innerMode(stream, state) || restOfLine(stream, state) || interpolationContinued(stream, state) || includeFilteredContinued(stream, state) || eachContinued(stream, state) || attrsContinued(stream, state) || javaScript(stream, state) || javaScriptArguments(stream, state) || callArguments(stream, state) || yieldStatement(stream) || doctype(stream) || interpolation(stream, state) || caseStatement(stream, state) || when(stream, state) || defaultStatement(stream) || extendsStatement(stream, state) || append(stream, state) || prepend(stream, state) || block(stream, state) || include(stream, state) || includeFiltered(stream, state) || mixin(stream, state) || call(stream, state) || conditional(stream, state) || each(stream, state) || whileStatement(stream, state) || tag(stream, state) || filter2(stream, state) || code3(stream, state) || id(stream) || className(stream) || attrs(stream, state) || attributesBlock(stream, state) || indent(stream) || text(stream, state) || comment(stream, state) || colon(stream) || dot(stream, state) || fail(stream);
            return tok === true ? null : tok;
          }
          return {
            startState,
            copyState,
            token: nextToken
          };
        }, "javascript", "css", "htmlmixed");
        CodeMirror3.defineMIME("text/x-pug", "pug");
        CodeMirror3.defineMIME("text/x-jade", "pug");
      });
    }
  });

  // node_modules/codemirror/addon/mode/multiplex.js
  var require_multiplex = __commonJS({
    "node_modules/codemirror/addon/mode/multiplex.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.multiplexingMode = function(outer) {
          var others = Array.prototype.slice.call(arguments, 1);
          function indexOf2(string, pattern, from, returnEnd) {
            if (typeof pattern == "string") {
              var found = string.indexOf(pattern, from);
              return returnEnd && found > -1 ? found + pattern.length : found;
            }
            var m2 = pattern.exec(from ? string.slice(from) : string);
            return m2 ? m2.index + from + (returnEnd ? m2[0].length : 0) : -1;
          }
          return {
            startState: function() {
              return {
                outer: CodeMirror3.startState(outer),
                innerActive: null,
                inner: null
              };
            },
            copyState: function(state) {
              return {
                outer: CodeMirror3.copyState(outer, state.outer),
                innerActive: state.innerActive,
                inner: state.innerActive && CodeMirror3.copyState(state.innerActive.mode, state.inner)
              };
            },
            token: function(stream, state) {
              if (!state.innerActive) {
                var cutOff = Infinity, oldContent = stream.string;
                for (var i2 = 0; i2 < others.length; ++i2) {
                  var other = others[i2];
                  var found = indexOf2(oldContent, other.open, stream.pos);
                  if (found == stream.pos) {
                    if (!other.parseDelimiters)
                      stream.match(other.open);
                    state.innerActive = other;
                    var outerIndent = 0;
                    if (outer.indent) {
                      var possibleOuterIndent = outer.indent(state.outer, "", "");
                      if (possibleOuterIndent !== CodeMirror3.Pass)
                        outerIndent = possibleOuterIndent;
                    }
                    state.inner = CodeMirror3.startState(other.mode, outerIndent);
                    return other.delimStyle && other.delimStyle + " " + other.delimStyle + "-open";
                  } else if (found != -1 && found < cutOff) {
                    cutOff = found;
                  }
                }
                if (cutOff != Infinity)
                  stream.string = oldContent.slice(0, cutOff);
                var outerToken = outer.token(stream, state.outer);
                if (cutOff != Infinity)
                  stream.string = oldContent;
                return outerToken;
              } else {
                var curInner = state.innerActive, oldContent = stream.string;
                if (!curInner.close && stream.sol()) {
                  state.innerActive = state.inner = null;
                  return this.token(stream, state);
                }
                var found = curInner.close ? indexOf2(oldContent, curInner.close, stream.pos, curInner.parseDelimiters) : -1;
                if (found == stream.pos && !curInner.parseDelimiters) {
                  stream.match(curInner.close);
                  state.innerActive = state.inner = null;
                  return curInner.delimStyle && curInner.delimStyle + " " + curInner.delimStyle + "-close";
                }
                if (found > -1)
                  stream.string = oldContent.slice(0, found);
                var innerToken = curInner.mode.token(stream, state.inner);
                if (found > -1)
                  stream.string = oldContent;
                if (found == stream.pos && curInner.parseDelimiters)
                  state.innerActive = state.inner = null;
                if (curInner.innerStyle) {
                  if (innerToken)
                    innerToken = innerToken + " " + curInner.innerStyle;
                  else
                    innerToken = curInner.innerStyle;
                }
                return innerToken;
              }
            },
            indent: function(state, textAfter, line) {
              var mode = state.innerActive ? state.innerActive.mode : outer;
              if (!mode.indent)
                return CodeMirror3.Pass;
              return mode.indent(state.innerActive ? state.inner : state.outer, textAfter, line);
            },
            blankLine: function(state) {
              var mode = state.innerActive ? state.innerActive.mode : outer;
              if (mode.blankLine) {
                mode.blankLine(state.innerActive ? state.inner : state.outer);
              }
              if (!state.innerActive) {
                for (var i2 = 0; i2 < others.length; ++i2) {
                  var other = others[i2];
                  if (other.open === "\n") {
                    state.innerActive = other;
                    state.inner = CodeMirror3.startState(other.mode, mode.indent ? mode.indent(state.outer, "", "") : 0);
                  }
                }
              } else if (state.innerActive.close === "\n") {
                state.innerActive = state.inner = null;
              }
            },
            electricChars: outer.electricChars,
            innerMode: function(state) {
              return state.inner ? { state: state.inner, mode: state.innerActive.mode } : { state: state.outer, mode: outer };
            }
          };
        };
      });
    }
  });

  // node_modules/codemirror/mode/handlebars/handlebars.js
  var require_handlebars = __commonJS({
    "node_modules/codemirror/mode/handlebars/handlebars.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror(), require_simple(), require_multiplex());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror", "../../addon/mode/simple", "../../addon/mode/multiplex"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.defineSimpleMode("handlebars-tags", {
          start: [
            { regex: /\{\{\{/, push: "handlebars_raw", token: "tag" },
            { regex: /\{\{!--/, push: "dash_comment", token: "comment" },
            { regex: /\{\{!/, push: "comment", token: "comment" },
            { regex: /\{\{/, push: "handlebars", token: "tag" }
          ],
          handlebars_raw: [
            { regex: /\}\}\}/, pop: true, token: "tag" }
          ],
          handlebars: [
            { regex: /\}\}/, pop: true, token: "tag" },
            { regex: /"(?:[^\\"]|\\.)*"?/, token: "string" },
            { regex: /'(?:[^\\']|\\.)*'?/, token: "string" },
            { regex: />|[#\/]([A-Za-z_]\w*)/, token: "keyword" },
            { regex: /(?:else|this)\b/, token: "keyword" },
            { regex: /\d+/i, token: "number" },
            { regex: /=|~|@|true|false/, token: "atom" },
            { regex: /(?:\.\.\/)*(?:[A-Za-z_][\w\.]*)+/, token: "variable-2" }
          ],
          dash_comment: [
            { regex: /--\}\}/, pop: true, token: "comment" },
            { regex: /./, token: "comment" }
          ],
          comment: [
            { regex: /\}\}/, pop: true, token: "comment" },
            { regex: /./, token: "comment" }
          ],
          meta: {
            blockCommentStart: "{{--",
            blockCommentEnd: "--}}"
          }
        });
        CodeMirror3.defineMode("handlebars", function(config, parserConfig) {
          var handlebars = CodeMirror3.getMode(config, "handlebars-tags");
          if (!parserConfig || !parserConfig.base)
            return handlebars;
          return CodeMirror3.multiplexingMode(CodeMirror3.getMode(config, parserConfig.base), { open: "{{", close: /\}\}\}?/, mode: handlebars, parseDelimiters: true });
        });
        CodeMirror3.defineMIME("text/x-handlebars-template", "handlebars");
      });
    }
  });

  // node_modules/codemirror/mode/vue/vue.js
  var require_vue = __commonJS({
    "node_modules/codemirror/mode/vue/vue.js"(exports, module) {
      (function(mod) {
        "use strict";
        if (typeof exports === "object" && typeof module === "object") {
          mod(require_codemirror(), require_overlay(), require_xml(), require_javascript(), require_coffeescript(), require_css(), require_sass(), require_stylus(), require_pug(), require_handlebars());
        } else if (typeof define === "function" && define.amd) {
          define([
            "../../lib/codemirror",
            "../../addon/mode/overlay",
            "../xml/xml",
            "../javascript/javascript",
            "../coffeescript/coffeescript",
            "../css/css",
            "../sass/sass",
            "../stylus/stylus",
            "../pug/pug",
            "../handlebars/handlebars"
          ], mod);
        } else {
          mod(CodeMirror);
        }
      })(function(CodeMirror3) {
        var tagLanguages = {
          script: [
            ["lang", /coffee(script)?/, "coffeescript"],
            ["type", /^(?:text|application)\/(?:x-)?coffee(?:script)?$/, "coffeescript"],
            ["lang", /^babel$/, "javascript"],
            ["type", /^text\/babel$/, "javascript"],
            ["type", /^text\/ecmascript-\d+$/, "javascript"]
          ],
          style: [
            ["lang", /^stylus$/i, "stylus"],
            ["lang", /^sass$/i, "sass"],
            ["lang", /^less$/i, "text/x-less"],
            ["lang", /^scss$/i, "text/x-scss"],
            ["type", /^(text\/)?(x-)?styl(us)?$/i, "stylus"],
            ["type", /^text\/sass/i, "sass"],
            ["type", /^(text\/)?(x-)?scss$/i, "text/x-scss"],
            ["type", /^(text\/)?(x-)?less$/i, "text/x-less"]
          ],
          template: [
            ["lang", /^vue-template$/i, "vue"],
            ["lang", /^pug$/i, "pug"],
            ["lang", /^handlebars$/i, "handlebars"],
            ["type", /^(text\/)?(x-)?pug$/i, "pug"],
            ["type", /^text\/x-handlebars-template$/i, "handlebars"],
            [null, null, "vue-template"]
          ]
        };
        CodeMirror3.defineMode("vue-template", function(config, parserConfig) {
          var mustacheOverlay = {
            token: function(stream) {
              if (stream.match(/^\{\{.*?\}\}/))
                return "meta mustache";
              while (stream.next() && !stream.match("{{", false)) {
              }
              return null;
            }
          };
          return CodeMirror3.overlayMode(CodeMirror3.getMode(config, parserConfig.backdrop || "text/html"), mustacheOverlay);
        });
        CodeMirror3.defineMode("vue", function(config) {
          return CodeMirror3.getMode(config, { name: "htmlmixed", tags: tagLanguages });
        }, "htmlmixed", "xml", "javascript", "coffeescript", "css", "sass", "stylus", "pug", "handlebars");
        CodeMirror3.defineMIME("script/x-vue", "vue");
        CodeMirror3.defineMIME("text/x-vue", "vue");
      });
    }
  });

  // node_modules/codemirror/mode/yaml/yaml.js
  var require_yaml = __commonJS({
    "node_modules/codemirror/mode/yaml/yaml.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.defineMode("yaml", function() {
          var cons = ["true", "false", "on", "off", "yes", "no"];
          var keywordRegex = new RegExp("\\b((" + cons.join(")|(") + "))$", "i");
          return {
            token: function(stream, state) {
              var ch = stream.peek();
              var esc = state.escaped;
              state.escaped = false;
              if (ch == "#" && (stream.pos == 0 || /\s/.test(stream.string.charAt(stream.pos - 1)))) {
                stream.skipToEnd();
                return "comment";
              }
              if (stream.match(/^('([^']|\\.)*'?|"([^"]|\\.)*"?)/))
                return "string";
              if (state.literal && stream.indentation() > state.keyCol) {
                stream.skipToEnd();
                return "string";
              } else if (state.literal) {
                state.literal = false;
              }
              if (stream.sol()) {
                state.keyCol = 0;
                state.pair = false;
                state.pairStart = false;
                if (stream.match("---")) {
                  return "def";
                }
                if (stream.match("...")) {
                  return "def";
                }
                if (stream.match(/\s*-\s+/)) {
                  return "meta";
                }
              }
              if (stream.match(/^(\{|\}|\[|\])/)) {
                if (ch == "{")
                  state.inlinePairs++;
                else if (ch == "}")
                  state.inlinePairs--;
                else if (ch == "[")
                  state.inlineList++;
                else
                  state.inlineList--;
                return "meta";
              }
              if (state.inlineList > 0 && !esc && ch == ",") {
                stream.next();
                return "meta";
              }
              if (state.inlinePairs > 0 && !esc && ch == ",") {
                state.keyCol = 0;
                state.pair = false;
                state.pairStart = false;
                stream.next();
                return "meta";
              }
              if (state.pairStart) {
                if (stream.match(/^\s*(\||\>)\s*/)) {
                  state.literal = true;
                  return "meta";
                }
                ;
                if (stream.match(/^\s*(\&|\*)[a-z0-9\._-]+\b/i)) {
                  return "variable-2";
                }
                if (state.inlinePairs == 0 && stream.match(/^\s*-?[0-9\.\,]+\s?$/)) {
                  return "number";
                }
                if (state.inlinePairs > 0 && stream.match(/^\s*-?[0-9\.\,]+\s?(?=(,|}))/)) {
                  return "number";
                }
                if (stream.match(keywordRegex)) {
                  return "keyword";
                }
              }
              if (!state.pair && stream.match(/^\s*(?:[,\[\]{}&*!|>'"%@`][^\s'":]|[^,\[\]{}#&*!|>'"%@`])[^#]*?(?=\s*:($|\s))/)) {
                state.pair = true;
                state.keyCol = stream.indentation();
                return "atom";
              }
              if (state.pair && stream.match(/^:\s*/)) {
                state.pairStart = true;
                return "meta";
              }
              state.pairStart = false;
              state.escaped = ch == "\\";
              stream.next();
              return null;
            },
            startState: function() {
              return {
                pair: false,
                pairStart: false,
                keyCol: 0,
                inlinePairs: 0,
                inlineList: 0,
                literal: false,
                escaped: false
              };
            },
            lineComment: "#",
            fold: "indent"
          };
        });
        CodeMirror3.defineMIME("text/x-yaml", "yaml");
        CodeMirror3.defineMIME("text/yaml", "yaml");
      });
    }
  });

  // node_modules/luxon/build/cjs-browser/luxon.js
  var require_luxon = __commonJS({
    "node_modules/luxon/build/cjs-browser/luxon.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      function _getPrototypeOf(o2) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
          return o3.__proto__ || Object.getPrototypeOf(o3);
        };
        return _getPrototypeOf(o2);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
          o3.__proto__ = p3;
          return o3;
        };
        return _setPrototypeOf(o2, p2);
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e2) {
          return false;
        }
      }
      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct;
        } else {
          _construct = function _construct2(Parent2, args2, Class2) {
            var a2 = [null];
            a2.push.apply(a2, args2);
            var Constructor = Function.bind.apply(Parent2, a2);
            var instance = new Constructor();
            if (Class2)
              _setPrototypeOf(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _isNativeFunction(fn2) {
        return Function.toString.call(fn2).indexOf("[native code]") !== -1;
      }
      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
        _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
          if (Class2 === null || !_isNativeFunction(Class2))
            return Class2;
          if (typeof Class2 !== "function") {
            throw new TypeError("Super expression must either be null or a function");
          }
          if (typeof _cache !== "undefined") {
            if (_cache.has(Class2))
              return _cache.get(Class2);
            _cache.set(Class2, Wrapper);
          }
          function Wrapper() {
            return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
          }
          Wrapper.prototype = Object.create(Class2.prototype, {
            constructor: {
              value: Wrapper,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          return _setPrototypeOf(Wrapper, Class2);
        };
        return _wrapNativeSuper(Class);
      }
      function _objectWithoutPropertiesLoose7(source, excluded) {
        if (source == null)
          return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i2;
        for (i2 = 0; i2 < sourceKeys.length; i2++) {
          key = sourceKeys[i2];
          if (excluded.indexOf(key) >= 0)
            continue;
          target[key] = source[key];
        }
        return target;
      }
      function _unsupportedIterableToArray11(o2, minLen) {
        if (!o2)
          return;
        if (typeof o2 === "string")
          return _arrayLikeToArray11(o2, minLen);
        var n3 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n3 === "Object" && o2.constructor)
          n3 = o2.constructor.name;
        if (n3 === "Map" || n3 === "Set")
          return Array.from(n3);
        if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
          return _arrayLikeToArray11(o2, minLen);
      }
      function _arrayLikeToArray11(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
          arr2[i2] = arr[i2];
        return arr2;
      }
      function _createForOfIteratorHelperLoose(o2) {
        var i2 = 0;
        if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
          if (Array.isArray(o2) || (o2 = _unsupportedIterableToArray11(o2)))
            return function() {
              if (i2 >= o2.length)
                return {
                  done: true
                };
              return {
                done: false,
                value: o2[i2++]
              };
            };
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        i2 = o2[Symbol.iterator]();
        return i2.next.bind(i2);
      }
      var LuxonError = /* @__PURE__ */ function(_Error) {
        _inheritsLoose(LuxonError2, _Error);
        function LuxonError2() {
          return _Error.apply(this, arguments) || this;
        }
        return LuxonError2;
      }(/* @__PURE__ */ _wrapNativeSuper(Error));
      var InvalidDateTimeError = /* @__PURE__ */ function(_LuxonError) {
        _inheritsLoose(InvalidDateTimeError2, _LuxonError);
        function InvalidDateTimeError2(reason) {
          return _LuxonError.call(this, "Invalid DateTime: " + reason.toMessage()) || this;
        }
        return InvalidDateTimeError2;
      }(LuxonError);
      var InvalidIntervalError = /* @__PURE__ */ function(_LuxonError2) {
        _inheritsLoose(InvalidIntervalError2, _LuxonError2);
        function InvalidIntervalError2(reason) {
          return _LuxonError2.call(this, "Invalid Interval: " + reason.toMessage()) || this;
        }
        return InvalidIntervalError2;
      }(LuxonError);
      var InvalidDurationError = /* @__PURE__ */ function(_LuxonError3) {
        _inheritsLoose(InvalidDurationError2, _LuxonError3);
        function InvalidDurationError2(reason) {
          return _LuxonError3.call(this, "Invalid Duration: " + reason.toMessage()) || this;
        }
        return InvalidDurationError2;
      }(LuxonError);
      var ConflictingSpecificationError = /* @__PURE__ */ function(_LuxonError4) {
        _inheritsLoose(ConflictingSpecificationError2, _LuxonError4);
        function ConflictingSpecificationError2() {
          return _LuxonError4.apply(this, arguments) || this;
        }
        return ConflictingSpecificationError2;
      }(LuxonError);
      var InvalidUnitError = /* @__PURE__ */ function(_LuxonError5) {
        _inheritsLoose(InvalidUnitError2, _LuxonError5);
        function InvalidUnitError2(unit) {
          return _LuxonError5.call(this, "Invalid unit " + unit) || this;
        }
        return InvalidUnitError2;
      }(LuxonError);
      var InvalidArgumentError = /* @__PURE__ */ function(_LuxonError6) {
        _inheritsLoose(InvalidArgumentError2, _LuxonError6);
        function InvalidArgumentError2() {
          return _LuxonError6.apply(this, arguments) || this;
        }
        return InvalidArgumentError2;
      }(LuxonError);
      var ZoneIsAbstractError = /* @__PURE__ */ function(_LuxonError7) {
        _inheritsLoose(ZoneIsAbstractError2, _LuxonError7);
        function ZoneIsAbstractError2() {
          return _LuxonError7.call(this, "Zone is an abstract class") || this;
        }
        return ZoneIsAbstractError2;
      }(LuxonError);
      var n2 = "numeric";
      var s2 = "short";
      var l2 = "long";
      var DATE_SHORT = {
        year: n2,
        month: n2,
        day: n2
      };
      var DATE_MED = {
        year: n2,
        month: s2,
        day: n2
      };
      var DATE_MED_WITH_WEEKDAY = {
        year: n2,
        month: s2,
        day: n2,
        weekday: s2
      };
      var DATE_FULL = {
        year: n2,
        month: l2,
        day: n2
      };
      var DATE_HUGE = {
        year: n2,
        month: l2,
        day: n2,
        weekday: l2
      };
      var TIME_SIMPLE = {
        hour: n2,
        minute: n2
      };
      var TIME_WITH_SECONDS = {
        hour: n2,
        minute: n2,
        second: n2
      };
      var TIME_WITH_SHORT_OFFSET = {
        hour: n2,
        minute: n2,
        second: n2,
        timeZoneName: s2
      };
      var TIME_WITH_LONG_OFFSET = {
        hour: n2,
        minute: n2,
        second: n2,
        timeZoneName: l2
      };
      var TIME_24_SIMPLE = {
        hour: n2,
        minute: n2,
        hour12: false
      };
      var TIME_24_WITH_SECONDS = {
        hour: n2,
        minute: n2,
        second: n2,
        hour12: false
      };
      var TIME_24_WITH_SHORT_OFFSET = {
        hour: n2,
        minute: n2,
        second: n2,
        hour12: false,
        timeZoneName: s2
      };
      var TIME_24_WITH_LONG_OFFSET = {
        hour: n2,
        minute: n2,
        second: n2,
        hour12: false,
        timeZoneName: l2
      };
      var DATETIME_SHORT = {
        year: n2,
        month: n2,
        day: n2,
        hour: n2,
        minute: n2
      };
      var DATETIME_SHORT_WITH_SECONDS = {
        year: n2,
        month: n2,
        day: n2,
        hour: n2,
        minute: n2,
        second: n2
      };
      var DATETIME_MED = {
        year: n2,
        month: s2,
        day: n2,
        hour: n2,
        minute: n2
      };
      var DATETIME_MED_WITH_SECONDS = {
        year: n2,
        month: s2,
        day: n2,
        hour: n2,
        minute: n2,
        second: n2
      };
      var DATETIME_MED_WITH_WEEKDAY = {
        year: n2,
        month: s2,
        day: n2,
        weekday: s2,
        hour: n2,
        minute: n2
      };
      var DATETIME_FULL = {
        year: n2,
        month: l2,
        day: n2,
        hour: n2,
        minute: n2,
        timeZoneName: s2
      };
      var DATETIME_FULL_WITH_SECONDS = {
        year: n2,
        month: l2,
        day: n2,
        hour: n2,
        minute: n2,
        second: n2,
        timeZoneName: s2
      };
      var DATETIME_HUGE = {
        year: n2,
        month: l2,
        day: n2,
        weekday: l2,
        hour: n2,
        minute: n2,
        timeZoneName: l2
      };
      var DATETIME_HUGE_WITH_SECONDS = {
        year: n2,
        month: l2,
        day: n2,
        weekday: l2,
        hour: n2,
        minute: n2,
        second: n2,
        timeZoneName: l2
      };
      function isUndefined(o2) {
        return typeof o2 === "undefined";
      }
      function isNumber(o2) {
        return typeof o2 === "number";
      }
      function isInteger(o2) {
        return typeof o2 === "number" && o2 % 1 === 0;
      }
      function isString(o2) {
        return typeof o2 === "string";
      }
      function isDate(o2) {
        return Object.prototype.toString.call(o2) === "[object Date]";
      }
      function hasIntl() {
        try {
          return typeof Intl !== "undefined" && Intl.DateTimeFormat;
        } catch (e2) {
          return false;
        }
      }
      function hasFormatToParts() {
        return !isUndefined(Intl.DateTimeFormat.prototype.formatToParts);
      }
      function hasRelative() {
        try {
          return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
        } catch (e2) {
          return false;
        }
      }
      function maybeArray(thing) {
        return Array.isArray(thing) ? thing : [thing];
      }
      function bestBy(arr, by, compare) {
        if (arr.length === 0) {
          return void 0;
        }
        return arr.reduce(function(best, next) {
          var pair = [by(next), next];
          if (!best) {
            return pair;
          } else if (compare(best[0], pair[0]) === best[0]) {
            return best;
          } else {
            return pair;
          }
        }, null)[1];
      }
      function pick(obj, keys) {
        return keys.reduce(function(a2, k2) {
          a2[k2] = obj[k2];
          return a2;
        }, {});
      }
      function hasOwnProperty2(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      function integerBetween(thing, bottom2, top2) {
        return isInteger(thing) && thing >= bottom2 && thing <= top2;
      }
      function floorMod(x2, n3) {
        return x2 - n3 * Math.floor(x2 / n3);
      }
      function padStart(input, n3) {
        if (n3 === void 0) {
          n3 = 2;
        }
        var minus = input < 0 ? "-" : "";
        var target = minus ? input * -1 : input;
        var result;
        if (target.toString().length < n3) {
          result = ("0".repeat(n3) + target).slice(-n3);
        } else {
          result = target.toString();
        }
        return "" + minus + result;
      }
      function parseInteger(string) {
        if (isUndefined(string) || string === null || string === "") {
          return void 0;
        } else {
          return parseInt(string, 10);
        }
      }
      function parseMillis(fraction) {
        if (isUndefined(fraction) || fraction === null || fraction === "") {
          return void 0;
        } else {
          var f2 = parseFloat("0." + fraction) * 1e3;
          return Math.floor(f2);
        }
      }
      function roundTo(number, digits, towardZero) {
        if (towardZero === void 0) {
          towardZero = false;
        }
        var factor = Math.pow(10, digits), rounder = towardZero ? Math.trunc : Math.round;
        return rounder(number * factor) / factor;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
      }
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      function daysInMonth(year, month) {
        var modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
        if (modMonth === 2) {
          return isLeapYear(modYear) ? 29 : 28;
        } else {
          return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
        }
      }
      function objToLocalTS(obj) {
        var d2 = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond);
        if (obj.year < 100 && obj.year >= 0) {
          d2 = new Date(d2);
          d2.setUTCFullYear(d2.getUTCFullYear() - 1900);
        }
        return +d2;
      }
      function weeksInWeekYear(weekYear) {
        var p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
        return p1 === 4 || p2 === 3 ? 53 : 52;
      }
      function untruncateYear(year) {
        if (year > 99) {
          return year;
        } else
          return year > 60 ? 1900 + year : 2e3 + year;
      }
      function parseZoneInfo(ts, offsetFormat, locale, timeZone) {
        if (timeZone === void 0) {
          timeZone = null;
        }
        var date = new Date(ts), intlOpts = {
          hour12: false,
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit"
        };
        if (timeZone) {
          intlOpts.timeZone = timeZone;
        }
        var modified = Object.assign({
          timeZoneName: offsetFormat
        }, intlOpts), intl = hasIntl();
        if (intl && hasFormatToParts()) {
          var parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find(function(m2) {
            return m2.type.toLowerCase() === "timezonename";
          });
          return parsed ? parsed.value : null;
        } else if (intl) {
          var without = new Intl.DateTimeFormat(locale, intlOpts).format(date), included = new Intl.DateTimeFormat(locale, modified).format(date), diffed = included.substring(without.length), trimmed = diffed.replace(/^[, \u200e]+/, "");
          return trimmed;
        } else {
          return null;
        }
      }
      function signedOffset(offHourStr, offMinuteStr) {
        var offHour = parseInt(offHourStr, 10);
        if (Number.isNaN(offHour)) {
          offHour = 0;
        }
        var offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
        return offHour * 60 + offMinSigned;
      }
      function asNumber(value) {
        var numericValue = Number(value);
        if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
          throw new InvalidArgumentError("Invalid unit value " + value);
        return numericValue;
      }
      function normalizeObject(obj, normalizer, nonUnitKeys) {
        var normalized = {};
        for (var u2 in obj) {
          if (hasOwnProperty2(obj, u2)) {
            if (nonUnitKeys.indexOf(u2) >= 0)
              continue;
            var v2 = obj[u2];
            if (v2 === void 0 || v2 === null)
              continue;
            normalized[normalizer(u2)] = asNumber(v2);
          }
        }
        return normalized;
      }
      function formatOffset(offset3, format2) {
        var hours = Math.trunc(Math.abs(offset3 / 60)), minutes = Math.trunc(Math.abs(offset3 % 60)), sign = offset3 >= 0 ? "+" : "-";
        switch (format2) {
          case "short":
            return "" + sign + padStart(hours, 2) + ":" + padStart(minutes, 2);
          case "narrow":
            return "" + sign + hours + (minutes > 0 ? ":" + minutes : "");
          case "techie":
            return "" + sign + padStart(hours, 2) + padStart(minutes, 2);
          default:
            throw new RangeError("Value format " + format2 + " is out of range for property format");
        }
      }
      function timeObject(obj) {
        return pick(obj, ["hour", "minute", "second", "millisecond"]);
      }
      var ianaRegex = /[A-Za-z_+-]{1,256}(:?\/[A-Za-z_+-]{1,256}(\/[A-Za-z_+-]{1,256})?)?/;
      function stringify(obj) {
        return JSON.stringify(obj, Object.keys(obj).sort());
      }
      var monthsLong = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
      var monthsShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
      function months(length) {
        switch (length) {
          case "narrow":
            return monthsNarrow;
          case "short":
            return monthsShort;
          case "long":
            return monthsLong;
          case "numeric":
            return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
          case "2-digit":
            return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
          default:
            return null;
        }
      }
      var weekdaysLong = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
      var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
      var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
      function weekdays(length) {
        switch (length) {
          case "narrow":
            return weekdaysNarrow;
          case "short":
            return weekdaysShort;
          case "long":
            return weekdaysLong;
          case "numeric":
            return ["1", "2", "3", "4", "5", "6", "7"];
          default:
            return null;
        }
      }
      var meridiems = ["AM", "PM"];
      var erasLong = ["Before Christ", "Anno Domini"];
      var erasShort = ["BC", "AD"];
      var erasNarrow = ["B", "A"];
      function eras(length) {
        switch (length) {
          case "narrow":
            return erasNarrow;
          case "short":
            return erasShort;
          case "long":
            return erasLong;
          default:
            return null;
        }
      }
      function meridiemForDateTime(dt) {
        return meridiems[dt.hour < 12 ? 0 : 1];
      }
      function weekdayForDateTime(dt, length) {
        return weekdays(length)[dt.weekday - 1];
      }
      function monthForDateTime(dt, length) {
        return months(length)[dt.month - 1];
      }
      function eraForDateTime(dt, length) {
        return eras(length)[dt.year < 0 ? 0 : 1];
      }
      function formatRelativeTime(unit, count, numeric, narrow) {
        if (numeric === void 0) {
          numeric = "always";
        }
        if (narrow === void 0) {
          narrow = false;
        }
        var units = {
          years: ["year", "yr."],
          quarters: ["quarter", "qtr."],
          months: ["month", "mo."],
          weeks: ["week", "wk."],
          days: ["day", "day", "days"],
          hours: ["hour", "hr."],
          minutes: ["minute", "min."],
          seconds: ["second", "sec."]
        };
        var lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
        if (numeric === "auto" && lastable) {
          var isDay = unit === "days";
          switch (count) {
            case 1:
              return isDay ? "tomorrow" : "next " + units[unit][0];
            case -1:
              return isDay ? "yesterday" : "last " + units[unit][0];
            case 0:
              return isDay ? "today" : "this " + units[unit][0];
          }
        }
        var isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
        return isInPast ? fmtValue + " " + fmtUnit + " ago" : "in " + fmtValue + " " + fmtUnit;
      }
      function formatString(knownFormat) {
        var filtered = pick(knownFormat, ["weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "hour12"]), key = stringify(filtered), dateTimeHuge = "EEEE, LLLL d, yyyy, h:mm a";
        switch (key) {
          case stringify(DATE_SHORT):
            return "M/d/yyyy";
          case stringify(DATE_MED):
            return "LLL d, yyyy";
          case stringify(DATE_MED_WITH_WEEKDAY):
            return "EEE, LLL d, yyyy";
          case stringify(DATE_FULL):
            return "LLLL d, yyyy";
          case stringify(DATE_HUGE):
            return "EEEE, LLLL d, yyyy";
          case stringify(TIME_SIMPLE):
            return "h:mm a";
          case stringify(TIME_WITH_SECONDS):
            return "h:mm:ss a";
          case stringify(TIME_WITH_SHORT_OFFSET):
            return "h:mm a";
          case stringify(TIME_WITH_LONG_OFFSET):
            return "h:mm a";
          case stringify(TIME_24_SIMPLE):
            return "HH:mm";
          case stringify(TIME_24_WITH_SECONDS):
            return "HH:mm:ss";
          case stringify(TIME_24_WITH_SHORT_OFFSET):
            return "HH:mm";
          case stringify(TIME_24_WITH_LONG_OFFSET):
            return "HH:mm";
          case stringify(DATETIME_SHORT):
            return "M/d/yyyy, h:mm a";
          case stringify(DATETIME_MED):
            return "LLL d, yyyy, h:mm a";
          case stringify(DATETIME_FULL):
            return "LLLL d, yyyy, h:mm a";
          case stringify(DATETIME_HUGE):
            return dateTimeHuge;
          case stringify(DATETIME_SHORT_WITH_SECONDS):
            return "M/d/yyyy, h:mm:ss a";
          case stringify(DATETIME_MED_WITH_SECONDS):
            return "LLL d, yyyy, h:mm:ss a";
          case stringify(DATETIME_MED_WITH_WEEKDAY):
            return "EEE, d LLL yyyy, h:mm a";
          case stringify(DATETIME_FULL_WITH_SECONDS):
            return "LLLL d, yyyy, h:mm:ss a";
          case stringify(DATETIME_HUGE_WITH_SECONDS):
            return "EEEE, LLLL d, yyyy, h:mm:ss a";
          default:
            return dateTimeHuge;
        }
      }
      function stringifyTokens(splits, tokenToString) {
        var s3 = "";
        for (var _iterator = _createForOfIteratorHelperLoose(splits), _step; !(_step = _iterator()).done; ) {
          var token = _step.value;
          if (token.literal) {
            s3 += token.val;
          } else {
            s3 += tokenToString(token.val);
          }
        }
        return s3;
      }
      var _macroTokenToFormatOpts = {
        D: DATE_SHORT,
        DD: DATE_MED,
        DDD: DATE_FULL,
        DDDD: DATE_HUGE,
        t: TIME_SIMPLE,
        tt: TIME_WITH_SECONDS,
        ttt: TIME_WITH_SHORT_OFFSET,
        tttt: TIME_WITH_LONG_OFFSET,
        T: TIME_24_SIMPLE,
        TT: TIME_24_WITH_SECONDS,
        TTT: TIME_24_WITH_SHORT_OFFSET,
        TTTT: TIME_24_WITH_LONG_OFFSET,
        f: DATETIME_SHORT,
        ff: DATETIME_MED,
        fff: DATETIME_FULL,
        ffff: DATETIME_HUGE,
        F: DATETIME_SHORT_WITH_SECONDS,
        FF: DATETIME_MED_WITH_SECONDS,
        FFF: DATETIME_FULL_WITH_SECONDS,
        FFFF: DATETIME_HUGE_WITH_SECONDS
      };
      var Formatter = /* @__PURE__ */ function() {
        Formatter2.create = function create(locale, opts) {
          if (opts === void 0) {
            opts = {};
          }
          return new Formatter2(locale, opts);
        };
        Formatter2.parseFormat = function parseFormat(fmt) {
          var current = null, currentFull = "", bracketed = false;
          var splits = [];
          for (var i2 = 0; i2 < fmt.length; i2++) {
            var c2 = fmt.charAt(i2);
            if (c2 === "'") {
              if (currentFull.length > 0) {
                splits.push({
                  literal: bracketed,
                  val: currentFull
                });
              }
              current = null;
              currentFull = "";
              bracketed = !bracketed;
            } else if (bracketed) {
              currentFull += c2;
            } else if (c2 === current) {
              currentFull += c2;
            } else {
              if (currentFull.length > 0) {
                splits.push({
                  literal: false,
                  val: currentFull
                });
              }
              currentFull = c2;
              current = c2;
            }
          }
          if (currentFull.length > 0) {
            splits.push({
              literal: bracketed,
              val: currentFull
            });
          }
          return splits;
        };
        Formatter2.macroTokenToFormatOpts = function macroTokenToFormatOpts(token) {
          return _macroTokenToFormatOpts[token];
        };
        function Formatter2(locale, formatOpts) {
          this.opts = formatOpts;
          this.loc = locale;
          this.systemLoc = null;
        }
        var _proto = Formatter2.prototype;
        _proto.formatWithSystemDefault = function formatWithSystemDefault(dt, opts) {
          if (this.systemLoc === null) {
            this.systemLoc = this.loc.redefaultToSystem();
          }
          var df = this.systemLoc.dtFormatter(dt, Object.assign({}, this.opts, opts));
          return df.format();
        };
        _proto.formatDateTime = function formatDateTime(dt, opts) {
          if (opts === void 0) {
            opts = {};
          }
          var df = this.loc.dtFormatter(dt, Object.assign({}, this.opts, opts));
          return df.format();
        };
        _proto.formatDateTimeParts = function formatDateTimeParts(dt, opts) {
          if (opts === void 0) {
            opts = {};
          }
          var df = this.loc.dtFormatter(dt, Object.assign({}, this.opts, opts));
          return df.formatToParts();
        };
        _proto.resolvedOptions = function resolvedOptions(dt, opts) {
          if (opts === void 0) {
            opts = {};
          }
          var df = this.loc.dtFormatter(dt, Object.assign({}, this.opts, opts));
          return df.resolvedOptions();
        };
        _proto.num = function num(n3, p2) {
          if (p2 === void 0) {
            p2 = 0;
          }
          if (this.opts.forceSimple) {
            return padStart(n3, p2);
          }
          var opts = Object.assign({}, this.opts);
          if (p2 > 0) {
            opts.padTo = p2;
          }
          return this.loc.numberFormatter(opts).format(n3);
        };
        _proto.formatDateTimeFromString = function formatDateTimeFromString(dt, fmt) {
          var _this = this;
          var knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory" && hasFormatToParts(), string = function string2(opts, extract) {
            return _this.loc.extract(dt, opts, extract);
          }, formatOffset2 = function formatOffset3(opts) {
            if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
              return "Z";
            }
            return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
          }, meridiem = function meridiem2() {
            return knownEnglish ? meridiemForDateTime(dt) : string({
              hour: "numeric",
              hour12: true
            }, "dayperiod");
          }, month = function month2(length, standalone) {
            return knownEnglish ? monthForDateTime(dt, length) : string(standalone ? {
              month: length
            } : {
              month: length,
              day: "numeric"
            }, "month");
          }, weekday = function weekday2(length, standalone) {
            return knownEnglish ? weekdayForDateTime(dt, length) : string(standalone ? {
              weekday: length
            } : {
              weekday: length,
              month: "long",
              day: "numeric"
            }, "weekday");
          }, maybeMacro = function maybeMacro2(token) {
            var formatOpts = Formatter2.macroTokenToFormatOpts(token);
            if (formatOpts) {
              return _this.formatWithSystemDefault(dt, formatOpts);
            } else {
              return token;
            }
          }, era = function era2(length) {
            return knownEnglish ? eraForDateTime(dt, length) : string({
              era: length
            }, "era");
          }, tokenToString = function tokenToString2(token) {
            switch (token) {
              case "S":
                return _this.num(dt.millisecond);
              case "u":
              case "SSS":
                return _this.num(dt.millisecond, 3);
              case "s":
                return _this.num(dt.second);
              case "ss":
                return _this.num(dt.second, 2);
              case "m":
                return _this.num(dt.minute);
              case "mm":
                return _this.num(dt.minute, 2);
              case "h":
                return _this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
              case "hh":
                return _this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
              case "H":
                return _this.num(dt.hour);
              case "HH":
                return _this.num(dt.hour, 2);
              case "Z":
                return formatOffset2({
                  format: "narrow",
                  allowZ: _this.opts.allowZ
                });
              case "ZZ":
                return formatOffset2({
                  format: "short",
                  allowZ: _this.opts.allowZ
                });
              case "ZZZ":
                return formatOffset2({
                  format: "techie",
                  allowZ: _this.opts.allowZ
                });
              case "ZZZZ":
                return dt.zone.offsetName(dt.ts, {
                  format: "short",
                  locale: _this.loc.locale
                });
              case "ZZZZZ":
                return dt.zone.offsetName(dt.ts, {
                  format: "long",
                  locale: _this.loc.locale
                });
              case "z":
                return dt.zoneName;
              case "a":
                return meridiem();
              case "d":
                return useDateTimeFormatter ? string({
                  day: "numeric"
                }, "day") : _this.num(dt.day);
              case "dd":
                return useDateTimeFormatter ? string({
                  day: "2-digit"
                }, "day") : _this.num(dt.day, 2);
              case "c":
                return _this.num(dt.weekday);
              case "ccc":
                return weekday("short", true);
              case "cccc":
                return weekday("long", true);
              case "ccccc":
                return weekday("narrow", true);
              case "E":
                return _this.num(dt.weekday);
              case "EEE":
                return weekday("short", false);
              case "EEEE":
                return weekday("long", false);
              case "EEEEE":
                return weekday("narrow", false);
              case "L":
                return useDateTimeFormatter ? string({
                  month: "numeric",
                  day: "numeric"
                }, "month") : _this.num(dt.month);
              case "LL":
                return useDateTimeFormatter ? string({
                  month: "2-digit",
                  day: "numeric"
                }, "month") : _this.num(dt.month, 2);
              case "LLL":
                return month("short", true);
              case "LLLL":
                return month("long", true);
              case "LLLLL":
                return month("narrow", true);
              case "M":
                return useDateTimeFormatter ? string({
                  month: "numeric"
                }, "month") : _this.num(dt.month);
              case "MM":
                return useDateTimeFormatter ? string({
                  month: "2-digit"
                }, "month") : _this.num(dt.month, 2);
              case "MMM":
                return month("short", false);
              case "MMMM":
                return month("long", false);
              case "MMMMM":
                return month("narrow", false);
              case "y":
                return useDateTimeFormatter ? string({
                  year: "numeric"
                }, "year") : _this.num(dt.year);
              case "yy":
                return useDateTimeFormatter ? string({
                  year: "2-digit"
                }, "year") : _this.num(dt.year.toString().slice(-2), 2);
              case "yyyy":
                return useDateTimeFormatter ? string({
                  year: "numeric"
                }, "year") : _this.num(dt.year, 4);
              case "yyyyyy":
                return useDateTimeFormatter ? string({
                  year: "numeric"
                }, "year") : _this.num(dt.year, 6);
              case "G":
                return era("short");
              case "GG":
                return era("long");
              case "GGGGG":
                return era("narrow");
              case "kk":
                return _this.num(dt.weekYear.toString().slice(-2), 2);
              case "kkkk":
                return _this.num(dt.weekYear, 4);
              case "W":
                return _this.num(dt.weekNumber);
              case "WW":
                return _this.num(dt.weekNumber, 2);
              case "o":
                return _this.num(dt.ordinal);
              case "ooo":
                return _this.num(dt.ordinal, 3);
              case "q":
                return _this.num(dt.quarter);
              case "qq":
                return _this.num(dt.quarter, 2);
              case "X":
                return _this.num(Math.floor(dt.ts / 1e3));
              case "x":
                return _this.num(dt.ts);
              default:
                return maybeMacro(token);
            }
          };
          return stringifyTokens(Formatter2.parseFormat(fmt), tokenToString);
        };
        _proto.formatDurationFromString = function formatDurationFromString(dur, fmt) {
          var _this2 = this;
          var tokenToField = function tokenToField2(token) {
            switch (token[0]) {
              case "S":
                return "millisecond";
              case "s":
                return "second";
              case "m":
                return "minute";
              case "h":
                return "hour";
              case "d":
                return "day";
              case "M":
                return "month";
              case "y":
                return "year";
              default:
                return null;
            }
          }, tokenToString = function tokenToString2(lildur) {
            return function(token) {
              var mapped = tokenToField(token);
              if (mapped) {
                return _this2.num(lildur.get(mapped), token.length);
              } else {
                return token;
              }
            };
          }, tokens = Formatter2.parseFormat(fmt), realTokens = tokens.reduce(function(found, _ref) {
            var literal = _ref.literal, val = _ref.val;
            return literal ? found : found.concat(val);
          }, []), collapsed = dur.shiftTo.apply(dur, realTokens.map(tokenToField).filter(function(t2) {
            return t2;
          }));
          return stringifyTokens(tokens, tokenToString(collapsed));
        };
        return Formatter2;
      }();
      var Invalid = /* @__PURE__ */ function() {
        function Invalid2(reason, explanation) {
          this.reason = reason;
          this.explanation = explanation;
        }
        var _proto = Invalid2.prototype;
        _proto.toMessage = function toMessage() {
          if (this.explanation) {
            return this.reason + ": " + this.explanation;
          } else {
            return this.reason;
          }
        };
        return Invalid2;
      }();
      var Zone = /* @__PURE__ */ function() {
        function Zone2() {
        }
        var _proto = Zone2.prototype;
        _proto.offsetName = function offsetName(ts, opts) {
          throw new ZoneIsAbstractError();
        };
        _proto.formatOffset = function formatOffset2(ts, format2) {
          throw new ZoneIsAbstractError();
        };
        _proto.offset = function offset3(ts) {
          throw new ZoneIsAbstractError();
        };
        _proto.equals = function equals(otherZone) {
          throw new ZoneIsAbstractError();
        };
        _createClass(Zone2, [{
          key: "type",
          get: function get() {
            throw new ZoneIsAbstractError();
          }
        }, {
          key: "name",
          get: function get() {
            throw new ZoneIsAbstractError();
          }
        }, {
          key: "universal",
          get: function get() {
            throw new ZoneIsAbstractError();
          }
        }, {
          key: "isValid",
          get: function get() {
            throw new ZoneIsAbstractError();
          }
        }]);
        return Zone2;
      }();
      var singleton = null;
      var LocalZone = /* @__PURE__ */ function(_Zone) {
        _inheritsLoose(LocalZone2, _Zone);
        function LocalZone2() {
          return _Zone.apply(this, arguments) || this;
        }
        var _proto = LocalZone2.prototype;
        _proto.offsetName = function offsetName(ts, _ref) {
          var format2 = _ref.format, locale = _ref.locale;
          return parseZoneInfo(ts, format2, locale);
        };
        _proto.formatOffset = function formatOffset$1(ts, format2) {
          return formatOffset(this.offset(ts), format2);
        };
        _proto.offset = function offset3(ts) {
          return -new Date(ts).getTimezoneOffset();
        };
        _proto.equals = function equals(otherZone) {
          return otherZone.type === "local";
        };
        _createClass(LocalZone2, [{
          key: "type",
          get: function get() {
            return "local";
          }
        }, {
          key: "name",
          get: function get() {
            if (hasIntl()) {
              return new Intl.DateTimeFormat().resolvedOptions().timeZone;
            } else
              return "local";
          }
        }, {
          key: "universal",
          get: function get() {
            return false;
          }
        }, {
          key: "isValid",
          get: function get() {
            return true;
          }
        }], [{
          key: "instance",
          get: function get() {
            if (singleton === null) {
              singleton = new LocalZone2();
            }
            return singleton;
          }
        }]);
        return LocalZone2;
      }(Zone);
      var matchingRegex = RegExp("^" + ianaRegex.source + "$");
      var dtfCache = {};
      function makeDTF(zone) {
        if (!dtfCache[zone]) {
          dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
            hour12: false,
            timeZone: zone,
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
          });
        }
        return dtfCache[zone];
      }
      var typeToPos = {
        year: 0,
        month: 1,
        day: 2,
        hour: 3,
        minute: 4,
        second: 5
      };
      function hackyOffset(dtf, date) {
        var formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted), fMonth = parsed[1], fDay = parsed[2], fYear = parsed[3], fHour = parsed[4], fMinute = parsed[5], fSecond = parsed[6];
        return [fYear, fMonth, fDay, fHour, fMinute, fSecond];
      }
      function partsOffset(dtf, date) {
        var formatted = dtf.formatToParts(date), filled = [];
        for (var i2 = 0; i2 < formatted.length; i2++) {
          var _formatted$i = formatted[i2], type = _formatted$i.type, value = _formatted$i.value, pos = typeToPos[type];
          if (!isUndefined(pos)) {
            filled[pos] = parseInt(value, 10);
          }
        }
        return filled;
      }
      var ianaZoneCache = {};
      var IANAZone = /* @__PURE__ */ function(_Zone) {
        _inheritsLoose(IANAZone2, _Zone);
        IANAZone2.create = function create(name) {
          if (!ianaZoneCache[name]) {
            ianaZoneCache[name] = new IANAZone2(name);
          }
          return ianaZoneCache[name];
        };
        IANAZone2.resetCache = function resetCache() {
          ianaZoneCache = {};
          dtfCache = {};
        };
        IANAZone2.isValidSpecifier = function isValidSpecifier(s3) {
          return !!(s3 && s3.match(matchingRegex));
        };
        IANAZone2.isValidZone = function isValidZone(zone) {
          try {
            new Intl.DateTimeFormat("en-US", {
              timeZone: zone
            }).format();
            return true;
          } catch (e2) {
            return false;
          }
        };
        IANAZone2.parseGMTOffset = function parseGMTOffset(specifier) {
          if (specifier) {
            var match2 = specifier.match(/^Etc\/GMT([+-]\d{1,2})$/i);
            if (match2) {
              return -60 * parseInt(match2[1]);
            }
          }
          return null;
        };
        function IANAZone2(name) {
          var _this;
          _this = _Zone.call(this) || this;
          _this.zoneName = name;
          _this.valid = IANAZone2.isValidZone(name);
          return _this;
        }
        var _proto = IANAZone2.prototype;
        _proto.offsetName = function offsetName(ts, _ref) {
          var format2 = _ref.format, locale = _ref.locale;
          return parseZoneInfo(ts, format2, locale, this.name);
        };
        _proto.formatOffset = function formatOffset$1(ts, format2) {
          return formatOffset(this.offset(ts), format2);
        };
        _proto.offset = function offset3(ts) {
          var date = new Date(ts), dtf = makeDTF(this.name), _ref2 = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date), year = _ref2[0], month = _ref2[1], day = _ref2[2], hour = _ref2[3], minute = _ref2[4], second = _ref2[5], adjustedHour = hour === 24 ? 0 : hour;
          var asUTC = objToLocalTS({
            year,
            month,
            day,
            hour: adjustedHour,
            minute,
            second,
            millisecond: 0
          });
          var asTS = +date;
          var over = asTS % 1e3;
          asTS -= over >= 0 ? over : 1e3 + over;
          return (asUTC - asTS) / (60 * 1e3);
        };
        _proto.equals = function equals(otherZone) {
          return otherZone.type === "iana" && otherZone.name === this.name;
        };
        _createClass(IANAZone2, [{
          key: "type",
          get: function get() {
            return "iana";
          }
        }, {
          key: "name",
          get: function get() {
            return this.zoneName;
          }
        }, {
          key: "universal",
          get: function get() {
            return false;
          }
        }, {
          key: "isValid",
          get: function get() {
            return this.valid;
          }
        }]);
        return IANAZone2;
      }(Zone);
      var singleton$1 = null;
      var FixedOffsetZone = /* @__PURE__ */ function(_Zone) {
        _inheritsLoose(FixedOffsetZone2, _Zone);
        FixedOffsetZone2.instance = function instance(offset3) {
          return offset3 === 0 ? FixedOffsetZone2.utcInstance : new FixedOffsetZone2(offset3);
        };
        FixedOffsetZone2.parseSpecifier = function parseSpecifier(s3) {
          if (s3) {
            var r2 = s3.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
            if (r2) {
              return new FixedOffsetZone2(signedOffset(r2[1], r2[2]));
            }
          }
          return null;
        };
        _createClass(FixedOffsetZone2, null, [{
          key: "utcInstance",
          get: function get() {
            if (singleton$1 === null) {
              singleton$1 = new FixedOffsetZone2(0);
            }
            return singleton$1;
          }
        }]);
        function FixedOffsetZone2(offset3) {
          var _this;
          _this = _Zone.call(this) || this;
          _this.fixed = offset3;
          return _this;
        }
        var _proto = FixedOffsetZone2.prototype;
        _proto.offsetName = function offsetName() {
          return this.name;
        };
        _proto.formatOffset = function formatOffset$1(ts, format2) {
          return formatOffset(this.fixed, format2);
        };
        _proto.offset = function offset3() {
          return this.fixed;
        };
        _proto.equals = function equals(otherZone) {
          return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
        };
        _createClass(FixedOffsetZone2, [{
          key: "type",
          get: function get() {
            return "fixed";
          }
        }, {
          key: "name",
          get: function get() {
            return this.fixed === 0 ? "UTC" : "UTC" + formatOffset(this.fixed, "narrow");
          }
        }, {
          key: "universal",
          get: function get() {
            return true;
          }
        }, {
          key: "isValid",
          get: function get() {
            return true;
          }
        }]);
        return FixedOffsetZone2;
      }(Zone);
      var InvalidZone = /* @__PURE__ */ function(_Zone) {
        _inheritsLoose(InvalidZone2, _Zone);
        function InvalidZone2(zoneName) {
          var _this;
          _this = _Zone.call(this) || this;
          _this.zoneName = zoneName;
          return _this;
        }
        var _proto = InvalidZone2.prototype;
        _proto.offsetName = function offsetName() {
          return null;
        };
        _proto.formatOffset = function formatOffset2() {
          return "";
        };
        _proto.offset = function offset3() {
          return NaN;
        };
        _proto.equals = function equals() {
          return false;
        };
        _createClass(InvalidZone2, [{
          key: "type",
          get: function get() {
            return "invalid";
          }
        }, {
          key: "name",
          get: function get() {
            return this.zoneName;
          }
        }, {
          key: "universal",
          get: function get() {
            return false;
          }
        }, {
          key: "isValid",
          get: function get() {
            return false;
          }
        }]);
        return InvalidZone2;
      }(Zone);
      function normalizeZone(input, defaultZone2) {
        var offset3;
        if (isUndefined(input) || input === null) {
          return defaultZone2;
        } else if (input instanceof Zone) {
          return input;
        } else if (isString(input)) {
          var lowered = input.toLowerCase();
          if (lowered === "local")
            return defaultZone2;
          else if (lowered === "utc" || lowered === "gmt")
            return FixedOffsetZone.utcInstance;
          else if ((offset3 = IANAZone.parseGMTOffset(input)) != null) {
            return FixedOffsetZone.instance(offset3);
          } else if (IANAZone.isValidSpecifier(lowered))
            return IANAZone.create(input);
          else
            return FixedOffsetZone.parseSpecifier(lowered) || new InvalidZone(input);
        } else if (isNumber(input)) {
          return FixedOffsetZone.instance(input);
        } else if (typeof input === "object" && input.offset && typeof input.offset === "number") {
          return input;
        } else {
          return new InvalidZone(input);
        }
      }
      var now2 = function now3() {
        return Date.now();
      };
      var defaultZone = null;
      var defaultLocale = null;
      var defaultNumberingSystem = null;
      var defaultOutputCalendar = null;
      var throwOnInvalid = false;
      var Settings = /* @__PURE__ */ function() {
        function Settings2() {
        }
        Settings2.resetCaches = function resetCaches() {
          Locale.resetCache();
          IANAZone.resetCache();
        };
        _createClass(Settings2, null, [{
          key: "now",
          get: function get() {
            return now2;
          },
          set: function set(n3) {
            now2 = n3;
          }
        }, {
          key: "defaultZoneName",
          get: function get() {
            return Settings2.defaultZone.name;
          },
          set: function set(z2) {
            if (!z2) {
              defaultZone = null;
            } else {
              defaultZone = normalizeZone(z2);
            }
          }
        }, {
          key: "defaultZone",
          get: function get() {
            return defaultZone || LocalZone.instance;
          }
        }, {
          key: "defaultLocale",
          get: function get() {
            return defaultLocale;
          },
          set: function set(locale) {
            defaultLocale = locale;
          }
        }, {
          key: "defaultNumberingSystem",
          get: function get() {
            return defaultNumberingSystem;
          },
          set: function set(numberingSystem) {
            defaultNumberingSystem = numberingSystem;
          }
        }, {
          key: "defaultOutputCalendar",
          get: function get() {
            return defaultOutputCalendar;
          },
          set: function set(outputCalendar) {
            defaultOutputCalendar = outputCalendar;
          }
        }, {
          key: "throwOnInvalid",
          get: function get() {
            return throwOnInvalid;
          },
          set: function set(t2) {
            throwOnInvalid = t2;
          }
        }]);
        return Settings2;
      }();
      var intlDTCache = {};
      function getCachedDTF(locString, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var key = JSON.stringify([locString, opts]);
        var dtf = intlDTCache[key];
        if (!dtf) {
          dtf = new Intl.DateTimeFormat(locString, opts);
          intlDTCache[key] = dtf;
        }
        return dtf;
      }
      var intlNumCache = {};
      function getCachedINF(locString, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var key = JSON.stringify([locString, opts]);
        var inf = intlNumCache[key];
        if (!inf) {
          inf = new Intl.NumberFormat(locString, opts);
          intlNumCache[key] = inf;
        }
        return inf;
      }
      var intlRelCache = {};
      function getCachedRTF(locString, opts) {
        if (opts === void 0) {
          opts = {};
        }
        var _opts = opts, base = _opts.base, cacheKeyOpts = _objectWithoutPropertiesLoose7(_opts, ["base"]);
        var key = JSON.stringify([locString, cacheKeyOpts]);
        var inf = intlRelCache[key];
        if (!inf) {
          inf = new Intl.RelativeTimeFormat(locString, opts);
          intlRelCache[key] = inf;
        }
        return inf;
      }
      var sysLocaleCache = null;
      function systemLocale() {
        if (sysLocaleCache) {
          return sysLocaleCache;
        } else if (hasIntl()) {
          var computedSys = new Intl.DateTimeFormat().resolvedOptions().locale;
          sysLocaleCache = !computedSys || computedSys === "und" ? "en-US" : computedSys;
          return sysLocaleCache;
        } else {
          sysLocaleCache = "en-US";
          return sysLocaleCache;
        }
      }
      function parseLocaleString(localeStr) {
        var uIndex = localeStr.indexOf("-u-");
        if (uIndex === -1) {
          return [localeStr];
        } else {
          var options;
          var smaller = localeStr.substring(0, uIndex);
          try {
            options = getCachedDTF(localeStr).resolvedOptions();
          } catch (e2) {
            options = getCachedDTF(smaller).resolvedOptions();
          }
          var _options = options, numberingSystem = _options.numberingSystem, calendar = _options.calendar;
          return [smaller, numberingSystem, calendar];
        }
      }
      function intlConfigString(localeStr, numberingSystem, outputCalendar) {
        if (hasIntl()) {
          if (outputCalendar || numberingSystem) {
            localeStr += "-u";
            if (outputCalendar) {
              localeStr += "-ca-" + outputCalendar;
            }
            if (numberingSystem) {
              localeStr += "-nu-" + numberingSystem;
            }
            return localeStr;
          } else {
            return localeStr;
          }
        } else {
          return [];
        }
      }
      function mapMonths(f2) {
        var ms = [];
        for (var i2 = 1; i2 <= 12; i2++) {
          var dt = DateTime2.utc(2016, i2, 1);
          ms.push(f2(dt));
        }
        return ms;
      }
      function mapWeekdays(f2) {
        var ms = [];
        for (var i2 = 1; i2 <= 7; i2++) {
          var dt = DateTime2.utc(2016, 11, 13 + i2);
          ms.push(f2(dt));
        }
        return ms;
      }
      function listStuff(loc, length, defaultOK, englishFn, intlFn) {
        var mode = loc.listingMode(defaultOK);
        if (mode === "error") {
          return null;
        } else if (mode === "en") {
          return englishFn(length);
        } else {
          return intlFn(length);
        }
      }
      function supportsFastNumbers(loc) {
        if (loc.numberingSystem && loc.numberingSystem !== "latn") {
          return false;
        } else {
          return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || hasIntl() && new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
        }
      }
      var PolyNumberFormatter = /* @__PURE__ */ function() {
        function PolyNumberFormatter2(intl, forceSimple, opts) {
          this.padTo = opts.padTo || 0;
          this.floor = opts.floor || false;
          if (!forceSimple && hasIntl()) {
            var intlOpts = {
              useGrouping: false
            };
            if (opts.padTo > 0)
              intlOpts.minimumIntegerDigits = opts.padTo;
            this.inf = getCachedINF(intl, intlOpts);
          }
        }
        var _proto = PolyNumberFormatter2.prototype;
        _proto.format = function format2(i2) {
          if (this.inf) {
            var fixed = this.floor ? Math.floor(i2) : i2;
            return this.inf.format(fixed);
          } else {
            var _fixed = this.floor ? Math.floor(i2) : roundTo(i2, 3);
            return padStart(_fixed, this.padTo);
          }
        };
        return PolyNumberFormatter2;
      }();
      var PolyDateFormatter = /* @__PURE__ */ function() {
        function PolyDateFormatter2(dt, intl, opts) {
          this.opts = opts;
          this.hasIntl = hasIntl();
          var z2;
          if (dt.zone.universal && this.hasIntl) {
            var gmtOffset = -1 * (dt.offset / 60);
            if (gmtOffset >= -14 && gmtOffset <= 12 && gmtOffset % 1 === 0) {
              z2 = gmtOffset >= 0 ? "Etc/GMT+" + gmtOffset : "Etc/GMT" + gmtOffset;
              this.dt = dt;
            } else {
              z2 = "UTC";
              if (opts.timeZoneName) {
                this.dt = dt;
              } else {
                this.dt = dt.offset === 0 ? dt : DateTime2.fromMillis(dt.ts + dt.offset * 60 * 1e3);
              }
            }
          } else if (dt.zone.type === "local") {
            this.dt = dt;
          } else {
            this.dt = dt;
            z2 = dt.zone.name;
          }
          if (this.hasIntl) {
            var intlOpts = Object.assign({}, this.opts);
            if (z2) {
              intlOpts.timeZone = z2;
            }
            this.dtf = getCachedDTF(intl, intlOpts);
          }
        }
        var _proto2 = PolyDateFormatter2.prototype;
        _proto2.format = function format2() {
          if (this.hasIntl) {
            return this.dtf.format(this.dt.toJSDate());
          } else {
            var tokenFormat = formatString(this.opts), loc = Locale.create("en-US");
            return Formatter.create(loc).formatDateTimeFromString(this.dt, tokenFormat);
          }
        };
        _proto2.formatToParts = function formatToParts() {
          if (this.hasIntl && hasFormatToParts()) {
            return this.dtf.formatToParts(this.dt.toJSDate());
          } else {
            return [];
          }
        };
        _proto2.resolvedOptions = function resolvedOptions() {
          if (this.hasIntl) {
            return this.dtf.resolvedOptions();
          } else {
            return {
              locale: "en-US",
              numberingSystem: "latn",
              outputCalendar: "gregory"
            };
          }
        };
        return PolyDateFormatter2;
      }();
      var PolyRelFormatter = /* @__PURE__ */ function() {
        function PolyRelFormatter2(intl, isEnglish, opts) {
          this.opts = Object.assign({
            style: "long"
          }, opts);
          if (!isEnglish && hasRelative()) {
            this.rtf = getCachedRTF(intl, opts);
          }
        }
        var _proto3 = PolyRelFormatter2.prototype;
        _proto3.format = function format2(count, unit) {
          if (this.rtf) {
            return this.rtf.format(count, unit);
          } else {
            return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
          }
        };
        _proto3.formatToParts = function formatToParts(count, unit) {
          if (this.rtf) {
            return this.rtf.formatToParts(count, unit);
          } else {
            return [];
          }
        };
        return PolyRelFormatter2;
      }();
      var Locale = /* @__PURE__ */ function() {
        Locale2.fromOpts = function fromOpts(opts) {
          return Locale2.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
        };
        Locale2.create = function create(locale, numberingSystem, outputCalendar, defaultToEN) {
          if (defaultToEN === void 0) {
            defaultToEN = false;
          }
          var specifiedLocale = locale || Settings.defaultLocale, localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale()), numberingSystemR = numberingSystem || Settings.defaultNumberingSystem, outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
          return new Locale2(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
        };
        Locale2.resetCache = function resetCache() {
          sysLocaleCache = null;
          intlDTCache = {};
          intlNumCache = {};
          intlRelCache = {};
        };
        Locale2.fromObject = function fromObject(_temp) {
          var _ref = _temp === void 0 ? {} : _temp, locale = _ref.locale, numberingSystem = _ref.numberingSystem, outputCalendar = _ref.outputCalendar;
          return Locale2.create(locale, numberingSystem, outputCalendar);
        };
        function Locale2(locale, numbering, outputCalendar, specifiedLocale) {
          var _parseLocaleString = parseLocaleString(locale), parsedLocale = _parseLocaleString[0], parsedNumberingSystem = _parseLocaleString[1], parsedOutputCalendar = _parseLocaleString[2];
          this.locale = parsedLocale;
          this.numberingSystem = numbering || parsedNumberingSystem || null;
          this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
          this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
          this.weekdaysCache = {
            format: {},
            standalone: {}
          };
          this.monthsCache = {
            format: {},
            standalone: {}
          };
          this.meridiemCache = null;
          this.eraCache = {};
          this.specifiedLocale = specifiedLocale;
          this.fastNumbersCached = null;
        }
        var _proto4 = Locale2.prototype;
        _proto4.listingMode = function listingMode(defaultOK) {
          if (defaultOK === void 0) {
            defaultOK = true;
          }
          var intl = hasIntl(), hasFTP = intl && hasFormatToParts(), isActuallyEn = this.isEnglish(), hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
          if (!hasFTP && !(isActuallyEn && hasNoWeirdness) && !defaultOK) {
            return "error";
          } else if (!hasFTP || isActuallyEn && hasNoWeirdness) {
            return "en";
          } else {
            return "intl";
          }
        };
        _proto4.clone = function clone2(alts) {
          if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
            return this;
          } else {
            return Locale2.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, alts.defaultToEN || false);
          }
        };
        _proto4.redefaultToEN = function redefaultToEN(alts) {
          if (alts === void 0) {
            alts = {};
          }
          return this.clone(Object.assign({}, alts, {
            defaultToEN: true
          }));
        };
        _proto4.redefaultToSystem = function redefaultToSystem(alts) {
          if (alts === void 0) {
            alts = {};
          }
          return this.clone(Object.assign({}, alts, {
            defaultToEN: false
          }));
        };
        _proto4.months = function months$1(length, format2, defaultOK) {
          var _this = this;
          if (format2 === void 0) {
            format2 = false;
          }
          if (defaultOK === void 0) {
            defaultOK = true;
          }
          return listStuff(this, length, defaultOK, months, function() {
            var intl = format2 ? {
              month: length,
              day: "numeric"
            } : {
              month: length
            }, formatStr = format2 ? "format" : "standalone";
            if (!_this.monthsCache[formatStr][length]) {
              _this.monthsCache[formatStr][length] = mapMonths(function(dt) {
                return _this.extract(dt, intl, "month");
              });
            }
            return _this.monthsCache[formatStr][length];
          });
        };
        _proto4.weekdays = function weekdays$1(length, format2, defaultOK) {
          var _this2 = this;
          if (format2 === void 0) {
            format2 = false;
          }
          if (defaultOK === void 0) {
            defaultOK = true;
          }
          return listStuff(this, length, defaultOK, weekdays, function() {
            var intl = format2 ? {
              weekday: length,
              year: "numeric",
              month: "long",
              day: "numeric"
            } : {
              weekday: length
            }, formatStr = format2 ? "format" : "standalone";
            if (!_this2.weekdaysCache[formatStr][length]) {
              _this2.weekdaysCache[formatStr][length] = mapWeekdays(function(dt) {
                return _this2.extract(dt, intl, "weekday");
              });
            }
            return _this2.weekdaysCache[formatStr][length];
          });
        };
        _proto4.meridiems = function meridiems$1(defaultOK) {
          var _this3 = this;
          if (defaultOK === void 0) {
            defaultOK = true;
          }
          return listStuff(this, void 0, defaultOK, function() {
            return meridiems;
          }, function() {
            if (!_this3.meridiemCache) {
              var intl = {
                hour: "numeric",
                hour12: true
              };
              _this3.meridiemCache = [DateTime2.utc(2016, 11, 13, 9), DateTime2.utc(2016, 11, 13, 19)].map(function(dt) {
                return _this3.extract(dt, intl, "dayperiod");
              });
            }
            return _this3.meridiemCache;
          });
        };
        _proto4.eras = function eras$1(length, defaultOK) {
          var _this4 = this;
          if (defaultOK === void 0) {
            defaultOK = true;
          }
          return listStuff(this, length, defaultOK, eras, function() {
            var intl = {
              era: length
            };
            if (!_this4.eraCache[length]) {
              _this4.eraCache[length] = [DateTime2.utc(-40, 1, 1), DateTime2.utc(2017, 1, 1)].map(function(dt) {
                return _this4.extract(dt, intl, "era");
              });
            }
            return _this4.eraCache[length];
          });
        };
        _proto4.extract = function extract(dt, intlOpts, field) {
          var df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find(function(m2) {
            return m2.type.toLowerCase() === field;
          });
          return matching ? matching.value : null;
        };
        _proto4.numberFormatter = function numberFormatter(opts) {
          if (opts === void 0) {
            opts = {};
          }
          return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
        };
        _proto4.dtFormatter = function dtFormatter(dt, intlOpts) {
          if (intlOpts === void 0) {
            intlOpts = {};
          }
          return new PolyDateFormatter(dt, this.intl, intlOpts);
        };
        _proto4.relFormatter = function relFormatter(opts) {
          if (opts === void 0) {
            opts = {};
          }
          return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
        };
        _proto4.isEnglish = function isEnglish() {
          return this.locale === "en" || this.locale.toLowerCase() === "en-us" || hasIntl() && new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
        };
        _proto4.equals = function equals(other) {
          return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
        };
        _createClass(Locale2, [{
          key: "fastNumbers",
          get: function get() {
            if (this.fastNumbersCached == null) {
              this.fastNumbersCached = supportsFastNumbers(this);
            }
            return this.fastNumbersCached;
          }
        }]);
        return Locale2;
      }();
      function combineRegexes() {
        for (var _len = arguments.length, regexes = new Array(_len), _key = 0; _key < _len; _key++) {
          regexes[_key] = arguments[_key];
        }
        var full = regexes.reduce(function(f2, r2) {
          return f2 + r2.source;
        }, "");
        return RegExp("^" + full + "$");
      }
      function combineExtractors() {
        for (var _len2 = arguments.length, extractors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          extractors[_key2] = arguments[_key2];
        }
        return function(m2) {
          return extractors.reduce(function(_ref, ex) {
            var mergedVals = _ref[0], mergedZone = _ref[1], cursor = _ref[2];
            var _ex = ex(m2, cursor), val = _ex[0], zone = _ex[1], next = _ex[2];
            return [Object.assign(mergedVals, val), mergedZone || zone, next];
          }, [{}, null, 1]).slice(0, 2);
        };
      }
      function parse(s3) {
        if (s3 == null) {
          return [null, null];
        }
        for (var _len3 = arguments.length, patterns = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          patterns[_key3 - 1] = arguments[_key3];
        }
        for (var _i = 0, _patterns = patterns; _i < _patterns.length; _i++) {
          var _patterns$_i = _patterns[_i], regex = _patterns$_i[0], extractor = _patterns$_i[1];
          var m2 = regex.exec(s3);
          if (m2) {
            return extractor(m2);
          }
        }
        return [null, null];
      }
      function simpleParse() {
        for (var _len4 = arguments.length, keys = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          keys[_key4] = arguments[_key4];
        }
        return function(match2, cursor) {
          var ret = {};
          var i2;
          for (i2 = 0; i2 < keys.length; i2++) {
            ret[keys[i2]] = parseInteger(match2[cursor + i2]);
          }
          return [ret, null, cursor + i2];
        };
      }
      var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
      var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
      var isoTimeRegex = RegExp("" + isoTimeBaseRegex.source + offsetRegex.source + "?");
      var isoTimeExtensionRegex = RegExp("(?:T" + isoTimeRegex.source + ")?");
      var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
      var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
      var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
      var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
      var extractISOOrdinalData = simpleParse("year", "ordinal");
      var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
      var sqlTimeRegex = RegExp(isoTimeBaseRegex.source + " ?(?:" + offsetRegex.source + "|(" + ianaRegex.source + "))?");
      var sqlTimeExtensionRegex = RegExp("(?: " + sqlTimeRegex.source + ")?");
      function int2(match2, pos, fallback) {
        var m2 = match2[pos];
        return isUndefined(m2) ? fallback : parseInteger(m2);
      }
      function extractISOYmd(match2, cursor) {
        var item = {
          year: int2(match2, cursor),
          month: int2(match2, cursor + 1, 1),
          day: int2(match2, cursor + 2, 1)
        };
        return [item, null, cursor + 3];
      }
      function extractISOTime(match2, cursor) {
        var item = {
          hours: int2(match2, cursor, 0),
          minutes: int2(match2, cursor + 1, 0),
          seconds: int2(match2, cursor + 2, 0),
          milliseconds: parseMillis(match2[cursor + 3])
        };
        return [item, null, cursor + 4];
      }
      function extractISOOffset(match2, cursor) {
        var local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
        return [{}, zone, cursor + 3];
      }
      function extractIANAZone(match2, cursor) {
        var zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
        return [{}, zone, cursor + 1];
      }
      var isoTimeOnly = RegExp("^T?" + isoTimeBaseRegex.source + "$");
      var isoDuration = /^-?P(?:(?:(-?\d{1,9})Y)?(?:(-?\d{1,9})M)?(?:(-?\d{1,9})W)?(?:(-?\d{1,9})D)?(?:T(?:(-?\d{1,9})H)?(?:(-?\d{1,9})M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,9}))?S)?)?)$/;
      function extractISODuration(match2) {
        var s3 = match2[0], yearStr = match2[1], monthStr = match2[2], weekStr = match2[3], dayStr = match2[4], hourStr = match2[5], minuteStr = match2[6], secondStr = match2[7], millisecondsStr = match2[8];
        var hasNegativePrefix = s3[0] === "-";
        var maybeNegate = function maybeNegate2(num) {
          return num && hasNegativePrefix ? -num : num;
        };
        return [{
          years: maybeNegate(parseInteger(yearStr)),
          months: maybeNegate(parseInteger(monthStr)),
          weeks: maybeNegate(parseInteger(weekStr)),
          days: maybeNegate(parseInteger(dayStr)),
          hours: maybeNegate(parseInteger(hourStr)),
          minutes: maybeNegate(parseInteger(minuteStr)),
          seconds: maybeNegate(parseInteger(secondStr)),
          milliseconds: maybeNegate(parseMillis(millisecondsStr))
        }];
      }
      var obsOffsets = {
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = {
          year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
          month: monthsShort.indexOf(monthStr) + 1,
          day: parseInteger(dayStr),
          hour: parseInteger(hourStr),
          minute: parseInteger(minuteStr)
        };
        if (secondStr)
          result.second = parseInteger(secondStr);
        if (weekdayStr) {
          result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
        }
        return result;
      }
      var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
      function extractRFC2822(match2) {
        var weekdayStr = match2[1], dayStr = match2[2], monthStr = match2[3], yearStr = match2[4], hourStr = match2[5], minuteStr = match2[6], secondStr = match2[7], obsOffset = match2[8], milOffset = match2[9], offHourStr = match2[10], offMinuteStr = match2[11], result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
        var offset3;
        if (obsOffset) {
          offset3 = obsOffsets[obsOffset];
        } else if (milOffset) {
          offset3 = 0;
        } else {
          offset3 = signedOffset(offHourStr, offMinuteStr);
        }
        return [result, new FixedOffsetZone(offset3)];
      }
      function preprocessRFC2822(s3) {
        return s3.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
      }
      var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
      var rfc850 = /^(Monday|Tuesday|Wedsday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
      var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
      function extractRFC1123Or850(match2) {
        var weekdayStr = match2[1], dayStr = match2[2], monthStr = match2[3], yearStr = match2[4], hourStr = match2[5], minuteStr = match2[6], secondStr = match2[7], result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
        return [result, FixedOffsetZone.utcInstance];
      }
      function extractASCII(match2) {
        var weekdayStr = match2[1], monthStr = match2[2], dayStr = match2[3], hourStr = match2[4], minuteStr = match2[5], secondStr = match2[6], yearStr = match2[7], result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
        return [result, FixedOffsetZone.utcInstance];
      }
      var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
      var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
      var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
      var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
      var extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset);
      var extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset);
      var extractISOOrdinalDataAndTime = combineExtractors(extractISOOrdinalData, extractISOTime);
      var extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset);
      function parseISODate(s3) {
        return parse(s3, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDataAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);
      }
      function parseRFC2822Date(s3) {
        return parse(preprocessRFC2822(s3), [rfc2822, extractRFC2822]);
      }
      function parseHTTPDate(s3) {
        return parse(s3, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);
      }
      function parseISODuration(s3) {
        return parse(s3, [isoDuration, extractISODuration]);
      }
      var extractISOTimeOnly = combineExtractors(extractISOTime);
      function parseISOTimeOnly(s3) {
        return parse(s3, [isoTimeOnly, extractISOTimeOnly]);
      }
      var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
      var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
      var extractISOYmdTimeOffsetAndIANAZone = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
      var extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
      function parseSQL(s3) {
        return parse(s3, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeOffsetAndIANAZone], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);
      }
      var INVALID = "Invalid Duration";
      var lowOrderMatrix = {
        weeks: {
          days: 7,
          hours: 7 * 24,
          minutes: 7 * 24 * 60,
          seconds: 7 * 24 * 60 * 60,
          milliseconds: 7 * 24 * 60 * 60 * 1e3
        },
        days: {
          hours: 24,
          minutes: 24 * 60,
          seconds: 24 * 60 * 60,
          milliseconds: 24 * 60 * 60 * 1e3
        },
        hours: {
          minutes: 60,
          seconds: 60 * 60,
          milliseconds: 60 * 60 * 1e3
        },
        minutes: {
          seconds: 60,
          milliseconds: 60 * 1e3
        },
        seconds: {
          milliseconds: 1e3
        }
      };
      var casualMatrix = Object.assign({
        years: {
          quarters: 4,
          months: 12,
          weeks: 52,
          days: 365,
          hours: 365 * 24,
          minutes: 365 * 24 * 60,
          seconds: 365 * 24 * 60 * 60,
          milliseconds: 365 * 24 * 60 * 60 * 1e3
        },
        quarters: {
          months: 3,
          weeks: 13,
          days: 91,
          hours: 91 * 24,
          minutes: 91 * 24 * 60,
          seconds: 91 * 24 * 60 * 60,
          milliseconds: 91 * 24 * 60 * 60 * 1e3
        },
        months: {
          weeks: 4,
          days: 30,
          hours: 30 * 24,
          minutes: 30 * 24 * 60,
          seconds: 30 * 24 * 60 * 60,
          milliseconds: 30 * 24 * 60 * 60 * 1e3
        }
      }, lowOrderMatrix);
      var daysInYearAccurate = 146097 / 400;
      var daysInMonthAccurate = 146097 / 4800;
      var accurateMatrix = Object.assign({
        years: {
          quarters: 4,
          months: 12,
          weeks: daysInYearAccurate / 7,
          days: daysInYearAccurate,
          hours: daysInYearAccurate * 24,
          minutes: daysInYearAccurate * 24 * 60,
          seconds: daysInYearAccurate * 24 * 60 * 60,
          milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
        },
        quarters: {
          months: 3,
          weeks: daysInYearAccurate / 28,
          days: daysInYearAccurate / 4,
          hours: daysInYearAccurate * 24 / 4,
          minutes: daysInYearAccurate * 24 * 60 / 4,
          seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
          milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
        },
        months: {
          weeks: daysInMonthAccurate / 7,
          days: daysInMonthAccurate,
          hours: daysInMonthAccurate * 24,
          minutes: daysInMonthAccurate * 24 * 60,
          seconds: daysInMonthAccurate * 24 * 60 * 60,
          milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
        }
      }, lowOrderMatrix);
      var orderedUnits = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"];
      var reverseUnits = orderedUnits.slice(0).reverse();
      function clone(dur, alts, clear) {
        if (clear === void 0) {
          clear = false;
        }
        var conf = {
          values: clear ? alts.values : Object.assign({}, dur.values, alts.values || {}),
          loc: dur.loc.clone(alts.loc),
          conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy
        };
        return new Duration(conf);
      }
      function antiTrunc(n3) {
        return n3 < 0 ? Math.floor(n3) : Math.ceil(n3);
      }
      function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
        var conv = matrix[toUnit][fromUnit], raw = fromMap[fromUnit] / conv, sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]), added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
        toMap[toUnit] += added;
        fromMap[fromUnit] -= added * conv;
      }
      function normalizeValues(matrix, vals) {
        reverseUnits.reduce(function(previous, current) {
          if (!isUndefined(vals[current])) {
            if (previous) {
              convert(matrix, vals, previous, vals, current);
            }
            return current;
          } else {
            return previous;
          }
        }, null);
      }
      var Duration = /* @__PURE__ */ function() {
        function Duration2(config) {
          var accurate = config.conversionAccuracy === "longterm" || false;
          this.values = config.values;
          this.loc = config.loc || Locale.create();
          this.conversionAccuracy = accurate ? "longterm" : "casual";
          this.invalid = config.invalid || null;
          this.matrix = accurate ? accurateMatrix : casualMatrix;
          this.isLuxonDuration = true;
        }
        Duration2.fromMillis = function fromMillis(count, opts) {
          return Duration2.fromObject(Object.assign({
            milliseconds: count
          }, opts));
        };
        Duration2.fromObject = function fromObject(obj) {
          if (obj == null || typeof obj !== "object") {
            throw new InvalidArgumentError("Duration.fromObject: argument expected to be an object, got " + (obj === null ? "null" : typeof obj));
          }
          return new Duration2({
            values: normalizeObject(obj, Duration2.normalizeUnit, [
              "locale",
              "numberingSystem",
              "conversionAccuracy",
              "zone"
            ]),
            loc: Locale.fromObject(obj),
            conversionAccuracy: obj.conversionAccuracy
          });
        };
        Duration2.fromISO = function fromISO(text, opts) {
          var _parseISODuration = parseISODuration(text), parsed = _parseISODuration[0];
          if (parsed) {
            var obj = Object.assign(parsed, opts);
            return Duration2.fromObject(obj);
          } else {
            return Duration2.invalid("unparsable", 'the input "' + text + `" can't be parsed as ISO 8601`);
          }
        };
        Duration2.fromISOTime = function fromISOTime(text, opts) {
          var _parseISOTimeOnly = parseISOTimeOnly(text), parsed = _parseISOTimeOnly[0];
          if (parsed) {
            var obj = Object.assign(parsed, opts);
            return Duration2.fromObject(obj);
          } else {
            return Duration2.invalid("unparsable", 'the input "' + text + `" can't be parsed as ISO 8601`);
          }
        };
        Duration2.invalid = function invalid(reason, explanation) {
          if (explanation === void 0) {
            explanation = null;
          }
          if (!reason) {
            throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
          }
          var invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
          if (Settings.throwOnInvalid) {
            throw new InvalidDurationError(invalid2);
          } else {
            return new Duration2({
              invalid: invalid2
            });
          }
        };
        Duration2.normalizeUnit = function normalizeUnit2(unit) {
          var normalized = {
            year: "years",
            years: "years",
            quarter: "quarters",
            quarters: "quarters",
            month: "months",
            months: "months",
            week: "weeks",
            weeks: "weeks",
            day: "days",
            days: "days",
            hour: "hours",
            hours: "hours",
            minute: "minutes",
            minutes: "minutes",
            second: "seconds",
            seconds: "seconds",
            millisecond: "milliseconds",
            milliseconds: "milliseconds"
          }[unit ? unit.toLowerCase() : unit];
          if (!normalized)
            throw new InvalidUnitError(unit);
          return normalized;
        };
        Duration2.isDuration = function isDuration(o2) {
          return o2 && o2.isLuxonDuration || false;
        };
        var _proto = Duration2.prototype;
        _proto.toFormat = function toFormat(fmt, opts) {
          if (opts === void 0) {
            opts = {};
          }
          var fmtOpts = Object.assign({}, opts, {
            floor: opts.round !== false && opts.floor !== false
          });
          return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID;
        };
        _proto.toObject = function toObject(opts) {
          if (opts === void 0) {
            opts = {};
          }
          if (!this.isValid)
            return {};
          var base = Object.assign({}, this.values);
          if (opts.includeConfig) {
            base.conversionAccuracy = this.conversionAccuracy;
            base.numberingSystem = this.loc.numberingSystem;
            base.locale = this.loc.locale;
          }
          return base;
        };
        _proto.toISO = function toISO() {
          if (!this.isValid)
            return null;
          var s3 = "P";
          if (this.years !== 0)
            s3 += this.years + "Y";
          if (this.months !== 0 || this.quarters !== 0)
            s3 += this.months + this.quarters * 3 + "M";
          if (this.weeks !== 0)
            s3 += this.weeks + "W";
          if (this.days !== 0)
            s3 += this.days + "D";
          if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
            s3 += "T";
          if (this.hours !== 0)
            s3 += this.hours + "H";
          if (this.minutes !== 0)
            s3 += this.minutes + "M";
          if (this.seconds !== 0 || this.milliseconds !== 0)
            s3 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
          if (s3 === "P")
            s3 += "T0S";
          return s3;
        };
        _proto.toISOTime = function toISOTime(opts) {
          if (opts === void 0) {
            opts = {};
          }
          if (!this.isValid)
            return null;
          var millis = this.toMillis();
          if (millis < 0 || millis >= 864e5)
            return null;
          opts = Object.assign({
            suppressMilliseconds: false,
            suppressSeconds: false,
            includePrefix: false,
            format: "extended"
          }, opts);
          var value = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
          var fmt = opts.format === "basic" ? "hhmm" : "hh:mm";
          if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {
            fmt += opts.format === "basic" ? "ss" : ":ss";
            if (!opts.suppressMilliseconds || value.milliseconds !== 0) {
              fmt += ".SSS";
            }
          }
          var str = value.toFormat(fmt);
          if (opts.includePrefix) {
            str = "T" + str;
          }
          return str;
        };
        _proto.toJSON = function toJSON() {
          return this.toISO();
        };
        _proto.toString = function toString() {
          return this.toISO();
        };
        _proto.toMillis = function toMillis() {
          return this.as("milliseconds");
        };
        _proto.valueOf = function valueOf() {
          return this.toMillis();
        };
        _proto.plus = function plus(duration2) {
          if (!this.isValid)
            return this;
          var dur = friendlyDuration(duration2), result = {};
          for (var _iterator = _createForOfIteratorHelperLoose(orderedUnits), _step; !(_step = _iterator()).done; ) {
            var k2 = _step.value;
            if (hasOwnProperty2(dur.values, k2) || hasOwnProperty2(this.values, k2)) {
              result[k2] = dur.get(k2) + this.get(k2);
            }
          }
          return clone(this, {
            values: result
          }, true);
        };
        _proto.minus = function minus(duration2) {
          if (!this.isValid)
            return this;
          var dur = friendlyDuration(duration2);
          return this.plus(dur.negate());
        };
        _proto.mapUnits = function mapUnits(fn2) {
          if (!this.isValid)
            return this;
          var result = {};
          for (var _i = 0, _Object$keys = Object.keys(this.values); _i < _Object$keys.length; _i++) {
            var k2 = _Object$keys[_i];
            result[k2] = asNumber(fn2(this.values[k2], k2));
          }
          return clone(this, {
            values: result
          }, true);
        };
        _proto.get = function get(unit) {
          return this[Duration2.normalizeUnit(unit)];
        };
        _proto.set = function set(values) {
          if (!this.isValid)
            return this;
          var mixed = Object.assign(this.values, normalizeObject(values, Duration2.normalizeUnit, []));
          return clone(this, {
            values: mixed
          });
        };
        _proto.reconfigure = function reconfigure(_temp) {
          var _ref = _temp === void 0 ? {} : _temp, locale = _ref.locale, numberingSystem = _ref.numberingSystem, conversionAccuracy = _ref.conversionAccuracy;
          var loc = this.loc.clone({
            locale,
            numberingSystem
          }), opts = {
            loc
          };
          if (conversionAccuracy) {
            opts.conversionAccuracy = conversionAccuracy;
          }
          return clone(this, opts);
        };
        _proto.as = function as(unit) {
          return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
        };
        _proto.normalize = function normalize() {
          if (!this.isValid)
            return this;
          var vals = this.toObject();
          normalizeValues(this.matrix, vals);
          return clone(this, {
            values: vals
          }, true);
        };
        _proto.shiftTo = function shiftTo() {
          for (var _len = arguments.length, units = new Array(_len), _key = 0; _key < _len; _key++) {
            units[_key] = arguments[_key];
          }
          if (!this.isValid)
            return this;
          if (units.length === 0) {
            return this;
          }
          units = units.map(function(u2) {
            return Duration2.normalizeUnit(u2);
          });
          var built = {}, accumulated = {}, vals = this.toObject();
          var lastUnit;
          for (var _iterator2 = _createForOfIteratorHelperLoose(orderedUnits), _step2; !(_step2 = _iterator2()).done; ) {
            var k2 = _step2.value;
            if (units.indexOf(k2) >= 0) {
              lastUnit = k2;
              var own = 0;
              for (var ak in accumulated) {
                own += this.matrix[ak][k2] * accumulated[ak];
                accumulated[ak] = 0;
              }
              if (isNumber(vals[k2])) {
                own += vals[k2];
              }
              var i2 = Math.trunc(own);
              built[k2] = i2;
              accumulated[k2] = own - i2;
              for (var down in vals) {
                if (orderedUnits.indexOf(down) > orderedUnits.indexOf(k2)) {
                  convert(this.matrix, vals, down, built, k2);
                }
              }
            } else if (isNumber(vals[k2])) {
              accumulated[k2] = vals[k2];
            }
          }
          for (var key in accumulated) {
            if (accumulated[key] !== 0) {
              built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
            }
          }
          return clone(this, {
            values: built
          }, true).normalize();
        };
        _proto.negate = function negate() {
          if (!this.isValid)
            return this;
          var negated = {};
          for (var _i2 = 0, _Object$keys2 = Object.keys(this.values); _i2 < _Object$keys2.length; _i2++) {
            var k2 = _Object$keys2[_i2];
            negated[k2] = -this.values[k2];
          }
          return clone(this, {
            values: negated
          }, true);
        };
        _proto.equals = function equals(other) {
          if (!this.isValid || !other.isValid) {
            return false;
          }
          if (!this.loc.equals(other.loc)) {
            return false;
          }
          function eq(v1, v2) {
            if (v1 === void 0 || v1 === 0)
              return v2 === void 0 || v2 === 0;
            return v1 === v2;
          }
          for (var _iterator3 = _createForOfIteratorHelperLoose(orderedUnits), _step3; !(_step3 = _iterator3()).done; ) {
            var u2 = _step3.value;
            if (!eq(this.values[u2], other.values[u2])) {
              return false;
            }
          }
          return true;
        };
        _createClass(Duration2, [{
          key: "locale",
          get: function get() {
            return this.isValid ? this.loc.locale : null;
          }
        }, {
          key: "numberingSystem",
          get: function get() {
            return this.isValid ? this.loc.numberingSystem : null;
          }
        }, {
          key: "years",
          get: function get() {
            return this.isValid ? this.values.years || 0 : NaN;
          }
        }, {
          key: "quarters",
          get: function get() {
            return this.isValid ? this.values.quarters || 0 : NaN;
          }
        }, {
          key: "months",
          get: function get() {
            return this.isValid ? this.values.months || 0 : NaN;
          }
        }, {
          key: "weeks",
          get: function get() {
            return this.isValid ? this.values.weeks || 0 : NaN;
          }
        }, {
          key: "days",
          get: function get() {
            return this.isValid ? this.values.days || 0 : NaN;
          }
        }, {
          key: "hours",
          get: function get() {
            return this.isValid ? this.values.hours || 0 : NaN;
          }
        }, {
          key: "minutes",
          get: function get() {
            return this.isValid ? this.values.minutes || 0 : NaN;
          }
        }, {
          key: "seconds",
          get: function get() {
            return this.isValid ? this.values.seconds || 0 : NaN;
          }
        }, {
          key: "milliseconds",
          get: function get() {
            return this.isValid ? this.values.milliseconds || 0 : NaN;
          }
        }, {
          key: "isValid",
          get: function get() {
            return this.invalid === null;
          }
        }, {
          key: "invalidReason",
          get: function get() {
            return this.invalid ? this.invalid.reason : null;
          }
        }, {
          key: "invalidExplanation",
          get: function get() {
            return this.invalid ? this.invalid.explanation : null;
          }
        }]);
        return Duration2;
      }();
      function friendlyDuration(durationish) {
        if (isNumber(durationish)) {
          return Duration.fromMillis(durationish);
        } else if (Duration.isDuration(durationish)) {
          return durationish;
        } else if (typeof durationish === "object") {
          return Duration.fromObject(durationish);
        } else {
          throw new InvalidArgumentError("Unknown duration argument " + durationish + " of type " + typeof durationish);
        }
      }
      var INVALID$1 = "Invalid Interval";
      function validateStartEnd(start4, end2) {
        if (!start4 || !start4.isValid) {
          return Interval.invalid("missing or invalid start");
        } else if (!end2 || !end2.isValid) {
          return Interval.invalid("missing or invalid end");
        } else if (end2 < start4) {
          return Interval.invalid("end before start", "The end of an interval must be after its start, but you had start=" + start4.toISO() + " and end=" + end2.toISO());
        } else {
          return null;
        }
      }
      var Interval = /* @__PURE__ */ function() {
        function Interval2(config) {
          this.s = config.start;
          this.e = config.end;
          this.invalid = config.invalid || null;
          this.isLuxonInterval = true;
        }
        Interval2.invalid = function invalid(reason, explanation) {
          if (explanation === void 0) {
            explanation = null;
          }
          if (!reason) {
            throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
          }
          var invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
          if (Settings.throwOnInvalid) {
            throw new InvalidIntervalError(invalid2);
          } else {
            return new Interval2({
              invalid: invalid2
            });
          }
        };
        Interval2.fromDateTimes = function fromDateTimes(start4, end2) {
          var builtStart = friendlyDateTime(start4), builtEnd = friendlyDateTime(end2);
          var validateError = validateStartEnd(builtStart, builtEnd);
          if (validateError == null) {
            return new Interval2({
              start: builtStart,
              end: builtEnd
            });
          } else {
            return validateError;
          }
        };
        Interval2.after = function after(start4, duration2) {
          var dur = friendlyDuration(duration2), dt = friendlyDateTime(start4);
          return Interval2.fromDateTimes(dt, dt.plus(dur));
        };
        Interval2.before = function before(end2, duration2) {
          var dur = friendlyDuration(duration2), dt = friendlyDateTime(end2);
          return Interval2.fromDateTimes(dt.minus(dur), dt);
        };
        Interval2.fromISO = function fromISO(text, opts) {
          var _split = (text || "").split("/", 2), s3 = _split[0], e2 = _split[1];
          if (s3 && e2) {
            var start4, startIsValid;
            try {
              start4 = DateTime2.fromISO(s3, opts);
              startIsValid = start4.isValid;
            } catch (e3) {
              startIsValid = false;
            }
            var end2, endIsValid;
            try {
              end2 = DateTime2.fromISO(e2, opts);
              endIsValid = end2.isValid;
            } catch (e3) {
              endIsValid = false;
            }
            if (startIsValid && endIsValid) {
              return Interval2.fromDateTimes(start4, end2);
            }
            if (startIsValid) {
              var dur = Duration.fromISO(e2, opts);
              if (dur.isValid) {
                return Interval2.after(start4, dur);
              }
            } else if (endIsValid) {
              var _dur = Duration.fromISO(s3, opts);
              if (_dur.isValid) {
                return Interval2.before(end2, _dur);
              }
            }
          }
          return Interval2.invalid("unparsable", 'the input "' + text + `" can't be parsed as ISO 8601`);
        };
        Interval2.isInterval = function isInterval(o2) {
          return o2 && o2.isLuxonInterval || false;
        };
        var _proto = Interval2.prototype;
        _proto.length = function length(unit) {
          if (unit === void 0) {
            unit = "milliseconds";
          }
          return this.isValid ? this.toDuration.apply(this, [unit]).get(unit) : NaN;
        };
        _proto.count = function count(unit) {
          if (unit === void 0) {
            unit = "milliseconds";
          }
          if (!this.isValid)
            return NaN;
          var start4 = this.start.startOf(unit), end2 = this.end.startOf(unit);
          return Math.floor(end2.diff(start4, unit).get(unit)) + 1;
        };
        _proto.hasSame = function hasSame(unit) {
          return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
        };
        _proto.isEmpty = function isEmpty() {
          return this.s.valueOf() === this.e.valueOf();
        };
        _proto.isAfter = function isAfter(dateTime) {
          if (!this.isValid)
            return false;
          return this.s > dateTime;
        };
        _proto.isBefore = function isBefore(dateTime) {
          if (!this.isValid)
            return false;
          return this.e <= dateTime;
        };
        _proto.contains = function contains2(dateTime) {
          if (!this.isValid)
            return false;
          return this.s <= dateTime && this.e > dateTime;
        };
        _proto.set = function set(_temp) {
          var _ref = _temp === void 0 ? {} : _temp, start4 = _ref.start, end2 = _ref.end;
          if (!this.isValid)
            return this;
          return Interval2.fromDateTimes(start4 || this.s, end2 || this.e);
        };
        _proto.splitAt = function splitAt() {
          var _this = this;
          if (!this.isValid)
            return [];
          for (var _len = arguments.length, dateTimes = new Array(_len), _key = 0; _key < _len; _key++) {
            dateTimes[_key] = arguments[_key];
          }
          var sorted = dateTimes.map(friendlyDateTime).filter(function(d2) {
            return _this.contains(d2);
          }).sort(), results = [];
          var s3 = this.s, i2 = 0;
          while (s3 < this.e) {
            var added = sorted[i2] || this.e, next = +added > +this.e ? this.e : added;
            results.push(Interval2.fromDateTimes(s3, next));
            s3 = next;
            i2 += 1;
          }
          return results;
        };
        _proto.splitBy = function splitBy(duration2) {
          var dur = friendlyDuration(duration2);
          if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
            return [];
          }
          var s3 = this.s, added, next;
          var results = [];
          while (s3 < this.e) {
            added = s3.plus(dur);
            next = +added > +this.e ? this.e : added;
            results.push(Interval2.fromDateTimes(s3, next));
            s3 = next;
          }
          return results;
        };
        _proto.divideEqually = function divideEqually(numberOfParts) {
          if (!this.isValid)
            return [];
          return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
        };
        _proto.overlaps = function overlaps(other) {
          return this.e > other.s && this.s < other.e;
        };
        _proto.abutsStart = function abutsStart(other) {
          if (!this.isValid)
            return false;
          return +this.e === +other.s;
        };
        _proto.abutsEnd = function abutsEnd(other) {
          if (!this.isValid)
            return false;
          return +other.e === +this.s;
        };
        _proto.engulfs = function engulfs(other) {
          if (!this.isValid)
            return false;
          return this.s <= other.s && this.e >= other.e;
        };
        _proto.equals = function equals(other) {
          if (!this.isValid || !other.isValid) {
            return false;
          }
          return this.s.equals(other.s) && this.e.equals(other.e);
        };
        _proto.intersection = function intersection(other) {
          if (!this.isValid)
            return this;
          var s3 = this.s > other.s ? this.s : other.s, e2 = this.e < other.e ? this.e : other.e;
          if (s3 > e2) {
            return null;
          } else {
            return Interval2.fromDateTimes(s3, e2);
          }
        };
        _proto.union = function union(other) {
          if (!this.isValid)
            return this;
          var s3 = this.s < other.s ? this.s : other.s, e2 = this.e > other.e ? this.e : other.e;
          return Interval2.fromDateTimes(s3, e2);
        };
        Interval2.merge = function merge(intervals) {
          var _intervals$sort$reduc = intervals.sort(function(a2, b2) {
            return a2.s - b2.s;
          }).reduce(function(_ref2, item) {
            var sofar = _ref2[0], current = _ref2[1];
            if (!current) {
              return [sofar, item];
            } else if (current.overlaps(item) || current.abutsStart(item)) {
              return [sofar, current.union(item)];
            } else {
              return [sofar.concat([current]), item];
            }
          }, [[], null]), found = _intervals$sort$reduc[0], final = _intervals$sort$reduc[1];
          if (final) {
            found.push(final);
          }
          return found;
        };
        Interval2.xor = function xor(intervals) {
          var _Array$prototype;
          var start4 = null, currentCount = 0;
          var results = [], ends = intervals.map(function(i3) {
            return [{
              time: i3.s,
              type: "s"
            }, {
              time: i3.e,
              type: "e"
            }];
          }), flattened = (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, ends), arr = flattened.sort(function(a2, b2) {
            return a2.time - b2.time;
          });
          for (var _iterator = _createForOfIteratorHelperLoose(arr), _step; !(_step = _iterator()).done; ) {
            var i2 = _step.value;
            currentCount += i2.type === "s" ? 1 : -1;
            if (currentCount === 1) {
              start4 = i2.time;
            } else {
              if (start4 && +start4 !== +i2.time) {
                results.push(Interval2.fromDateTimes(start4, i2.time));
              }
              start4 = null;
            }
          }
          return Interval2.merge(results);
        };
        _proto.difference = function difference() {
          var _this2 = this;
          for (var _len2 = arguments.length, intervals = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            intervals[_key2] = arguments[_key2];
          }
          return Interval2.xor([this].concat(intervals)).map(function(i2) {
            return _this2.intersection(i2);
          }).filter(function(i2) {
            return i2 && !i2.isEmpty();
          });
        };
        _proto.toString = function toString() {
          if (!this.isValid)
            return INVALID$1;
          return "[" + this.s.toISO() + " \u2013 " + this.e.toISO() + ")";
        };
        _proto.toISO = function toISO(opts) {
          if (!this.isValid)
            return INVALID$1;
          return this.s.toISO(opts) + "/" + this.e.toISO(opts);
        };
        _proto.toISODate = function toISODate() {
          if (!this.isValid)
            return INVALID$1;
          return this.s.toISODate() + "/" + this.e.toISODate();
        };
        _proto.toISOTime = function toISOTime(opts) {
          if (!this.isValid)
            return INVALID$1;
          return this.s.toISOTime(opts) + "/" + this.e.toISOTime(opts);
        };
        _proto.toFormat = function toFormat(dateFormat, _temp2) {
          var _ref3 = _temp2 === void 0 ? {} : _temp2, _ref3$separator = _ref3.separator, separator = _ref3$separator === void 0 ? " \u2013 " : _ref3$separator;
          if (!this.isValid)
            return INVALID$1;
          return "" + this.s.toFormat(dateFormat) + separator + this.e.toFormat(dateFormat);
        };
        _proto.toDuration = function toDuration(unit, opts) {
          if (!this.isValid) {
            return Duration.invalid(this.invalidReason);
          }
          return this.e.diff(this.s, unit, opts);
        };
        _proto.mapEndpoints = function mapEndpoints(mapFn) {
          return Interval2.fromDateTimes(mapFn(this.s), mapFn(this.e));
        };
        _createClass(Interval2, [{
          key: "start",
          get: function get() {
            return this.isValid ? this.s : null;
          }
        }, {
          key: "end",
          get: function get() {
            return this.isValid ? this.e : null;
          }
        }, {
          key: "isValid",
          get: function get() {
            return this.invalidReason === null;
          }
        }, {
          key: "invalidReason",
          get: function get() {
            return this.invalid ? this.invalid.reason : null;
          }
        }, {
          key: "invalidExplanation",
          get: function get() {
            return this.invalid ? this.invalid.explanation : null;
          }
        }]);
        return Interval2;
      }();
      var Info = /* @__PURE__ */ function() {
        function Info2() {
        }
        Info2.hasDST = function hasDST(zone) {
          if (zone === void 0) {
            zone = Settings.defaultZone;
          }
          var proto = DateTime2.now().setZone(zone).set({
            month: 12
          });
          return !zone.universal && proto.offset !== proto.set({
            month: 6
          }).offset;
        };
        Info2.isValidIANAZone = function isValidIANAZone(zone) {
          return IANAZone.isValidSpecifier(zone) && IANAZone.isValidZone(zone);
        };
        Info2.normalizeZone = function normalizeZone$1(input) {
          return normalizeZone(input, Settings.defaultZone);
        };
        Info2.months = function months2(length, _temp) {
          if (length === void 0) {
            length = "long";
          }
          var _ref = _temp === void 0 ? {} : _temp, _ref$locale = _ref.locale, locale = _ref$locale === void 0 ? null : _ref$locale, _ref$numberingSystem = _ref.numberingSystem, numberingSystem = _ref$numberingSystem === void 0 ? null : _ref$numberingSystem, _ref$outputCalendar = _ref.outputCalendar, outputCalendar = _ref$outputCalendar === void 0 ? "gregory" : _ref$outputCalendar;
          return Locale.create(locale, numberingSystem, outputCalendar).months(length);
        };
        Info2.monthsFormat = function monthsFormat(length, _temp2) {
          if (length === void 0) {
            length = "long";
          }
          var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$locale = _ref2.locale, locale = _ref2$locale === void 0 ? null : _ref2$locale, _ref2$numberingSystem = _ref2.numberingSystem, numberingSystem = _ref2$numberingSystem === void 0 ? null : _ref2$numberingSystem, _ref2$outputCalendar = _ref2.outputCalendar, outputCalendar = _ref2$outputCalendar === void 0 ? "gregory" : _ref2$outputCalendar;
          return Locale.create(locale, numberingSystem, outputCalendar).months(length, true);
        };
        Info2.weekdays = function weekdays2(length, _temp3) {
          if (length === void 0) {
            length = "long";
          }
          var _ref3 = _temp3 === void 0 ? {} : _temp3, _ref3$locale = _ref3.locale, locale = _ref3$locale === void 0 ? null : _ref3$locale, _ref3$numberingSystem = _ref3.numberingSystem, numberingSystem = _ref3$numberingSystem === void 0 ? null : _ref3$numberingSystem;
          return Locale.create(locale, numberingSystem, null).weekdays(length);
        };
        Info2.weekdaysFormat = function weekdaysFormat(length, _temp4) {
          if (length === void 0) {
            length = "long";
          }
          var _ref4 = _temp4 === void 0 ? {} : _temp4, _ref4$locale = _ref4.locale, locale = _ref4$locale === void 0 ? null : _ref4$locale, _ref4$numberingSystem = _ref4.numberingSystem, numberingSystem = _ref4$numberingSystem === void 0 ? null : _ref4$numberingSystem;
          return Locale.create(locale, numberingSystem, null).weekdays(length, true);
        };
        Info2.meridiems = function meridiems2(_temp5) {
          var _ref5 = _temp5 === void 0 ? {} : _temp5, _ref5$locale = _ref5.locale, locale = _ref5$locale === void 0 ? null : _ref5$locale;
          return Locale.create(locale).meridiems();
        };
        Info2.eras = function eras2(length, _temp6) {
          if (length === void 0) {
            length = "short";
          }
          var _ref6 = _temp6 === void 0 ? {} : _temp6, _ref6$locale = _ref6.locale, locale = _ref6$locale === void 0 ? null : _ref6$locale;
          return Locale.create(locale, null, "gregory").eras(length);
        };
        Info2.features = function features() {
          var intl = false, intlTokens = false, zones = false, relative = false;
          if (hasIntl()) {
            intl = true;
            intlTokens = hasFormatToParts();
            relative = hasRelative();
            try {
              zones = new Intl.DateTimeFormat("en", {
                timeZone: "America/New_York"
              }).resolvedOptions().timeZone === "America/New_York";
            } catch (e2) {
              zones = false;
            }
          }
          return {
            intl,
            intlTokens,
            zones,
            relative
          };
        };
        return Info2;
      }();
      function dayDiff(earlier, later) {
        var utcDayStart = function utcDayStart2(dt) {
          return dt.toUTC(0, {
            keepLocalTime: true
          }).startOf("day").valueOf();
        }, ms = utcDayStart(later) - utcDayStart(earlier);
        return Math.floor(Duration.fromMillis(ms).as("days"));
      }
      function highOrderDiffs(cursor, later, units) {
        var differs = [["years", function(a2, b2) {
          return b2.year - a2.year;
        }], ["quarters", function(a2, b2) {
          return b2.quarter - a2.quarter;
        }], ["months", function(a2, b2) {
          return b2.month - a2.month + (b2.year - a2.year) * 12;
        }], ["weeks", function(a2, b2) {
          var days = dayDiff(a2, b2);
          return (days - days % 7) / 7;
        }], ["days", dayDiff]];
        var results = {};
        var lowestOrder, highWater;
        for (var _i = 0, _differs = differs; _i < _differs.length; _i++) {
          var _differs$_i = _differs[_i], unit = _differs$_i[0], differ = _differs$_i[1];
          if (units.indexOf(unit) >= 0) {
            var _cursor$plus;
            lowestOrder = unit;
            var delta = differ(cursor, later);
            highWater = cursor.plus((_cursor$plus = {}, _cursor$plus[unit] = delta, _cursor$plus));
            if (highWater > later) {
              var _cursor$plus2;
              cursor = cursor.plus((_cursor$plus2 = {}, _cursor$plus2[unit] = delta - 1, _cursor$plus2));
              delta -= 1;
            } else {
              cursor = highWater;
            }
            results[unit] = delta;
          }
        }
        return [cursor, results, highWater, lowestOrder];
      }
      function _diff(earlier, later, units, opts) {
        var _highOrderDiffs = highOrderDiffs(earlier, later, units), cursor = _highOrderDiffs[0], results = _highOrderDiffs[1], highWater = _highOrderDiffs[2], lowestOrder = _highOrderDiffs[3];
        var remainingMillis = later - cursor;
        var lowerOrderUnits = units.filter(function(u2) {
          return ["hours", "minutes", "seconds", "milliseconds"].indexOf(u2) >= 0;
        });
        if (lowerOrderUnits.length === 0) {
          if (highWater < later) {
            var _cursor$plus3;
            highWater = cursor.plus((_cursor$plus3 = {}, _cursor$plus3[lowestOrder] = 1, _cursor$plus3));
          }
          if (highWater !== cursor) {
            results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
          }
        }
        var duration2 = Duration.fromObject(Object.assign(results, opts));
        if (lowerOrderUnits.length > 0) {
          var _Duration$fromMillis;
          return (_Duration$fromMillis = Duration.fromMillis(remainingMillis, opts)).shiftTo.apply(_Duration$fromMillis, lowerOrderUnits).plus(duration2);
        } else {
          return duration2;
        }
      }
      var numberingSystems = {
        arab: "[\u0660-\u0669]",
        arabext: "[\u06F0-\u06F9]",
        bali: "[\u1B50-\u1B59]",
        beng: "[\u09E6-\u09EF]",
        deva: "[\u0966-\u096F]",
        fullwide: "[\uFF10-\uFF19]",
        gujr: "[\u0AE6-\u0AEF]",
        hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
        khmr: "[\u17E0-\u17E9]",
        knda: "[\u0CE6-\u0CEF]",
        laoo: "[\u0ED0-\u0ED9]",
        limb: "[\u1946-\u194F]",
        mlym: "[\u0D66-\u0D6F]",
        mong: "[\u1810-\u1819]",
        mymr: "[\u1040-\u1049]",
        orya: "[\u0B66-\u0B6F]",
        tamldec: "[\u0BE6-\u0BEF]",
        telu: "[\u0C66-\u0C6F]",
        thai: "[\u0E50-\u0E59]",
        tibt: "[\u0F20-\u0F29]",
        latn: "\\d"
      };
      var numberingSystemsUTF16 = {
        arab: [1632, 1641],
        arabext: [1776, 1785],
        bali: [6992, 7001],
        beng: [2534, 2543],
        deva: [2406, 2415],
        fullwide: [65296, 65303],
        gujr: [2790, 2799],
        khmr: [6112, 6121],
        knda: [3302, 3311],
        laoo: [3792, 3801],
        limb: [6470, 6479],
        mlym: [3430, 3439],
        mong: [6160, 6169],
        mymr: [4160, 4169],
        orya: [2918, 2927],
        tamldec: [3046, 3055],
        telu: [3174, 3183],
        thai: [3664, 3673],
        tibt: [3872, 3881]
      };
      var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
      function parseDigits(str) {
        var value = parseInt(str, 10);
        if (isNaN(value)) {
          value = "";
          for (var i2 = 0; i2 < str.length; i2++) {
            var code3 = str.charCodeAt(i2);
            if (str[i2].search(numberingSystems.hanidec) !== -1) {
              value += hanidecChars.indexOf(str[i2]);
            } else {
              for (var key in numberingSystemsUTF16) {
                var _numberingSystemsUTF = numberingSystemsUTF16[key], min2 = _numberingSystemsUTF[0], max2 = _numberingSystemsUTF[1];
                if (code3 >= min2 && code3 <= max2) {
                  value += code3 - min2;
                }
              }
            }
          }
          return parseInt(value, 10);
        } else {
          return value;
        }
      }
      function digitRegex(_ref, append) {
        var numberingSystem = _ref.numberingSystem;
        if (append === void 0) {
          append = "";
        }
        return new RegExp("" + numberingSystems[numberingSystem || "latn"] + append);
      }
      var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
      function intUnit(regex, post) {
        if (post === void 0) {
          post = function post2(i2) {
            return i2;
          };
        }
        return {
          regex,
          deser: function deser(_ref) {
            var s3 = _ref[0];
            return post(parseDigits(s3));
          }
        };
      }
      var NBSP = String.fromCharCode(160);
      var spaceOrNBSP = "( |" + NBSP + ")";
      var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
      function fixListRegex(s3) {
        return s3.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
      }
      function stripInsensitivities(s3) {
        return s3.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
      }
      function oneOf(strings, startIndex) {
        if (strings === null) {
          return null;
        } else {
          return {
            regex: RegExp(strings.map(fixListRegex).join("|")),
            deser: function deser(_ref2) {
              var s3 = _ref2[0];
              return strings.findIndex(function(i2) {
                return stripInsensitivities(s3) === stripInsensitivities(i2);
              }) + startIndex;
            }
          };
        }
      }
      function offset2(regex, groups) {
        return {
          regex,
          deser: function deser(_ref3) {
            var h = _ref3[1], m2 = _ref3[2];
            return signedOffset(h, m2);
          },
          groups
        };
      }
      function simple(regex) {
        return {
          regex,
          deser: function deser(_ref4) {
            var s3 = _ref4[0];
            return s3;
          }
        };
      }
      function escapeToken(value) {
        return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
      }
      function unitForToken(token, loc) {
        var one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = function literal2(t2) {
          return {
            regex: RegExp(escapeToken(t2.val)),
            deser: function deser(_ref5) {
              var s3 = _ref5[0];
              return s3;
            },
            literal: true
          };
        }, unitate = function unitate2(t2) {
          if (token.literal) {
            return literal(t2);
          }
          switch (t2.val) {
            case "G":
              return oneOf(loc.eras("short", false), 0);
            case "GG":
              return oneOf(loc.eras("long", false), 0);
            case "y":
              return intUnit(oneToSix);
            case "yy":
              return intUnit(twoToFour, untruncateYear);
            case "yyyy":
              return intUnit(four);
            case "yyyyy":
              return intUnit(fourToSix);
            case "yyyyyy":
              return intUnit(six);
            case "M":
              return intUnit(oneOrTwo);
            case "MM":
              return intUnit(two);
            case "MMM":
              return oneOf(loc.months("short", true, false), 1);
            case "MMMM":
              return oneOf(loc.months("long", true, false), 1);
            case "L":
              return intUnit(oneOrTwo);
            case "LL":
              return intUnit(two);
            case "LLL":
              return oneOf(loc.months("short", false, false), 1);
            case "LLLL":
              return oneOf(loc.months("long", false, false), 1);
            case "d":
              return intUnit(oneOrTwo);
            case "dd":
              return intUnit(two);
            case "o":
              return intUnit(oneToThree);
            case "ooo":
              return intUnit(three);
            case "HH":
              return intUnit(two);
            case "H":
              return intUnit(oneOrTwo);
            case "hh":
              return intUnit(two);
            case "h":
              return intUnit(oneOrTwo);
            case "mm":
              return intUnit(two);
            case "m":
              return intUnit(oneOrTwo);
            case "q":
              return intUnit(oneOrTwo);
            case "qq":
              return intUnit(two);
            case "s":
              return intUnit(oneOrTwo);
            case "ss":
              return intUnit(two);
            case "S":
              return intUnit(oneToThree);
            case "SSS":
              return intUnit(three);
            case "u":
              return simple(oneToNine);
            case "a":
              return oneOf(loc.meridiems(), 0);
            case "kkkk":
              return intUnit(four);
            case "kk":
              return intUnit(twoToFour, untruncateYear);
            case "W":
              return intUnit(oneOrTwo);
            case "WW":
              return intUnit(two);
            case "E":
            case "c":
              return intUnit(one);
            case "EEE":
              return oneOf(loc.weekdays("short", false, false), 1);
            case "EEEE":
              return oneOf(loc.weekdays("long", false, false), 1);
            case "ccc":
              return oneOf(loc.weekdays("short", true, false), 1);
            case "cccc":
              return oneOf(loc.weekdays("long", true, false), 1);
            case "Z":
            case "ZZ":
              return offset2(new RegExp("([+-]" + oneOrTwo.source + ")(?::(" + two.source + "))?"), 2);
            case "ZZZ":
              return offset2(new RegExp("([+-]" + oneOrTwo.source + ")(" + two.source + ")?"), 2);
            case "z":
              return simple(/[a-z_+-/]{1,256}?/i);
            default:
              return literal(t2);
          }
        };
        var unit = unitate(token) || {
          invalidReason: MISSING_FTP
        };
        unit.token = token;
        return unit;
      }
      var partTypeStyleToTokenVal = {
        year: {
          "2-digit": "yy",
          numeric: "yyyyy"
        },
        month: {
          numeric: "M",
          "2-digit": "MM",
          short: "MMM",
          long: "MMMM"
        },
        day: {
          numeric: "d",
          "2-digit": "dd"
        },
        weekday: {
          short: "EEE",
          long: "EEEE"
        },
        dayperiod: "a",
        dayPeriod: "a",
        hour: {
          numeric: "h",
          "2-digit": "hh"
        },
        minute: {
          numeric: "m",
          "2-digit": "mm"
        },
        second: {
          numeric: "s",
          "2-digit": "ss"
        }
      };
      function tokenForPart(part, locale, formatOpts) {
        var type = part.type, value = part.value;
        if (type === "literal") {
          return {
            literal: true,
            val: value
          };
        }
        var style = formatOpts[type];
        var val = partTypeStyleToTokenVal[type];
        if (typeof val === "object") {
          val = val[style];
        }
        if (val) {
          return {
            literal: false,
            val
          };
        }
        return void 0;
      }
      function buildRegex(units) {
        var re = units.map(function(u2) {
          return u2.regex;
        }).reduce(function(f2, r2) {
          return f2 + "(" + r2.source + ")";
        }, "");
        return ["^" + re + "$", units];
      }
      function match(input, regex, handlers) {
        var matches = input.match(regex);
        if (matches) {
          var all = {};
          var matchIndex = 1;
          for (var i2 in handlers) {
            if (hasOwnProperty2(handlers, i2)) {
              var h = handlers[i2], groups = h.groups ? h.groups + 1 : 1;
              if (!h.literal && h.token) {
                all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
              }
              matchIndex += groups;
            }
          }
          return [matches, all];
        } else {
          return [matches, {}];
        }
      }
      function dateTimeFromMatches(matches) {
        var toField = function toField2(token) {
          switch (token) {
            case "S":
              return "millisecond";
            case "s":
              return "second";
            case "m":
              return "minute";
            case "h":
            case "H":
              return "hour";
            case "d":
              return "day";
            case "o":
              return "ordinal";
            case "L":
            case "M":
              return "month";
            case "y":
              return "year";
            case "E":
            case "c":
              return "weekday";
            case "W":
              return "weekNumber";
            case "k":
              return "weekYear";
            case "q":
              return "quarter";
            default:
              return null;
          }
        };
        var zone;
        if (!isUndefined(matches.Z)) {
          zone = new FixedOffsetZone(matches.Z);
        } else if (!isUndefined(matches.z)) {
          zone = IANAZone.create(matches.z);
        } else {
          zone = null;
        }
        if (!isUndefined(matches.q)) {
          matches.M = (matches.q - 1) * 3 + 1;
        }
        if (!isUndefined(matches.h)) {
          if (matches.h < 12 && matches.a === 1) {
            matches.h += 12;
          } else if (matches.h === 12 && matches.a === 0) {
            matches.h = 0;
          }
        }
        if (matches.G === 0 && matches.y) {
          matches.y = -matches.y;
        }
        if (!isUndefined(matches.u)) {
          matches.S = parseMillis(matches.u);
        }
        var vals = Object.keys(matches).reduce(function(r2, k2) {
          var f2 = toField(k2);
          if (f2) {
            r2[f2] = matches[k2];
          }
          return r2;
        }, {});
        return [vals, zone];
      }
      var dummyDateTimeCache = null;
      function getDummyDateTime() {
        if (!dummyDateTimeCache) {
          dummyDateTimeCache = DateTime2.fromMillis(1555555555555);
        }
        return dummyDateTimeCache;
      }
      function maybeExpandMacroToken(token, locale) {
        if (token.literal) {
          return token;
        }
        var formatOpts = Formatter.macroTokenToFormatOpts(token.val);
        if (!formatOpts) {
          return token;
        }
        var formatter = Formatter.create(locale, formatOpts);
        var parts = formatter.formatDateTimeParts(getDummyDateTime());
        var tokens = parts.map(function(p2) {
          return tokenForPart(p2, locale, formatOpts);
        });
        if (tokens.includes(void 0)) {
          return token;
        }
        return tokens;
      }
      function expandMacroTokens(tokens, locale) {
        var _Array$prototype;
        return (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, tokens.map(function(t2) {
          return maybeExpandMacroToken(t2, locale);
        }));
      }
      function explainFromTokens(locale, input, format2) {
        var tokens = expandMacroTokens(Formatter.parseFormat(format2), locale), units = tokens.map(function(t2) {
          return unitForToken(t2, locale);
        }), disqualifyingUnit = units.find(function(t2) {
          return t2.invalidReason;
        });
        if (disqualifyingUnit) {
          return {
            input,
            tokens,
            invalidReason: disqualifyingUnit.invalidReason
          };
        } else {
          var _buildRegex = buildRegex(units), regexString = _buildRegex[0], handlers = _buildRegex[1], regex = RegExp(regexString, "i"), _match = match(input, regex, handlers), rawMatches = _match[0], matches = _match[1], _ref6 = matches ? dateTimeFromMatches(matches) : [null, null], result = _ref6[0], zone = _ref6[1];
          if (hasOwnProperty2(matches, "a") && hasOwnProperty2(matches, "H")) {
            throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
          }
          return {
            input,
            tokens,
            regex,
            rawMatches,
            matches,
            result,
            zone
          };
        }
      }
      function parseFromTokens(locale, input, format2) {
        var _explainFromTokens = explainFromTokens(locale, input, format2), result = _explainFromTokens.result, zone = _explainFromTokens.zone, invalidReason = _explainFromTokens.invalidReason;
        return [result, zone, invalidReason];
      }
      var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
      function unitOutOfRange(unit, value) {
        return new Invalid("unit out of range", "you specified " + value + " (of type " + typeof value + ") as a " + unit + ", which is invalid");
      }
      function dayOfWeek(year, month, day) {
        var js = new Date(Date.UTC(year, month - 1, day)).getUTCDay();
        return js === 0 ? 7 : js;
      }
      function computeOrdinal(year, month, day) {
        return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
      }
      function uncomputeOrdinal(year, ordinal) {
        var table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex(function(i2) {
          return i2 < ordinal;
        }), day = ordinal - table[month0];
        return {
          month: month0 + 1,
          day
        };
      }
      function gregorianToWeek(gregObj) {
        var year = gregObj.year, month = gregObj.month, day = gregObj.day, ordinal = computeOrdinal(year, month, day), weekday = dayOfWeek(year, month, day);
        var weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
        if (weekNumber < 1) {
          weekYear = year - 1;
          weekNumber = weeksInWeekYear(weekYear);
        } else if (weekNumber > weeksInWeekYear(year)) {
          weekYear = year + 1;
          weekNumber = 1;
        } else {
          weekYear = year;
        }
        return Object.assign({
          weekYear,
          weekNumber,
          weekday
        }, timeObject(gregObj));
      }
      function weekToGregorian(weekData) {
        var weekYear = weekData.weekYear, weekNumber = weekData.weekNumber, weekday = weekData.weekday, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear(weekYear);
        var ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
        if (ordinal < 1) {
          year = weekYear - 1;
          ordinal += daysInYear(year);
        } else if (ordinal > yearInDays) {
          year = weekYear + 1;
          ordinal -= daysInYear(weekYear);
        } else {
          year = weekYear;
        }
        var _uncomputeOrdinal = uncomputeOrdinal(year, ordinal), month = _uncomputeOrdinal.month, day = _uncomputeOrdinal.day;
        return Object.assign({
          year,
          month,
          day
        }, timeObject(weekData));
      }
      function gregorianToOrdinal(gregData) {
        var year = gregData.year, month = gregData.month, day = gregData.day, ordinal = computeOrdinal(year, month, day);
        return Object.assign({
          year,
          ordinal
        }, timeObject(gregData));
      }
      function ordinalToGregorian(ordinalData) {
        var year = ordinalData.year, ordinal = ordinalData.ordinal, _uncomputeOrdinal2 = uncomputeOrdinal(year, ordinal), month = _uncomputeOrdinal2.month, day = _uncomputeOrdinal2.day;
        return Object.assign({
          year,
          month,
          day
        }, timeObject(ordinalData));
      }
      function hasInvalidWeekData(obj) {
        var validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
        if (!validYear) {
          return unitOutOfRange("weekYear", obj.weekYear);
        } else if (!validWeek) {
          return unitOutOfRange("week", obj.week);
        } else if (!validWeekday) {
          return unitOutOfRange("weekday", obj.weekday);
        } else
          return false;
      }
      function hasInvalidOrdinalData(obj) {
        var validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
        if (!validYear) {
          return unitOutOfRange("year", obj.year);
        } else if (!validOrdinal) {
          return unitOutOfRange("ordinal", obj.ordinal);
        } else
          return false;
      }
      function hasInvalidGregorianData(obj) {
        var validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
        if (!validYear) {
          return unitOutOfRange("year", obj.year);
        } else if (!validMonth) {
          return unitOutOfRange("month", obj.month);
        } else if (!validDay) {
          return unitOutOfRange("day", obj.day);
        } else
          return false;
      }
      function hasInvalidTimeData(obj) {
        var hour = obj.hour, minute = obj.minute, second = obj.second, millisecond = obj.millisecond;
        var validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
        if (!validHour) {
          return unitOutOfRange("hour", hour);
        } else if (!validMinute) {
          return unitOutOfRange("minute", minute);
        } else if (!validSecond) {
          return unitOutOfRange("second", second);
        } else if (!validMillisecond) {
          return unitOutOfRange("millisecond", millisecond);
        } else
          return false;
      }
      var INVALID$2 = "Invalid DateTime";
      var MAX_DATE = 864e13;
      function unsupportedZone(zone) {
        return new Invalid("unsupported zone", 'the zone "' + zone.name + '" is not supported');
      }
      function possiblyCachedWeekData(dt) {
        if (dt.weekData === null) {
          dt.weekData = gregorianToWeek(dt.c);
        }
        return dt.weekData;
      }
      function clone$1(inst, alts) {
        var current = {
          ts: inst.ts,
          zone: inst.zone,
          c: inst.c,
          o: inst.o,
          loc: inst.loc,
          invalid: inst.invalid
        };
        return new DateTime2(Object.assign({}, current, alts, {
          old: current
        }));
      }
      function fixOffset(localTS, o2, tz) {
        var utcGuess = localTS - o2 * 60 * 1e3;
        var o22 = tz.offset(utcGuess);
        if (o2 === o22) {
          return [utcGuess, o2];
        }
        utcGuess -= (o22 - o2) * 60 * 1e3;
        var o3 = tz.offset(utcGuess);
        if (o22 === o3) {
          return [utcGuess, o22];
        }
        return [localTS - Math.min(o22, o3) * 60 * 1e3, Math.max(o22, o3)];
      }
      function tsToObj(ts, offset3) {
        ts += offset3 * 60 * 1e3;
        var d2 = new Date(ts);
        return {
          year: d2.getUTCFullYear(),
          month: d2.getUTCMonth() + 1,
          day: d2.getUTCDate(),
          hour: d2.getUTCHours(),
          minute: d2.getUTCMinutes(),
          second: d2.getUTCSeconds(),
          millisecond: d2.getUTCMilliseconds()
        };
      }
      function objToTS(obj, offset3, zone) {
        return fixOffset(objToLocalTS(obj), offset3, zone);
      }
      function adjustTime(inst, dur) {
        var oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c2 = Object.assign({}, inst.c, {
          year,
          month,
          day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
        }), millisToAdd = Duration.fromObject({
          years: dur.years - Math.trunc(dur.years),
          quarters: dur.quarters - Math.trunc(dur.quarters),
          months: dur.months - Math.trunc(dur.months),
          weeks: dur.weeks - Math.trunc(dur.weeks),
          days: dur.days - Math.trunc(dur.days),
          hours: dur.hours,
          minutes: dur.minutes,
          seconds: dur.seconds,
          milliseconds: dur.milliseconds
        }).as("milliseconds"), localTS = objToLocalTS(c2);
        var _fixOffset = fixOffset(localTS, oPre, inst.zone), ts = _fixOffset[0], o2 = _fixOffset[1];
        if (millisToAdd !== 0) {
          ts += millisToAdd;
          o2 = inst.zone.offset(ts);
        }
        return {
          ts,
          o: o2
        };
      }
      function parseDataToDateTime(parsed, parsedZone, opts, format2, text) {
        var setZone = opts.setZone, zone = opts.zone;
        if (parsed && Object.keys(parsed).length !== 0) {
          var interpretationZone = parsedZone || zone, inst = DateTime2.fromObject(Object.assign(parsed, opts, {
            zone: interpretationZone,
            setZone: void 0
          }));
          return setZone ? inst : inst.setZone(zone);
        } else {
          return DateTime2.invalid(new Invalid("unparsable", 'the input "' + text + `" can't be parsed as ` + format2));
        }
      }
      function toTechFormat(dt, format2, allowZ) {
        if (allowZ === void 0) {
          allowZ = true;
        }
        return dt.isValid ? Formatter.create(Locale.create("en-US"), {
          allowZ,
          forceSimple: true
        }).formatDateTimeFromString(dt, format2) : null;
      }
      function toTechTimeFormat(dt, _ref) {
        var _ref$suppressSeconds = _ref.suppressSeconds, suppressSeconds = _ref$suppressSeconds === void 0 ? false : _ref$suppressSeconds, _ref$suppressMillisec = _ref.suppressMilliseconds, suppressMilliseconds = _ref$suppressMillisec === void 0 ? false : _ref$suppressMillisec, includeOffset = _ref.includeOffset, _ref$includePrefix = _ref.includePrefix, includePrefix = _ref$includePrefix === void 0 ? false : _ref$includePrefix, _ref$includeZone = _ref.includeZone, includeZone = _ref$includeZone === void 0 ? false : _ref$includeZone, _ref$spaceZone = _ref.spaceZone, spaceZone = _ref$spaceZone === void 0 ? false : _ref$spaceZone, _ref$format = _ref.format, format2 = _ref$format === void 0 ? "extended" : _ref$format;
        var fmt = format2 === "basic" ? "HHmm" : "HH:mm";
        if (!suppressSeconds || dt.second !== 0 || dt.millisecond !== 0) {
          fmt += format2 === "basic" ? "ss" : ":ss";
          if (!suppressMilliseconds || dt.millisecond !== 0) {
            fmt += ".SSS";
          }
        }
        if ((includeZone || includeOffset) && spaceZone) {
          fmt += " ";
        }
        if (includeZone) {
          fmt += "z";
        } else if (includeOffset) {
          fmt += format2 === "basic" ? "ZZZ" : "ZZ";
        }
        var str = toTechFormat(dt, fmt);
        if (includePrefix) {
          str = "T" + str;
        }
        return str;
      }
      var defaultUnitValues = {
        month: 1,
        day: 1,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0
      };
      var defaultWeekUnitValues = {
        weekNumber: 1,
        weekday: 1,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0
      };
      var defaultOrdinalUnitValues = {
        ordinal: 1,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0
      };
      var orderedUnits$1 = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
      var orderedWeekUnits = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"];
      var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
      function normalizeUnit(unit) {
        var normalized = {
          year: "year",
          years: "year",
          month: "month",
          months: "month",
          day: "day",
          days: "day",
          hour: "hour",
          hours: "hour",
          minute: "minute",
          minutes: "minute",
          quarter: "quarter",
          quarters: "quarter",
          second: "second",
          seconds: "second",
          millisecond: "millisecond",
          milliseconds: "millisecond",
          weekday: "weekday",
          weekdays: "weekday",
          weeknumber: "weekNumber",
          weeksnumber: "weekNumber",
          weeknumbers: "weekNumber",
          weekyear: "weekYear",
          weekyears: "weekYear",
          ordinal: "ordinal"
        }[unit.toLowerCase()];
        if (!normalized)
          throw new InvalidUnitError(unit);
        return normalized;
      }
      function quickDT(obj, zone) {
        for (var _iterator = _createForOfIteratorHelperLoose(orderedUnits$1), _step; !(_step = _iterator()).done; ) {
          var u2 = _step.value;
          if (isUndefined(obj[u2])) {
            obj[u2] = defaultUnitValues[u2];
          }
        }
        var invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
        if (invalid) {
          return DateTime2.invalid(invalid);
        }
        var tsNow = Settings.now(), offsetProvis = zone.offset(tsNow), _objToTS = objToTS(obj, offsetProvis, zone), ts = _objToTS[0], o2 = _objToTS[1];
        return new DateTime2({
          ts,
          zone,
          o: o2
        });
      }
      function diffRelative(start4, end2, opts) {
        var round2 = isUndefined(opts.round) ? true : opts.round, format2 = function format3(c2, unit2) {
          c2 = roundTo(c2, round2 || opts.calendary ? 0 : 2, true);
          var formatter = end2.loc.clone(opts).relFormatter(opts);
          return formatter.format(c2, unit2);
        }, differ = function differ2(unit2) {
          if (opts.calendary) {
            if (!end2.hasSame(start4, unit2)) {
              return end2.startOf(unit2).diff(start4.startOf(unit2), unit2).get(unit2);
            } else
              return 0;
          } else {
            return end2.diff(start4, unit2).get(unit2);
          }
        };
        if (opts.unit) {
          return format2(differ(opts.unit), opts.unit);
        }
        for (var _iterator2 = _createForOfIteratorHelperLoose(opts.units), _step2; !(_step2 = _iterator2()).done; ) {
          var unit = _step2.value;
          var count = differ(unit);
          if (Math.abs(count) >= 1) {
            return format2(count, unit);
          }
        }
        return format2(0, opts.units[opts.units.length - 1]);
      }
      var DateTime2 = /* @__PURE__ */ function() {
        function DateTime3(config) {
          var zone = config.zone || Settings.defaultZone;
          var invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
          this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
          var c2 = null, o2 = null;
          if (!invalid) {
            var unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
            if (unchanged) {
              var _ref2 = [config.old.c, config.old.o];
              c2 = _ref2[0];
              o2 = _ref2[1];
            } else {
              var ot = zone.offset(this.ts);
              c2 = tsToObj(this.ts, ot);
              invalid = Number.isNaN(c2.year) ? new Invalid("invalid input") : null;
              c2 = invalid ? null : c2;
              o2 = invalid ? null : ot;
            }
          }
          this._zone = zone;
          this.loc = config.loc || Locale.create();
          this.invalid = invalid;
          this.weekData = null;
          this.c = c2;
          this.o = o2;
          this.isLuxonDateTime = true;
        }
        DateTime3.now = function now3() {
          return new DateTime3({});
        };
        DateTime3.local = function local(year, month, day, hour, minute, second, millisecond) {
          if (isUndefined(year)) {
            return new DateTime3({});
          } else {
            return quickDT({
              year,
              month,
              day,
              hour,
              minute,
              second,
              millisecond
            }, Settings.defaultZone);
          }
        };
        DateTime3.utc = function utc(year, month, day, hour, minute, second, millisecond) {
          if (isUndefined(year)) {
            return new DateTime3({
              ts: Settings.now(),
              zone: FixedOffsetZone.utcInstance
            });
          } else {
            return quickDT({
              year,
              month,
              day,
              hour,
              minute,
              second,
              millisecond
            }, FixedOffsetZone.utcInstance);
          }
        };
        DateTime3.fromJSDate = function fromJSDate(date, options) {
          if (options === void 0) {
            options = {};
          }
          var ts = isDate(date) ? date.valueOf() : NaN;
          if (Number.isNaN(ts)) {
            return DateTime3.invalid("invalid input");
          }
          var zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
          if (!zoneToUse.isValid) {
            return DateTime3.invalid(unsupportedZone(zoneToUse));
          }
          return new DateTime3({
            ts,
            zone: zoneToUse,
            loc: Locale.fromObject(options)
          });
        };
        DateTime3.fromMillis = function fromMillis(milliseconds, options) {
          if (options === void 0) {
            options = {};
          }
          if (!isNumber(milliseconds)) {
            throw new InvalidArgumentError("fromMillis requires a numerical input, but received a " + typeof milliseconds + " with value " + milliseconds);
          } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
            return DateTime3.invalid("Timestamp out of range");
          } else {
            return new DateTime3({
              ts: milliseconds,
              zone: normalizeZone(options.zone, Settings.defaultZone),
              loc: Locale.fromObject(options)
            });
          }
        };
        DateTime3.fromSeconds = function fromSeconds(seconds, options) {
          if (options === void 0) {
            options = {};
          }
          if (!isNumber(seconds)) {
            throw new InvalidArgumentError("fromSeconds requires a numerical input");
          } else {
            return new DateTime3({
              ts: seconds * 1e3,
              zone: normalizeZone(options.zone, Settings.defaultZone),
              loc: Locale.fromObject(options)
            });
          }
        };
        DateTime3.fromObject = function fromObject(obj) {
          var zoneToUse = normalizeZone(obj.zone, Settings.defaultZone);
          if (!zoneToUse.isValid) {
            return DateTime3.invalid(unsupportedZone(zoneToUse));
          }
          var tsNow = Settings.now(), offsetProvis = zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit, ["zone", "locale", "outputCalendar", "numberingSystem"]), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale.fromObject(obj);
          if ((containsGregor || containsOrdinal) && definiteWeekDef) {
            throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
          }
          if (containsGregorMD && containsOrdinal) {
            throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
          }
          var useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
          var units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
          if (useWeekData) {
            units = orderedWeekUnits;
            defaultValues = defaultWeekUnitValues;
            objNow = gregorianToWeek(objNow);
          } else if (containsOrdinal) {
            units = orderedOrdinalUnits;
            defaultValues = defaultOrdinalUnitValues;
            objNow = gregorianToOrdinal(objNow);
          } else {
            units = orderedUnits$1;
            defaultValues = defaultUnitValues;
          }
          var foundFirst = false;
          for (var _iterator3 = _createForOfIteratorHelperLoose(units), _step3; !(_step3 = _iterator3()).done; ) {
            var u2 = _step3.value;
            var v2 = normalized[u2];
            if (!isUndefined(v2)) {
              foundFirst = true;
            } else if (foundFirst) {
              normalized[u2] = defaultValues[u2];
            } else {
              normalized[u2] = objNow[u2];
            }
          }
          var higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
          if (invalid) {
            return DateTime3.invalid(invalid);
          }
          var gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, _objToTS2 = objToTS(gregorian, offsetProvis, zoneToUse), tsFinal = _objToTS2[0], offsetFinal = _objToTS2[1], inst = new DateTime3({
            ts: tsFinal,
            zone: zoneToUse,
            o: offsetFinal,
            loc
          });
          if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
            return DateTime3.invalid("mismatched weekday", "you can't specify both a weekday of " + normalized.weekday + " and a date of " + inst.toISO());
          }
          return inst;
        };
        DateTime3.fromISO = function fromISO(text, opts) {
          if (opts === void 0) {
            opts = {};
          }
          var _parseISODate = parseISODate(text), vals = _parseISODate[0], parsedZone = _parseISODate[1];
          return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
        };
        DateTime3.fromRFC2822 = function fromRFC2822(text, opts) {
          if (opts === void 0) {
            opts = {};
          }
          var _parseRFC2822Date = parseRFC2822Date(text), vals = _parseRFC2822Date[0], parsedZone = _parseRFC2822Date[1];
          return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
        };
        DateTime3.fromHTTP = function fromHTTP(text, opts) {
          if (opts === void 0) {
            opts = {};
          }
          var _parseHTTPDate = parseHTTPDate(text), vals = _parseHTTPDate[0], parsedZone = _parseHTTPDate[1];
          return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
        };
        DateTime3.fromFormat = function fromFormat(text, fmt, opts) {
          if (opts === void 0) {
            opts = {};
          }
          if (isUndefined(text) || isUndefined(fmt)) {
            throw new InvalidArgumentError("fromFormat requires an input string and a format");
          }
          var _opts = opts, _opts$locale = _opts.locale, locale = _opts$locale === void 0 ? null : _opts$locale, _opts$numberingSystem = _opts.numberingSystem, numberingSystem = _opts$numberingSystem === void 0 ? null : _opts$numberingSystem, localeToUse = Locale.fromOpts({
            locale,
            numberingSystem,
            defaultToEN: true
          }), _parseFromTokens = parseFromTokens(localeToUse, text, fmt), vals = _parseFromTokens[0], parsedZone = _parseFromTokens[1], invalid = _parseFromTokens[2];
          if (invalid) {
            return DateTime3.invalid(invalid);
          } else {
            return parseDataToDateTime(vals, parsedZone, opts, "format " + fmt, text);
          }
        };
        DateTime3.fromString = function fromString(text, fmt, opts) {
          if (opts === void 0) {
            opts = {};
          }
          return DateTime3.fromFormat(text, fmt, opts);
        };
        DateTime3.fromSQL = function fromSQL(text, opts) {
          if (opts === void 0) {
            opts = {};
          }
          var _parseSQL = parseSQL(text), vals = _parseSQL[0], parsedZone = _parseSQL[1];
          return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
        };
        DateTime3.invalid = function invalid(reason, explanation) {
          if (explanation === void 0) {
            explanation = null;
          }
          if (!reason) {
            throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
          }
          var invalid2 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
          if (Settings.throwOnInvalid) {
            throw new InvalidDateTimeError(invalid2);
          } else {
            return new DateTime3({
              invalid: invalid2
            });
          }
        };
        DateTime3.isDateTime = function isDateTime(o2) {
          return o2 && o2.isLuxonDateTime || false;
        };
        var _proto = DateTime3.prototype;
        _proto.get = function get(unit) {
          return this[unit];
        };
        _proto.resolvedLocaleOpts = function resolvedLocaleOpts(opts) {
          if (opts === void 0) {
            opts = {};
          }
          var _Formatter$create$res = Formatter.create(this.loc.clone(opts), opts).resolvedOptions(this), locale = _Formatter$create$res.locale, numberingSystem = _Formatter$create$res.numberingSystem, calendar = _Formatter$create$res.calendar;
          return {
            locale,
            numberingSystem,
            outputCalendar: calendar
          };
        };
        _proto.toUTC = function toUTC(offset3, opts) {
          if (offset3 === void 0) {
            offset3 = 0;
          }
          if (opts === void 0) {
            opts = {};
          }
          return this.setZone(FixedOffsetZone.instance(offset3), opts);
        };
        _proto.toLocal = function toLocal() {
          return this.setZone(Settings.defaultZone);
        };
        _proto.setZone = function setZone(zone, _temp) {
          var _ref3 = _temp === void 0 ? {} : _temp, _ref3$keepLocalTime = _ref3.keepLocalTime, keepLocalTime = _ref3$keepLocalTime === void 0 ? false : _ref3$keepLocalTime, _ref3$keepCalendarTim = _ref3.keepCalendarTime, keepCalendarTime = _ref3$keepCalendarTim === void 0 ? false : _ref3$keepCalendarTim;
          zone = normalizeZone(zone, Settings.defaultZone);
          if (zone.equals(this.zone)) {
            return this;
          } else if (!zone.isValid) {
            return DateTime3.invalid(unsupportedZone(zone));
          } else {
            var newTS = this.ts;
            if (keepLocalTime || keepCalendarTime) {
              var offsetGuess = zone.offset(this.ts);
              var asObj = this.toObject();
              var _objToTS3 = objToTS(asObj, offsetGuess, zone);
              newTS = _objToTS3[0];
            }
            return clone$1(this, {
              ts: newTS,
              zone
            });
          }
        };
        _proto.reconfigure = function reconfigure(_temp2) {
          var _ref4 = _temp2 === void 0 ? {} : _temp2, locale = _ref4.locale, numberingSystem = _ref4.numberingSystem, outputCalendar = _ref4.outputCalendar;
          var loc = this.loc.clone({
            locale,
            numberingSystem,
            outputCalendar
          });
          return clone$1(this, {
            loc
          });
        };
        _proto.setLocale = function setLocale(locale) {
          return this.reconfigure({
            locale
          });
        };
        _proto.set = function set(values) {
          if (!this.isValid)
            return this;
          var normalized = normalizeObject(values, normalizeUnit, []), settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday);
          var mixed;
          if (settingWeekStuff) {
            mixed = weekToGregorian(Object.assign(gregorianToWeek(this.c), normalized));
          } else if (!isUndefined(normalized.ordinal)) {
            mixed = ordinalToGregorian(Object.assign(gregorianToOrdinal(this.c), normalized));
          } else {
            mixed = Object.assign(this.toObject(), normalized);
            if (isUndefined(normalized.day)) {
              mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
            }
          }
          var _objToTS4 = objToTS(mixed, this.o, this.zone), ts = _objToTS4[0], o2 = _objToTS4[1];
          return clone$1(this, {
            ts,
            o: o2
          });
        };
        _proto.plus = function plus(duration2) {
          if (!this.isValid)
            return this;
          var dur = friendlyDuration(duration2);
          return clone$1(this, adjustTime(this, dur));
        };
        _proto.minus = function minus(duration2) {
          if (!this.isValid)
            return this;
          var dur = friendlyDuration(duration2).negate();
          return clone$1(this, adjustTime(this, dur));
        };
        _proto.startOf = function startOf(unit) {
          if (!this.isValid)
            return this;
          var o2 = {}, normalizedUnit = Duration.normalizeUnit(unit);
          switch (normalizedUnit) {
            case "years":
              o2.month = 1;
            case "quarters":
            case "months":
              o2.day = 1;
            case "weeks":
            case "days":
              o2.hour = 0;
            case "hours":
              o2.minute = 0;
            case "minutes":
              o2.second = 0;
            case "seconds":
              o2.millisecond = 0;
              break;
          }
          if (normalizedUnit === "weeks") {
            o2.weekday = 1;
          }
          if (normalizedUnit === "quarters") {
            var q = Math.ceil(this.month / 3);
            o2.month = (q - 1) * 3 + 1;
          }
          return this.set(o2);
        };
        _proto.endOf = function endOf(unit) {
          var _this$plus;
          return this.isValid ? this.plus((_this$plus = {}, _this$plus[unit] = 1, _this$plus)).startOf(unit).minus(1) : this;
        };
        _proto.toFormat = function toFormat(fmt, opts) {
          if (opts === void 0) {
            opts = {};
          }
          return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID$2;
        };
        _proto.toLocaleString = function toLocaleString(opts) {
          if (opts === void 0) {
            opts = DATE_SHORT;
          }
          return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTime(this) : INVALID$2;
        };
        _proto.toLocaleParts = function toLocaleParts(opts) {
          if (opts === void 0) {
            opts = {};
          }
          return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
        };
        _proto.toISO = function toISO(opts) {
          if (opts === void 0) {
            opts = {};
          }
          if (!this.isValid) {
            return null;
          }
          return this.toISODate(opts) + "T" + this.toISOTime(opts);
        };
        _proto.toISODate = function toISODate(_temp3) {
          var _ref5 = _temp3 === void 0 ? {} : _temp3, _ref5$format = _ref5.format, format2 = _ref5$format === void 0 ? "extended" : _ref5$format;
          var fmt = format2 === "basic" ? "yyyyMMdd" : "yyyy-MM-dd";
          if (this.year > 9999) {
            fmt = "+" + fmt;
          }
          return toTechFormat(this, fmt);
        };
        _proto.toISOWeekDate = function toISOWeekDate() {
          return toTechFormat(this, "kkkk-'W'WW-c");
        };
        _proto.toISOTime = function toISOTime(_temp4) {
          var _ref6 = _temp4 === void 0 ? {} : _temp4, _ref6$suppressMillise = _ref6.suppressMilliseconds, suppressMilliseconds = _ref6$suppressMillise === void 0 ? false : _ref6$suppressMillise, _ref6$suppressSeconds = _ref6.suppressSeconds, suppressSeconds = _ref6$suppressSeconds === void 0 ? false : _ref6$suppressSeconds, _ref6$includeOffset = _ref6.includeOffset, includeOffset = _ref6$includeOffset === void 0 ? true : _ref6$includeOffset, _ref6$includePrefix = _ref6.includePrefix, includePrefix = _ref6$includePrefix === void 0 ? false : _ref6$includePrefix, _ref6$format = _ref6.format, format2 = _ref6$format === void 0 ? "extended" : _ref6$format;
          return toTechTimeFormat(this, {
            suppressSeconds,
            suppressMilliseconds,
            includeOffset,
            includePrefix,
            format: format2
          });
        };
        _proto.toRFC2822 = function toRFC2822() {
          return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
        };
        _proto.toHTTP = function toHTTP() {
          return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
        };
        _proto.toSQLDate = function toSQLDate() {
          return toTechFormat(this, "yyyy-MM-dd");
        };
        _proto.toSQLTime = function toSQLTime(_temp5) {
          var _ref7 = _temp5 === void 0 ? {} : _temp5, _ref7$includeOffset = _ref7.includeOffset, includeOffset = _ref7$includeOffset === void 0 ? true : _ref7$includeOffset, _ref7$includeZone = _ref7.includeZone, includeZone = _ref7$includeZone === void 0 ? false : _ref7$includeZone;
          return toTechTimeFormat(this, {
            includeOffset,
            includeZone,
            spaceZone: true
          });
        };
        _proto.toSQL = function toSQL(opts) {
          if (opts === void 0) {
            opts = {};
          }
          if (!this.isValid) {
            return null;
          }
          return this.toSQLDate() + " " + this.toSQLTime(opts);
        };
        _proto.toString = function toString() {
          return this.isValid ? this.toISO() : INVALID$2;
        };
        _proto.valueOf = function valueOf() {
          return this.toMillis();
        };
        _proto.toMillis = function toMillis() {
          return this.isValid ? this.ts : NaN;
        };
        _proto.toSeconds = function toSeconds() {
          return this.isValid ? this.ts / 1e3 : NaN;
        };
        _proto.toJSON = function toJSON() {
          return this.toISO();
        };
        _proto.toBSON = function toBSON() {
          return this.toJSDate();
        };
        _proto.toObject = function toObject(opts) {
          if (opts === void 0) {
            opts = {};
          }
          if (!this.isValid)
            return {};
          var base = Object.assign({}, this.c);
          if (opts.includeConfig) {
            base.outputCalendar = this.outputCalendar;
            base.numberingSystem = this.loc.numberingSystem;
            base.locale = this.loc.locale;
          }
          return base;
        };
        _proto.toJSDate = function toJSDate() {
          return new Date(this.isValid ? this.ts : NaN);
        };
        _proto.diff = function diff(otherDateTime, unit, opts) {
          if (unit === void 0) {
            unit = "milliseconds";
          }
          if (opts === void 0) {
            opts = {};
          }
          if (!this.isValid || !otherDateTime.isValid) {
            return Duration.invalid(this.invalid || otherDateTime.invalid, "created by diffing an invalid DateTime");
          }
          var durOpts = Object.assign({
            locale: this.locale,
            numberingSystem: this.numberingSystem
          }, opts);
          var units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = _diff(earlier, later, units, durOpts);
          return otherIsLater ? diffed.negate() : diffed;
        };
        _proto.diffNow = function diffNow(unit, opts) {
          if (unit === void 0) {
            unit = "milliseconds";
          }
          if (opts === void 0) {
            opts = {};
          }
          return this.diff(DateTime3.now(), unit, opts);
        };
        _proto.until = function until(otherDateTime) {
          return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
        };
        _proto.hasSame = function hasSame(otherDateTime, unit) {
          if (!this.isValid)
            return false;
          var inputMs = otherDateTime.valueOf();
          var otherZoneDateTime = this.setZone(otherDateTime.zone, {
            keepLocalTime: true
          });
          return otherZoneDateTime.startOf(unit) <= inputMs && inputMs <= otherZoneDateTime.endOf(unit);
        };
        _proto.equals = function equals(other) {
          return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
        };
        _proto.toRelative = function toRelative(options) {
          if (options === void 0) {
            options = {};
          }
          if (!this.isValid)
            return null;
          var base = options.base || DateTime3.fromObject({
            zone: this.zone
          }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
          return diffRelative(base, this.plus(padding), Object.assign(options, {
            numeric: "always",
            units: ["years", "months", "days", "hours", "minutes", "seconds"]
          }));
        };
        _proto.toRelativeCalendar = function toRelativeCalendar(options) {
          if (options === void 0) {
            options = {};
          }
          if (!this.isValid)
            return null;
          return diffRelative(options.base || DateTime3.fromObject({
            zone: this.zone
          }), this, Object.assign(options, {
            numeric: "auto",
            units: ["years", "months", "days"],
            calendary: true
          }));
        };
        DateTime3.min = function min2() {
          for (var _len = arguments.length, dateTimes = new Array(_len), _key = 0; _key < _len; _key++) {
            dateTimes[_key] = arguments[_key];
          }
          if (!dateTimes.every(DateTime3.isDateTime)) {
            throw new InvalidArgumentError("min requires all arguments be DateTimes");
          }
          return bestBy(dateTimes, function(i2) {
            return i2.valueOf();
          }, Math.min);
        };
        DateTime3.max = function max2() {
          for (var _len2 = arguments.length, dateTimes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            dateTimes[_key2] = arguments[_key2];
          }
          if (!dateTimes.every(DateTime3.isDateTime)) {
            throw new InvalidArgumentError("max requires all arguments be DateTimes");
          }
          return bestBy(dateTimes, function(i2) {
            return i2.valueOf();
          }, Math.max);
        };
        DateTime3.fromFormatExplain = function fromFormatExplain(text, fmt, options) {
          if (options === void 0) {
            options = {};
          }
          var _options = options, _options$locale = _options.locale, locale = _options$locale === void 0 ? null : _options$locale, _options$numberingSys = _options.numberingSystem, numberingSystem = _options$numberingSys === void 0 ? null : _options$numberingSys, localeToUse = Locale.fromOpts({
            locale,
            numberingSystem,
            defaultToEN: true
          });
          return explainFromTokens(localeToUse, text, fmt);
        };
        DateTime3.fromStringExplain = function fromStringExplain(text, fmt, options) {
          if (options === void 0) {
            options = {};
          }
          return DateTime3.fromFormatExplain(text, fmt, options);
        };
        _createClass(DateTime3, [{
          key: "isValid",
          get: function get() {
            return this.invalid === null;
          }
        }, {
          key: "invalidReason",
          get: function get() {
            return this.invalid ? this.invalid.reason : null;
          }
        }, {
          key: "invalidExplanation",
          get: function get() {
            return this.invalid ? this.invalid.explanation : null;
          }
        }, {
          key: "locale",
          get: function get() {
            return this.isValid ? this.loc.locale : null;
          }
        }, {
          key: "numberingSystem",
          get: function get() {
            return this.isValid ? this.loc.numberingSystem : null;
          }
        }, {
          key: "outputCalendar",
          get: function get() {
            return this.isValid ? this.loc.outputCalendar : null;
          }
        }, {
          key: "zone",
          get: function get() {
            return this._zone;
          }
        }, {
          key: "zoneName",
          get: function get() {
            return this.isValid ? this.zone.name : null;
          }
        }, {
          key: "year",
          get: function get() {
            return this.isValid ? this.c.year : NaN;
          }
        }, {
          key: "quarter",
          get: function get() {
            return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
          }
        }, {
          key: "month",
          get: function get() {
            return this.isValid ? this.c.month : NaN;
          }
        }, {
          key: "day",
          get: function get() {
            return this.isValid ? this.c.day : NaN;
          }
        }, {
          key: "hour",
          get: function get() {
            return this.isValid ? this.c.hour : NaN;
          }
        }, {
          key: "minute",
          get: function get() {
            return this.isValid ? this.c.minute : NaN;
          }
        }, {
          key: "second",
          get: function get() {
            return this.isValid ? this.c.second : NaN;
          }
        }, {
          key: "millisecond",
          get: function get() {
            return this.isValid ? this.c.millisecond : NaN;
          }
        }, {
          key: "weekYear",
          get: function get() {
            return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
          }
        }, {
          key: "weekNumber",
          get: function get() {
            return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
          }
        }, {
          key: "weekday",
          get: function get() {
            return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
          }
        }, {
          key: "ordinal",
          get: function get() {
            return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
          }
        }, {
          key: "monthShort",
          get: function get() {
            return this.isValid ? Info.months("short", {
              locale: this.locale
            })[this.month - 1] : null;
          }
        }, {
          key: "monthLong",
          get: function get() {
            return this.isValid ? Info.months("long", {
              locale: this.locale
            })[this.month - 1] : null;
          }
        }, {
          key: "weekdayShort",
          get: function get() {
            return this.isValid ? Info.weekdays("short", {
              locale: this.locale
            })[this.weekday - 1] : null;
          }
        }, {
          key: "weekdayLong",
          get: function get() {
            return this.isValid ? Info.weekdays("long", {
              locale: this.locale
            })[this.weekday - 1] : null;
          }
        }, {
          key: "offset",
          get: function get() {
            return this.isValid ? +this.o : NaN;
          }
        }, {
          key: "offsetNameShort",
          get: function get() {
            if (this.isValid) {
              return this.zone.offsetName(this.ts, {
                format: "short",
                locale: this.locale
              });
            } else {
              return null;
            }
          }
        }, {
          key: "offsetNameLong",
          get: function get() {
            if (this.isValid) {
              return this.zone.offsetName(this.ts, {
                format: "long",
                locale: this.locale
              });
            } else {
              return null;
            }
          }
        }, {
          key: "isOffsetFixed",
          get: function get() {
            return this.isValid ? this.zone.universal : null;
          }
        }, {
          key: "isInDST",
          get: function get() {
            if (this.isOffsetFixed) {
              return false;
            } else {
              return this.offset > this.set({
                month: 1
              }).offset || this.offset > this.set({
                month: 5
              }).offset;
            }
          }
        }, {
          key: "isInLeapYear",
          get: function get() {
            return isLeapYear(this.year);
          }
        }, {
          key: "daysInMonth",
          get: function get() {
            return daysInMonth(this.year, this.month);
          }
        }, {
          key: "daysInYear",
          get: function get() {
            return this.isValid ? daysInYear(this.year) : NaN;
          }
        }, {
          key: "weeksInWeekYear",
          get: function get() {
            return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
          }
        }], [{
          key: "DATE_SHORT",
          get: function get() {
            return DATE_SHORT;
          }
        }, {
          key: "DATE_MED",
          get: function get() {
            return DATE_MED;
          }
        }, {
          key: "DATE_MED_WITH_WEEKDAY",
          get: function get() {
            return DATE_MED_WITH_WEEKDAY;
          }
        }, {
          key: "DATE_FULL",
          get: function get() {
            return DATE_FULL;
          }
        }, {
          key: "DATE_HUGE",
          get: function get() {
            return DATE_HUGE;
          }
        }, {
          key: "TIME_SIMPLE",
          get: function get() {
            return TIME_SIMPLE;
          }
        }, {
          key: "TIME_WITH_SECONDS",
          get: function get() {
            return TIME_WITH_SECONDS;
          }
        }, {
          key: "TIME_WITH_SHORT_OFFSET",
          get: function get() {
            return TIME_WITH_SHORT_OFFSET;
          }
        }, {
          key: "TIME_WITH_LONG_OFFSET",
          get: function get() {
            return TIME_WITH_LONG_OFFSET;
          }
        }, {
          key: "TIME_24_SIMPLE",
          get: function get() {
            return TIME_24_SIMPLE;
          }
        }, {
          key: "TIME_24_WITH_SECONDS",
          get: function get() {
            return TIME_24_WITH_SECONDS;
          }
        }, {
          key: "TIME_24_WITH_SHORT_OFFSET",
          get: function get() {
            return TIME_24_WITH_SHORT_OFFSET;
          }
        }, {
          key: "TIME_24_WITH_LONG_OFFSET",
          get: function get() {
            return TIME_24_WITH_LONG_OFFSET;
          }
        }, {
          key: "DATETIME_SHORT",
          get: function get() {
            return DATETIME_SHORT;
          }
        }, {
          key: "DATETIME_SHORT_WITH_SECONDS",
          get: function get() {
            return DATETIME_SHORT_WITH_SECONDS;
          }
        }, {
          key: "DATETIME_MED",
          get: function get() {
            return DATETIME_MED;
          }
        }, {
          key: "DATETIME_MED_WITH_SECONDS",
          get: function get() {
            return DATETIME_MED_WITH_SECONDS;
          }
        }, {
          key: "DATETIME_MED_WITH_WEEKDAY",
          get: function get() {
            return DATETIME_MED_WITH_WEEKDAY;
          }
        }, {
          key: "DATETIME_FULL",
          get: function get() {
            return DATETIME_FULL;
          }
        }, {
          key: "DATETIME_FULL_WITH_SECONDS",
          get: function get() {
            return DATETIME_FULL_WITH_SECONDS;
          }
        }, {
          key: "DATETIME_HUGE",
          get: function get() {
            return DATETIME_HUGE;
          }
        }, {
          key: "DATETIME_HUGE_WITH_SECONDS",
          get: function get() {
            return DATETIME_HUGE_WITH_SECONDS;
          }
        }]);
        return DateTime3;
      }();
      function friendlyDateTime(dateTimeish) {
        if (DateTime2.isDateTime(dateTimeish)) {
          return dateTimeish;
        } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
          return DateTime2.fromJSDate(dateTimeish);
        } else if (dateTimeish && typeof dateTimeish === "object") {
          return DateTime2.fromObject(dateTimeish);
        } else {
          throw new InvalidArgumentError("Unknown datetime argument: " + dateTimeish + ", of type " + typeof dateTimeish);
        }
      }
      var VERSION = "1.26.0";
      exports.DateTime = DateTime2;
      exports.Duration = Duration;
      exports.FixedOffsetZone = FixedOffsetZone;
      exports.IANAZone = IANAZone;
      exports.Info = Info;
      exports.Interval = Interval;
      exports.InvalidZone = InvalidZone;
      exports.LocalZone = LocalZone;
      exports.Settings = Settings;
      exports.VERSION = VERSION;
      exports.Zone = Zone;
    }
  });

  // node_modules/simplemde/node_modules/codemirror/lib/codemirror.js
  var require_codemirror2 = __commonJS({
    "node_modules/simplemde/node_modules/codemirror/lib/codemirror.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.CodeMirror = factory());
      })(exports, function() {
        "use strict";
        var userAgent = navigator.userAgent;
        var platform = navigator.platform;
        var gecko = /gecko\/\d/i.test(userAgent);
        var ie_upto10 = /MSIE \d/.test(userAgent);
        var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
        var edge = /Edge\/(\d+)/.exec(userAgent);
        var ie = ie_upto10 || ie_11up || edge;
        var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
        var webkit = !edge && /WebKit\//.test(userAgent);
        var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
        var chrome2 = !edge && /Chrome\//.test(userAgent);
        var presto = /Opera\//.test(userAgent);
        var safari = /Apple Computer/.test(navigator.vendor);
        var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
        var phantom = /PhantomJS/.test(userAgent);
        var ios = safari && (/Mobile\/\w+/.test(userAgent) || navigator.maxTouchPoints > 2);
        var android = /Android/.test(userAgent);
        var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
        var mac = ios || /Mac/.test(platform);
        var chromeOS = /\bCrOS\b/.test(userAgent);
        var windows = /win/i.test(platform);
        var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
        if (presto_version) {
          presto_version = Number(presto_version[1]);
        }
        if (presto_version && presto_version >= 15) {
          presto = false;
          webkit = true;
        }
        var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
        var captureRightClick = gecko || ie && ie_version >= 9;
        function classTest(cls) {
          return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
        }
        var rmClass = function(node, cls) {
          var current = node.className;
          var match = classTest(cls).exec(current);
          if (match) {
            var after = current.slice(match.index + match[0].length);
            node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
          }
        };
        function removeChildren(e2) {
          for (var count = e2.childNodes.length; count > 0; --count) {
            e2.removeChild(e2.firstChild);
          }
          return e2;
        }
        function removeChildrenAndAdd(parent, e2) {
          return removeChildren(parent).appendChild(e2);
        }
        function elt(tag, content, className, style) {
          var e2 = document.createElement(tag);
          if (className) {
            e2.className = className;
          }
          if (style) {
            e2.style.cssText = style;
          }
          if (typeof content == "string") {
            e2.appendChild(document.createTextNode(content));
          } else if (content) {
            for (var i3 = 0; i3 < content.length; ++i3) {
              e2.appendChild(content[i3]);
            }
          }
          return e2;
        }
        function eltP(tag, content, className, style) {
          var e2 = elt(tag, content, className, style);
          e2.setAttribute("role", "presentation");
          return e2;
        }
        var range;
        if (document.createRange) {
          range = function(node, start4, end2, endNode) {
            var r2 = document.createRange();
            r2.setEnd(endNode || node, end2);
            r2.setStart(node, start4);
            return r2;
          };
        } else {
          range = function(node, start4, end2) {
            var r2 = document.body.createTextRange();
            try {
              r2.moveToElementText(node.parentNode);
            } catch (e2) {
              return r2;
            }
            r2.collapse(true);
            r2.moveEnd("character", end2);
            r2.moveStart("character", start4);
            return r2;
          };
        }
        function contains2(parent, child) {
          if (child.nodeType == 3) {
            child = child.parentNode;
          }
          if (parent.contains) {
            return parent.contains(child);
          }
          do {
            if (child.nodeType == 11) {
              child = child.host;
            }
            if (child == parent) {
              return true;
            }
          } while (child = child.parentNode);
        }
        function activeElt() {
          var activeElement;
          try {
            activeElement = document.activeElement;
          } catch (e2) {
            activeElement = document.body || null;
          }
          while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
            activeElement = activeElement.shadowRoot.activeElement;
          }
          return activeElement;
        }
        function addClass(node, cls) {
          var current = node.className;
          if (!classTest(cls).test(current)) {
            node.className += (current ? " " : "") + cls;
          }
        }
        function joinClasses(a2, b2) {
          var as = a2.split(" ");
          for (var i3 = 0; i3 < as.length; i3++) {
            if (as[i3] && !classTest(as[i3]).test(b2)) {
              b2 += " " + as[i3];
            }
          }
          return b2;
        }
        var selectInput = function(node) {
          node.select();
        };
        if (ios) {
          selectInput = function(node) {
            node.selectionStart = 0;
            node.selectionEnd = node.value.length;
          };
        } else if (ie) {
          selectInput = function(node) {
            try {
              node.select();
            } catch (_e) {
            }
          };
        }
        function bind3(f2) {
          var args = Array.prototype.slice.call(arguments, 1);
          return function() {
            return f2.apply(null, args);
          };
        }
        function copyObj(obj, target, overwrite) {
          if (!target) {
            target = {};
          }
          for (var prop2 in obj) {
            if (obj.hasOwnProperty(prop2) && (overwrite !== false || !target.hasOwnProperty(prop2))) {
              target[prop2] = obj[prop2];
            }
          }
          return target;
        }
        function countColumn(string, end2, tabSize, startIndex, startValue) {
          if (end2 == null) {
            end2 = string.search(/[^\s\u00a0]/);
            if (end2 == -1) {
              end2 = string.length;
            }
          }
          for (var i3 = startIndex || 0, n2 = startValue || 0; ; ) {
            var nextTab = string.indexOf("	", i3);
            if (nextTab < 0 || nextTab >= end2) {
              return n2 + (end2 - i3);
            }
            n2 += nextTab - i3;
            n2 += tabSize - n2 % tabSize;
            i3 = nextTab + 1;
          }
        }
        var Delayed = function() {
          this.id = null;
          this.f = null;
          this.time = 0;
          this.handler = bind3(this.onTimeout, this);
        };
        Delayed.prototype.onTimeout = function(self2) {
          self2.id = 0;
          if (self2.time <= +new Date()) {
            self2.f();
          } else {
            setTimeout(self2.handler, self2.time - +new Date());
          }
        };
        Delayed.prototype.set = function(ms, f2) {
          this.f = f2;
          var time = +new Date() + ms;
          if (!this.id || time < this.time) {
            clearTimeout(this.id);
            this.id = setTimeout(this.handler, ms);
            this.time = time;
          }
        };
        function indexOf2(array, elt2) {
          for (var i3 = 0; i3 < array.length; ++i3) {
            if (array[i3] == elt2) {
              return i3;
            }
          }
          return -1;
        }
        var scrollerGap = 50;
        var Pass = { toString: function() {
          return "CodeMirror.Pass";
        } };
        var sel_dontScroll = { scroll: false }, sel_mouse = { origin: "*mouse" }, sel_move = { origin: "+move" };
        function findColumn(string, goal, tabSize) {
          for (var pos = 0, col = 0; ; ) {
            var nextTab = string.indexOf("	", pos);
            if (nextTab == -1) {
              nextTab = string.length;
            }
            var skipped = nextTab - pos;
            if (nextTab == string.length || col + skipped >= goal) {
              return pos + Math.min(skipped, goal - col);
            }
            col += nextTab - pos;
            col += tabSize - col % tabSize;
            pos = nextTab + 1;
            if (col >= goal) {
              return pos;
            }
          }
        }
        var spaceStrs = [""];
        function spaceStr(n2) {
          while (spaceStrs.length <= n2) {
            spaceStrs.push(lst(spaceStrs) + " ");
          }
          return spaceStrs[n2];
        }
        function lst(arr) {
          return arr[arr.length - 1];
        }
        function map(array, f2) {
          var out = [];
          for (var i3 = 0; i3 < array.length; i3++) {
            out[i3] = f2(array[i3], i3);
          }
          return out;
        }
        function insertSorted(array, value, score) {
          var pos = 0, priority = score(value);
          while (pos < array.length && score(array[pos]) <= priority) {
            pos++;
          }
          array.splice(pos, 0, value);
        }
        function nothing() {
        }
        function createObj(base, props) {
          var inst;
          if (Object.create) {
            inst = Object.create(base);
          } else {
            nothing.prototype = base;
            inst = new nothing();
          }
          if (props) {
            copyObj(props, inst);
          }
          return inst;
        }
        var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
        function isWordCharBasic(ch) {
          return /\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
        }
        function isWordChar(ch, helper) {
          if (!helper) {
            return isWordCharBasic(ch);
          }
          if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) {
            return true;
          }
          return helper.test(ch);
        }
        function isEmpty(obj) {
          for (var n2 in obj) {
            if (obj.hasOwnProperty(n2) && obj[n2]) {
              return false;
            }
          }
          return true;
        }
        var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
        function isExtendingChar(ch) {
          return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
        }
        function skipExtendingChars(str, pos, dir) {
          while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {
            pos += dir;
          }
          return pos;
        }
        function findFirst(pred, from, to) {
          var dir = from > to ? -1 : 1;
          for (; ; ) {
            if (from == to) {
              return from;
            }
            var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
            if (mid == from) {
              return pred(mid) ? from : to;
            }
            if (pred(mid)) {
              to = mid;
            } else {
              from = mid + dir;
            }
          }
        }
        function iterateBidiSections(order2, from, to, f2) {
          if (!order2) {
            return f2(from, to, "ltr", 0);
          }
          var found = false;
          for (var i3 = 0; i3 < order2.length; ++i3) {
            var part = order2[i3];
            if (part.from < to && part.to > from || from == to && part.to == from) {
              f2(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i3);
              found = true;
            }
          }
          if (!found) {
            f2(from, to, "ltr");
          }
        }
        var bidiOther = null;
        function getBidiPartAt(order2, ch, sticky) {
          var found;
          bidiOther = null;
          for (var i3 = 0; i3 < order2.length; ++i3) {
            var cur = order2[i3];
            if (cur.from < ch && cur.to > ch) {
              return i3;
            }
            if (cur.to == ch) {
              if (cur.from != cur.to && sticky == "before") {
                found = i3;
              } else {
                bidiOther = i3;
              }
            }
            if (cur.from == ch) {
              if (cur.from != cur.to && sticky != "before") {
                found = i3;
              } else {
                bidiOther = i3;
              }
            }
          }
          return found != null ? found : bidiOther;
        }
        var bidiOrdering = function() {
          var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
          var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
          function charType(code3) {
            if (code3 <= 247) {
              return lowTypes.charAt(code3);
            } else if (1424 <= code3 && code3 <= 1524) {
              return "R";
            } else if (1536 <= code3 && code3 <= 1785) {
              return arabicTypes.charAt(code3 - 1536);
            } else if (1774 <= code3 && code3 <= 2220) {
              return "r";
            } else if (8192 <= code3 && code3 <= 8203) {
              return "w";
            } else if (code3 == 8204) {
              return "b";
            } else {
              return "L";
            }
          }
          var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
          var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
          function BidiSpan(level, from, to) {
            this.level = level;
            this.from = from;
            this.to = to;
          }
          return function(str, direction) {
            var outerType = direction == "ltr" ? "L" : "R";
            if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {
              return false;
            }
            var len = str.length, types = [];
            for (var i3 = 0; i3 < len; ++i3) {
              types.push(charType(str.charCodeAt(i3)));
            }
            for (var i$12 = 0, prev = outerType; i$12 < len; ++i$12) {
              var type = types[i$12];
              if (type == "m") {
                types[i$12] = prev;
              } else {
                prev = type;
              }
            }
            for (var i$22 = 0, cur = outerType; i$22 < len; ++i$22) {
              var type$1 = types[i$22];
              if (type$1 == "1" && cur == "r") {
                types[i$22] = "n";
              } else if (isStrong.test(type$1)) {
                cur = type$1;
                if (type$1 == "r") {
                  types[i$22] = "R";
                }
              }
            }
            for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
              var type$2 = types[i$3];
              if (type$2 == "+" && prev$1 == "1" && types[i$3 + 1] == "1") {
                types[i$3] = "1";
              } else if (type$2 == "," && prev$1 == types[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
                types[i$3] = prev$1;
              }
              prev$1 = type$2;
            }
            for (var i$4 = 0; i$4 < len; ++i$4) {
              var type$3 = types[i$4];
              if (type$3 == ",") {
                types[i$4] = "N";
              } else if (type$3 == "%") {
                var end2 = void 0;
                for (end2 = i$4 + 1; end2 < len && types[end2] == "%"; ++end2) {
                }
                var replace = i$4 && types[i$4 - 1] == "!" || end2 < len && types[end2] == "1" ? "1" : "N";
                for (var j2 = i$4; j2 < end2; ++j2) {
                  types[j2] = replace;
                }
                i$4 = end2 - 1;
              }
            }
            for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
              var type$4 = types[i$5];
              if (cur$1 == "L" && type$4 == "1") {
                types[i$5] = "L";
              } else if (isStrong.test(type$4)) {
                cur$1 = type$4;
              }
            }
            for (var i$6 = 0; i$6 < len; ++i$6) {
              if (isNeutral.test(types[i$6])) {
                var end$1 = void 0;
                for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {
                }
                var before = (i$6 ? types[i$6 - 1] : outerType) == "L";
                var after = (end$1 < len ? types[end$1] : outerType) == "L";
                var replace$1 = before == after ? before ? "L" : "R" : outerType;
                for (var j$1 = i$6; j$1 < end$1; ++j$1) {
                  types[j$1] = replace$1;
                }
                i$6 = end$1 - 1;
              }
            }
            var order2 = [], m2;
            for (var i$7 = 0; i$7 < len; ) {
              if (countsAsLeft.test(types[i$7])) {
                var start4 = i$7;
                for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {
                }
                order2.push(new BidiSpan(0, start4, i$7));
              } else {
                var pos = i$7, at = order2.length, isRTL = direction == "rtl" ? 1 : 0;
                for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {
                }
                for (var j$2 = pos; j$2 < i$7; ) {
                  if (countsAsNum.test(types[j$2])) {
                    if (pos < j$2) {
                      order2.splice(at, 0, new BidiSpan(1, pos, j$2));
                      at += isRTL;
                    }
                    var nstart = j$2;
                    for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {
                    }
                    order2.splice(at, 0, new BidiSpan(2, nstart, j$2));
                    at += isRTL;
                    pos = j$2;
                  } else {
                    ++j$2;
                  }
                }
                if (pos < i$7) {
                  order2.splice(at, 0, new BidiSpan(1, pos, i$7));
                }
              }
            }
            if (direction == "ltr") {
              if (order2[0].level == 1 && (m2 = str.match(/^\s+/))) {
                order2[0].from = m2[0].length;
                order2.unshift(new BidiSpan(0, 0, m2[0].length));
              }
              if (lst(order2).level == 1 && (m2 = str.match(/\s+$/))) {
                lst(order2).to -= m2[0].length;
                order2.push(new BidiSpan(0, len - m2[0].length, len));
              }
            }
            return direction == "rtl" ? order2.reverse() : order2;
          };
        }();
        function getOrder(line, direction) {
          var order2 = line.order;
          if (order2 == null) {
            order2 = line.order = bidiOrdering(line.text, direction);
          }
          return order2;
        }
        var noHandlers = [];
        var on = function(emitter, type, f2) {
          if (emitter.addEventListener) {
            emitter.addEventListener(type, f2, false);
          } else if (emitter.attachEvent) {
            emitter.attachEvent("on" + type, f2);
          } else {
            var map2 = emitter._handlers || (emitter._handlers = {});
            map2[type] = (map2[type] || noHandlers).concat(f2);
          }
        };
        function getHandlers(emitter, type) {
          return emitter._handlers && emitter._handlers[type] || noHandlers;
        }
        function off(emitter, type, f2) {
          if (emitter.removeEventListener) {
            emitter.removeEventListener(type, f2, false);
          } else if (emitter.detachEvent) {
            emitter.detachEvent("on" + type, f2);
          } else {
            var map2 = emitter._handlers, arr = map2 && map2[type];
            if (arr) {
              var index = indexOf2(arr, f2);
              if (index > -1) {
                map2[type] = arr.slice(0, index).concat(arr.slice(index + 1));
              }
            }
          }
        }
        function signal(emitter, type) {
          var handlers = getHandlers(emitter, type);
          if (!handlers.length) {
            return;
          }
          var args = Array.prototype.slice.call(arguments, 2);
          for (var i3 = 0; i3 < handlers.length; ++i3) {
            handlers[i3].apply(null, args);
          }
        }
        function signalDOMEvent(cm, e2, override) {
          if (typeof e2 == "string") {
            e2 = { type: e2, preventDefault: function() {
              this.defaultPrevented = true;
            } };
          }
          signal(cm, override || e2.type, cm, e2);
          return e_defaultPrevented(e2) || e2.codemirrorIgnore;
        }
        function signalCursorActivity(cm) {
          var arr = cm._handlers && cm._handlers.cursorActivity;
          if (!arr) {
            return;
          }
          var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
          for (var i3 = 0; i3 < arr.length; ++i3) {
            if (indexOf2(set, arr[i3]) == -1) {
              set.push(arr[i3]);
            }
          }
        }
        function hasHandler(emitter, type) {
          return getHandlers(emitter, type).length > 0;
        }
        function eventMixin(ctor) {
          ctor.prototype.on = function(type, f2) {
            on(this, type, f2);
          };
          ctor.prototype.off = function(type, f2) {
            off(this, type, f2);
          };
        }
        function e_preventDefault(e2) {
          if (e2.preventDefault) {
            e2.preventDefault();
          } else {
            e2.returnValue = false;
          }
        }
        function e_stopPropagation(e2) {
          if (e2.stopPropagation) {
            e2.stopPropagation();
          } else {
            e2.cancelBubble = true;
          }
        }
        function e_defaultPrevented(e2) {
          return e2.defaultPrevented != null ? e2.defaultPrevented : e2.returnValue == false;
        }
        function e_stop(e2) {
          e_preventDefault(e2);
          e_stopPropagation(e2);
        }
        function e_target(e2) {
          return e2.target || e2.srcElement;
        }
        function e_button(e2) {
          var b2 = e2.which;
          if (b2 == null) {
            if (e2.button & 1) {
              b2 = 1;
            } else if (e2.button & 2) {
              b2 = 3;
            } else if (e2.button & 4) {
              b2 = 2;
            }
          }
          if (mac && e2.ctrlKey && b2 == 1) {
            b2 = 3;
          }
          return b2;
        }
        var dragAndDrop = function() {
          if (ie && ie_version < 9) {
            return false;
          }
          var div2 = elt("div");
          return "draggable" in div2 || "dragDrop" in div2;
        }();
        var zwspSupported;
        function zeroWidthElement(measure) {
          if (zwspSupported == null) {
            var test = elt("span", "\u200B");
            removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
            if (measure.firstChild.offsetHeight != 0) {
              zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
            }
          }
          var node = zwspSupported ? elt("span", "\u200B") : elt("span", "\xA0", null, "display: inline-block; width: 1px; margin-right: -1px");
          node.setAttribute("cm-text", "");
          return node;
        }
        var badBidiRects;
        function hasBadBidiRects(measure) {
          if (badBidiRects != null) {
            return badBidiRects;
          }
          var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062EA"));
          var r0 = range(txt, 0, 1).getBoundingClientRect();
          var r1 = range(txt, 1, 2).getBoundingClientRect();
          removeChildren(measure);
          if (!r0 || r0.left == r0.right) {
            return false;
          }
          return badBidiRects = r1.right - r0.right < 3;
        }
        var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function(string) {
          var pos = 0, result = [], l2 = string.length;
          while (pos <= l2) {
            var nl = string.indexOf("\n", pos);
            if (nl == -1) {
              nl = string.length;
            }
            var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
            var rt = line.indexOf("\r");
            if (rt != -1) {
              result.push(line.slice(0, rt));
              pos += rt + 1;
            } else {
              result.push(line);
              pos = nl + 1;
            }
          }
          return result;
        } : function(string) {
          return string.split(/\r\n?|\n/);
        };
        var hasSelection = window.getSelection ? function(te) {
          try {
            return te.selectionStart != te.selectionEnd;
          } catch (e2) {
            return false;
          }
        } : function(te) {
          var range2;
          try {
            range2 = te.ownerDocument.selection.createRange();
          } catch (e2) {
          }
          if (!range2 || range2.parentElement() != te) {
            return false;
          }
          return range2.compareEndPoints("StartToEnd", range2) != 0;
        };
        var hasCopyEvent = function() {
          var e2 = elt("div");
          if ("oncopy" in e2) {
            return true;
          }
          e2.setAttribute("oncopy", "return;");
          return typeof e2.oncopy == "function";
        }();
        var badZoomedRects = null;
        function hasBadZoomedRects(measure) {
          if (badZoomedRects != null) {
            return badZoomedRects;
          }
          var node = removeChildrenAndAdd(measure, elt("span", "x"));
          var normal = node.getBoundingClientRect();
          var fromRange = range(node, 0, 1).getBoundingClientRect();
          return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
        }
        var modes = {}, mimeModes = {};
        function defineMode(name, mode) {
          if (arguments.length > 2) {
            mode.dependencies = Array.prototype.slice.call(arguments, 2);
          }
          modes[name] = mode;
        }
        function defineMIME(mime, spec) {
          mimeModes[mime] = spec;
        }
        function resolveMode(spec) {
          if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
            spec = mimeModes[spec];
          } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
            var found = mimeModes[spec.name];
            if (typeof found == "string") {
              found = { name: found };
            }
            spec = createObj(found, spec);
            spec.name = found.name;
          } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
            return resolveMode("application/xml");
          } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
            return resolveMode("application/json");
          }
          if (typeof spec == "string") {
            return { name: spec };
          } else {
            return spec || { name: "null" };
          }
        }
        function getMode(options, spec) {
          spec = resolveMode(spec);
          var mfactory = modes[spec.name];
          if (!mfactory) {
            return getMode(options, "text/plain");
          }
          var modeObj = mfactory(options, spec);
          if (modeExtensions.hasOwnProperty(spec.name)) {
            var exts = modeExtensions[spec.name];
            for (var prop2 in exts) {
              if (!exts.hasOwnProperty(prop2)) {
                continue;
              }
              if (modeObj.hasOwnProperty(prop2)) {
                modeObj["_" + prop2] = modeObj[prop2];
              }
              modeObj[prop2] = exts[prop2];
            }
          }
          modeObj.name = spec.name;
          if (spec.helperType) {
            modeObj.helperType = spec.helperType;
          }
          if (spec.modeProps) {
            for (var prop$1 in spec.modeProps) {
              modeObj[prop$1] = spec.modeProps[prop$1];
            }
          }
          return modeObj;
        }
        var modeExtensions = {};
        function extendMode(mode, properties) {
          var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
          copyObj(properties, exts);
        }
        function copyState(mode, state) {
          if (state === true) {
            return state;
          }
          if (mode.copyState) {
            return mode.copyState(state);
          }
          var nstate = {};
          for (var n2 in state) {
            var val = state[n2];
            if (val instanceof Array) {
              val = val.concat([]);
            }
            nstate[n2] = val;
          }
          return nstate;
        }
        function innerMode(mode, state) {
          var info;
          while (mode.innerMode) {
            info = mode.innerMode(state);
            if (!info || info.mode == mode) {
              break;
            }
            state = info.state;
            mode = info.mode;
          }
          return info || { mode, state };
        }
        function startState(mode, a1, a2) {
          return mode.startState ? mode.startState(a1, a2) : true;
        }
        var StringStream = function(string, tabSize, lineOracle) {
          this.pos = this.start = 0;
          this.string = string;
          this.tabSize = tabSize || 8;
          this.lastColumnPos = this.lastColumnValue = 0;
          this.lineStart = 0;
          this.lineOracle = lineOracle;
        };
        StringStream.prototype.eol = function() {
          return this.pos >= this.string.length;
        };
        StringStream.prototype.sol = function() {
          return this.pos == this.lineStart;
        };
        StringStream.prototype.peek = function() {
          return this.string.charAt(this.pos) || void 0;
        };
        StringStream.prototype.next = function() {
          if (this.pos < this.string.length) {
            return this.string.charAt(this.pos++);
          }
        };
        StringStream.prototype.eat = function(match) {
          var ch = this.string.charAt(this.pos);
          var ok;
          if (typeof match == "string") {
            ok = ch == match;
          } else {
            ok = ch && (match.test ? match.test(ch) : match(ch));
          }
          if (ok) {
            ++this.pos;
            return ch;
          }
        };
        StringStream.prototype.eatWhile = function(match) {
          var start4 = this.pos;
          while (this.eat(match)) {
          }
          return this.pos > start4;
        };
        StringStream.prototype.eatSpace = function() {
          var start4 = this.pos;
          while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
            ++this.pos;
          }
          return this.pos > start4;
        };
        StringStream.prototype.skipToEnd = function() {
          this.pos = this.string.length;
        };
        StringStream.prototype.skipTo = function(ch) {
          var found = this.string.indexOf(ch, this.pos);
          if (found > -1) {
            this.pos = found;
            return true;
          }
        };
        StringStream.prototype.backUp = function(n2) {
          this.pos -= n2;
        };
        StringStream.prototype.column = function() {
          if (this.lastColumnPos < this.start) {
            this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
            this.lastColumnPos = this.start;
          }
          return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
        };
        StringStream.prototype.indentation = function() {
          return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
        };
        StringStream.prototype.match = function(pattern, consume, caseInsensitive) {
          if (typeof pattern == "string") {
            var cased = function(str) {
              return caseInsensitive ? str.toLowerCase() : str;
            };
            var substr = this.string.substr(this.pos, pattern.length);
            if (cased(substr) == cased(pattern)) {
              if (consume !== false) {
                this.pos += pattern.length;
              }
              return true;
            }
          } else {
            var match = this.string.slice(this.pos).match(pattern);
            if (match && match.index > 0) {
              return null;
            }
            if (match && consume !== false) {
              this.pos += match[0].length;
            }
            return match;
          }
        };
        StringStream.prototype.current = function() {
          return this.string.slice(this.start, this.pos);
        };
        StringStream.prototype.hideFirstChars = function(n2, inner) {
          this.lineStart += n2;
          try {
            return inner();
          } finally {
            this.lineStart -= n2;
          }
        };
        StringStream.prototype.lookAhead = function(n2) {
          var oracle = this.lineOracle;
          return oracle && oracle.lookAhead(n2);
        };
        StringStream.prototype.baseToken = function() {
          var oracle = this.lineOracle;
          return oracle && oracle.baseToken(this.pos);
        };
        function getLine(doc, n2) {
          n2 -= doc.first;
          if (n2 < 0 || n2 >= doc.size) {
            throw new Error("There is no line " + (n2 + doc.first) + " in the document.");
          }
          var chunk = doc;
          while (!chunk.lines) {
            for (var i3 = 0; ; ++i3) {
              var child = chunk.children[i3], sz = child.chunkSize();
              if (n2 < sz) {
                chunk = child;
                break;
              }
              n2 -= sz;
            }
          }
          return chunk.lines[n2];
        }
        function getBetween(doc, start4, end2) {
          var out = [], n2 = start4.line;
          doc.iter(start4.line, end2.line + 1, function(line) {
            var text = line.text;
            if (n2 == end2.line) {
              text = text.slice(0, end2.ch);
            }
            if (n2 == start4.line) {
              text = text.slice(start4.ch);
            }
            out.push(text);
            ++n2;
          });
          return out;
        }
        function getLines(doc, from, to) {
          var out = [];
          doc.iter(from, to, function(line) {
            out.push(line.text);
          });
          return out;
        }
        function updateLineHeight(line, height) {
          var diff = height - line.height;
          if (diff) {
            for (var n2 = line; n2; n2 = n2.parent) {
              n2.height += diff;
            }
          }
        }
        function lineNo(line) {
          if (line.parent == null) {
            return null;
          }
          var cur = line.parent, no = indexOf2(cur.lines, line);
          for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
            for (var i3 = 0; ; ++i3) {
              if (chunk.children[i3] == cur) {
                break;
              }
              no += chunk.children[i3].chunkSize();
            }
          }
          return no + cur.first;
        }
        function lineAtHeight(chunk, h) {
          var n2 = chunk.first;
          outer:
            do {
              for (var i$12 = 0; i$12 < chunk.children.length; ++i$12) {
                var child = chunk.children[i$12], ch = child.height;
                if (h < ch) {
                  chunk = child;
                  continue outer;
                }
                h -= ch;
                n2 += child.chunkSize();
              }
              return n2;
            } while (!chunk.lines);
          var i3 = 0;
          for (; i3 < chunk.lines.length; ++i3) {
            var line = chunk.lines[i3], lh = line.height;
            if (h < lh) {
              break;
            }
            h -= lh;
          }
          return n2 + i3;
        }
        function isLine(doc, l2) {
          return l2 >= doc.first && l2 < doc.first + doc.size;
        }
        function lineNumberFor(options, i3) {
          return String(options.lineNumberFormatter(i3 + options.firstLineNumber));
        }
        function Pos(line, ch, sticky) {
          if (sticky === void 0)
            sticky = null;
          if (!(this instanceof Pos)) {
            return new Pos(line, ch, sticky);
          }
          this.line = line;
          this.ch = ch;
          this.sticky = sticky;
        }
        function cmp(a2, b2) {
          return a2.line - b2.line || a2.ch - b2.ch;
        }
        function equalCursorPos(a2, b2) {
          return a2.sticky == b2.sticky && cmp(a2, b2) == 0;
        }
        function copyPos(x2) {
          return Pos(x2.line, x2.ch);
        }
        function maxPos(a2, b2) {
          return cmp(a2, b2) < 0 ? b2 : a2;
        }
        function minPos(a2, b2) {
          return cmp(a2, b2) < 0 ? a2 : b2;
        }
        function clipLine(doc, n2) {
          return Math.max(doc.first, Math.min(n2, doc.first + doc.size - 1));
        }
        function clipPos(doc, pos) {
          if (pos.line < doc.first) {
            return Pos(doc.first, 0);
          }
          var last = doc.first + doc.size - 1;
          if (pos.line > last) {
            return Pos(last, getLine(doc, last).text.length);
          }
          return clipToLen(pos, getLine(doc, pos.line).text.length);
        }
        function clipToLen(pos, linelen) {
          var ch = pos.ch;
          if (ch == null || ch > linelen) {
            return Pos(pos.line, linelen);
          } else if (ch < 0) {
            return Pos(pos.line, 0);
          } else {
            return pos;
          }
        }
        function clipPosArray(doc, array) {
          var out = [];
          for (var i3 = 0; i3 < array.length; i3++) {
            out[i3] = clipPos(doc, array[i3]);
          }
          return out;
        }
        var SavedContext = function(state, lookAhead) {
          this.state = state;
          this.lookAhead = lookAhead;
        };
        var Context2 = function(doc, state, line, lookAhead) {
          this.state = state;
          this.doc = doc;
          this.line = line;
          this.maxLookAhead = lookAhead || 0;
          this.baseTokens = null;
          this.baseTokenPos = 1;
        };
        Context2.prototype.lookAhead = function(n2) {
          var line = this.doc.getLine(this.line + n2);
          if (line != null && n2 > this.maxLookAhead) {
            this.maxLookAhead = n2;
          }
          return line;
        };
        Context2.prototype.baseToken = function(n2) {
          if (!this.baseTokens) {
            return null;
          }
          while (this.baseTokens[this.baseTokenPos] <= n2) {
            this.baseTokenPos += 2;
          }
          var type = this.baseTokens[this.baseTokenPos + 1];
          return {
            type: type && type.replace(/( |^)overlay .*/, ""),
            size: this.baseTokens[this.baseTokenPos] - n2
          };
        };
        Context2.prototype.nextLine = function() {
          this.line++;
          if (this.maxLookAhead > 0) {
            this.maxLookAhead--;
          }
        };
        Context2.fromSaved = function(doc, saved, line) {
          if (saved instanceof SavedContext) {
            return new Context2(doc, copyState(doc.mode, saved.state), line, saved.lookAhead);
          } else {
            return new Context2(doc, copyState(doc.mode, saved), line);
          }
        };
        Context2.prototype.save = function(copy) {
          var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
          return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
        };
        function highlightLine(cm, line, context, forceToEnd) {
          var st = [cm.state.modeGen], lineClasses = {};
          runMode(cm, line.text, cm.doc.mode, context, function(end2, style) {
            return st.push(end2, style);
          }, lineClasses, forceToEnd);
          var state = context.state;
          var loop = function(o3) {
            context.baseTokens = st;
            var overlay = cm.state.overlays[o3], i3 = 1, at = 0;
            context.state = true;
            runMode(cm, line.text, overlay.mode, context, function(end2, style) {
              var start4 = i3;
              while (at < end2) {
                var i_end = st[i3];
                if (i_end > end2) {
                  st.splice(i3, 1, end2, st[i3 + 1], i_end);
                }
                i3 += 2;
                at = Math.min(end2, i_end);
              }
              if (!style) {
                return;
              }
              if (overlay.opaque) {
                st.splice(start4, i3 - start4, end2, "overlay " + style);
                i3 = start4 + 2;
              } else {
                for (; start4 < i3; start4 += 2) {
                  var cur = st[start4 + 1];
                  st[start4 + 1] = (cur ? cur + " " : "") + "overlay " + style;
                }
              }
            }, lineClasses);
            context.state = state;
            context.baseTokens = null;
            context.baseTokenPos = 1;
          };
          for (var o2 = 0; o2 < cm.state.overlays.length; ++o2)
            loop(o2);
          return { styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null };
        }
        function getLineStyles(cm, line, updateFrontier) {
          if (!line.styles || line.styles[0] != cm.state.modeGen) {
            var context = getContextBefore(cm, lineNo(line));
            var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
            var result = highlightLine(cm, line, context);
            if (resetState) {
              context.state = resetState;
            }
            line.stateAfter = context.save(!resetState);
            line.styles = result.styles;
            if (result.classes) {
              line.styleClasses = result.classes;
            } else if (line.styleClasses) {
              line.styleClasses = null;
            }
            if (updateFrontier === cm.doc.highlightFrontier) {
              cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
            }
          }
          return line.styles;
        }
        function getContextBefore(cm, n2, precise) {
          var doc = cm.doc, display = cm.display;
          if (!doc.mode.startState) {
            return new Context2(doc, true, n2);
          }
          var start4 = findStartLine(cm, n2, precise);
          var saved = start4 > doc.first && getLine(doc, start4 - 1).stateAfter;
          var context = saved ? Context2.fromSaved(doc, saved, start4) : new Context2(doc, startState(doc.mode), start4);
          doc.iter(start4, n2, function(line) {
            processLine(cm, line.text, context);
            var pos = context.line;
            line.stateAfter = pos == n2 - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
            context.nextLine();
          });
          if (precise) {
            doc.modeFrontier = context.line;
          }
          return context;
        }
        function processLine(cm, text, context, startAt) {
          var mode = cm.doc.mode;
          var stream = new StringStream(text, cm.options.tabSize, context);
          stream.start = stream.pos = startAt || 0;
          if (text == "") {
            callBlankLine(mode, context.state);
          }
          while (!stream.eol()) {
            readToken(mode, stream, context.state);
            stream.start = stream.pos;
          }
        }
        function callBlankLine(mode, state) {
          if (mode.blankLine) {
            return mode.blankLine(state);
          }
          if (!mode.innerMode) {
            return;
          }
          var inner = innerMode(mode, state);
          if (inner.mode.blankLine) {
            return inner.mode.blankLine(inner.state);
          }
        }
        function readToken(mode, stream, state, inner) {
          for (var i3 = 0; i3 < 10; i3++) {
            if (inner) {
              inner[0] = innerMode(mode, state).mode;
            }
            var style = mode.token(stream, state);
            if (stream.pos > stream.start) {
              return style;
            }
          }
          throw new Error("Mode " + mode.name + " failed to advance stream.");
        }
        var Token = function(stream, type, state) {
          this.start = stream.start;
          this.end = stream.pos;
          this.string = stream.current();
          this.type = type || null;
          this.state = state;
        };
        function takeToken(cm, pos, precise, asArray) {
          var doc = cm.doc, mode = doc.mode, style;
          pos = clipPos(doc, pos);
          var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
          var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
          if (asArray) {
            tokens = [];
          }
          while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
            stream.start = stream.pos;
            style = readToken(mode, stream, context.state);
            if (asArray) {
              tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));
            }
          }
          return asArray ? tokens : new Token(stream, style, context.state);
        }
        function extractLineClasses(type, output) {
          if (type) {
            for (; ; ) {
              var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
              if (!lineClass) {
                break;
              }
              type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
              var prop2 = lineClass[1] ? "bgClass" : "textClass";
              if (output[prop2] == null) {
                output[prop2] = lineClass[2];
              } else if (!new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)").test(output[prop2])) {
                output[prop2] += " " + lineClass[2];
              }
            }
          }
          return type;
        }
        function runMode(cm, text, mode, context, f2, lineClasses, forceToEnd) {
          var flattenSpans = mode.flattenSpans;
          if (flattenSpans == null) {
            flattenSpans = cm.options.flattenSpans;
          }
          var curStart = 0, curStyle = null;
          var stream = new StringStream(text, cm.options.tabSize, context), style;
          var inner = cm.options.addModeClass && [null];
          if (text == "") {
            extractLineClasses(callBlankLine(mode, context.state), lineClasses);
          }
          while (!stream.eol()) {
            if (stream.pos > cm.options.maxHighlightLength) {
              flattenSpans = false;
              if (forceToEnd) {
                processLine(cm, text, context, stream.pos);
              }
              stream.pos = text.length;
              style = null;
            } else {
              style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
            }
            if (inner) {
              var mName = inner[0].name;
              if (mName) {
                style = "m-" + (style ? mName + " " + style : mName);
              }
            }
            if (!flattenSpans || curStyle != style) {
              while (curStart < stream.start) {
                curStart = Math.min(stream.start, curStart + 5e3);
                f2(curStart, curStyle);
              }
              curStyle = style;
            }
            stream.start = stream.pos;
          }
          while (curStart < stream.pos) {
            var pos = Math.min(stream.pos, curStart + 5e3);
            f2(pos, curStyle);
            curStart = pos;
          }
        }
        function findStartLine(cm, n2, precise) {
          var minindent, minline, doc = cm.doc;
          var lim = precise ? -1 : n2 - (cm.doc.mode.innerMode ? 1e3 : 100);
          for (var search = n2; search > lim; --search) {
            if (search <= doc.first) {
              return doc.first;
            }
            var line = getLine(doc, search - 1), after = line.stateAfter;
            if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) {
              return search;
            }
            var indented = countColumn(line.text, null, cm.options.tabSize);
            if (minline == null || minindent > indented) {
              minline = search - 1;
              minindent = indented;
            }
          }
          return minline;
        }
        function retreatFrontier(doc, n2) {
          doc.modeFrontier = Math.min(doc.modeFrontier, n2);
          if (doc.highlightFrontier < n2 - 10) {
            return;
          }
          var start4 = doc.first;
          for (var line = n2 - 1; line > start4; line--) {
            var saved = getLine(doc, line).stateAfter;
            if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n2)) {
              start4 = line + 1;
              break;
            }
          }
          doc.highlightFrontier = Math.min(doc.highlightFrontier, start4);
        }
        var sawReadOnlySpans = false, sawCollapsedSpans = false;
        function seeReadOnlySpans() {
          sawReadOnlySpans = true;
        }
        function seeCollapsedSpans() {
          sawCollapsedSpans = true;
        }
        function MarkedSpan(marker, from, to) {
          this.marker = marker;
          this.from = from;
          this.to = to;
        }
        function getMarkedSpanFor(spans, marker) {
          if (spans) {
            for (var i3 = 0; i3 < spans.length; ++i3) {
              var span = spans[i3];
              if (span.marker == marker) {
                return span;
              }
            }
          }
        }
        function removeMarkedSpan(spans, span) {
          var r2;
          for (var i3 = 0; i3 < spans.length; ++i3) {
            if (spans[i3] != span) {
              (r2 || (r2 = [])).push(spans[i3]);
            }
          }
          return r2;
        }
        function addMarkedSpan(line, span) {
          line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
          span.marker.attachLine(line);
        }
        function markedSpansBefore(old, startCh, isInsert) {
          var nw;
          if (old) {
            for (var i3 = 0; i3 < old.length; ++i3) {
              var span = old[i3], marker = span.marker;
              var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
              if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
                var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
                (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
              }
            }
          }
          return nw;
        }
        function markedSpansAfter(old, endCh, isInsert) {
          var nw;
          if (old) {
            for (var i3 = 0; i3 < old.length; ++i3) {
              var span = old[i3], marker = span.marker;
              var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
              if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
                var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
                (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
              }
            }
          }
          return nw;
        }
        function stretchSpansOverChange(doc, change) {
          if (change.full) {
            return null;
          }
          var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
          var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
          if (!oldFirst && !oldLast) {
            return null;
          }
          var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
          var first = markedSpansBefore(oldFirst, startCh, isInsert);
          var last = markedSpansAfter(oldLast, endCh, isInsert);
          var sameLine = change.text.length == 1, offset2 = lst(change.text).length + (sameLine ? startCh : 0);
          if (first) {
            for (var i3 = 0; i3 < first.length; ++i3) {
              var span = first[i3];
              if (span.to == null) {
                var found = getMarkedSpanFor(last, span.marker);
                if (!found) {
                  span.to = startCh;
                } else if (sameLine) {
                  span.to = found.to == null ? null : found.to + offset2;
                }
              }
            }
          }
          if (last) {
            for (var i$12 = 0; i$12 < last.length; ++i$12) {
              var span$1 = last[i$12];
              if (span$1.to != null) {
                span$1.to += offset2;
              }
              if (span$1.from == null) {
                var found$1 = getMarkedSpanFor(first, span$1.marker);
                if (!found$1) {
                  span$1.from = offset2;
                  if (sameLine) {
                    (first || (first = [])).push(span$1);
                  }
                }
              } else {
                span$1.from += offset2;
                if (sameLine) {
                  (first || (first = [])).push(span$1);
                }
              }
            }
          }
          if (first) {
            first = clearEmptySpans(first);
          }
          if (last && last != first) {
            last = clearEmptySpans(last);
          }
          var newMarkers = [first];
          if (!sameLine) {
            var gap = change.text.length - 2, gapMarkers;
            if (gap > 0 && first) {
              for (var i$22 = 0; i$22 < first.length; ++i$22) {
                if (first[i$22].to == null) {
                  (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$22].marker, null, null));
                }
              }
            }
            for (var i$3 = 0; i$3 < gap; ++i$3) {
              newMarkers.push(gapMarkers);
            }
            newMarkers.push(last);
          }
          return newMarkers;
        }
        function clearEmptySpans(spans) {
          for (var i3 = 0; i3 < spans.length; ++i3) {
            var span = spans[i3];
            if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
              spans.splice(i3--, 1);
            }
          }
          if (!spans.length) {
            return null;
          }
          return spans;
        }
        function removeReadOnlyRanges(doc, from, to) {
          var markers = null;
          doc.iter(from.line, to.line + 1, function(line) {
            if (line.markedSpans) {
              for (var i4 = 0; i4 < line.markedSpans.length; ++i4) {
                var mark = line.markedSpans[i4].marker;
                if (mark.readOnly && (!markers || indexOf2(markers, mark) == -1)) {
                  (markers || (markers = [])).push(mark);
                }
              }
            }
          });
          if (!markers) {
            return null;
          }
          var parts = [{ from, to }];
          for (var i3 = 0; i3 < markers.length; ++i3) {
            var mk = markers[i3], m2 = mk.find(0);
            for (var j2 = 0; j2 < parts.length; ++j2) {
              var p2 = parts[j2];
              if (cmp(p2.to, m2.from) < 0 || cmp(p2.from, m2.to) > 0) {
                continue;
              }
              var newParts = [j2, 1], dfrom = cmp(p2.from, m2.from), dto = cmp(p2.to, m2.to);
              if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
                newParts.push({ from: p2.from, to: m2.from });
              }
              if (dto > 0 || !mk.inclusiveRight && !dto) {
                newParts.push({ from: m2.to, to: p2.to });
              }
              parts.splice.apply(parts, newParts);
              j2 += newParts.length - 3;
            }
          }
          return parts;
        }
        function detachMarkedSpans(line) {
          var spans = line.markedSpans;
          if (!spans) {
            return;
          }
          for (var i3 = 0; i3 < spans.length; ++i3) {
            spans[i3].marker.detachLine(line);
          }
          line.markedSpans = null;
        }
        function attachMarkedSpans(line, spans) {
          if (!spans) {
            return;
          }
          for (var i3 = 0; i3 < spans.length; ++i3) {
            spans[i3].marker.attachLine(line);
          }
          line.markedSpans = spans;
        }
        function extraLeft(marker) {
          return marker.inclusiveLeft ? -1 : 0;
        }
        function extraRight(marker) {
          return marker.inclusiveRight ? 1 : 0;
        }
        function compareCollapsedMarkers(a2, b2) {
          var lenDiff = a2.lines.length - b2.lines.length;
          if (lenDiff != 0) {
            return lenDiff;
          }
          var aPos = a2.find(), bPos = b2.find();
          var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a2) - extraLeft(b2);
          if (fromCmp) {
            return -fromCmp;
          }
          var toCmp = cmp(aPos.to, bPos.to) || extraRight(a2) - extraRight(b2);
          if (toCmp) {
            return toCmp;
          }
          return b2.id - a2.id;
        }
        function collapsedSpanAtSide(line, start4) {
          var sps = sawCollapsedSpans && line.markedSpans, found;
          if (sps) {
            for (var sp = void 0, i3 = 0; i3 < sps.length; ++i3) {
              sp = sps[i3];
              if (sp.marker.collapsed && (start4 ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
                found = sp.marker;
              }
            }
          }
          return found;
        }
        function collapsedSpanAtStart(line) {
          return collapsedSpanAtSide(line, true);
        }
        function collapsedSpanAtEnd(line) {
          return collapsedSpanAtSide(line, false);
        }
        function collapsedSpanAround(line, ch) {
          var sps = sawCollapsedSpans && line.markedSpans, found;
          if (sps) {
            for (var i3 = 0; i3 < sps.length; ++i3) {
              var sp = sps[i3];
              if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
                found = sp.marker;
              }
            }
          }
          return found;
        }
        function conflictingCollapsedRange(doc, lineNo2, from, to, marker) {
          var line = getLine(doc, lineNo2);
          var sps = sawCollapsedSpans && line.markedSpans;
          if (sps) {
            for (var i3 = 0; i3 < sps.length; ++i3) {
              var sp = sps[i3];
              if (!sp.marker.collapsed) {
                continue;
              }
              var found = sp.marker.find(0);
              var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
              var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
              if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
                continue;
              }
              if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
                return true;
              }
            }
          }
        }
        function visualLine(line) {
          var merged;
          while (merged = collapsedSpanAtStart(line)) {
            line = merged.find(-1, true).line;
          }
          return line;
        }
        function visualLineEnd(line) {
          var merged;
          while (merged = collapsedSpanAtEnd(line)) {
            line = merged.find(1, true).line;
          }
          return line;
        }
        function visualLineContinued(line) {
          var merged, lines;
          while (merged = collapsedSpanAtEnd(line)) {
            line = merged.find(1, true).line;
            (lines || (lines = [])).push(line);
          }
          return lines;
        }
        function visualLineNo(doc, lineN) {
          var line = getLine(doc, lineN), vis = visualLine(line);
          if (line == vis) {
            return lineN;
          }
          return lineNo(vis);
        }
        function visualLineEndNo(doc, lineN) {
          if (lineN > doc.lastLine()) {
            return lineN;
          }
          var line = getLine(doc, lineN), merged;
          if (!lineIsHidden(doc, line)) {
            return lineN;
          }
          while (merged = collapsedSpanAtEnd(line)) {
            line = merged.find(1, true).line;
          }
          return lineNo(line) + 1;
        }
        function lineIsHidden(doc, line) {
          var sps = sawCollapsedSpans && line.markedSpans;
          if (sps) {
            for (var sp = void 0, i3 = 0; i3 < sps.length; ++i3) {
              sp = sps[i3];
              if (!sp.marker.collapsed) {
                continue;
              }
              if (sp.from == null) {
                return true;
              }
              if (sp.marker.widgetNode) {
                continue;
              }
              if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {
                return true;
              }
            }
          }
        }
        function lineIsHiddenInner(doc, line, span) {
          if (span.to == null) {
            var end2 = span.marker.find(1, true);
            return lineIsHiddenInner(doc, end2.line, getMarkedSpanFor(end2.line.markedSpans, span.marker));
          }
          if (span.marker.inclusiveRight && span.to == line.text.length) {
            return true;
          }
          for (var sp = void 0, i3 = 0; i3 < line.markedSpans.length; ++i3) {
            sp = line.markedSpans[i3];
            if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {
              return true;
            }
          }
        }
        function heightAtLine(lineObj) {
          lineObj = visualLine(lineObj);
          var h = 0, chunk = lineObj.parent;
          for (var i3 = 0; i3 < chunk.lines.length; ++i3) {
            var line = chunk.lines[i3];
            if (line == lineObj) {
              break;
            } else {
              h += line.height;
            }
          }
          for (var p2 = chunk.parent; p2; chunk = p2, p2 = chunk.parent) {
            for (var i$12 = 0; i$12 < p2.children.length; ++i$12) {
              var cur = p2.children[i$12];
              if (cur == chunk) {
                break;
              } else {
                h += cur.height;
              }
            }
          }
          return h;
        }
        function lineLength(line) {
          if (line.height == 0) {
            return 0;
          }
          var len = line.text.length, merged, cur = line;
          while (merged = collapsedSpanAtStart(cur)) {
            var found = merged.find(0, true);
            cur = found.from.line;
            len += found.from.ch - found.to.ch;
          }
          cur = line;
          while (merged = collapsedSpanAtEnd(cur)) {
            var found$1 = merged.find(0, true);
            len -= cur.text.length - found$1.from.ch;
            cur = found$1.to.line;
            len += cur.text.length - found$1.to.ch;
          }
          return len;
        }
        function findMaxLine(cm) {
          var d2 = cm.display, doc = cm.doc;
          d2.maxLine = getLine(doc, doc.first);
          d2.maxLineLength = lineLength(d2.maxLine);
          d2.maxLineChanged = true;
          doc.iter(function(line) {
            var len = lineLength(line);
            if (len > d2.maxLineLength) {
              d2.maxLineLength = len;
              d2.maxLine = line;
            }
          });
        }
        var Line = function(text, markedSpans, estimateHeight2) {
          this.text = text;
          attachMarkedSpans(this, markedSpans);
          this.height = estimateHeight2 ? estimateHeight2(this) : 1;
        };
        Line.prototype.lineNo = function() {
          return lineNo(this);
        };
        eventMixin(Line);
        function updateLine(line, text, markedSpans, estimateHeight2) {
          line.text = text;
          if (line.stateAfter) {
            line.stateAfter = null;
          }
          if (line.styles) {
            line.styles = null;
          }
          if (line.order != null) {
            line.order = null;
          }
          detachMarkedSpans(line);
          attachMarkedSpans(line, markedSpans);
          var estHeight = estimateHeight2 ? estimateHeight2(line) : 1;
          if (estHeight != line.height) {
            updateLineHeight(line, estHeight);
          }
        }
        function cleanUpLine(line) {
          line.parent = null;
          detachMarkedSpans(line);
        }
        var styleToClassCache = {}, styleToClassCacheWithMode = {};
        function interpretTokenStyle(style, options) {
          if (!style || /^\s*$/.test(style)) {
            return null;
          }
          var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
          return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
        }
        function buildLineContent(cm, lineView) {
          var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
          var builder = {
            pre: eltP("pre", [content], "CodeMirror-line"),
            content,
            col: 0,
            pos: 0,
            cm,
            trailingSpace: false,
            splitSpaces: cm.getOption("lineWrapping")
          };
          lineView.measure = {};
          for (var i3 = 0; i3 <= (lineView.rest ? lineView.rest.length : 0); i3++) {
            var line = i3 ? lineView.rest[i3 - 1] : lineView.line, order2 = void 0;
            builder.pos = 0;
            builder.addToken = buildToken;
            if (hasBadBidiRects(cm.display.measure) && (order2 = getOrder(line, cm.doc.direction))) {
              builder.addToken = buildTokenBadBidi(builder.addToken, order2);
            }
            builder.map = [];
            var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
            insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
            if (line.styleClasses) {
              if (line.styleClasses.bgClass) {
                builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
              }
              if (line.styleClasses.textClass) {
                builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
              }
            }
            if (builder.map.length == 0) {
              builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
            }
            if (i3 == 0) {
              lineView.measure.map = builder.map;
              lineView.measure.cache = {};
            } else {
              (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
              (lineView.measure.caches || (lineView.measure.caches = [])).push({});
            }
          }
          if (webkit) {
            var last = builder.content.lastChild;
            if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
              builder.content.className = "cm-tab-wrap-hack";
            }
          }
          signal(cm, "renderLine", cm, lineView.line, builder.pre);
          if (builder.pre.className) {
            builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
          }
          return builder;
        }
        function defaultSpecialCharPlaceholder(ch) {
          var token = elt("span", "\u2022", "cm-invalidchar");
          token.title = "\\u" + ch.charCodeAt(0).toString(16);
          token.setAttribute("aria-label", token.title);
          return token;
        }
        function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
          if (!text) {
            return;
          }
          var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
          var special = builder.cm.state.specialChars, mustWrap = false;
          var content;
          if (!special.test(text)) {
            builder.col += text.length;
            content = document.createTextNode(displayText);
            builder.map.push(builder.pos, builder.pos + text.length, content);
            if (ie && ie_version < 9) {
              mustWrap = true;
            }
            builder.pos += text.length;
          } else {
            content = document.createDocumentFragment();
            var pos = 0;
            while (true) {
              special.lastIndex = pos;
              var m2 = special.exec(text);
              var skipped = m2 ? m2.index - pos : text.length - pos;
              if (skipped) {
                var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
                if (ie && ie_version < 9) {
                  content.appendChild(elt("span", [txt]));
                } else {
                  content.appendChild(txt);
                }
                builder.map.push(builder.pos, builder.pos + skipped, txt);
                builder.col += skipped;
                builder.pos += skipped;
              }
              if (!m2) {
                break;
              }
              pos += skipped + 1;
              var txt$1 = void 0;
              if (m2[0] == "	") {
                var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
                txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
                txt$1.setAttribute("role", "presentation");
                txt$1.setAttribute("cm-text", "	");
                builder.col += tabWidth;
              } else if (m2[0] == "\r" || m2[0] == "\n") {
                txt$1 = content.appendChild(elt("span", m2[0] == "\r" ? "\u240D" : "\u2424", "cm-invalidchar"));
                txt$1.setAttribute("cm-text", m2[0]);
                builder.col += 1;
              } else {
                txt$1 = builder.cm.options.specialCharPlaceholder(m2[0]);
                txt$1.setAttribute("cm-text", m2[0]);
                if (ie && ie_version < 9) {
                  content.appendChild(elt("span", [txt$1]));
                } else {
                  content.appendChild(txt$1);
                }
                builder.col += 1;
              }
              builder.map.push(builder.pos, builder.pos + 1, txt$1);
              builder.pos++;
            }
          }
          builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
          if (style || startStyle || endStyle || mustWrap || css || attributes) {
            var fullStyle = style || "";
            if (startStyle) {
              fullStyle += startStyle;
            }
            if (endStyle) {
              fullStyle += endStyle;
            }
            var token = elt("span", [content], fullStyle, css);
            if (attributes) {
              for (var attr in attributes) {
                if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class") {
                  token.setAttribute(attr, attributes[attr]);
                }
              }
            }
            return builder.content.appendChild(token);
          }
          builder.content.appendChild(content);
        }
        function splitSpaces(text, trailingBefore) {
          if (text.length > 1 && !/  /.test(text)) {
            return text;
          }
          var spaceBefore = trailingBefore, result = "";
          for (var i3 = 0; i3 < text.length; i3++) {
            var ch = text.charAt(i3);
            if (ch == " " && spaceBefore && (i3 == text.length - 1 || text.charCodeAt(i3 + 1) == 32)) {
              ch = "\xA0";
            }
            result += ch;
            spaceBefore = ch == " ";
          }
          return result;
        }
        function buildTokenBadBidi(inner, order2) {
          return function(builder, text, style, startStyle, endStyle, css, attributes) {
            style = style ? style + " cm-force-border" : "cm-force-border";
            var start4 = builder.pos, end2 = start4 + text.length;
            for (; ; ) {
              var part = void 0;
              for (var i3 = 0; i3 < order2.length; i3++) {
                part = order2[i3];
                if (part.to > start4 && part.from <= start4) {
                  break;
                }
              }
              if (part.to >= end2) {
                return inner(builder, text, style, startStyle, endStyle, css, attributes);
              }
              inner(builder, text.slice(0, part.to - start4), style, startStyle, null, css, attributes);
              startStyle = null;
              text = text.slice(part.to - start4);
              start4 = part.to;
            }
          };
        }
        function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
          var widget = !ignoreWidget && marker.widgetNode;
          if (widget) {
            builder.map.push(builder.pos, builder.pos + size, widget);
          }
          if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
            if (!widget) {
              widget = builder.content.appendChild(document.createElement("span"));
            }
            widget.setAttribute("cm-marker", marker.id);
          }
          if (widget) {
            builder.cm.display.input.setUneditable(widget);
            builder.content.appendChild(widget);
          }
          builder.pos += size;
          builder.trailingSpace = false;
        }
        function insertLineContent(line, builder, styles) {
          var spans = line.markedSpans, allText = line.text, at = 0;
          if (!spans) {
            for (var i$12 = 1; i$12 < styles.length; i$12 += 2) {
              builder.addToken(builder, allText.slice(at, at = styles[i$12]), interpretTokenStyle(styles[i$12 + 1], builder.cm.options));
            }
            return;
          }
          var len = allText.length, pos = 0, i3 = 1, text = "", style, css;
          var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
          for (; ; ) {
            if (nextChange == pos) {
              spanStyle = spanEndStyle = spanStartStyle = css = "";
              attributes = null;
              collapsed = null;
              nextChange = Infinity;
              var foundBookmarks = [], endStyles = void 0;
              for (var j2 = 0; j2 < spans.length; ++j2) {
                var sp = spans[j2], m2 = sp.marker;
                if (m2.type == "bookmark" && sp.from == pos && m2.widgetNode) {
                  foundBookmarks.push(m2);
                } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m2.collapsed && sp.to == pos && sp.from == pos)) {
                  if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                    nextChange = sp.to;
                    spanEndStyle = "";
                  }
                  if (m2.className) {
                    spanStyle += " " + m2.className;
                  }
                  if (m2.css) {
                    css = (css ? css + ";" : "") + m2.css;
                  }
                  if (m2.startStyle && sp.from == pos) {
                    spanStartStyle += " " + m2.startStyle;
                  }
                  if (m2.endStyle && sp.to == nextChange) {
                    (endStyles || (endStyles = [])).push(m2.endStyle, sp.to);
                  }
                  if (m2.title) {
                    (attributes || (attributes = {})).title = m2.title;
                  }
                  if (m2.attributes) {
                    for (var attr in m2.attributes) {
                      (attributes || (attributes = {}))[attr] = m2.attributes[attr];
                    }
                  }
                  if (m2.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m2) < 0)) {
                    collapsed = sp;
                  }
                } else if (sp.from > pos && nextChange > sp.from) {
                  nextChange = sp.from;
                }
              }
              if (endStyles) {
                for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {
                  if (endStyles[j$1 + 1] == nextChange) {
                    spanEndStyle += " " + endStyles[j$1];
                  }
                }
              }
              if (!collapsed || collapsed.from == pos) {
                for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
                  buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
                }
              }
              if (collapsed && (collapsed.from || 0) == pos) {
                buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
                if (collapsed.to == null) {
                  return;
                }
                if (collapsed.to == pos) {
                  collapsed = false;
                }
              }
            }
            if (pos >= len) {
              break;
            }
            var upto = Math.min(len, nextChange);
            while (true) {
              if (text) {
                var end2 = pos + text.length;
                if (!collapsed) {
                  var tokenText = end2 > upto ? text.slice(0, upto - pos) : text;
                  builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
                }
                if (end2 >= upto) {
                  text = text.slice(upto - pos);
                  pos = upto;
                  break;
                }
                pos = end2;
                spanStartStyle = "";
              }
              text = allText.slice(at, at = styles[i3++]);
              style = interpretTokenStyle(styles[i3++], builder.cm.options);
            }
          }
        }
        function LineView(doc, line, lineN) {
          this.line = line;
          this.rest = visualLineContinued(line);
          this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
          this.node = this.text = null;
          this.hidden = lineIsHidden(doc, line);
        }
        function buildViewArray(cm, from, to) {
          var array = [], nextPos;
          for (var pos = from; pos < to; pos = nextPos) {
            var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
            nextPos = pos + view.size;
            array.push(view);
          }
          return array;
        }
        var operationGroup = null;
        function pushOperation(op) {
          if (operationGroup) {
            operationGroup.ops.push(op);
          } else {
            op.ownsGroup = operationGroup = {
              ops: [op],
              delayedCallbacks: []
            };
          }
        }
        function fireCallbacksForOps(group) {
          var callbacks = group.delayedCallbacks, i3 = 0;
          do {
            for (; i3 < callbacks.length; i3++) {
              callbacks[i3].call(null);
            }
            for (var j2 = 0; j2 < group.ops.length; j2++) {
              var op = group.ops[j2];
              if (op.cursorActivityHandlers) {
                while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
                  op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
                }
              }
            }
          } while (i3 < callbacks.length);
        }
        function finishOperation(op, endCb) {
          var group = op.ownsGroup;
          if (!group) {
            return;
          }
          try {
            fireCallbacksForOps(group);
          } finally {
            operationGroup = null;
            endCb(group);
          }
        }
        var orphanDelayedCallbacks = null;
        function signalLater(emitter, type) {
          var arr = getHandlers(emitter, type);
          if (!arr.length) {
            return;
          }
          var args = Array.prototype.slice.call(arguments, 2), list;
          if (operationGroup) {
            list = operationGroup.delayedCallbacks;
          } else if (orphanDelayedCallbacks) {
            list = orphanDelayedCallbacks;
          } else {
            list = orphanDelayedCallbacks = [];
            setTimeout(fireOrphanDelayed, 0);
          }
          var loop = function(i4) {
            list.push(function() {
              return arr[i4].apply(null, args);
            });
          };
          for (var i3 = 0; i3 < arr.length; ++i3)
            loop(i3);
        }
        function fireOrphanDelayed() {
          var delayed = orphanDelayedCallbacks;
          orphanDelayedCallbacks = null;
          for (var i3 = 0; i3 < delayed.length; ++i3) {
            delayed[i3]();
          }
        }
        function updateLineForChanges(cm, lineView, lineN, dims) {
          for (var j2 = 0; j2 < lineView.changes.length; j2++) {
            var type = lineView.changes[j2];
            if (type == "text") {
              updateLineText(cm, lineView);
            } else if (type == "gutter") {
              updateLineGutter(cm, lineView, lineN, dims);
            } else if (type == "class") {
              updateLineClasses(cm, lineView);
            } else if (type == "widget") {
              updateLineWidgets(cm, lineView, dims);
            }
          }
          lineView.changes = null;
        }
        function ensureLineWrapped(lineView) {
          if (lineView.node == lineView.text) {
            lineView.node = elt("div", null, null, "position: relative");
            if (lineView.text.parentNode) {
              lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
            }
            lineView.node.appendChild(lineView.text);
            if (ie && ie_version < 8) {
              lineView.node.style.zIndex = 2;
            }
          }
          return lineView.node;
        }
        function updateLineBackground(cm, lineView) {
          var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
          if (cls) {
            cls += " CodeMirror-linebackground";
          }
          if (lineView.background) {
            if (cls) {
              lineView.background.className = cls;
            } else {
              lineView.background.parentNode.removeChild(lineView.background);
              lineView.background = null;
            }
          } else if (cls) {
            var wrap2 = ensureLineWrapped(lineView);
            lineView.background = wrap2.insertBefore(elt("div", null, cls), wrap2.firstChild);
            cm.display.input.setUneditable(lineView.background);
          }
        }
        function getLineContent(cm, lineView) {
          var ext = cm.display.externalMeasured;
          if (ext && ext.line == lineView.line) {
            cm.display.externalMeasured = null;
            lineView.measure = ext.measure;
            return ext.built;
          }
          return buildLineContent(cm, lineView);
        }
        function updateLineText(cm, lineView) {
          var cls = lineView.text.className;
          var built = getLineContent(cm, lineView);
          if (lineView.text == lineView.node) {
            lineView.node = built.pre;
          }
          lineView.text.parentNode.replaceChild(built.pre, lineView.text);
          lineView.text = built.pre;
          if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
            lineView.bgClass = built.bgClass;
            lineView.textClass = built.textClass;
            updateLineClasses(cm, lineView);
          } else if (cls) {
            lineView.text.className = cls;
          }
        }
        function updateLineClasses(cm, lineView) {
          updateLineBackground(cm, lineView);
          if (lineView.line.wrapClass) {
            ensureLineWrapped(lineView).className = lineView.line.wrapClass;
          } else if (lineView.node != lineView.text) {
            lineView.node.className = "";
          }
          var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
          lineView.text.className = textClass || "";
        }
        function updateLineGutter(cm, lineView, lineN, dims) {
          if (lineView.gutter) {
            lineView.node.removeChild(lineView.gutter);
            lineView.gutter = null;
          }
          if (lineView.gutterBackground) {
            lineView.node.removeChild(lineView.gutterBackground);
            lineView.gutterBackground = null;
          }
          if (lineView.line.gutterClass) {
            var wrap2 = ensureLineWrapped(lineView);
            lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
            cm.display.input.setUneditable(lineView.gutterBackground);
            wrap2.insertBefore(lineView.gutterBackground, lineView.text);
          }
          var markers = lineView.line.gutterMarkers;
          if (cm.options.lineNumbers || markers) {
            var wrap$1 = ensureLineWrapped(lineView);
            var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
            cm.display.input.setUneditable(gutterWrap);
            wrap$1.insertBefore(gutterWrap, lineView.text);
            if (lineView.line.gutterClass) {
              gutterWrap.className += " " + lineView.line.gutterClass;
            }
            if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
              lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));
            }
            if (markers) {
              for (var k2 = 0; k2 < cm.display.gutterSpecs.length; ++k2) {
                var id = cm.display.gutterSpecs[k2].className, found = markers.hasOwnProperty(id) && markers[id];
                if (found) {
                  gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
                }
              }
            }
          }
        }
        function updateLineWidgets(cm, lineView, dims) {
          if (lineView.alignable) {
            lineView.alignable = null;
          }
          var isWidget = classTest("CodeMirror-linewidget");
          for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
            next = node.nextSibling;
            if (isWidget.test(node.className)) {
              lineView.node.removeChild(node);
            }
          }
          insertLineWidgets(cm, lineView, dims);
        }
        function buildLineElement(cm, lineView, lineN, dims) {
          var built = getLineContent(cm, lineView);
          lineView.text = lineView.node = built.pre;
          if (built.bgClass) {
            lineView.bgClass = built.bgClass;
          }
          if (built.textClass) {
            lineView.textClass = built.textClass;
          }
          updateLineClasses(cm, lineView);
          updateLineGutter(cm, lineView, lineN, dims);
          insertLineWidgets(cm, lineView, dims);
          return lineView.node;
        }
        function insertLineWidgets(cm, lineView, dims) {
          insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
          if (lineView.rest) {
            for (var i3 = 0; i3 < lineView.rest.length; i3++) {
              insertLineWidgetsFor(cm, lineView.rest[i3], lineView, dims, false);
            }
          }
        }
        function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
          if (!line.widgets) {
            return;
          }
          var wrap2 = ensureLineWrapped(lineView);
          for (var i3 = 0, ws = line.widgets; i3 < ws.length; ++i3) {
            var widget = ws[i3], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
            if (!widget.handleMouseEvents) {
              node.setAttribute("cm-ignore-events", "true");
            }
            positionLineWidget(widget, node, lineView, dims);
            cm.display.input.setUneditable(node);
            if (allowAbove && widget.above) {
              wrap2.insertBefore(node, lineView.gutter || lineView.text);
            } else {
              wrap2.appendChild(node);
            }
            signalLater(widget, "redraw");
          }
        }
        function positionLineWidget(widget, node, lineView, dims) {
          if (widget.noHScroll) {
            (lineView.alignable || (lineView.alignable = [])).push(node);
            var width = dims.wrapperWidth;
            node.style.left = dims.fixedPos + "px";
            if (!widget.coverGutter) {
              width -= dims.gutterTotalWidth;
              node.style.paddingLeft = dims.gutterTotalWidth + "px";
            }
            node.style.width = width + "px";
          }
          if (widget.coverGutter) {
            node.style.zIndex = 5;
            node.style.position = "relative";
            if (!widget.noHScroll) {
              node.style.marginLeft = -dims.gutterTotalWidth + "px";
            }
          }
        }
        function widgetHeight(widget) {
          if (widget.height != null) {
            return widget.height;
          }
          var cm = widget.doc.cm;
          if (!cm) {
            return 0;
          }
          if (!contains2(document.body, widget.node)) {
            var parentStyle = "position: relative;";
            if (widget.coverGutter) {
              parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
            }
            if (widget.noHScroll) {
              parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
            }
            removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
          }
          return widget.height = widget.node.parentNode.offsetHeight;
        }
        function eventInWidget(display, e2) {
          for (var n2 = e_target(e2); n2 != display.wrapper; n2 = n2.parentNode) {
            if (!n2 || n2.nodeType == 1 && n2.getAttribute("cm-ignore-events") == "true" || n2.parentNode == display.sizer && n2 != display.mover) {
              return true;
            }
          }
        }
        function paddingTop(display) {
          return display.lineSpace.offsetTop;
        }
        function paddingVert(display) {
          return display.mover.offsetHeight - display.lineSpace.offsetHeight;
        }
        function paddingH(display) {
          if (display.cachedPaddingH) {
            return display.cachedPaddingH;
          }
          var e2 = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
          var style = window.getComputedStyle ? window.getComputedStyle(e2) : e2.currentStyle;
          var data = { left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight) };
          if (!isNaN(data.left) && !isNaN(data.right)) {
            display.cachedPaddingH = data;
          }
          return data;
        }
        function scrollGap(cm) {
          return scrollerGap - cm.display.nativeBarWidth;
        }
        function displayWidth(cm) {
          return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
        }
        function displayHeight(cm) {
          return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
        }
        function ensureLineHeights(cm, lineView, rect) {
          var wrapping = cm.options.lineWrapping;
          var curWidth = wrapping && displayWidth(cm);
          if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
            var heights = lineView.measure.heights = [];
            if (wrapping) {
              lineView.measure.width = curWidth;
              var rects = lineView.text.firstChild.getClientRects();
              for (var i3 = 0; i3 < rects.length - 1; i3++) {
                var cur = rects[i3], next = rects[i3 + 1];
                if (Math.abs(cur.bottom - next.bottom) > 2) {
                  heights.push((cur.bottom + next.top) / 2 - rect.top);
                }
              }
            }
            heights.push(rect.bottom - rect.top);
          }
        }
        function mapFromLineView(lineView, line, lineN) {
          if (lineView.line == line) {
            return { map: lineView.measure.map, cache: lineView.measure.cache };
          }
          for (var i3 = 0; i3 < lineView.rest.length; i3++) {
            if (lineView.rest[i3] == line) {
              return { map: lineView.measure.maps[i3], cache: lineView.measure.caches[i3] };
            }
          }
          for (var i$12 = 0; i$12 < lineView.rest.length; i$12++) {
            if (lineNo(lineView.rest[i$12]) > lineN) {
              return { map: lineView.measure.maps[i$12], cache: lineView.measure.caches[i$12], before: true };
            }
          }
        }
        function updateExternalMeasurement(cm, line) {
          line = visualLine(line);
          var lineN = lineNo(line);
          var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
          view.lineN = lineN;
          var built = view.built = buildLineContent(cm, view);
          view.text = built.pre;
          removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
          return view;
        }
        function measureChar(cm, line, ch, bias) {
          return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
        }
        function findViewForLine(cm, lineN) {
          if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
            return cm.display.view[findViewIndex(cm, lineN)];
          }
          var ext = cm.display.externalMeasured;
          if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
            return ext;
          }
        }
        function prepareMeasureForLine(cm, line) {
          var lineN = lineNo(line);
          var view = findViewForLine(cm, lineN);
          if (view && !view.text) {
            view = null;
          } else if (view && view.changes) {
            updateLineForChanges(cm, view, lineN, getDimensions(cm));
            cm.curOp.forceUpdate = true;
          }
          if (!view) {
            view = updateExternalMeasurement(cm, line);
          }
          var info = mapFromLineView(view, line, lineN);
          return {
            line,
            view,
            rect: null,
            map: info.map,
            cache: info.cache,
            before: info.before,
            hasHeights: false
          };
        }
        function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
          if (prepared.before) {
            ch = -1;
          }
          var key = ch + (bias || ""), found;
          if (prepared.cache.hasOwnProperty(key)) {
            found = prepared.cache[key];
          } else {
            if (!prepared.rect) {
              prepared.rect = prepared.view.text.getBoundingClientRect();
            }
            if (!prepared.hasHeights) {
              ensureLineHeights(cm, prepared.view, prepared.rect);
              prepared.hasHeights = true;
            }
            found = measureCharInner(cm, prepared, ch, bias);
            if (!found.bogus) {
              prepared.cache[key] = found;
            }
          }
          return {
            left: found.left,
            right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom
          };
        }
        var nullRect = { left: 0, right: 0, top: 0, bottom: 0 };
        function nodeAndOffsetInLineMap(map2, ch, bias) {
          var node, start4, end2, collapse, mStart, mEnd;
          for (var i3 = 0; i3 < map2.length; i3 += 3) {
            mStart = map2[i3];
            mEnd = map2[i3 + 1];
            if (ch < mStart) {
              start4 = 0;
              end2 = 1;
              collapse = "left";
            } else if (ch < mEnd) {
              start4 = ch - mStart;
              end2 = start4 + 1;
            } else if (i3 == map2.length - 3 || ch == mEnd && map2[i3 + 3] > ch) {
              end2 = mEnd - mStart;
              start4 = end2 - 1;
              if (ch >= mEnd) {
                collapse = "right";
              }
            }
            if (start4 != null) {
              node = map2[i3 + 2];
              if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
                collapse = bias;
              }
              if (bias == "left" && start4 == 0) {
                while (i3 && map2[i3 - 2] == map2[i3 - 3] && map2[i3 - 1].insertLeft) {
                  node = map2[(i3 -= 3) + 2];
                  collapse = "left";
                }
              }
              if (bias == "right" && start4 == mEnd - mStart) {
                while (i3 < map2.length - 3 && map2[i3 + 3] == map2[i3 + 4] && !map2[i3 + 5].insertLeft) {
                  node = map2[(i3 += 3) + 2];
                  collapse = "right";
                }
              }
              break;
            }
          }
          return { node, start: start4, end: end2, collapse, coverStart: mStart, coverEnd: mEnd };
        }
        function getUsefulRect(rects, bias) {
          var rect = nullRect;
          if (bias == "left") {
            for (var i3 = 0; i3 < rects.length; i3++) {
              if ((rect = rects[i3]).left != rect.right) {
                break;
              }
            }
          } else {
            for (var i$12 = rects.length - 1; i$12 >= 0; i$12--) {
              if ((rect = rects[i$12]).left != rect.right) {
                break;
              }
            }
          }
          return rect;
        }
        function measureCharInner(cm, prepared, ch, bias) {
          var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
          var node = place.node, start4 = place.start, end2 = place.end, collapse = place.collapse;
          var rect;
          if (node.nodeType == 3) {
            for (var i$12 = 0; i$12 < 4; i$12++) {
              while (start4 && isExtendingChar(prepared.line.text.charAt(place.coverStart + start4))) {
                --start4;
              }
              while (place.coverStart + end2 < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end2))) {
                ++end2;
              }
              if (ie && ie_version < 9 && start4 == 0 && end2 == place.coverEnd - place.coverStart) {
                rect = node.parentNode.getBoundingClientRect();
              } else {
                rect = getUsefulRect(range(node, start4, end2).getClientRects(), bias);
              }
              if (rect.left || rect.right || start4 == 0) {
                break;
              }
              end2 = start4;
              start4 = start4 - 1;
              collapse = "right";
            }
            if (ie && ie_version < 11) {
              rect = maybeUpdateRectForZooming(cm.display.measure, rect);
            }
          } else {
            if (start4 > 0) {
              collapse = bias = "right";
            }
            var rects;
            if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
              rect = rects[bias == "right" ? rects.length - 1 : 0];
            } else {
              rect = node.getBoundingClientRect();
            }
          }
          if (ie && ie_version < 9 && !start4 && (!rect || !rect.left && !rect.right)) {
            var rSpan = node.parentNode.getClientRects()[0];
            if (rSpan) {
              rect = { left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom };
            } else {
              rect = nullRect;
            }
          }
          var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
          var mid = (rtop + rbot) / 2;
          var heights = prepared.view.measure.heights;
          var i3 = 0;
          for (; i3 < heights.length - 1; i3++) {
            if (mid < heights[i3]) {
              break;
            }
          }
          var top2 = i3 ? heights[i3 - 1] : 0, bot = heights[i3];
          var result = {
            left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
            right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
            top: top2,
            bottom: bot
          };
          if (!rect.left && !rect.right) {
            result.bogus = true;
          }
          if (!cm.options.singleCursorHeightPerLine) {
            result.rtop = rtop;
            result.rbottom = rbot;
          }
          return result;
        }
        function maybeUpdateRectForZooming(measure, rect) {
          if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
            return rect;
          }
          var scaleX = screen.logicalXDPI / screen.deviceXDPI;
          var scaleY = screen.logicalYDPI / screen.deviceYDPI;
          return {
            left: rect.left * scaleX,
            right: rect.right * scaleX,
            top: rect.top * scaleY,
            bottom: rect.bottom * scaleY
          };
        }
        function clearLineMeasurementCacheFor(lineView) {
          if (lineView.measure) {
            lineView.measure.cache = {};
            lineView.measure.heights = null;
            if (lineView.rest) {
              for (var i3 = 0; i3 < lineView.rest.length; i3++) {
                lineView.measure.caches[i3] = {};
              }
            }
          }
        }
        function clearLineMeasurementCache(cm) {
          cm.display.externalMeasure = null;
          removeChildren(cm.display.lineMeasure);
          for (var i3 = 0; i3 < cm.display.view.length; i3++) {
            clearLineMeasurementCacheFor(cm.display.view[i3]);
          }
        }
        function clearCaches(cm) {
          clearLineMeasurementCache(cm);
          cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
          if (!cm.options.lineWrapping) {
            cm.display.maxLineChanged = true;
          }
          cm.display.lineNumChars = null;
        }
        function pageScrollX() {
          if (chrome2 && android) {
            return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));
          }
          return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
        }
        function pageScrollY() {
          if (chrome2 && android) {
            return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));
          }
          return window.pageYOffset || (document.documentElement || document.body).scrollTop;
        }
        function widgetTopHeight(lineObj) {
          var height = 0;
          if (lineObj.widgets) {
            for (var i3 = 0; i3 < lineObj.widgets.length; ++i3) {
              if (lineObj.widgets[i3].above) {
                height += widgetHeight(lineObj.widgets[i3]);
              }
            }
          }
          return height;
        }
        function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
          if (!includeWidgets) {
            var height = widgetTopHeight(lineObj);
            rect.top += height;
            rect.bottom += height;
          }
          if (context == "line") {
            return rect;
          }
          if (!context) {
            context = "local";
          }
          var yOff = heightAtLine(lineObj);
          if (context == "local") {
            yOff += paddingTop(cm.display);
          } else {
            yOff -= cm.display.viewOffset;
          }
          if (context == "page" || context == "window") {
            var lOff = cm.display.lineSpace.getBoundingClientRect();
            yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
            var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
            rect.left += xOff;
            rect.right += xOff;
          }
          rect.top += yOff;
          rect.bottom += yOff;
          return rect;
        }
        function fromCoordSystem(cm, coords, context) {
          if (context == "div") {
            return coords;
          }
          var left2 = coords.left, top2 = coords.top;
          if (context == "page") {
            left2 -= pageScrollX();
            top2 -= pageScrollY();
          } else if (context == "local" || !context) {
            var localBox = cm.display.sizer.getBoundingClientRect();
            left2 += localBox.left;
            top2 += localBox.top;
          }
          var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
          return { left: left2 - lineSpaceBox.left, top: top2 - lineSpaceBox.top };
        }
        function charCoords(cm, pos, context, lineObj, bias) {
          if (!lineObj) {
            lineObj = getLine(cm.doc, pos.line);
          }
          return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
        }
        function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
          lineObj = lineObj || getLine(cm.doc, pos.line);
          if (!preparedMeasure) {
            preparedMeasure = prepareMeasureForLine(cm, lineObj);
          }
          function get(ch2, right2) {
            var m2 = measureCharPrepared(cm, preparedMeasure, ch2, right2 ? "right" : "left", varHeight);
            if (right2) {
              m2.left = m2.right;
            } else {
              m2.right = m2.left;
            }
            return intoCoordSystem(cm, lineObj, m2, context);
          }
          var order2 = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
          if (ch >= lineObj.text.length) {
            ch = lineObj.text.length;
            sticky = "before";
          } else if (ch <= 0) {
            ch = 0;
            sticky = "after";
          }
          if (!order2) {
            return get(sticky == "before" ? ch - 1 : ch, sticky == "before");
          }
          function getBidi(ch2, partPos2, invert) {
            var part = order2[partPos2], right2 = part.level == 1;
            return get(invert ? ch2 - 1 : ch2, right2 != invert);
          }
          var partPos = getBidiPartAt(order2, ch, sticky);
          var other = bidiOther;
          var val = getBidi(ch, partPos, sticky == "before");
          if (other != null) {
            val.other = getBidi(ch, other, sticky != "before");
          }
          return val;
        }
        function estimateCoords(cm, pos) {
          var left2 = 0;
          pos = clipPos(cm.doc, pos);
          if (!cm.options.lineWrapping) {
            left2 = charWidth(cm.display) * pos.ch;
          }
          var lineObj = getLine(cm.doc, pos.line);
          var top2 = heightAtLine(lineObj) + paddingTop(cm.display);
          return { left: left2, right: left2, top: top2, bottom: top2 + lineObj.height };
        }
        function PosWithInfo(line, ch, sticky, outside, xRel) {
          var pos = Pos(line, ch, sticky);
          pos.xRel = xRel;
          if (outside) {
            pos.outside = outside;
          }
          return pos;
        }
        function coordsChar(cm, x2, y2) {
          var doc = cm.doc;
          y2 += cm.display.viewOffset;
          if (y2 < 0) {
            return PosWithInfo(doc.first, 0, null, -1, -1);
          }
          var lineN = lineAtHeight(doc, y2), last = doc.first + doc.size - 1;
          if (lineN > last) {
            return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1);
          }
          if (x2 < 0) {
            x2 = 0;
          }
          var lineObj = getLine(doc, lineN);
          for (; ; ) {
            var found = coordsCharInner(cm, lineObj, lineN, x2, y2);
            var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
            if (!collapsed) {
              return found;
            }
            var rangeEnd = collapsed.find(1);
            if (rangeEnd.line == lineN) {
              return rangeEnd;
            }
            lineObj = getLine(doc, lineN = rangeEnd.line);
          }
        }
        function wrappedLineExtent(cm, lineObj, preparedMeasure, y2) {
          y2 -= widgetTopHeight(lineObj);
          var end2 = lineObj.text.length;
          var begin = findFirst(function(ch) {
            return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y2;
          }, end2, 0);
          end2 = findFirst(function(ch) {
            return measureCharPrepared(cm, preparedMeasure, ch).top > y2;
          }, begin, end2);
          return { begin, end: end2 };
        }
        function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
          if (!preparedMeasure) {
            preparedMeasure = prepareMeasureForLine(cm, lineObj);
          }
          var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
          return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
        }
        function boxIsAfter(box, x2, y2, left2) {
          return box.bottom <= y2 ? false : box.top > y2 ? true : (left2 ? box.left : box.right) > x2;
        }
        function coordsCharInner(cm, lineObj, lineNo2, x2, y2) {
          y2 -= heightAtLine(lineObj);
          var preparedMeasure = prepareMeasureForLine(cm, lineObj);
          var widgetHeight2 = widgetTopHeight(lineObj);
          var begin = 0, end2 = lineObj.text.length, ltr = true;
          var order2 = getOrder(lineObj, cm.doc.direction);
          if (order2) {
            var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo2, preparedMeasure, order2, x2, y2);
            ltr = part.level != 1;
            begin = ltr ? part.from : part.to - 1;
            end2 = ltr ? part.to : part.from - 1;
          }
          var chAround = null, boxAround = null;
          var ch = findFirst(function(ch2) {
            var box = measureCharPrepared(cm, preparedMeasure, ch2);
            box.top += widgetHeight2;
            box.bottom += widgetHeight2;
            if (!boxIsAfter(box, x2, y2, false)) {
              return false;
            }
            if (box.top <= y2 && box.left <= x2) {
              chAround = ch2;
              boxAround = box;
            }
            return true;
          }, begin, end2);
          var baseX, sticky, outside = false;
          if (boxAround) {
            var atLeft = x2 - boxAround.left < boxAround.right - x2, atStart = atLeft == ltr;
            ch = chAround + (atStart ? 0 : 1);
            sticky = atStart ? "after" : "before";
            baseX = atLeft ? boxAround.left : boxAround.right;
          } else {
            if (!ltr && (ch == end2 || ch == begin)) {
              ch++;
            }
            sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight2 <= y2 == ltr ? "after" : "before";
            var coords = cursorCoords(cm, Pos(lineNo2, ch, sticky), "line", lineObj, preparedMeasure);
            baseX = coords.left;
            outside = y2 < coords.top ? -1 : y2 >= coords.bottom ? 1 : 0;
          }
          ch = skipExtendingChars(lineObj.text, ch, 1);
          return PosWithInfo(lineNo2, ch, sticky, outside, x2 - baseX);
        }
        function coordsBidiPart(cm, lineObj, lineNo2, preparedMeasure, order2, x2, y2) {
          var index = findFirst(function(i3) {
            var part2 = order2[i3], ltr2 = part2.level != 1;
            return boxIsAfter(cursorCoords(cm, Pos(lineNo2, ltr2 ? part2.to : part2.from, ltr2 ? "before" : "after"), "line", lineObj, preparedMeasure), x2, y2, true);
          }, 0, order2.length - 1);
          var part = order2[index];
          if (index > 0) {
            var ltr = part.level != 1;
            var start4 = cursorCoords(cm, Pos(lineNo2, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);
            if (boxIsAfter(start4, x2, y2, true) && start4.top > y2) {
              part = order2[index - 1];
            }
          }
          return part;
        }
        function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order2, x2, y2) {
          var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y2);
          var begin = ref.begin;
          var end2 = ref.end;
          if (/\s/.test(lineObj.text.charAt(end2 - 1))) {
            end2--;
          }
          var part = null, closestDist = null;
          for (var i3 = 0; i3 < order2.length; i3++) {
            var p2 = order2[i3];
            if (p2.from >= end2 || p2.to <= begin) {
              continue;
            }
            var ltr = p2.level != 1;
            var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end2, p2.to) - 1 : Math.max(begin, p2.from)).right;
            var dist = endX < x2 ? x2 - endX + 1e9 : endX - x2;
            if (!part || closestDist > dist) {
              part = p2;
              closestDist = dist;
            }
          }
          if (!part) {
            part = order2[order2.length - 1];
          }
          if (part.from < begin) {
            part = { from: begin, to: part.to, level: part.level };
          }
          if (part.to > end2) {
            part = { from: part.from, to: end2, level: part.level };
          }
          return part;
        }
        var measureText;
        function textHeight(display) {
          if (display.cachedTextHeight != null) {
            return display.cachedTextHeight;
          }
          if (measureText == null) {
            measureText = elt("pre", null, "CodeMirror-line-like");
            for (var i3 = 0; i3 < 49; ++i3) {
              measureText.appendChild(document.createTextNode("x"));
              measureText.appendChild(elt("br"));
            }
            measureText.appendChild(document.createTextNode("x"));
          }
          removeChildrenAndAdd(display.measure, measureText);
          var height = measureText.offsetHeight / 50;
          if (height > 3) {
            display.cachedTextHeight = height;
          }
          removeChildren(display.measure);
          return height || 1;
        }
        function charWidth(display) {
          if (display.cachedCharWidth != null) {
            return display.cachedCharWidth;
          }
          var anchor = elt("span", "xxxxxxxxxx");
          var pre = elt("pre", [anchor], "CodeMirror-line-like");
          removeChildrenAndAdd(display.measure, pre);
          var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
          if (width > 2) {
            display.cachedCharWidth = width;
          }
          return width || 10;
        }
        function getDimensions(cm) {
          var d2 = cm.display, left2 = {}, width = {};
          var gutterLeft = d2.gutters.clientLeft;
          for (var n2 = d2.gutters.firstChild, i3 = 0; n2; n2 = n2.nextSibling, ++i3) {
            var id = cm.display.gutterSpecs[i3].className;
            left2[id] = n2.offsetLeft + n2.clientLeft + gutterLeft;
            width[id] = n2.clientWidth;
          }
          return {
            fixedPos: compensateForHScroll(d2),
            gutterTotalWidth: d2.gutters.offsetWidth,
            gutterLeft: left2,
            gutterWidth: width,
            wrapperWidth: d2.wrapper.clientWidth
          };
        }
        function compensateForHScroll(display) {
          return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
        }
        function estimateHeight(cm) {
          var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
          var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
          return function(line) {
            if (lineIsHidden(cm.doc, line)) {
              return 0;
            }
            var widgetsHeight = 0;
            if (line.widgets) {
              for (var i3 = 0; i3 < line.widgets.length; i3++) {
                if (line.widgets[i3].height) {
                  widgetsHeight += line.widgets[i3].height;
                }
              }
            }
            if (wrapping) {
              return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
            } else {
              return widgetsHeight + th;
            }
          };
        }
        function estimateLineHeights(cm) {
          var doc = cm.doc, est = estimateHeight(cm);
          doc.iter(function(line) {
            var estHeight = est(line);
            if (estHeight != line.height) {
              updateLineHeight(line, estHeight);
            }
          });
        }
        function posFromMouse(cm, e2, liberal, forRect) {
          var display = cm.display;
          if (!liberal && e_target(e2).getAttribute("cm-not-content") == "true") {
            return null;
          }
          var x2, y2, space = display.lineSpace.getBoundingClientRect();
          try {
            x2 = e2.clientX - space.left;
            y2 = e2.clientY - space.top;
          } catch (e$1) {
            return null;
          }
          var coords = coordsChar(cm, x2, y2), line;
          if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
            var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
            coords = Pos(coords.line, Math.max(0, Math.round((x2 - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
          }
          return coords;
        }
        function findViewIndex(cm, n2) {
          if (n2 >= cm.display.viewTo) {
            return null;
          }
          n2 -= cm.display.viewFrom;
          if (n2 < 0) {
            return null;
          }
          var view = cm.display.view;
          for (var i3 = 0; i3 < view.length; i3++) {
            n2 -= view[i3].size;
            if (n2 < 0) {
              return i3;
            }
          }
        }
        function regChange(cm, from, to, lendiff) {
          if (from == null) {
            from = cm.doc.first;
          }
          if (to == null) {
            to = cm.doc.first + cm.doc.size;
          }
          if (!lendiff) {
            lendiff = 0;
          }
          var display = cm.display;
          if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
            display.updateLineNumbers = from;
          }
          cm.curOp.viewChanged = true;
          if (from >= display.viewTo) {
            if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {
              resetView(cm);
            }
          } else if (to <= display.viewFrom) {
            if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
              resetView(cm);
            } else {
              display.viewFrom += lendiff;
              display.viewTo += lendiff;
            }
          } else if (from <= display.viewFrom && to >= display.viewTo) {
            resetView(cm);
          } else if (from <= display.viewFrom) {
            var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
            if (cut) {
              display.view = display.view.slice(cut.index);
              display.viewFrom = cut.lineN;
              display.viewTo += lendiff;
            } else {
              resetView(cm);
            }
          } else if (to >= display.viewTo) {
            var cut$1 = viewCuttingPoint(cm, from, from, -1);
            if (cut$1) {
              display.view = display.view.slice(0, cut$1.index);
              display.viewTo = cut$1.lineN;
            } else {
              resetView(cm);
            }
          } else {
            var cutTop = viewCuttingPoint(cm, from, from, -1);
            var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
            if (cutTop && cutBot) {
              display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
              display.viewTo += lendiff;
            } else {
              resetView(cm);
            }
          }
          var ext = display.externalMeasured;
          if (ext) {
            if (to < ext.lineN) {
              ext.lineN += lendiff;
            } else if (from < ext.lineN + ext.size) {
              display.externalMeasured = null;
            }
          }
        }
        function regLineChange(cm, line, type) {
          cm.curOp.viewChanged = true;
          var display = cm.display, ext = cm.display.externalMeasured;
          if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
            display.externalMeasured = null;
          }
          if (line < display.viewFrom || line >= display.viewTo) {
            return;
          }
          var lineView = display.view[findViewIndex(cm, line)];
          if (lineView.node == null) {
            return;
          }
          var arr = lineView.changes || (lineView.changes = []);
          if (indexOf2(arr, type) == -1) {
            arr.push(type);
          }
        }
        function resetView(cm) {
          cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
          cm.display.view = [];
          cm.display.viewOffset = 0;
        }
        function viewCuttingPoint(cm, oldN, newN, dir) {
          var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
          if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
            return { index, lineN: newN };
          }
          var n2 = cm.display.viewFrom;
          for (var i3 = 0; i3 < index; i3++) {
            n2 += view[i3].size;
          }
          if (n2 != oldN) {
            if (dir > 0) {
              if (index == view.length - 1) {
                return null;
              }
              diff = n2 + view[index].size - oldN;
              index++;
            } else {
              diff = n2 - oldN;
            }
            oldN += diff;
            newN += diff;
          }
          while (visualLineNo(cm.doc, newN) != newN) {
            if (index == (dir < 0 ? 0 : view.length - 1)) {
              return null;
            }
            newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
            index += dir;
          }
          return { index, lineN: newN };
        }
        function adjustView(cm, from, to) {
          var display = cm.display, view = display.view;
          if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
            display.view = buildViewArray(cm, from, to);
            display.viewFrom = from;
          } else {
            if (display.viewFrom > from) {
              display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
            } else if (display.viewFrom < from) {
              display.view = display.view.slice(findViewIndex(cm, from));
            }
            display.viewFrom = from;
            if (display.viewTo < to) {
              display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
            } else if (display.viewTo > to) {
              display.view = display.view.slice(0, findViewIndex(cm, to));
            }
          }
          display.viewTo = to;
        }
        function countDirtyView(cm) {
          var view = cm.display.view, dirty = 0;
          for (var i3 = 0; i3 < view.length; i3++) {
            var lineView = view[i3];
            if (!lineView.hidden && (!lineView.node || lineView.changes)) {
              ++dirty;
            }
          }
          return dirty;
        }
        function updateSelection(cm) {
          cm.display.input.showSelection(cm.display.input.prepareSelection());
        }
        function prepareSelection(cm, primary) {
          if (primary === void 0)
            primary = true;
          var doc = cm.doc, result = {};
          var curFragment = result.cursors = document.createDocumentFragment();
          var selFragment = result.selection = document.createDocumentFragment();
          for (var i3 = 0; i3 < doc.sel.ranges.length; i3++) {
            if (!primary && i3 == doc.sel.primIndex) {
              continue;
            }
            var range2 = doc.sel.ranges[i3];
            if (range2.from().line >= cm.display.viewTo || range2.to().line < cm.display.viewFrom) {
              continue;
            }
            var collapsed = range2.empty();
            if (collapsed || cm.options.showCursorWhenSelecting) {
              drawSelectionCursor(cm, range2.head, curFragment);
            }
            if (!collapsed) {
              drawSelectionRange(cm, range2, selFragment);
            }
          }
          return result;
        }
        function drawSelectionCursor(cm, head, output) {
          var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
          var cursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor"));
          cursor.style.left = pos.left + "px";
          cursor.style.top = pos.top + "px";
          cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
          if (pos.other) {
            var otherCursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor CodeMirror-secondarycursor"));
            otherCursor.style.display = "";
            otherCursor.style.left = pos.other.left + "px";
            otherCursor.style.top = pos.other.top + "px";
            otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + "px";
          }
        }
        function cmpCoords(a2, b2) {
          return a2.top - b2.top || a2.left - b2.left;
        }
        function drawSelectionRange(cm, range2, output) {
          var display = cm.display, doc = cm.doc;
          var fragment = document.createDocumentFragment();
          var padding = paddingH(cm.display), leftSide = padding.left;
          var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
          var docLTR = doc.direction == "ltr";
          function add3(left2, top2, width, bottom2) {
            if (top2 < 0) {
              top2 = 0;
            }
            top2 = Math.round(top2);
            bottom2 = Math.round(bottom2);
            fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left2 + "px;\n                             top: " + top2 + "px; width: " + (width == null ? rightSide - left2 : width) + "px;\n                             height: " + (bottom2 - top2) + "px"));
          }
          function drawForLine(line, fromArg, toArg) {
            var lineObj = getLine(doc, line);
            var lineLen = lineObj.text.length;
            var start4, end2;
            function coords(ch, bias) {
              return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
            }
            function wrapX(pos, dir, side) {
              var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
              var prop2 = dir == "ltr" == (side == "after") ? "left" : "right";
              var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
              return coords(ch, prop2)[prop2];
            }
            var order2 = getOrder(lineObj, doc.direction);
            iterateBidiSections(order2, fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir, i3) {
              var ltr = dir == "ltr";
              var fromPos = coords(from, ltr ? "left" : "right");
              var toPos = coords(to - 1, ltr ? "right" : "left");
              var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
              var first = i3 == 0, last = !order2 || i3 == order2.length - 1;
              if (toPos.top - fromPos.top <= 3) {
                var openLeft = (docLTR ? openStart : openEnd) && first;
                var openRight = (docLTR ? openEnd : openStart) && last;
                var left2 = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
                var right2 = openRight ? rightSide : (ltr ? toPos : fromPos).right;
                add3(left2, fromPos.top, right2 - left2, fromPos.bottom);
              } else {
                var topLeft, topRight, botLeft, botRight;
                if (ltr) {
                  topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
                  topRight = docLTR ? rightSide : wrapX(from, dir, "before");
                  botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
                  botRight = docLTR && openEnd && last ? rightSide : toPos.right;
                } else {
                  topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
                  topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
                  botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
                  botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
                }
                add3(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
                if (fromPos.bottom < toPos.top) {
                  add3(leftSide, fromPos.bottom, null, toPos.top);
                }
                add3(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
              }
              if (!start4 || cmpCoords(fromPos, start4) < 0) {
                start4 = fromPos;
              }
              if (cmpCoords(toPos, start4) < 0) {
                start4 = toPos;
              }
              if (!end2 || cmpCoords(fromPos, end2) < 0) {
                end2 = fromPos;
              }
              if (cmpCoords(toPos, end2) < 0) {
                end2 = toPos;
              }
            });
            return { start: start4, end: end2 };
          }
          var sFrom = range2.from(), sTo = range2.to();
          if (sFrom.line == sTo.line) {
            drawForLine(sFrom.line, sFrom.ch, sTo.ch);
          } else {
            var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
            var singleVLine = visualLine(fromLine) == visualLine(toLine);
            var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
            var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
            if (singleVLine) {
              if (leftEnd.top < rightStart.top - 2) {
                add3(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
                add3(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
              } else {
                add3(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
              }
            }
            if (leftEnd.bottom < rightStart.top) {
              add3(leftSide, leftEnd.bottom, null, rightStart.top);
            }
          }
          output.appendChild(fragment);
        }
        function restartBlink(cm) {
          if (!cm.state.focused) {
            return;
          }
          var display = cm.display;
          clearInterval(display.blinker);
          var on2 = true;
          display.cursorDiv.style.visibility = "";
          if (cm.options.cursorBlinkRate > 0) {
            display.blinker = setInterval(function() {
              if (!cm.hasFocus()) {
                onBlur(cm);
              }
              display.cursorDiv.style.visibility = (on2 = !on2) ? "" : "hidden";
            }, cm.options.cursorBlinkRate);
          } else if (cm.options.cursorBlinkRate < 0) {
            display.cursorDiv.style.visibility = "hidden";
          }
        }
        function ensureFocus(cm) {
          if (!cm.hasFocus()) {
            cm.display.input.focus();
            if (!cm.state.focused) {
              onFocus(cm);
            }
          }
        }
        function delayBlurEvent(cm) {
          cm.state.delayingBlurEvent = true;
          setTimeout(function() {
            if (cm.state.delayingBlurEvent) {
              cm.state.delayingBlurEvent = false;
              if (cm.state.focused) {
                onBlur(cm);
              }
            }
          }, 100);
        }
        function onFocus(cm, e2) {
          if (cm.state.delayingBlurEvent && !cm.state.draggingText) {
            cm.state.delayingBlurEvent = false;
          }
          if (cm.options.readOnly == "nocursor") {
            return;
          }
          if (!cm.state.focused) {
            signal(cm, "focus", cm, e2);
            cm.state.focused = true;
            addClass(cm.display.wrapper, "CodeMirror-focused");
            if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
              cm.display.input.reset();
              if (webkit) {
                setTimeout(function() {
                  return cm.display.input.reset(true);
                }, 20);
              }
            }
            cm.display.input.receivedFocus();
          }
          restartBlink(cm);
        }
        function onBlur(cm, e2) {
          if (cm.state.delayingBlurEvent) {
            return;
          }
          if (cm.state.focused) {
            signal(cm, "blur", cm, e2);
            cm.state.focused = false;
            rmClass(cm.display.wrapper, "CodeMirror-focused");
          }
          clearInterval(cm.display.blinker);
          setTimeout(function() {
            if (!cm.state.focused) {
              cm.display.shift = false;
            }
          }, 150);
        }
        function updateHeightsInViewport(cm) {
          var display = cm.display;
          var prevBottom = display.lineDiv.offsetTop;
          for (var i3 = 0; i3 < display.view.length; i3++) {
            var cur = display.view[i3], wrapping = cm.options.lineWrapping;
            var height = void 0, width = 0;
            if (cur.hidden) {
              continue;
            }
            if (ie && ie_version < 8) {
              var bot = cur.node.offsetTop + cur.node.offsetHeight;
              height = bot - prevBottom;
              prevBottom = bot;
            } else {
              var box = cur.node.getBoundingClientRect();
              height = box.bottom - box.top;
              if (!wrapping && cur.text.firstChild) {
                width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;
              }
            }
            var diff = cur.line.height - height;
            if (diff > 5e-3 || diff < -5e-3) {
              updateLineHeight(cur.line, height);
              updateWidgetHeight(cur.line);
              if (cur.rest) {
                for (var j2 = 0; j2 < cur.rest.length; j2++) {
                  updateWidgetHeight(cur.rest[j2]);
                }
              }
            }
            if (width > cm.display.sizerWidth) {
              var chWidth = Math.ceil(width / charWidth(cm.display));
              if (chWidth > cm.display.maxLineLength) {
                cm.display.maxLineLength = chWidth;
                cm.display.maxLine = cur.line;
                cm.display.maxLineChanged = true;
              }
            }
          }
        }
        function updateWidgetHeight(line) {
          if (line.widgets) {
            for (var i3 = 0; i3 < line.widgets.length; ++i3) {
              var w = line.widgets[i3], parent = w.node.parentNode;
              if (parent) {
                w.height = parent.offsetHeight;
              }
            }
          }
        }
        function visibleLines(display, doc, viewport2) {
          var top2 = viewport2 && viewport2.top != null ? Math.max(0, viewport2.top) : display.scroller.scrollTop;
          top2 = Math.floor(top2 - paddingTop(display));
          var bottom2 = viewport2 && viewport2.bottom != null ? viewport2.bottom : top2 + display.wrapper.clientHeight;
          var from = lineAtHeight(doc, top2), to = lineAtHeight(doc, bottom2);
          if (viewport2 && viewport2.ensure) {
            var ensureFrom = viewport2.ensure.from.line, ensureTo = viewport2.ensure.to.line;
            if (ensureFrom < from) {
              from = ensureFrom;
              to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
            } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
              from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
              to = ensureTo;
            }
          }
          return { from, to: Math.max(to, from + 1) };
        }
        function maybeScrollWindow(cm, rect) {
          if (signalDOMEvent(cm, "scrollCursorIntoView")) {
            return;
          }
          var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
          if (rect.top + box.top < 0) {
            doScroll = true;
          } else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {
            doScroll = false;
          }
          if (doScroll != null && !phantom) {
            var scrollNode = elt("div", "\u200B", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
            cm.display.lineSpace.appendChild(scrollNode);
            scrollNode.scrollIntoView(doScroll);
            cm.display.lineSpace.removeChild(scrollNode);
          }
        }
        function scrollPosIntoView(cm, pos, end2, margin) {
          if (margin == null) {
            margin = 0;
          }
          var rect;
          if (!cm.options.lineWrapping && pos == end2) {
            pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
            end2 = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
          }
          for (var limit = 0; limit < 5; limit++) {
            var changed = false;
            var coords = cursorCoords(cm, pos);
            var endCoords = !end2 || end2 == pos ? coords : cursorCoords(cm, end2);
            rect = {
              left: Math.min(coords.left, endCoords.left),
              top: Math.min(coords.top, endCoords.top) - margin,
              right: Math.max(coords.left, endCoords.left),
              bottom: Math.max(coords.bottom, endCoords.bottom) + margin
            };
            var scrollPos = calculateScrollPos(cm, rect);
            var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
            if (scrollPos.scrollTop != null) {
              updateScrollTop(cm, scrollPos.scrollTop);
              if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
                changed = true;
              }
            }
            if (scrollPos.scrollLeft != null) {
              setScrollLeft(cm, scrollPos.scrollLeft);
              if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
                changed = true;
              }
            }
            if (!changed) {
              break;
            }
          }
          return rect;
        }
        function scrollIntoView(cm, rect) {
          var scrollPos = calculateScrollPos(cm, rect);
          if (scrollPos.scrollTop != null) {
            updateScrollTop(cm, scrollPos.scrollTop);
          }
          if (scrollPos.scrollLeft != null) {
            setScrollLeft(cm, scrollPos.scrollLeft);
          }
        }
        function calculateScrollPos(cm, rect) {
          var display = cm.display, snapMargin = textHeight(cm.display);
          if (rect.top < 0) {
            rect.top = 0;
          }
          var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
          var screen2 = displayHeight(cm), result = {};
          if (rect.bottom - rect.top > screen2) {
            rect.bottom = rect.top + screen2;
          }
          var docBottom = cm.doc.height + paddingVert(display);
          var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
          if (rect.top < screentop) {
            result.scrollTop = atTop ? 0 : rect.top;
          } else if (rect.bottom > screentop + screen2) {
            var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen2);
            if (newTop != screentop) {
              result.scrollTop = newTop;
            }
          }
          var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
          var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
          var screenw = displayWidth(cm) - display.gutters.offsetWidth;
          var tooWide = rect.right - rect.left > screenw;
          if (tooWide) {
            rect.right = rect.left + screenw;
          }
          if (rect.left < 10) {
            result.scrollLeft = 0;
          } else if (rect.left < screenleft) {
            result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10));
          } else if (rect.right > screenw + screenleft - 3) {
            result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
          }
          return result;
        }
        function addToScrollTop(cm, top2) {
          if (top2 == null) {
            return;
          }
          resolveScrollToPos(cm);
          cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top2;
        }
        function ensureCursorVisible(cm) {
          resolveScrollToPos(cm);
          var cur = cm.getCursor();
          cm.curOp.scrollToPos = { from: cur, to: cur, margin: cm.options.cursorScrollMargin };
        }
        function scrollToCoords(cm, x2, y2) {
          if (x2 != null || y2 != null) {
            resolveScrollToPos(cm);
          }
          if (x2 != null) {
            cm.curOp.scrollLeft = x2;
          }
          if (y2 != null) {
            cm.curOp.scrollTop = y2;
          }
        }
        function scrollToRange(cm, range2) {
          resolveScrollToPos(cm);
          cm.curOp.scrollToPos = range2;
        }
        function resolveScrollToPos(cm) {
          var range2 = cm.curOp.scrollToPos;
          if (range2) {
            cm.curOp.scrollToPos = null;
            var from = estimateCoords(cm, range2.from), to = estimateCoords(cm, range2.to);
            scrollToCoordsRange(cm, from, to, range2.margin);
          }
        }
        function scrollToCoordsRange(cm, from, to, margin) {
          var sPos = calculateScrollPos(cm, {
            left: Math.min(from.left, to.left),
            top: Math.min(from.top, to.top) - margin,
            right: Math.max(from.right, to.right),
            bottom: Math.max(from.bottom, to.bottom) + margin
          });
          scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
        }
        function updateScrollTop(cm, val) {
          if (Math.abs(cm.doc.scrollTop - val) < 2) {
            return;
          }
          if (!gecko) {
            updateDisplaySimple(cm, { top: val });
          }
          setScrollTop(cm, val, true);
          if (gecko) {
            updateDisplaySimple(cm);
          }
          startWorker(cm, 100);
        }
        function setScrollTop(cm, val, forceScroll) {
          val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
          if (cm.display.scroller.scrollTop == val && !forceScroll) {
            return;
          }
          cm.doc.scrollTop = val;
          cm.display.scrollbars.setScrollTop(val);
          if (cm.display.scroller.scrollTop != val) {
            cm.display.scroller.scrollTop = val;
          }
        }
        function setScrollLeft(cm, val, isScroller, forceScroll) {
          val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
          if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
            return;
          }
          cm.doc.scrollLeft = val;
          alignHorizontally(cm);
          if (cm.display.scroller.scrollLeft != val) {
            cm.display.scroller.scrollLeft = val;
          }
          cm.display.scrollbars.setScrollLeft(val);
        }
        function measureForScrollbars(cm) {
          var d2 = cm.display, gutterW = d2.gutters.offsetWidth;
          var docH = Math.round(cm.doc.height + paddingVert(cm.display));
          return {
            clientHeight: d2.scroller.clientHeight,
            viewHeight: d2.wrapper.clientHeight,
            scrollWidth: d2.scroller.scrollWidth,
            clientWidth: d2.scroller.clientWidth,
            viewWidth: d2.wrapper.clientWidth,
            barLeft: cm.options.fixedGutter ? gutterW : 0,
            docHeight: docH,
            scrollHeight: docH + scrollGap(cm) + d2.barHeight,
            nativeBarWidth: d2.nativeBarWidth,
            gutterWidth: gutterW
          };
        }
        var NativeScrollbars = function(place, scroll, cm) {
          this.cm = cm;
          var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
          var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
          vert.tabIndex = horiz.tabIndex = -1;
          place(vert);
          place(horiz);
          on(vert, "scroll", function() {
            if (vert.clientHeight) {
              scroll(vert.scrollTop, "vertical");
            }
          });
          on(horiz, "scroll", function() {
            if (horiz.clientWidth) {
              scroll(horiz.scrollLeft, "horizontal");
            }
          });
          this.checkedZeroWidth = false;
          if (ie && ie_version < 8) {
            this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
          }
        };
        NativeScrollbars.prototype.update = function(measure) {
          var needsH = measure.scrollWidth > measure.clientWidth + 1;
          var needsV = measure.scrollHeight > measure.clientHeight + 1;
          var sWidth = measure.nativeBarWidth;
          if (needsV) {
            this.vert.style.display = "block";
            this.vert.style.bottom = needsH ? sWidth + "px" : "0";
            var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
            this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
          } else {
            this.vert.style.display = "";
            this.vert.firstChild.style.height = "0";
          }
          if (needsH) {
            this.horiz.style.display = "block";
            this.horiz.style.right = needsV ? sWidth + "px" : "0";
            this.horiz.style.left = measure.barLeft + "px";
            var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
            this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
          } else {
            this.horiz.style.display = "";
            this.horiz.firstChild.style.width = "0";
          }
          if (!this.checkedZeroWidth && measure.clientHeight > 0) {
            if (sWidth == 0) {
              this.zeroWidthHack();
            }
            this.checkedZeroWidth = true;
          }
          return { right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0 };
        };
        NativeScrollbars.prototype.setScrollLeft = function(pos) {
          if (this.horiz.scrollLeft != pos) {
            this.horiz.scrollLeft = pos;
          }
          if (this.disableHoriz) {
            this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
          }
        };
        NativeScrollbars.prototype.setScrollTop = function(pos) {
          if (this.vert.scrollTop != pos) {
            this.vert.scrollTop = pos;
          }
          if (this.disableVert) {
            this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
          }
        };
        NativeScrollbars.prototype.zeroWidthHack = function() {
          var w = mac && !mac_geMountainLion ? "12px" : "18px";
          this.horiz.style.height = this.vert.style.width = w;
          this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
          this.disableHoriz = new Delayed();
          this.disableVert = new Delayed();
        };
        NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay, type) {
          bar.style.pointerEvents = "auto";
          function maybeDisable() {
            var box = bar.getBoundingClientRect();
            var elt2 = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
            if (elt2 != bar) {
              bar.style.pointerEvents = "none";
            } else {
              delay.set(1e3, maybeDisable);
            }
          }
          delay.set(1e3, maybeDisable);
        };
        NativeScrollbars.prototype.clear = function() {
          var parent = this.horiz.parentNode;
          parent.removeChild(this.horiz);
          parent.removeChild(this.vert);
        };
        var NullScrollbars = function() {
        };
        NullScrollbars.prototype.update = function() {
          return { bottom: 0, right: 0 };
        };
        NullScrollbars.prototype.setScrollLeft = function() {
        };
        NullScrollbars.prototype.setScrollTop = function() {
        };
        NullScrollbars.prototype.clear = function() {
        };
        function updateScrollbars(cm, measure) {
          if (!measure) {
            measure = measureForScrollbars(cm);
          }
          var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
          updateScrollbarsInner(cm, measure);
          for (var i3 = 0; i3 < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i3++) {
            if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
              updateHeightsInViewport(cm);
            }
            updateScrollbarsInner(cm, measureForScrollbars(cm));
            startWidth = cm.display.barWidth;
            startHeight = cm.display.barHeight;
          }
        }
        function updateScrollbarsInner(cm, measure) {
          var d2 = cm.display;
          var sizes = d2.scrollbars.update(measure);
          d2.sizer.style.paddingRight = (d2.barWidth = sizes.right) + "px";
          d2.sizer.style.paddingBottom = (d2.barHeight = sizes.bottom) + "px";
          d2.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
          if (sizes.right && sizes.bottom) {
            d2.scrollbarFiller.style.display = "block";
            d2.scrollbarFiller.style.height = sizes.bottom + "px";
            d2.scrollbarFiller.style.width = sizes.right + "px";
          } else {
            d2.scrollbarFiller.style.display = "";
          }
          if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
            d2.gutterFiller.style.display = "block";
            d2.gutterFiller.style.height = sizes.bottom + "px";
            d2.gutterFiller.style.width = measure.gutterWidth + "px";
          } else {
            d2.gutterFiller.style.display = "";
          }
        }
        var scrollbarModel = { "native": NativeScrollbars, "null": NullScrollbars };
        function initScrollbars(cm) {
          if (cm.display.scrollbars) {
            cm.display.scrollbars.clear();
            if (cm.display.scrollbars.addClass) {
              rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
            }
          }
          cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {
            cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
            on(node, "mousedown", function() {
              if (cm.state.focused) {
                setTimeout(function() {
                  return cm.display.input.focus();
                }, 0);
              }
            });
            node.setAttribute("cm-not-content", "true");
          }, function(pos, axis) {
            if (axis == "horizontal") {
              setScrollLeft(cm, pos);
            } else {
              updateScrollTop(cm, pos);
            }
          }, cm);
          if (cm.display.scrollbars.addClass) {
            addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
          }
        }
        var nextOpId = 0;
        function startOperation(cm) {
          cm.curOp = {
            cm,
            viewChanged: false,
            startHeight: cm.doc.height,
            forceUpdate: false,
            updateInput: 0,
            typing: false,
            changeObjs: null,
            cursorActivityHandlers: null,
            cursorActivityCalled: 0,
            selectionChanged: false,
            updateMaxLine: false,
            scrollLeft: null,
            scrollTop: null,
            scrollToPos: null,
            focus: false,
            id: ++nextOpId
          };
          pushOperation(cm.curOp);
        }
        function endOperation(cm) {
          var op = cm.curOp;
          if (op) {
            finishOperation(op, function(group) {
              for (var i3 = 0; i3 < group.ops.length; i3++) {
                group.ops[i3].cm.curOp = null;
              }
              endOperations(group);
            });
          }
        }
        function endOperations(group) {
          var ops = group.ops;
          for (var i3 = 0; i3 < ops.length; i3++) {
            endOperation_R1(ops[i3]);
          }
          for (var i$12 = 0; i$12 < ops.length; i$12++) {
            endOperation_W1(ops[i$12]);
          }
          for (var i$22 = 0; i$22 < ops.length; i$22++) {
            endOperation_R2(ops[i$22]);
          }
          for (var i$3 = 0; i$3 < ops.length; i$3++) {
            endOperation_W2(ops[i$3]);
          }
          for (var i$4 = 0; i$4 < ops.length; i$4++) {
            endOperation_finish(ops[i$4]);
          }
        }
        function endOperation_R1(op) {
          var cm = op.cm, display = cm.display;
          maybeClipScrollbars(cm);
          if (op.updateMaxLine) {
            findMaxLine(cm);
          }
          op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
          op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && { top: op.scrollTop, ensure: op.scrollToPos }, op.forceUpdate);
        }
        function endOperation_W1(op) {
          op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
        }
        function endOperation_R2(op) {
          var cm = op.cm, display = cm.display;
          if (op.updatedDisplay) {
            updateHeightsInViewport(cm);
          }
          op.barMeasure = measureForScrollbars(cm);
          if (display.maxLineChanged && !cm.options.lineWrapping) {
            op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
            cm.display.sizerWidth = op.adjustWidthTo;
            op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
            op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
          }
          if (op.updatedDisplay || op.selectionChanged) {
            op.preparedSelection = display.input.prepareSelection();
          }
        }
        function endOperation_W2(op) {
          var cm = op.cm;
          if (op.adjustWidthTo != null) {
            cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
            if (op.maxScrollLeft < cm.doc.scrollLeft) {
              setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
            }
            cm.display.maxLineChanged = false;
          }
          var takeFocus = op.focus && op.focus == activeElt();
          if (op.preparedSelection) {
            cm.display.input.showSelection(op.preparedSelection, takeFocus);
          }
          if (op.updatedDisplay || op.startHeight != cm.doc.height) {
            updateScrollbars(cm, op.barMeasure);
          }
          if (op.updatedDisplay) {
            setDocumentHeight(cm, op.barMeasure);
          }
          if (op.selectionChanged) {
            restartBlink(cm);
          }
          if (cm.state.focused && op.updateInput) {
            cm.display.input.reset(op.typing);
          }
          if (takeFocus) {
            ensureFocus(op.cm);
          }
        }
        function endOperation_finish(op) {
          var cm = op.cm, display = cm.display, doc = cm.doc;
          if (op.updatedDisplay) {
            postUpdateDisplay(cm, op.update);
          }
          if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
            display.wheelStartX = display.wheelStartY = null;
          }
          if (op.scrollTop != null) {
            setScrollTop(cm, op.scrollTop, op.forceScroll);
          }
          if (op.scrollLeft != null) {
            setScrollLeft(cm, op.scrollLeft, true, true);
          }
          if (op.scrollToPos) {
            var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
            maybeScrollWindow(cm, rect);
          }
          var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
          if (hidden) {
            for (var i3 = 0; i3 < hidden.length; ++i3) {
              if (!hidden[i3].lines.length) {
                signal(hidden[i3], "hide");
              }
            }
          }
          if (unhidden) {
            for (var i$12 = 0; i$12 < unhidden.length; ++i$12) {
              if (unhidden[i$12].lines.length) {
                signal(unhidden[i$12], "unhide");
              }
            }
          }
          if (display.wrapper.offsetHeight) {
            doc.scrollTop = cm.display.scroller.scrollTop;
          }
          if (op.changeObjs) {
            signal(cm, "changes", cm, op.changeObjs);
          }
          if (op.update) {
            op.update.finish();
          }
        }
        function runInOp(cm, f2) {
          if (cm.curOp) {
            return f2();
          }
          startOperation(cm);
          try {
            return f2();
          } finally {
            endOperation(cm);
          }
        }
        function operation(cm, f2) {
          return function() {
            if (cm.curOp) {
              return f2.apply(cm, arguments);
            }
            startOperation(cm);
            try {
              return f2.apply(cm, arguments);
            } finally {
              endOperation(cm);
            }
          };
        }
        function methodOp(f2) {
          return function() {
            if (this.curOp) {
              return f2.apply(this, arguments);
            }
            startOperation(this);
            try {
              return f2.apply(this, arguments);
            } finally {
              endOperation(this);
            }
          };
        }
        function docMethodOp(f2) {
          return function() {
            var cm = this.cm;
            if (!cm || cm.curOp) {
              return f2.apply(this, arguments);
            }
            startOperation(cm);
            try {
              return f2.apply(this, arguments);
            } finally {
              endOperation(cm);
            }
          };
        }
        function startWorker(cm, time) {
          if (cm.doc.highlightFrontier < cm.display.viewTo) {
            cm.state.highlight.set(time, bind3(highlightWorker, cm));
          }
        }
        function highlightWorker(cm) {
          var doc = cm.doc;
          if (doc.highlightFrontier >= cm.display.viewTo) {
            return;
          }
          var end2 = +new Date() + cm.options.workTime;
          var context = getContextBefore(cm, doc.highlightFrontier);
          var changedLines = [];
          doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
            if (context.line >= cm.display.viewFrom) {
              var oldStyles = line.styles;
              var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
              var highlighted = highlightLine(cm, line, context, true);
              if (resetState) {
                context.state = resetState;
              }
              line.styles = highlighted.styles;
              var oldCls = line.styleClasses, newCls = highlighted.classes;
              if (newCls) {
                line.styleClasses = newCls;
              } else if (oldCls) {
                line.styleClasses = null;
              }
              var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
              for (var i3 = 0; !ischange && i3 < oldStyles.length; ++i3) {
                ischange = oldStyles[i3] != line.styles[i3];
              }
              if (ischange) {
                changedLines.push(context.line);
              }
              line.stateAfter = context.save();
              context.nextLine();
            } else {
              if (line.text.length <= cm.options.maxHighlightLength) {
                processLine(cm, line.text, context);
              }
              line.stateAfter = context.line % 5 == 0 ? context.save() : null;
              context.nextLine();
            }
            if (+new Date() > end2) {
              startWorker(cm, cm.options.workDelay);
              return true;
            }
          });
          doc.highlightFrontier = context.line;
          doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
          if (changedLines.length) {
            runInOp(cm, function() {
              for (var i3 = 0; i3 < changedLines.length; i3++) {
                regLineChange(cm, changedLines[i3], "text");
              }
            });
          }
        }
        var DisplayUpdate = function(cm, viewport2, force) {
          var display = cm.display;
          this.viewport = viewport2;
          this.visible = visibleLines(display, cm.doc, viewport2);
          this.editorIsHidden = !display.wrapper.offsetWidth;
          this.wrapperHeight = display.wrapper.clientHeight;
          this.wrapperWidth = display.wrapper.clientWidth;
          this.oldDisplayWidth = displayWidth(cm);
          this.force = force;
          this.dims = getDimensions(cm);
          this.events = [];
        };
        DisplayUpdate.prototype.signal = function(emitter, type) {
          if (hasHandler(emitter, type)) {
            this.events.push(arguments);
          }
        };
        DisplayUpdate.prototype.finish = function() {
          for (var i3 = 0; i3 < this.events.length; i3++) {
            signal.apply(null, this.events[i3]);
          }
        };
        function maybeClipScrollbars(cm) {
          var display = cm.display;
          if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
            display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
            display.heightForcer.style.height = scrollGap(cm) + "px";
            display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
            display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
            display.scrollbarsClipped = true;
          }
        }
        function selectionSnapshot(cm) {
          if (cm.hasFocus()) {
            return null;
          }
          var active = activeElt();
          if (!active || !contains2(cm.display.lineDiv, active)) {
            return null;
          }
          var result = { activeElt: active };
          if (window.getSelection) {
            var sel = window.getSelection();
            if (sel.anchorNode && sel.extend && contains2(cm.display.lineDiv, sel.anchorNode)) {
              result.anchorNode = sel.anchorNode;
              result.anchorOffset = sel.anchorOffset;
              result.focusNode = sel.focusNode;
              result.focusOffset = sel.focusOffset;
            }
          }
          return result;
        }
        function restoreSelection(snapshot) {
          if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) {
            return;
          }
          snapshot.activeElt.focus();
          if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains2(document.body, snapshot.anchorNode) && contains2(document.body, snapshot.focusNode)) {
            var sel = window.getSelection(), range2 = document.createRange();
            range2.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
            range2.collapse(false);
            sel.removeAllRanges();
            sel.addRange(range2);
            sel.extend(snapshot.focusNode, snapshot.focusOffset);
          }
        }
        function updateDisplayIfNeeded(cm, update) {
          var display = cm.display, doc = cm.doc;
          if (update.editorIsHidden) {
            resetView(cm);
            return false;
          }
          if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
            return false;
          }
          if (maybeUpdateLineNumberWidth(cm)) {
            resetView(cm);
            update.dims = getDimensions(cm);
          }
          var end2 = doc.first + doc.size;
          var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
          var to = Math.min(end2, update.visible.to + cm.options.viewportMargin);
          if (display.viewFrom < from && from - display.viewFrom < 20) {
            from = Math.max(doc.first, display.viewFrom);
          }
          if (display.viewTo > to && display.viewTo - to < 20) {
            to = Math.min(end2, display.viewTo);
          }
          if (sawCollapsedSpans) {
            from = visualLineNo(cm.doc, from);
            to = visualLineEndNo(cm.doc, to);
          }
          var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
          adjustView(cm, from, to);
          display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
          cm.display.mover.style.top = display.viewOffset + "px";
          var toUpdate = countDirtyView(cm);
          if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
            return false;
          }
          var selSnapshot = selectionSnapshot(cm);
          if (toUpdate > 4) {
            display.lineDiv.style.display = "none";
          }
          patchDisplay(cm, display.updateLineNumbers, update.dims);
          if (toUpdate > 4) {
            display.lineDiv.style.display = "";
          }
          display.renderedView = display.view;
          restoreSelection(selSnapshot);
          removeChildren(display.cursorDiv);
          removeChildren(display.selectionDiv);
          display.gutters.style.height = display.sizer.style.minHeight = 0;
          if (different) {
            display.lastWrapHeight = update.wrapperHeight;
            display.lastWrapWidth = update.wrapperWidth;
            startWorker(cm, 400);
          }
          display.updateLineNumbers = null;
          return true;
        }
        function postUpdateDisplay(cm, update) {
          var viewport2 = update.viewport;
          for (var first = true; ; first = false) {
            if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
              if (viewport2 && viewport2.top != null) {
                viewport2 = { top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport2.top) };
              }
              update.visible = visibleLines(cm.display, cm.doc, viewport2);
              if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
                break;
              }
            } else if (first) {
              update.visible = visibleLines(cm.display, cm.doc, viewport2);
            }
            if (!updateDisplayIfNeeded(cm, update)) {
              break;
            }
            updateHeightsInViewport(cm);
            var barMeasure = measureForScrollbars(cm);
            updateSelection(cm);
            updateScrollbars(cm, barMeasure);
            setDocumentHeight(cm, barMeasure);
            update.force = false;
          }
          update.signal(cm, "update", cm);
          if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
            update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
            cm.display.reportedViewFrom = cm.display.viewFrom;
            cm.display.reportedViewTo = cm.display.viewTo;
          }
        }
        function updateDisplaySimple(cm, viewport2) {
          var update = new DisplayUpdate(cm, viewport2);
          if (updateDisplayIfNeeded(cm, update)) {
            updateHeightsInViewport(cm);
            postUpdateDisplay(cm, update);
            var barMeasure = measureForScrollbars(cm);
            updateSelection(cm);
            updateScrollbars(cm, barMeasure);
            setDocumentHeight(cm, barMeasure);
            update.finish();
          }
        }
        function patchDisplay(cm, updateNumbersFrom, dims) {
          var display = cm.display, lineNumbers = cm.options.lineNumbers;
          var container = display.lineDiv, cur = container.firstChild;
          function rm(node2) {
            var next = node2.nextSibling;
            if (webkit && mac && cm.display.currentWheelTarget == node2) {
              node2.style.display = "none";
            } else {
              node2.parentNode.removeChild(node2);
            }
            return next;
          }
          var view = display.view, lineN = display.viewFrom;
          for (var i3 = 0; i3 < view.length; i3++) {
            var lineView = view[i3];
            if (lineView.hidden)
              ;
            else if (!lineView.node || lineView.node.parentNode != container) {
              var node = buildLineElement(cm, lineView, lineN, dims);
              container.insertBefore(node, cur);
            } else {
              while (cur != lineView.node) {
                cur = rm(cur);
              }
              var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
              if (lineView.changes) {
                if (indexOf2(lineView.changes, "gutter") > -1) {
                  updateNumber = false;
                }
                updateLineForChanges(cm, lineView, lineN, dims);
              }
              if (updateNumber) {
                removeChildren(lineView.lineNumber);
                lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
              }
              cur = lineView.node.nextSibling;
            }
            lineN += lineView.size;
          }
          while (cur) {
            cur = rm(cur);
          }
        }
        function updateGutterSpace(display) {
          var width = display.gutters.offsetWidth;
          display.sizer.style.marginLeft = width + "px";
        }
        function setDocumentHeight(cm, measure) {
          cm.display.sizer.style.minHeight = measure.docHeight + "px";
          cm.display.heightForcer.style.top = measure.docHeight + "px";
          cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
        }
        function alignHorizontally(cm) {
          var display = cm.display, view = display.view;
          if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
            return;
          }
          var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
          var gutterW = display.gutters.offsetWidth, left2 = comp + "px";
          for (var i3 = 0; i3 < view.length; i3++) {
            if (!view[i3].hidden) {
              if (cm.options.fixedGutter) {
                if (view[i3].gutter) {
                  view[i3].gutter.style.left = left2;
                }
                if (view[i3].gutterBackground) {
                  view[i3].gutterBackground.style.left = left2;
                }
              }
              var align = view[i3].alignable;
              if (align) {
                for (var j2 = 0; j2 < align.length; j2++) {
                  align[j2].style.left = left2;
                }
              }
            }
          }
          if (cm.options.fixedGutter) {
            display.gutters.style.left = comp + gutterW + "px";
          }
        }
        function maybeUpdateLineNumberWidth(cm) {
          if (!cm.options.lineNumbers) {
            return false;
          }
          var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
          if (last.length != display.lineNumChars) {
            var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
            var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
            display.lineGutter.style.width = "";
            display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
            display.lineNumWidth = display.lineNumInnerWidth + padding;
            display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
            display.lineGutter.style.width = display.lineNumWidth + "px";
            updateGutterSpace(cm.display);
            return true;
          }
          return false;
        }
        function getGutters(gutters, lineNumbers) {
          var result = [], sawLineNumbers = false;
          for (var i3 = 0; i3 < gutters.length; i3++) {
            var name = gutters[i3], style = null;
            if (typeof name != "string") {
              style = name.style;
              name = name.className;
            }
            if (name == "CodeMirror-linenumbers") {
              if (!lineNumbers) {
                continue;
              } else {
                sawLineNumbers = true;
              }
            }
            result.push({ className: name, style });
          }
          if (lineNumbers && !sawLineNumbers) {
            result.push({ className: "CodeMirror-linenumbers", style: null });
          }
          return result;
        }
        function renderGutters(display) {
          var gutters = display.gutters, specs = display.gutterSpecs;
          removeChildren(gutters);
          display.lineGutter = null;
          for (var i3 = 0; i3 < specs.length; ++i3) {
            var ref = specs[i3];
            var className = ref.className;
            var style = ref.style;
            var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
            if (style) {
              gElt.style.cssText = style;
            }
            if (className == "CodeMirror-linenumbers") {
              display.lineGutter = gElt;
              gElt.style.width = (display.lineNumWidth || 1) + "px";
            }
          }
          gutters.style.display = specs.length ? "" : "none";
          updateGutterSpace(display);
        }
        function updateGutters(cm) {
          renderGutters(cm.display);
          regChange(cm);
          alignHorizontally(cm);
        }
        function Display(place, doc, input, options) {
          var d2 = this;
          this.input = input;
          d2.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
          d2.scrollbarFiller.setAttribute("cm-not-content", "true");
          d2.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
          d2.gutterFiller.setAttribute("cm-not-content", "true");
          d2.lineDiv = eltP("div", null, "CodeMirror-code");
          d2.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
          d2.cursorDiv = elt("div", null, "CodeMirror-cursors");
          d2.measure = elt("div", null, "CodeMirror-measure");
          d2.lineMeasure = elt("div", null, "CodeMirror-measure");
          d2.lineSpace = eltP("div", [d2.measure, d2.lineMeasure, d2.selectionDiv, d2.cursorDiv, d2.lineDiv], null, "position: relative; outline: none");
          var lines = eltP("div", [d2.lineSpace], "CodeMirror-lines");
          d2.mover = elt("div", [lines], null, "position: relative");
          d2.sizer = elt("div", [d2.mover], "CodeMirror-sizer");
          d2.sizerWidth = null;
          d2.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
          d2.gutters = elt("div", null, "CodeMirror-gutters");
          d2.lineGutter = null;
          d2.scroller = elt("div", [d2.sizer, d2.heightForcer, d2.gutters], "CodeMirror-scroll");
          d2.scroller.setAttribute("tabIndex", "-1");
          d2.wrapper = elt("div", [d2.scrollbarFiller, d2.gutterFiller, d2.scroller], "CodeMirror");
          if (ie && ie_version < 8) {
            d2.gutters.style.zIndex = -1;
            d2.scroller.style.paddingRight = 0;
          }
          if (!webkit && !(gecko && mobile)) {
            d2.scroller.draggable = true;
          }
          if (place) {
            if (place.appendChild) {
              place.appendChild(d2.wrapper);
            } else {
              place(d2.wrapper);
            }
          }
          d2.viewFrom = d2.viewTo = doc.first;
          d2.reportedViewFrom = d2.reportedViewTo = doc.first;
          d2.view = [];
          d2.renderedView = null;
          d2.externalMeasured = null;
          d2.viewOffset = 0;
          d2.lastWrapHeight = d2.lastWrapWidth = 0;
          d2.updateLineNumbers = null;
          d2.nativeBarWidth = d2.barHeight = d2.barWidth = 0;
          d2.scrollbarsClipped = false;
          d2.lineNumWidth = d2.lineNumInnerWidth = d2.lineNumChars = null;
          d2.alignWidgets = false;
          d2.cachedCharWidth = d2.cachedTextHeight = d2.cachedPaddingH = null;
          d2.maxLine = null;
          d2.maxLineLength = 0;
          d2.maxLineChanged = false;
          d2.wheelDX = d2.wheelDY = d2.wheelStartX = d2.wheelStartY = null;
          d2.shift = false;
          d2.selForContextMenu = null;
          d2.activeTouch = null;
          d2.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
          renderGutters(d2);
          input.init(d2);
        }
        var wheelSamples = 0, wheelPixelsPerUnit = null;
        if (ie) {
          wheelPixelsPerUnit = -0.53;
        } else if (gecko) {
          wheelPixelsPerUnit = 15;
        } else if (chrome2) {
          wheelPixelsPerUnit = -0.7;
        } else if (safari) {
          wheelPixelsPerUnit = -1 / 3;
        }
        function wheelEventDelta(e2) {
          var dx = e2.wheelDeltaX, dy = e2.wheelDeltaY;
          if (dx == null && e2.detail && e2.axis == e2.HORIZONTAL_AXIS) {
            dx = e2.detail;
          }
          if (dy == null && e2.detail && e2.axis == e2.VERTICAL_AXIS) {
            dy = e2.detail;
          } else if (dy == null) {
            dy = e2.wheelDelta;
          }
          return { x: dx, y: dy };
        }
        function wheelEventPixels(e2) {
          var delta = wheelEventDelta(e2);
          delta.x *= wheelPixelsPerUnit;
          delta.y *= wheelPixelsPerUnit;
          return delta;
        }
        function onScrollWheel(cm, e2) {
          var delta = wheelEventDelta(e2), dx = delta.x, dy = delta.y;
          var display = cm.display, scroll = display.scroller;
          var canScrollX = scroll.scrollWidth > scroll.clientWidth;
          var canScrollY = scroll.scrollHeight > scroll.clientHeight;
          if (!(dx && canScrollX || dy && canScrollY)) {
            return;
          }
          if (dy && mac && webkit) {
            outer:
              for (var cur = e2.target, view = display.view; cur != scroll; cur = cur.parentNode) {
                for (var i3 = 0; i3 < view.length; i3++) {
                  if (view[i3].node == cur) {
                    cm.display.currentWheelTarget = cur;
                    break outer;
                  }
                }
              }
          }
          if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
            if (dy && canScrollY) {
              updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit));
            }
            setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
            if (!dy || dy && canScrollY) {
              e_preventDefault(e2);
            }
            display.wheelStartX = null;
            return;
          }
          if (dy && wheelPixelsPerUnit != null) {
            var pixels = dy * wheelPixelsPerUnit;
            var top2 = cm.doc.scrollTop, bot = top2 + display.wrapper.clientHeight;
            if (pixels < 0) {
              top2 = Math.max(0, top2 + pixels - 50);
            } else {
              bot = Math.min(cm.doc.height, bot + pixels + 50);
            }
            updateDisplaySimple(cm, { top: top2, bottom: bot });
          }
          if (wheelSamples < 20) {
            if (display.wheelStartX == null) {
              display.wheelStartX = scroll.scrollLeft;
              display.wheelStartY = scroll.scrollTop;
              display.wheelDX = dx;
              display.wheelDY = dy;
              setTimeout(function() {
                if (display.wheelStartX == null) {
                  return;
                }
                var movedX = scroll.scrollLeft - display.wheelStartX;
                var movedY = scroll.scrollTop - display.wheelStartY;
                var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
                display.wheelStartX = display.wheelStartY = null;
                if (!sample) {
                  return;
                }
                wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
                ++wheelSamples;
              }, 200);
            } else {
              display.wheelDX += dx;
              display.wheelDY += dy;
            }
          }
        }
        var Selection = function(ranges, primIndex) {
          this.ranges = ranges;
          this.primIndex = primIndex;
        };
        Selection.prototype.primary = function() {
          return this.ranges[this.primIndex];
        };
        Selection.prototype.equals = function(other) {
          if (other == this) {
            return true;
          }
          if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
            return false;
          }
          for (var i3 = 0; i3 < this.ranges.length; i3++) {
            var here = this.ranges[i3], there = other.ranges[i3];
            if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {
              return false;
            }
          }
          return true;
        };
        Selection.prototype.deepCopy = function() {
          var out = [];
          for (var i3 = 0; i3 < this.ranges.length; i3++) {
            out[i3] = new Range(copyPos(this.ranges[i3].anchor), copyPos(this.ranges[i3].head));
          }
          return new Selection(out, this.primIndex);
        };
        Selection.prototype.somethingSelected = function() {
          for (var i3 = 0; i3 < this.ranges.length; i3++) {
            if (!this.ranges[i3].empty()) {
              return true;
            }
          }
          return false;
        };
        Selection.prototype.contains = function(pos, end2) {
          if (!end2) {
            end2 = pos;
          }
          for (var i3 = 0; i3 < this.ranges.length; i3++) {
            var range2 = this.ranges[i3];
            if (cmp(end2, range2.from()) >= 0 && cmp(pos, range2.to()) <= 0) {
              return i3;
            }
          }
          return -1;
        };
        var Range = function(anchor, head) {
          this.anchor = anchor;
          this.head = head;
        };
        Range.prototype.from = function() {
          return minPos(this.anchor, this.head);
        };
        Range.prototype.to = function() {
          return maxPos(this.anchor, this.head);
        };
        Range.prototype.empty = function() {
          return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
        };
        function normalizeSelection(cm, ranges, primIndex) {
          var mayTouch = cm && cm.options.selectionsMayTouch;
          var prim = ranges[primIndex];
          ranges.sort(function(a2, b2) {
            return cmp(a2.from(), b2.from());
          });
          primIndex = indexOf2(ranges, prim);
          for (var i3 = 1; i3 < ranges.length; i3++) {
            var cur = ranges[i3], prev = ranges[i3 - 1];
            var diff = cmp(prev.to(), cur.from());
            if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
              var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
              var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
              if (i3 <= primIndex) {
                --primIndex;
              }
              ranges.splice(--i3, 2, new Range(inv ? to : from, inv ? from : to));
            }
          }
          return new Selection(ranges, primIndex);
        }
        function simpleSelection(anchor, head) {
          return new Selection([new Range(anchor, head || anchor)], 0);
        }
        function changeEnd(change) {
          if (!change.text) {
            return change.to;
          }
          return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
        }
        function adjustForChange(pos, change) {
          if (cmp(pos, change.from) < 0) {
            return pos;
          }
          if (cmp(pos, change.to) <= 0) {
            return changeEnd(change);
          }
          var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
          if (pos.line == change.to.line) {
            ch += changeEnd(change).ch - change.to.ch;
          }
          return Pos(line, ch);
        }
        function computeSelAfterChange(doc, change) {
          var out = [];
          for (var i3 = 0; i3 < doc.sel.ranges.length; i3++) {
            var range2 = doc.sel.ranges[i3];
            out.push(new Range(adjustForChange(range2.anchor, change), adjustForChange(range2.head, change)));
          }
          return normalizeSelection(doc.cm, out, doc.sel.primIndex);
        }
        function offsetPos(pos, old, nw) {
          if (pos.line == old.line) {
            return Pos(nw.line, pos.ch - old.ch + nw.ch);
          } else {
            return Pos(nw.line + (pos.line - old.line), pos.ch);
          }
        }
        function computeReplacedSel(doc, changes, hint) {
          var out = [];
          var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
          for (var i3 = 0; i3 < changes.length; i3++) {
            var change = changes[i3];
            var from = offsetPos(change.from, oldPrev, newPrev);
            var to = offsetPos(changeEnd(change), oldPrev, newPrev);
            oldPrev = change.to;
            newPrev = to;
            if (hint == "around") {
              var range2 = doc.sel.ranges[i3], inv = cmp(range2.head, range2.anchor) < 0;
              out[i3] = new Range(inv ? to : from, inv ? from : to);
            } else {
              out[i3] = new Range(from, from);
            }
          }
          return new Selection(out, doc.sel.primIndex);
        }
        function loadMode(cm) {
          cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
          resetModeState(cm);
        }
        function resetModeState(cm) {
          cm.doc.iter(function(line) {
            if (line.stateAfter) {
              line.stateAfter = null;
            }
            if (line.styles) {
              line.styles = null;
            }
          });
          cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
          startWorker(cm, 100);
          cm.state.modeGen++;
          if (cm.curOp) {
            regChange(cm);
          }
        }
        function isWholeLineUpdate(doc, change) {
          return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
        }
        function updateDoc(doc, change, markedSpans, estimateHeight2) {
          function spansFor(n2) {
            return markedSpans ? markedSpans[n2] : null;
          }
          function update(line, text2, spans) {
            updateLine(line, text2, spans, estimateHeight2);
            signalLater(line, "change", line, change);
          }
          function linesFor(start4, end2) {
            var result = [];
            for (var i3 = start4; i3 < end2; ++i3) {
              result.push(new Line(text[i3], spansFor(i3), estimateHeight2));
            }
            return result;
          }
          var from = change.from, to = change.to, text = change.text;
          var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
          var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
          if (change.full) {
            doc.insert(0, linesFor(0, text.length));
            doc.remove(text.length, doc.size - text.length);
          } else if (isWholeLineUpdate(doc, change)) {
            var added = linesFor(0, text.length - 1);
            update(lastLine, lastLine.text, lastSpans);
            if (nlines) {
              doc.remove(from.line, nlines);
            }
            if (added.length) {
              doc.insert(from.line, added);
            }
          } else if (firstLine == lastLine) {
            if (text.length == 1) {
              update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
            } else {
              var added$1 = linesFor(1, text.length - 1);
              added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight2));
              update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
              doc.insert(from.line + 1, added$1);
            }
          } else if (text.length == 1) {
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
            doc.remove(from.line + 1, nlines);
          } else {
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
            update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
            var added$2 = linesFor(1, text.length - 1);
            if (nlines > 1) {
              doc.remove(from.line + 1, nlines - 1);
            }
            doc.insert(from.line + 1, added$2);
          }
          signalLater(doc, "change", doc, change);
        }
        function linkedDocs(doc, f2, sharedHistOnly) {
          function propagate(doc2, skip, sharedHist) {
            if (doc2.linked) {
              for (var i3 = 0; i3 < doc2.linked.length; ++i3) {
                var rel = doc2.linked[i3];
                if (rel.doc == skip) {
                  continue;
                }
                var shared = sharedHist && rel.sharedHist;
                if (sharedHistOnly && !shared) {
                  continue;
                }
                f2(rel.doc, shared);
                propagate(rel.doc, doc2, shared);
              }
            }
          }
          propagate(doc, null, true);
        }
        function attachDoc(cm, doc) {
          if (doc.cm) {
            throw new Error("This document is already in use.");
          }
          cm.doc = doc;
          doc.cm = cm;
          estimateLineHeights(cm);
          loadMode(cm);
          setDirectionClass(cm);
          if (!cm.options.lineWrapping) {
            findMaxLine(cm);
          }
          cm.options.mode = doc.modeOption;
          regChange(cm);
        }
        function setDirectionClass(cm) {
          (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
        }
        function directionChanged(cm) {
          runInOp(cm, function() {
            setDirectionClass(cm);
            regChange(cm);
          });
        }
        function History2(startGen) {
          this.done = [];
          this.undone = [];
          this.undoDepth = Infinity;
          this.lastModTime = this.lastSelTime = 0;
          this.lastOp = this.lastSelOp = null;
          this.lastOrigin = this.lastSelOrigin = null;
          this.generation = this.maxGeneration = startGen || 1;
        }
        function historyChangeFromChange(doc, change) {
          var histChange = { from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to) };
          attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
          linkedDocs(doc, function(doc2) {
            return attachLocalSpans(doc2, histChange, change.from.line, change.to.line + 1);
          }, true);
          return histChange;
        }
        function clearSelectionEvents(array) {
          while (array.length) {
            var last = lst(array);
            if (last.ranges) {
              array.pop();
            } else {
              break;
            }
          }
        }
        function lastChangeEvent(hist, force) {
          if (force) {
            clearSelectionEvents(hist.done);
            return lst(hist.done);
          } else if (hist.done.length && !lst(hist.done).ranges) {
            return lst(hist.done);
          } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
            hist.done.pop();
            return lst(hist.done);
          }
        }
        function addChangeToHistory(doc, change, selAfter, opId) {
          var hist = doc.history;
          hist.undone.length = 0;
          var time = +new Date(), cur;
          var last;
          if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
            last = lst(cur.changes);
            if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
              last.to = changeEnd(change);
            } else {
              cur.changes.push(historyChangeFromChange(doc, change));
            }
          } else {
            var before = lst(hist.done);
            if (!before || !before.ranges) {
              pushSelectionToHistory(doc.sel, hist.done);
            }
            cur = {
              changes: [historyChangeFromChange(doc, change)],
              generation: hist.generation
            };
            hist.done.push(cur);
            while (hist.done.length > hist.undoDepth) {
              hist.done.shift();
              if (!hist.done[0].ranges) {
                hist.done.shift();
              }
            }
          }
          hist.done.push(selAfter);
          hist.generation = ++hist.maxGeneration;
          hist.lastModTime = hist.lastSelTime = time;
          hist.lastOp = hist.lastSelOp = opId;
          hist.lastOrigin = hist.lastSelOrigin = change.origin;
          if (!last) {
            signal(doc, "historyAdded");
          }
        }
        function selectionEventCanBeMerged(doc, origin, prev, sel) {
          var ch = origin.charAt(0);
          return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
        }
        function addSelectionToHistory(doc, sel, opId, options) {
          var hist = doc.history, origin = options && options.origin;
          if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {
            hist.done[hist.done.length - 1] = sel;
          } else {
            pushSelectionToHistory(sel, hist.done);
          }
          hist.lastSelTime = +new Date();
          hist.lastSelOrigin = origin;
          hist.lastSelOp = opId;
          if (options && options.clearRedo !== false) {
            clearSelectionEvents(hist.undone);
          }
        }
        function pushSelectionToHistory(sel, dest) {
          var top2 = lst(dest);
          if (!(top2 && top2.ranges && top2.equals(sel))) {
            dest.push(sel);
          }
        }
        function attachLocalSpans(doc, change, from, to) {
          var existing = change["spans_" + doc.id], n2 = 0;
          doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
            if (line.markedSpans) {
              (existing || (existing = change["spans_" + doc.id] = {}))[n2] = line.markedSpans;
            }
            ++n2;
          });
        }
        function removeClearedSpans(spans) {
          if (!spans) {
            return null;
          }
          var out;
          for (var i3 = 0; i3 < spans.length; ++i3) {
            if (spans[i3].marker.explicitlyCleared) {
              if (!out) {
                out = spans.slice(0, i3);
              }
            } else if (out) {
              out.push(spans[i3]);
            }
          }
          return !out ? spans : out.length ? out : null;
        }
        function getOldSpans(doc, change) {
          var found = change["spans_" + doc.id];
          if (!found) {
            return null;
          }
          var nw = [];
          for (var i3 = 0; i3 < change.text.length; ++i3) {
            nw.push(removeClearedSpans(found[i3]));
          }
          return nw;
        }
        function mergeOldSpans(doc, change) {
          var old = getOldSpans(doc, change);
          var stretched = stretchSpansOverChange(doc, change);
          if (!old) {
            return stretched;
          }
          if (!stretched) {
            return old;
          }
          for (var i3 = 0; i3 < old.length; ++i3) {
            var oldCur = old[i3], stretchCur = stretched[i3];
            if (oldCur && stretchCur) {
              spans:
                for (var j2 = 0; j2 < stretchCur.length; ++j2) {
                  var span = stretchCur[j2];
                  for (var k2 = 0; k2 < oldCur.length; ++k2) {
                    if (oldCur[k2].marker == span.marker) {
                      continue spans;
                    }
                  }
                  oldCur.push(span);
                }
            } else if (stretchCur) {
              old[i3] = stretchCur;
            }
          }
          return old;
        }
        function copyHistoryArray(events, newGroup, instantiateSel) {
          var copy = [];
          for (var i3 = 0; i3 < events.length; ++i3) {
            var event = events[i3];
            if (event.ranges) {
              copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
              continue;
            }
            var changes = event.changes, newChanges = [];
            copy.push({ changes: newChanges });
            for (var j2 = 0; j2 < changes.length; ++j2) {
              var change = changes[j2], m2 = void 0;
              newChanges.push({ from: change.from, to: change.to, text: change.text });
              if (newGroup) {
                for (var prop2 in change) {
                  if (m2 = prop2.match(/^spans_(\d+)$/)) {
                    if (indexOf2(newGroup, Number(m2[1])) > -1) {
                      lst(newChanges)[prop2] = change[prop2];
                      delete change[prop2];
                    }
                  }
                }
              }
            }
          }
          return copy;
        }
        function extendRange(range2, head, other, extend3) {
          if (extend3) {
            var anchor = range2.anchor;
            if (other) {
              var posBefore = cmp(head, anchor) < 0;
              if (posBefore != cmp(other, anchor) < 0) {
                anchor = head;
                head = other;
              } else if (posBefore != cmp(head, other) < 0) {
                head = other;
              }
            }
            return new Range(anchor, head);
          } else {
            return new Range(other || head, head);
          }
        }
        function extendSelection(doc, head, other, options, extend3) {
          if (extend3 == null) {
            extend3 = doc.cm && (doc.cm.display.shift || doc.extend);
          }
          setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend3)], 0), options);
        }
        function extendSelections(doc, heads, options) {
          var out = [];
          var extend3 = doc.cm && (doc.cm.display.shift || doc.extend);
          for (var i3 = 0; i3 < doc.sel.ranges.length; i3++) {
            out[i3] = extendRange(doc.sel.ranges[i3], heads[i3], null, extend3);
          }
          var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
          setSelection(doc, newSel, options);
        }
        function replaceOneSelection(doc, i3, range2, options) {
          var ranges = doc.sel.ranges.slice(0);
          ranges[i3] = range2;
          setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
        }
        function setSimpleSelection(doc, anchor, head, options) {
          setSelection(doc, simpleSelection(anchor, head), options);
        }
        function filterSelectionChange(doc, sel, options) {
          var obj = {
            ranges: sel.ranges,
            update: function(ranges) {
              this.ranges = [];
              for (var i3 = 0; i3 < ranges.length; i3++) {
                this.ranges[i3] = new Range(clipPos(doc, ranges[i3].anchor), clipPos(doc, ranges[i3].head));
              }
            },
            origin: options && options.origin
          };
          signal(doc, "beforeSelectionChange", doc, obj);
          if (doc.cm) {
            signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
          }
          if (obj.ranges != sel.ranges) {
            return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1);
          } else {
            return sel;
          }
        }
        function setSelectionReplaceHistory(doc, sel, options) {
          var done = doc.history.done, last = lst(done);
          if (last && last.ranges) {
            done[done.length - 1] = sel;
            setSelectionNoUndo(doc, sel, options);
          } else {
            setSelection(doc, sel, options);
          }
        }
        function setSelection(doc, sel, options) {
          setSelectionNoUndo(doc, sel, options);
          addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
        }
        function setSelectionNoUndo(doc, sel, options) {
          if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
            sel = filterSelectionChange(doc, sel, options);
          }
          var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
          setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));
          if (!(options && options.scroll === false) && doc.cm) {
            ensureCursorVisible(doc.cm);
          }
        }
        function setSelectionInner(doc, sel) {
          if (sel.equals(doc.sel)) {
            return;
          }
          doc.sel = sel;
          if (doc.cm) {
            doc.cm.curOp.updateInput = 1;
            doc.cm.curOp.selectionChanged = true;
            signalCursorActivity(doc.cm);
          }
          signalLater(doc, "cursorActivity", doc);
        }
        function reCheckSelection(doc) {
          setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
        }
        function skipAtomicInSelection(doc, sel, bias, mayClear) {
          var out;
          for (var i3 = 0; i3 < sel.ranges.length; i3++) {
            var range2 = sel.ranges[i3];
            var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i3];
            var newAnchor = skipAtomic(doc, range2.anchor, old && old.anchor, bias, mayClear);
            var newHead = skipAtomic(doc, range2.head, old && old.head, bias, mayClear);
            if (out || newAnchor != range2.anchor || newHead != range2.head) {
              if (!out) {
                out = sel.ranges.slice(0, i3);
              }
              out[i3] = new Range(newAnchor, newHead);
            }
          }
          return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel;
        }
        function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
          var line = getLine(doc, pos.line);
          if (line.markedSpans) {
            for (var i3 = 0; i3 < line.markedSpans.length; ++i3) {
              var sp = line.markedSpans[i3], m2 = sp.marker;
              var preventCursorLeft = "selectLeft" in m2 ? !m2.selectLeft : m2.inclusiveLeft;
              var preventCursorRight = "selectRight" in m2 ? !m2.selectRight : m2.inclusiveRight;
              if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
                if (mayClear) {
                  signal(m2, "beforeCursorEnter");
                  if (m2.explicitlyCleared) {
                    if (!line.markedSpans) {
                      break;
                    } else {
                      --i3;
                      continue;
                    }
                  }
                }
                if (!m2.atomic) {
                  continue;
                }
                if (oldPos) {
                  var near = m2.find(dir < 0 ? 1 : -1), diff = void 0;
                  if (dir < 0 ? preventCursorRight : preventCursorLeft) {
                    near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
                  }
                  if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {
                    return skipAtomicInner(doc, near, pos, dir, mayClear);
                  }
                }
                var far = m2.find(dir < 0 ? -1 : 1);
                if (dir < 0 ? preventCursorLeft : preventCursorRight) {
                  far = movePos(doc, far, dir, far.line == pos.line ? line : null);
                }
                return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
              }
            }
          }
          return pos;
        }
        function skipAtomic(doc, pos, oldPos, bias, mayClear) {
          var dir = bias || 1;
          var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);
          if (!found) {
            doc.cantEdit = true;
            return Pos(doc.first, 0);
          }
          return found;
        }
        function movePos(doc, pos, dir, line) {
          if (dir < 0 && pos.ch == 0) {
            if (pos.line > doc.first) {
              return clipPos(doc, Pos(pos.line - 1));
            } else {
              return null;
            }
          } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
            if (pos.line < doc.first + doc.size - 1) {
              return Pos(pos.line + 1, 0);
            } else {
              return null;
            }
          } else {
            return new Pos(pos.line, pos.ch + dir);
          }
        }
        function selectAll(cm) {
          cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
        }
        function filterChange(doc, change, update) {
          var obj = {
            canceled: false,
            from: change.from,
            to: change.to,
            text: change.text,
            origin: change.origin,
            cancel: function() {
              return obj.canceled = true;
            }
          };
          if (update) {
            obj.update = function(from, to, text, origin) {
              if (from) {
                obj.from = clipPos(doc, from);
              }
              if (to) {
                obj.to = clipPos(doc, to);
              }
              if (text) {
                obj.text = text;
              }
              if (origin !== void 0) {
                obj.origin = origin;
              }
            };
          }
          signal(doc, "beforeChange", doc, obj);
          if (doc.cm) {
            signal(doc.cm, "beforeChange", doc.cm, obj);
          }
          if (obj.canceled) {
            if (doc.cm) {
              doc.cm.curOp.updateInput = 2;
            }
            return null;
          }
          return { from: obj.from, to: obj.to, text: obj.text, origin: obj.origin };
        }
        function makeChange(doc, change, ignoreReadOnly) {
          if (doc.cm) {
            if (!doc.cm.curOp) {
              return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
            }
            if (doc.cm.state.suppressEdits) {
              return;
            }
          }
          if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
            change = filterChange(doc, change, true);
            if (!change) {
              return;
            }
          }
          var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
          if (split) {
            for (var i3 = split.length - 1; i3 >= 0; --i3) {
              makeChangeInner(doc, { from: split[i3].from, to: split[i3].to, text: i3 ? [""] : change.text, origin: change.origin });
            }
          } else {
            makeChangeInner(doc, change);
          }
        }
        function makeChangeInner(doc, change) {
          if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
            return;
          }
          var selAfter = computeSelAfterChange(doc, change);
          addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
          makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
          var rebased = [];
          linkedDocs(doc, function(doc2, sharedHist) {
            if (!sharedHist && indexOf2(rebased, doc2.history) == -1) {
              rebaseHist(doc2.history, change);
              rebased.push(doc2.history);
            }
            makeChangeSingleDoc(doc2, change, null, stretchSpansOverChange(doc2, change));
          });
        }
        function makeChangeFromHistory(doc, type, allowSelectionOnly) {
          var suppress = doc.cm && doc.cm.state.suppressEdits;
          if (suppress && !allowSelectionOnly) {
            return;
          }
          var hist = doc.history, event, selAfter = doc.sel;
          var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;
          var i3 = 0;
          for (; i3 < source.length; i3++) {
            event = source[i3];
            if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) {
              break;
            }
          }
          if (i3 == source.length) {
            return;
          }
          hist.lastOrigin = hist.lastSelOrigin = null;
          for (; ; ) {
            event = source.pop();
            if (event.ranges) {
              pushSelectionToHistory(event, dest);
              if (allowSelectionOnly && !event.equals(doc.sel)) {
                setSelection(doc, event, { clearRedo: false });
                return;
              }
              selAfter = event;
            } else if (suppress) {
              source.push(event);
              return;
            } else {
              break;
            }
          }
          var antiChanges = [];
          pushSelectionToHistory(selAfter, dest);
          dest.push({ changes: antiChanges, generation: hist.generation });
          hist.generation = event.generation || ++hist.maxGeneration;
          var filter2 = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");
          var loop = function(i4) {
            var change = event.changes[i4];
            change.origin = type;
            if (filter2 && !filterChange(doc, change, false)) {
              source.length = 0;
              return {};
            }
            antiChanges.push(historyChangeFromChange(doc, change));
            var after = i4 ? computeSelAfterChange(doc, change) : lst(source);
            makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
            if (!i4 && doc.cm) {
              doc.cm.scrollIntoView({ from: change.from, to: changeEnd(change) });
            }
            var rebased = [];
            linkedDocs(doc, function(doc2, sharedHist) {
              if (!sharedHist && indexOf2(rebased, doc2.history) == -1) {
                rebaseHist(doc2.history, change);
                rebased.push(doc2.history);
              }
              makeChangeSingleDoc(doc2, change, null, mergeOldSpans(doc2, change));
            });
          };
          for (var i$12 = event.changes.length - 1; i$12 >= 0; --i$12) {
            var returned = loop(i$12);
            if (returned)
              return returned.v;
          }
        }
        function shiftDoc(doc, distance) {
          if (distance == 0) {
            return;
          }
          doc.first += distance;
          doc.sel = new Selection(map(doc.sel.ranges, function(range2) {
            return new Range(Pos(range2.anchor.line + distance, range2.anchor.ch), Pos(range2.head.line + distance, range2.head.ch));
          }), doc.sel.primIndex);
          if (doc.cm) {
            regChange(doc.cm, doc.first, doc.first - distance, distance);
            for (var d2 = doc.cm.display, l2 = d2.viewFrom; l2 < d2.viewTo; l2++) {
              regLineChange(doc.cm, l2, "gutter");
            }
          }
        }
        function makeChangeSingleDoc(doc, change, selAfter, spans) {
          if (doc.cm && !doc.cm.curOp) {
            return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
          }
          if (change.to.line < doc.first) {
            shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
            return;
          }
          if (change.from.line > doc.lastLine()) {
            return;
          }
          if (change.from.line < doc.first) {
            var shift = change.text.length - 1 - (doc.first - change.from.line);
            shiftDoc(doc, shift);
            change = {
              from: Pos(doc.first, 0),
              to: Pos(change.to.line + shift, change.to.ch),
              text: [lst(change.text)],
              origin: change.origin
            };
          }
          var last = doc.lastLine();
          if (change.to.line > last) {
            change = {
              from: change.from,
              to: Pos(last, getLine(doc, last).text.length),
              text: [change.text[0]],
              origin: change.origin
            };
          }
          change.removed = getBetween(doc, change.from, change.to);
          if (!selAfter) {
            selAfter = computeSelAfterChange(doc, change);
          }
          if (doc.cm) {
            makeChangeSingleDocInEditor(doc.cm, change, spans);
          } else {
            updateDoc(doc, change, spans);
          }
          setSelectionNoUndo(doc, selAfter, sel_dontScroll);
          if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0))) {
            doc.cantEdit = false;
          }
        }
        function makeChangeSingleDocInEditor(cm, change, spans) {
          var doc = cm.doc, display = cm.display, from = change.from, to = change.to;
          var recomputeMaxLength = false, checkWidthStart = from.line;
          if (!cm.options.lineWrapping) {
            checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
            doc.iter(checkWidthStart, to.line + 1, function(line) {
              if (line == display.maxLine) {
                recomputeMaxLength = true;
                return true;
              }
            });
          }
          if (doc.sel.contains(change.from, change.to) > -1) {
            signalCursorActivity(cm);
          }
          updateDoc(doc, change, spans, estimateHeight(cm));
          if (!cm.options.lineWrapping) {
            doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
              var len = lineLength(line);
              if (len > display.maxLineLength) {
                display.maxLine = line;
                display.maxLineLength = len;
                display.maxLineChanged = true;
                recomputeMaxLength = false;
              }
            });
            if (recomputeMaxLength) {
              cm.curOp.updateMaxLine = true;
            }
          }
          retreatFrontier(doc, from.line);
          startWorker(cm, 400);
          var lendiff = change.text.length - (to.line - from.line) - 1;
          if (change.full) {
            regChange(cm);
          } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
            regLineChange(cm, from.line, "text");
          } else {
            regChange(cm, from.line, to.line + 1, lendiff);
          }
          var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
          if (changeHandler || changesHandler) {
            var obj = {
              from,
              to,
              text: change.text,
              removed: change.removed,
              origin: change.origin
            };
            if (changeHandler) {
              signalLater(cm, "change", cm, obj);
            }
            if (changesHandler) {
              (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
            }
          }
          cm.display.selForContextMenu = null;
        }
        function replaceRange(doc, code3, from, to, origin) {
          var assign;
          if (!to) {
            to = from;
          }
          if (cmp(to, from) < 0) {
            assign = [to, from], from = assign[0], to = assign[1];
          }
          if (typeof code3 == "string") {
            code3 = doc.splitLines(code3);
          }
          makeChange(doc, { from, to, text: code3, origin });
        }
        function rebaseHistSelSingle(pos, from, to, diff) {
          if (to < pos.line) {
            pos.line += diff;
          } else if (from < pos.line) {
            pos.line = from;
            pos.ch = 0;
          }
        }
        function rebaseHistArray(array, from, to, diff) {
          for (var i3 = 0; i3 < array.length; ++i3) {
            var sub = array[i3], ok = true;
            if (sub.ranges) {
              if (!sub.copied) {
                sub = array[i3] = sub.deepCopy();
                sub.copied = true;
              }
              for (var j2 = 0; j2 < sub.ranges.length; j2++) {
                rebaseHistSelSingle(sub.ranges[j2].anchor, from, to, diff);
                rebaseHistSelSingle(sub.ranges[j2].head, from, to, diff);
              }
              continue;
            }
            for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
              var cur = sub.changes[j$1];
              if (to < cur.from.line) {
                cur.from = Pos(cur.from.line + diff, cur.from.ch);
                cur.to = Pos(cur.to.line + diff, cur.to.ch);
              } else if (from <= cur.to.line) {
                ok = false;
                break;
              }
            }
            if (!ok) {
              array.splice(0, i3 + 1);
              i3 = 0;
            }
          }
        }
        function rebaseHist(hist, change) {
          var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
          rebaseHistArray(hist.done, from, to, diff);
          rebaseHistArray(hist.undone, from, to, diff);
        }
        function changeLine(doc, handle, changeType, op) {
          var no = handle, line = handle;
          if (typeof handle == "number") {
            line = getLine(doc, clipLine(doc, handle));
          } else {
            no = lineNo(handle);
          }
          if (no == null) {
            return null;
          }
          if (op(line, no) && doc.cm) {
            regLineChange(doc.cm, no, changeType);
          }
          return line;
        }
        function LeafChunk(lines) {
          this.lines = lines;
          this.parent = null;
          var height = 0;
          for (var i3 = 0; i3 < lines.length; ++i3) {
            lines[i3].parent = this;
            height += lines[i3].height;
          }
          this.height = height;
        }
        LeafChunk.prototype = {
          chunkSize: function() {
            return this.lines.length;
          },
          removeInner: function(at, n2) {
            for (var i3 = at, e2 = at + n2; i3 < e2; ++i3) {
              var line = this.lines[i3];
              this.height -= line.height;
              cleanUpLine(line);
              signalLater(line, "delete");
            }
            this.lines.splice(at, n2);
          },
          collapse: function(lines) {
            lines.push.apply(lines, this.lines);
          },
          insertInner: function(at, lines, height) {
            this.height += height;
            this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
            for (var i3 = 0; i3 < lines.length; ++i3) {
              lines[i3].parent = this;
            }
          },
          iterN: function(at, n2, op) {
            for (var e2 = at + n2; at < e2; ++at) {
              if (op(this.lines[at])) {
                return true;
              }
            }
          }
        };
        function BranchChunk(children) {
          this.children = children;
          var size = 0, height = 0;
          for (var i3 = 0; i3 < children.length; ++i3) {
            var ch = children[i3];
            size += ch.chunkSize();
            height += ch.height;
            ch.parent = this;
          }
          this.size = size;
          this.height = height;
          this.parent = null;
        }
        BranchChunk.prototype = {
          chunkSize: function() {
            return this.size;
          },
          removeInner: function(at, n2) {
            this.size -= n2;
            for (var i3 = 0; i3 < this.children.length; ++i3) {
              var child = this.children[i3], sz = child.chunkSize();
              if (at < sz) {
                var rm = Math.min(n2, sz - at), oldHeight = child.height;
                child.removeInner(at, rm);
                this.height -= oldHeight - child.height;
                if (sz == rm) {
                  this.children.splice(i3--, 1);
                  child.parent = null;
                }
                if ((n2 -= rm) == 0) {
                  break;
                }
                at = 0;
              } else {
                at -= sz;
              }
            }
            if (this.size - n2 < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
              var lines = [];
              this.collapse(lines);
              this.children = [new LeafChunk(lines)];
              this.children[0].parent = this;
            }
          },
          collapse: function(lines) {
            for (var i3 = 0; i3 < this.children.length; ++i3) {
              this.children[i3].collapse(lines);
            }
          },
          insertInner: function(at, lines, height) {
            this.size += lines.length;
            this.height += height;
            for (var i3 = 0; i3 < this.children.length; ++i3) {
              var child = this.children[i3], sz = child.chunkSize();
              if (at <= sz) {
                child.insertInner(at, lines, height);
                if (child.lines && child.lines.length > 50) {
                  var remaining = child.lines.length % 25 + 25;
                  for (var pos = remaining; pos < child.lines.length; ) {
                    var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                    child.height -= leaf.height;
                    this.children.splice(++i3, 0, leaf);
                    leaf.parent = this;
                  }
                  child.lines = child.lines.slice(0, remaining);
                  this.maybeSpill();
                }
                break;
              }
              at -= sz;
            }
          },
          maybeSpill: function() {
            if (this.children.length <= 10) {
              return;
            }
            var me = this;
            do {
              var spilled = me.children.splice(me.children.length - 5, 5);
              var sibling = new BranchChunk(spilled);
              if (!me.parent) {
                var copy = new BranchChunk(me.children);
                copy.parent = me;
                me.children = [copy, sibling];
                me = copy;
              } else {
                me.size -= sibling.size;
                me.height -= sibling.height;
                var myIndex = indexOf2(me.parent.children, me);
                me.parent.children.splice(myIndex + 1, 0, sibling);
              }
              sibling.parent = me.parent;
            } while (me.children.length > 10);
            me.parent.maybeSpill();
          },
          iterN: function(at, n2, op) {
            for (var i3 = 0; i3 < this.children.length; ++i3) {
              var child = this.children[i3], sz = child.chunkSize();
              if (at < sz) {
                var used = Math.min(n2, sz - at);
                if (child.iterN(at, used, op)) {
                  return true;
                }
                if ((n2 -= used) == 0) {
                  break;
                }
                at = 0;
              } else {
                at -= sz;
              }
            }
          }
        };
        var LineWidget = function(doc, node, options) {
          if (options) {
            for (var opt in options) {
              if (options.hasOwnProperty(opt)) {
                this[opt] = options[opt];
              }
            }
          }
          this.doc = doc;
          this.node = node;
        };
        LineWidget.prototype.clear = function() {
          var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
          if (no == null || !ws) {
            return;
          }
          for (var i3 = 0; i3 < ws.length; ++i3) {
            if (ws[i3] == this) {
              ws.splice(i3--, 1);
            }
          }
          if (!ws.length) {
            line.widgets = null;
          }
          var height = widgetHeight(this);
          updateLineHeight(line, Math.max(0, line.height - height));
          if (cm) {
            runInOp(cm, function() {
              adjustScrollWhenAboveVisible(cm, line, -height);
              regLineChange(cm, no, "widget");
            });
            signalLater(cm, "lineWidgetCleared", cm, this, no);
          }
        };
        LineWidget.prototype.changed = function() {
          var this$1 = this;
          var oldH = this.height, cm = this.doc.cm, line = this.line;
          this.height = null;
          var diff = widgetHeight(this) - oldH;
          if (!diff) {
            return;
          }
          if (!lineIsHidden(this.doc, line)) {
            updateLineHeight(line, line.height + diff);
          }
          if (cm) {
            runInOp(cm, function() {
              cm.curOp.forceUpdate = true;
              adjustScrollWhenAboveVisible(cm, line, diff);
              signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
            });
          }
        };
        eventMixin(LineWidget);
        function adjustScrollWhenAboveVisible(cm, line, diff) {
          if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
            addToScrollTop(cm, diff);
          }
        }
        function addLineWidget(doc, handle, node, options) {
          var widget = new LineWidget(doc, node, options);
          var cm = doc.cm;
          if (cm && widget.noHScroll) {
            cm.display.alignWidgets = true;
          }
          changeLine(doc, handle, "widget", function(line) {
            var widgets = line.widgets || (line.widgets = []);
            if (widget.insertAt == null) {
              widgets.push(widget);
            } else {
              widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);
            }
            widget.line = line;
            if (cm && !lineIsHidden(doc, line)) {
              var aboveVisible = heightAtLine(line) < doc.scrollTop;
              updateLineHeight(line, line.height + widgetHeight(widget));
              if (aboveVisible) {
                addToScrollTop(cm, widget.height);
              }
              cm.curOp.forceUpdate = true;
            }
            return true;
          });
          if (cm) {
            signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
          }
          return widget;
        }
        var nextMarkerId = 0;
        var TextMarker = function(doc, type) {
          this.lines = [];
          this.type = type;
          this.doc = doc;
          this.id = ++nextMarkerId;
        };
        TextMarker.prototype.clear = function() {
          if (this.explicitlyCleared) {
            return;
          }
          var cm = this.doc.cm, withOp = cm && !cm.curOp;
          if (withOp) {
            startOperation(cm);
          }
          if (hasHandler(this, "clear")) {
            var found = this.find();
            if (found) {
              signalLater(this, "clear", found.from, found.to);
            }
          }
          var min2 = null, max2 = null;
          for (var i3 = 0; i3 < this.lines.length; ++i3) {
            var line = this.lines[i3];
            var span = getMarkedSpanFor(line.markedSpans, this);
            if (cm && !this.collapsed) {
              regLineChange(cm, lineNo(line), "text");
            } else if (cm) {
              if (span.to != null) {
                max2 = lineNo(line);
              }
              if (span.from != null) {
                min2 = lineNo(line);
              }
            }
            line.markedSpans = removeMarkedSpan(line.markedSpans, span);
            if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {
              updateLineHeight(line, textHeight(cm.display));
            }
          }
          if (cm && this.collapsed && !cm.options.lineWrapping) {
            for (var i$12 = 0; i$12 < this.lines.length; ++i$12) {
              var visual = visualLine(this.lines[i$12]), len = lineLength(visual);
              if (len > cm.display.maxLineLength) {
                cm.display.maxLine = visual;
                cm.display.maxLineLength = len;
                cm.display.maxLineChanged = true;
              }
            }
          }
          if (min2 != null && cm && this.collapsed) {
            regChange(cm, min2, max2 + 1);
          }
          this.lines.length = 0;
          this.explicitlyCleared = true;
          if (this.atomic && this.doc.cantEdit) {
            this.doc.cantEdit = false;
            if (cm) {
              reCheckSelection(cm.doc);
            }
          }
          if (cm) {
            signalLater(cm, "markerCleared", cm, this, min2, max2);
          }
          if (withOp) {
            endOperation(cm);
          }
          if (this.parent) {
            this.parent.clear();
          }
        };
        TextMarker.prototype.find = function(side, lineObj) {
          if (side == null && this.type == "bookmark") {
            side = 1;
          }
          var from, to;
          for (var i3 = 0; i3 < this.lines.length; ++i3) {
            var line = this.lines[i3];
            var span = getMarkedSpanFor(line.markedSpans, this);
            if (span.from != null) {
              from = Pos(lineObj ? line : lineNo(line), span.from);
              if (side == -1) {
                return from;
              }
            }
            if (span.to != null) {
              to = Pos(lineObj ? line : lineNo(line), span.to);
              if (side == 1) {
                return to;
              }
            }
          }
          return from && { from, to };
        };
        TextMarker.prototype.changed = function() {
          var this$1 = this;
          var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
          if (!pos || !cm) {
            return;
          }
          runInOp(cm, function() {
            var line = pos.line, lineN = lineNo(pos.line);
            var view = findViewForLine(cm, lineN);
            if (view) {
              clearLineMeasurementCacheFor(view);
              cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
            }
            cm.curOp.updateMaxLine = true;
            if (!lineIsHidden(widget.doc, line) && widget.height != null) {
              var oldHeight = widget.height;
              widget.height = null;
              var dHeight = widgetHeight(widget) - oldHeight;
              if (dHeight) {
                updateLineHeight(line, line.height + dHeight);
              }
            }
            signalLater(cm, "markerChanged", cm, this$1);
          });
        };
        TextMarker.prototype.attachLine = function(line) {
          if (!this.lines.length && this.doc.cm) {
            var op = this.doc.cm.curOp;
            if (!op.maybeHiddenMarkers || indexOf2(op.maybeHiddenMarkers, this) == -1) {
              (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
            }
          }
          this.lines.push(line);
        };
        TextMarker.prototype.detachLine = function(line) {
          this.lines.splice(indexOf2(this.lines, line), 1);
          if (!this.lines.length && this.doc.cm) {
            var op = this.doc.cm.curOp;
            (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
          }
        };
        eventMixin(TextMarker);
        function markText(doc, from, to, options, type) {
          if (options && options.shared) {
            return markTextShared(doc, from, to, options, type);
          }
          if (doc.cm && !doc.cm.curOp) {
            return operation(doc.cm, markText)(doc, from, to, options, type);
          }
          var marker = new TextMarker(doc, type), diff = cmp(from, to);
          if (options) {
            copyObj(options, marker, false);
          }
          if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {
            return marker;
          }
          if (marker.replacedWith) {
            marker.collapsed = true;
            marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
            if (!options.handleMouseEvents) {
              marker.widgetNode.setAttribute("cm-ignore-events", "true");
            }
            if (options.insertLeft) {
              marker.widgetNode.insertLeft = true;
            }
          }
          if (marker.collapsed) {
            if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) {
              throw new Error("Inserting collapsed marker partially overlapping an existing one");
            }
            seeCollapsedSpans();
          }
          if (marker.addToHistory) {
            addChangeToHistory(doc, { from, to, origin: "markText" }, doc.sel, NaN);
          }
          var curLine = from.line, cm = doc.cm, updateMaxLine;
          doc.iter(curLine, to.line + 1, function(line) {
            if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
              updateMaxLine = true;
            }
            if (marker.collapsed && curLine != from.line) {
              updateLineHeight(line, 0);
            }
            addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null));
            ++curLine;
          });
          if (marker.collapsed) {
            doc.iter(from.line, to.line + 1, function(line) {
              if (lineIsHidden(doc, line)) {
                updateLineHeight(line, 0);
              }
            });
          }
          if (marker.clearOnEnter) {
            on(marker, "beforeCursorEnter", function() {
              return marker.clear();
            });
          }
          if (marker.readOnly) {
            seeReadOnlySpans();
            if (doc.history.done.length || doc.history.undone.length) {
              doc.clearHistory();
            }
          }
          if (marker.collapsed) {
            marker.id = ++nextMarkerId;
            marker.atomic = true;
          }
          if (cm) {
            if (updateMaxLine) {
              cm.curOp.updateMaxLine = true;
            }
            if (marker.collapsed) {
              regChange(cm, from.line, to.line + 1);
            } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {
              for (var i3 = from.line; i3 <= to.line; i3++) {
                regLineChange(cm, i3, "text");
              }
            }
            if (marker.atomic) {
              reCheckSelection(cm.doc);
            }
            signalLater(cm, "markerAdded", cm, marker);
          }
          return marker;
        }
        var SharedTextMarker = function(markers, primary) {
          this.markers = markers;
          this.primary = primary;
          for (var i3 = 0; i3 < markers.length; ++i3) {
            markers[i3].parent = this;
          }
        };
        SharedTextMarker.prototype.clear = function() {
          if (this.explicitlyCleared) {
            return;
          }
          this.explicitlyCleared = true;
          for (var i3 = 0; i3 < this.markers.length; ++i3) {
            this.markers[i3].clear();
          }
          signalLater(this, "clear");
        };
        SharedTextMarker.prototype.find = function(side, lineObj) {
          return this.primary.find(side, lineObj);
        };
        eventMixin(SharedTextMarker);
        function markTextShared(doc, from, to, options, type) {
          options = copyObj(options);
          options.shared = false;
          var markers = [markText(doc, from, to, options, type)], primary = markers[0];
          var widget = options.widgetNode;
          linkedDocs(doc, function(doc2) {
            if (widget) {
              options.widgetNode = widget.cloneNode(true);
            }
            markers.push(markText(doc2, clipPos(doc2, from), clipPos(doc2, to), options, type));
            for (var i3 = 0; i3 < doc2.linked.length; ++i3) {
              if (doc2.linked[i3].isParent) {
                return;
              }
            }
            primary = lst(markers);
          });
          return new SharedTextMarker(markers, primary);
        }
        function findSharedMarkers(doc) {
          return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function(m2) {
            return m2.parent;
          });
        }
        function copySharedMarkers(doc, markers) {
          for (var i3 = 0; i3 < markers.length; i3++) {
            var marker = markers[i3], pos = marker.find();
            var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
            if (cmp(mFrom, mTo)) {
              var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
              marker.markers.push(subMark);
              subMark.parent = marker;
            }
          }
        }
        function detachSharedMarkers(markers) {
          var loop = function(i4) {
            var marker = markers[i4], linked = [marker.primary.doc];
            linkedDocs(marker.primary.doc, function(d2) {
              return linked.push(d2);
            });
            for (var j2 = 0; j2 < marker.markers.length; j2++) {
              var subMarker = marker.markers[j2];
              if (indexOf2(linked, subMarker.doc) == -1) {
                subMarker.parent = null;
                marker.markers.splice(j2--, 1);
              }
            }
          };
          for (var i3 = 0; i3 < markers.length; i3++)
            loop(i3);
        }
        var nextDocId = 0;
        var Doc = function(text, mode, firstLine, lineSep, direction) {
          if (!(this instanceof Doc)) {
            return new Doc(text, mode, firstLine, lineSep, direction);
          }
          if (firstLine == null) {
            firstLine = 0;
          }
          BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
          this.first = firstLine;
          this.scrollTop = this.scrollLeft = 0;
          this.cantEdit = false;
          this.cleanGeneration = 1;
          this.modeFrontier = this.highlightFrontier = firstLine;
          var start4 = Pos(firstLine, 0);
          this.sel = simpleSelection(start4);
          this.history = new History2(null);
          this.id = ++nextDocId;
          this.modeOption = mode;
          this.lineSep = lineSep;
          this.direction = direction == "rtl" ? "rtl" : "ltr";
          this.extend = false;
          if (typeof text == "string") {
            text = this.splitLines(text);
          }
          updateDoc(this, { from: start4, to: start4, text });
          setSelection(this, simpleSelection(start4), sel_dontScroll);
        };
        Doc.prototype = createObj(BranchChunk.prototype, {
          constructor: Doc,
          iter: function(from, to, op) {
            if (op) {
              this.iterN(from - this.first, to - from, op);
            } else {
              this.iterN(this.first, this.first + this.size, from);
            }
          },
          insert: function(at, lines) {
            var height = 0;
            for (var i3 = 0; i3 < lines.length; ++i3) {
              height += lines[i3].height;
            }
            this.insertInner(at - this.first, lines, height);
          },
          remove: function(at, n2) {
            this.removeInner(at - this.first, n2);
          },
          getValue: function(lineSep) {
            var lines = getLines(this, this.first, this.first + this.size);
            if (lineSep === false) {
              return lines;
            }
            return lines.join(lineSep || this.lineSeparator());
          },
          setValue: docMethodOp(function(code3) {
            var top2 = Pos(this.first, 0), last = this.first + this.size - 1;
            makeChange(this, {
              from: top2,
              to: Pos(last, getLine(this, last).text.length),
              text: this.splitLines(code3),
              origin: "setValue",
              full: true
            }, true);
            if (this.cm) {
              scrollToCoords(this.cm, 0, 0);
            }
            setSelection(this, simpleSelection(top2), sel_dontScroll);
          }),
          replaceRange: function(code3, from, to, origin) {
            from = clipPos(this, from);
            to = to ? clipPos(this, to) : from;
            replaceRange(this, code3, from, to, origin);
          },
          getRange: function(from, to, lineSep) {
            var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
            if (lineSep === false) {
              return lines;
            }
            return lines.join(lineSep || this.lineSeparator());
          },
          getLine: function(line) {
            var l2 = this.getLineHandle(line);
            return l2 && l2.text;
          },
          getLineHandle: function(line) {
            if (isLine(this, line)) {
              return getLine(this, line);
            }
          },
          getLineNumber: function(line) {
            return lineNo(line);
          },
          getLineHandleVisualStart: function(line) {
            if (typeof line == "number") {
              line = getLine(this, line);
            }
            return visualLine(line);
          },
          lineCount: function() {
            return this.size;
          },
          firstLine: function() {
            return this.first;
          },
          lastLine: function() {
            return this.first + this.size - 1;
          },
          clipPos: function(pos) {
            return clipPos(this, pos);
          },
          getCursor: function(start4) {
            var range2 = this.sel.primary(), pos;
            if (start4 == null || start4 == "head") {
              pos = range2.head;
            } else if (start4 == "anchor") {
              pos = range2.anchor;
            } else if (start4 == "end" || start4 == "to" || start4 === false) {
              pos = range2.to();
            } else {
              pos = range2.from();
            }
            return pos;
          },
          listSelections: function() {
            return this.sel.ranges;
          },
          somethingSelected: function() {
            return this.sel.somethingSelected();
          },
          setCursor: docMethodOp(function(line, ch, options) {
            setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
          }),
          setSelection: docMethodOp(function(anchor, head, options) {
            setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
          }),
          extendSelection: docMethodOp(function(head, other, options) {
            extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
          }),
          extendSelections: docMethodOp(function(heads, options) {
            extendSelections(this, clipPosArray(this, heads), options);
          }),
          extendSelectionsBy: docMethodOp(function(f2, options) {
            var heads = map(this.sel.ranges, f2);
            extendSelections(this, clipPosArray(this, heads), options);
          }),
          setSelections: docMethodOp(function(ranges, primary, options) {
            if (!ranges.length) {
              return;
            }
            var out = [];
            for (var i3 = 0; i3 < ranges.length; i3++) {
              out[i3] = new Range(clipPos(this, ranges[i3].anchor), clipPos(this, ranges[i3].head));
            }
            if (primary == null) {
              primary = Math.min(ranges.length - 1, this.sel.primIndex);
            }
            setSelection(this, normalizeSelection(this.cm, out, primary), options);
          }),
          addSelection: docMethodOp(function(anchor, head, options) {
            var ranges = this.sel.ranges.slice(0);
            ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
            setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
          }),
          getSelection: function(lineSep) {
            var ranges = this.sel.ranges, lines;
            for (var i3 = 0; i3 < ranges.length; i3++) {
              var sel = getBetween(this, ranges[i3].from(), ranges[i3].to());
              lines = lines ? lines.concat(sel) : sel;
            }
            if (lineSep === false) {
              return lines;
            } else {
              return lines.join(lineSep || this.lineSeparator());
            }
          },
          getSelections: function(lineSep) {
            var parts = [], ranges = this.sel.ranges;
            for (var i3 = 0; i3 < ranges.length; i3++) {
              var sel = getBetween(this, ranges[i3].from(), ranges[i3].to());
              if (lineSep !== false) {
                sel = sel.join(lineSep || this.lineSeparator());
              }
              parts[i3] = sel;
            }
            return parts;
          },
          replaceSelection: function(code3, collapse, origin) {
            var dup = [];
            for (var i3 = 0; i3 < this.sel.ranges.length; i3++) {
              dup[i3] = code3;
            }
            this.replaceSelections(dup, collapse, origin || "+input");
          },
          replaceSelections: docMethodOp(function(code3, collapse, origin) {
            var changes = [], sel = this.sel;
            for (var i3 = 0; i3 < sel.ranges.length; i3++) {
              var range2 = sel.ranges[i3];
              changes[i3] = { from: range2.from(), to: range2.to(), text: this.splitLines(code3[i3]), origin };
            }
            var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
            for (var i$12 = changes.length - 1; i$12 >= 0; i$12--) {
              makeChange(this, changes[i$12]);
            }
            if (newSel) {
              setSelectionReplaceHistory(this, newSel);
            } else if (this.cm) {
              ensureCursorVisible(this.cm);
            }
          }),
          undo: docMethodOp(function() {
            makeChangeFromHistory(this, "undo");
          }),
          redo: docMethodOp(function() {
            makeChangeFromHistory(this, "redo");
          }),
          undoSelection: docMethodOp(function() {
            makeChangeFromHistory(this, "undo", true);
          }),
          redoSelection: docMethodOp(function() {
            makeChangeFromHistory(this, "redo", true);
          }),
          setExtending: function(val) {
            this.extend = val;
          },
          getExtending: function() {
            return this.extend;
          },
          historySize: function() {
            var hist = this.history, done = 0, undone = 0;
            for (var i3 = 0; i3 < hist.done.length; i3++) {
              if (!hist.done[i3].ranges) {
                ++done;
              }
            }
            for (var i$12 = 0; i$12 < hist.undone.length; i$12++) {
              if (!hist.undone[i$12].ranges) {
                ++undone;
              }
            }
            return { undo: done, redo: undone };
          },
          clearHistory: function() {
            var this$1 = this;
            this.history = new History2(this.history.maxGeneration);
            linkedDocs(this, function(doc) {
              return doc.history = this$1.history;
            }, true);
          },
          markClean: function() {
            this.cleanGeneration = this.changeGeneration(true);
          },
          changeGeneration: function(forceSplit) {
            if (forceSplit) {
              this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
            }
            return this.history.generation;
          },
          isClean: function(gen) {
            return this.history.generation == (gen || this.cleanGeneration);
          },
          getHistory: function() {
            return {
              done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)
            };
          },
          setHistory: function(histData) {
            var hist = this.history = new History2(this.history.maxGeneration);
            hist.done = copyHistoryArray(histData.done.slice(0), null, true);
            hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
          },
          setGutterMarker: docMethodOp(function(line, gutterID, value) {
            return changeLine(this, line, "gutter", function(line2) {
              var markers = line2.gutterMarkers || (line2.gutterMarkers = {});
              markers[gutterID] = value;
              if (!value && isEmpty(markers)) {
                line2.gutterMarkers = null;
              }
              return true;
            });
          }),
          clearGutter: docMethodOp(function(gutterID) {
            var this$1 = this;
            this.iter(function(line) {
              if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
                changeLine(this$1, line, "gutter", function() {
                  line.gutterMarkers[gutterID] = null;
                  if (isEmpty(line.gutterMarkers)) {
                    line.gutterMarkers = null;
                  }
                  return true;
                });
              }
            });
          }),
          lineInfo: function(line) {
            var n2;
            if (typeof line == "number") {
              if (!isLine(this, line)) {
                return null;
              }
              n2 = line;
              line = getLine(this, line);
              if (!line) {
                return null;
              }
            } else {
              n2 = lineNo(line);
              if (n2 == null) {
                return null;
              }
            }
            return {
              line: n2,
              handle: line,
              text: line.text,
              gutterMarkers: line.gutterMarkers,
              textClass: line.textClass,
              bgClass: line.bgClass,
              wrapClass: line.wrapClass,
              widgets: line.widgets
            };
          },
          addLineClass: docMethodOp(function(handle, where, cls) {
            return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
              var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
              if (!line[prop2]) {
                line[prop2] = cls;
              } else if (classTest(cls).test(line[prop2])) {
                return false;
              } else {
                line[prop2] += " " + cls;
              }
              return true;
            });
          }),
          removeLineClass: docMethodOp(function(handle, where, cls) {
            return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
              var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
              var cur = line[prop2];
              if (!cur) {
                return false;
              } else if (cls == null) {
                line[prop2] = null;
              } else {
                var found = cur.match(classTest(cls));
                if (!found) {
                  return false;
                }
                var end2 = found.index + found[0].length;
                line[prop2] = cur.slice(0, found.index) + (!found.index || end2 == cur.length ? "" : " ") + cur.slice(end2) || null;
              }
              return true;
            });
          }),
          addLineWidget: docMethodOp(function(handle, node, options) {
            return addLineWidget(this, handle, node, options);
          }),
          removeLineWidget: function(widget) {
            widget.clear();
          },
          markText: function(from, to, options) {
            return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
          },
          setBookmark: function(pos, options) {
            var realOpts = {
              replacedWith: options && (options.nodeType == null ? options.widget : options),
              insertLeft: options && options.insertLeft,
              clearWhenEmpty: false,
              shared: options && options.shared,
              handleMouseEvents: options && options.handleMouseEvents
            };
            pos = clipPos(this, pos);
            return markText(this, pos, pos, realOpts, "bookmark");
          },
          findMarksAt: function(pos) {
            pos = clipPos(this, pos);
            var markers = [], spans = getLine(this, pos.line).markedSpans;
            if (spans) {
              for (var i3 = 0; i3 < spans.length; ++i3) {
                var span = spans[i3];
                if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
                  markers.push(span.marker.parent || span.marker);
                }
              }
            }
            return markers;
          },
          findMarks: function(from, to, filter2) {
            from = clipPos(this, from);
            to = clipPos(this, to);
            var found = [], lineNo2 = from.line;
            this.iter(from.line, to.line + 1, function(line) {
              var spans = line.markedSpans;
              if (spans) {
                for (var i3 = 0; i3 < spans.length; i3++) {
                  var span = spans[i3];
                  if (!(span.to != null && lineNo2 == from.line && from.ch >= span.to || span.from == null && lineNo2 != from.line || span.from != null && lineNo2 == to.line && span.from >= to.ch) && (!filter2 || filter2(span.marker))) {
                    found.push(span.marker.parent || span.marker);
                  }
                }
              }
              ++lineNo2;
            });
            return found;
          },
          getAllMarks: function() {
            var markers = [];
            this.iter(function(line) {
              var sps = line.markedSpans;
              if (sps) {
                for (var i3 = 0; i3 < sps.length; ++i3) {
                  if (sps[i3].from != null) {
                    markers.push(sps[i3].marker);
                  }
                }
              }
            });
            return markers;
          },
          posFromIndex: function(off2) {
            var ch, lineNo2 = this.first, sepSize = this.lineSeparator().length;
            this.iter(function(line) {
              var sz = line.text.length + sepSize;
              if (sz > off2) {
                ch = off2;
                return true;
              }
              off2 -= sz;
              ++lineNo2;
            });
            return clipPos(this, Pos(lineNo2, ch));
          },
          indexFromPos: function(coords) {
            coords = clipPos(this, coords);
            var index = coords.ch;
            if (coords.line < this.first || coords.ch < 0) {
              return 0;
            }
            var sepSize = this.lineSeparator().length;
            this.iter(this.first, coords.line, function(line) {
              index += line.text.length + sepSize;
            });
            return index;
          },
          copy: function(copyHistory) {
            var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
            doc.scrollTop = this.scrollTop;
            doc.scrollLeft = this.scrollLeft;
            doc.sel = this.sel;
            doc.extend = false;
            if (copyHistory) {
              doc.history.undoDepth = this.history.undoDepth;
              doc.setHistory(this.getHistory());
            }
            return doc;
          },
          linkedDoc: function(options) {
            if (!options) {
              options = {};
            }
            var from = this.first, to = this.first + this.size;
            if (options.from != null && options.from > from) {
              from = options.from;
            }
            if (options.to != null && options.to < to) {
              to = options.to;
            }
            var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
            if (options.sharedHist) {
              copy.history = this.history;
            }
            (this.linked || (this.linked = [])).push({ doc: copy, sharedHist: options.sharedHist });
            copy.linked = [{ doc: this, isParent: true, sharedHist: options.sharedHist }];
            copySharedMarkers(copy, findSharedMarkers(this));
            return copy;
          },
          unlinkDoc: function(other) {
            if (other instanceof CodeMirror3) {
              other = other.doc;
            }
            if (this.linked) {
              for (var i3 = 0; i3 < this.linked.length; ++i3) {
                var link = this.linked[i3];
                if (link.doc != other) {
                  continue;
                }
                this.linked.splice(i3, 1);
                other.unlinkDoc(this);
                detachSharedMarkers(findSharedMarkers(this));
                break;
              }
            }
            if (other.history == this.history) {
              var splitIds = [other.id];
              linkedDocs(other, function(doc) {
                return splitIds.push(doc.id);
              }, true);
              other.history = new History2(null);
              other.history.done = copyHistoryArray(this.history.done, splitIds);
              other.history.undone = copyHistoryArray(this.history.undone, splitIds);
            }
          },
          iterLinkedDocs: function(f2) {
            linkedDocs(this, f2);
          },
          getMode: function() {
            return this.mode;
          },
          getEditor: function() {
            return this.cm;
          },
          splitLines: function(str) {
            if (this.lineSep) {
              return str.split(this.lineSep);
            }
            return splitLinesAuto(str);
          },
          lineSeparator: function() {
            return this.lineSep || "\n";
          },
          setDirection: docMethodOp(function(dir) {
            if (dir != "rtl") {
              dir = "ltr";
            }
            if (dir == this.direction) {
              return;
            }
            this.direction = dir;
            this.iter(function(line) {
              return line.order = null;
            });
            if (this.cm) {
              directionChanged(this.cm);
            }
          })
        });
        Doc.prototype.eachLine = Doc.prototype.iter;
        var lastDrop = 0;
        function onDrop(e2) {
          var cm = this;
          clearDragCursor(cm);
          if (signalDOMEvent(cm, e2) || eventInWidget(cm.display, e2)) {
            return;
          }
          e_preventDefault(e2);
          if (ie) {
            lastDrop = +new Date();
          }
          var pos = posFromMouse(cm, e2, true), files = e2.dataTransfer.files;
          if (!pos || cm.isReadOnly()) {
            return;
          }
          if (files && files.length && window.FileReader && window.File) {
            var n2 = files.length, text = Array(n2), read2 = 0;
            var markAsReadAndPasteIfAllFilesAreRead = function() {
              if (++read2 == n2) {
                operation(cm, function() {
                  pos = clipPos(cm.doc, pos);
                  var change = {
                    from: pos,
                    to: pos,
                    text: cm.doc.splitLines(text.filter(function(t2) {
                      return t2 != null;
                    }).join(cm.doc.lineSeparator())),
                    origin: "paste"
                  };
                  makeChange(cm.doc, change);
                  setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
                })();
              }
            };
            var readTextFromFile = function(file, i4) {
              if (cm.options.allowDropFileTypes && indexOf2(cm.options.allowDropFileTypes, file.type) == -1) {
                markAsReadAndPasteIfAllFilesAreRead();
                return;
              }
              var reader = new FileReader();
              reader.onerror = function() {
                return markAsReadAndPasteIfAllFilesAreRead();
              };
              reader.onload = function() {
                var content = reader.result;
                if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
                  markAsReadAndPasteIfAllFilesAreRead();
                  return;
                }
                text[i4] = content;
                markAsReadAndPasteIfAllFilesAreRead();
              };
              reader.readAsText(file);
            };
            for (var i3 = 0; i3 < files.length; i3++) {
              readTextFromFile(files[i3], i3);
            }
          } else {
            if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
              cm.state.draggingText(e2);
              setTimeout(function() {
                return cm.display.input.focus();
              }, 20);
              return;
            }
            try {
              var text$1 = e2.dataTransfer.getData("Text");
              if (text$1) {
                var selected;
                if (cm.state.draggingText && !cm.state.draggingText.copy) {
                  selected = cm.listSelections();
                }
                setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
                if (selected) {
                  for (var i$12 = 0; i$12 < selected.length; ++i$12) {
                    replaceRange(cm.doc, "", selected[i$12].anchor, selected[i$12].head, "drag");
                  }
                }
                cm.replaceSelection(text$1, "around", "paste");
                cm.display.input.focus();
              }
            } catch (e$1) {
            }
          }
        }
        function onDragStart(cm, e2) {
          if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
            e_stop(e2);
            return;
          }
          if (signalDOMEvent(cm, e2) || eventInWidget(cm.display, e2)) {
            return;
          }
          e2.dataTransfer.setData("Text", cm.getSelection());
          e2.dataTransfer.effectAllowed = "copyMove";
          if (e2.dataTransfer.setDragImage && !safari) {
            var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
            img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
            if (presto) {
              img.width = img.height = 1;
              cm.display.wrapper.appendChild(img);
              img._top = img.offsetTop;
            }
            e2.dataTransfer.setDragImage(img, 0, 0);
            if (presto) {
              img.parentNode.removeChild(img);
            }
          }
        }
        function onDragOver(cm, e2) {
          var pos = posFromMouse(cm, e2);
          if (!pos) {
            return;
          }
          var frag = document.createDocumentFragment();
          drawSelectionCursor(cm, pos, frag);
          if (!cm.display.dragCursor) {
            cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
            cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
          }
          removeChildrenAndAdd(cm.display.dragCursor, frag);
        }
        function clearDragCursor(cm) {
          if (cm.display.dragCursor) {
            cm.display.lineSpace.removeChild(cm.display.dragCursor);
            cm.display.dragCursor = null;
          }
        }
        function forEachCodeMirror(f2) {
          if (!document.getElementsByClassName) {
            return;
          }
          var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
          for (var i3 = 0; i3 < byClass.length; i3++) {
            var cm = byClass[i3].CodeMirror;
            if (cm) {
              editors.push(cm);
            }
          }
          if (editors.length) {
            editors[0].operation(function() {
              for (var i4 = 0; i4 < editors.length; i4++) {
                f2(editors[i4]);
              }
            });
          }
        }
        var globalsRegistered = false;
        function ensureGlobalHandlers() {
          if (globalsRegistered) {
            return;
          }
          registerGlobalHandlers();
          globalsRegistered = true;
        }
        function registerGlobalHandlers() {
          var resizeTimer;
          on(window, "resize", function() {
            if (resizeTimer == null) {
              resizeTimer = setTimeout(function() {
                resizeTimer = null;
                forEachCodeMirror(onResize);
              }, 100);
            }
          });
          on(window, "blur", function() {
            return forEachCodeMirror(onBlur);
          });
        }
        function onResize(cm) {
          var d2 = cm.display;
          d2.cachedCharWidth = d2.cachedTextHeight = d2.cachedPaddingH = null;
          d2.scrollbarsClipped = false;
          cm.setSize();
        }
        var keyNames = {
          3: "Pause",
          8: "Backspace",
          9: "Tab",
          13: "Enter",
          16: "Shift",
          17: "Ctrl",
          18: "Alt",
          19: "Pause",
          20: "CapsLock",
          27: "Esc",
          32: "Space",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "Left",
          38: "Up",
          39: "Right",
          40: "Down",
          44: "PrintScrn",
          45: "Insert",
          46: "Delete",
          59: ";",
          61: "=",
          91: "Mod",
          92: "Mod",
          93: "Mod",
          106: "*",
          107: "=",
          109: "-",
          110: ".",
          111: "/",
          145: "ScrollLock",
          173: "-",
          186: ";",
          187: "=",
          188: ",",
          189: "-",
          190: ".",
          191: "/",
          192: "`",
          219: "[",
          220: "\\",
          221: "]",
          222: "'",
          224: "Mod",
          63232: "Up",
          63233: "Down",
          63234: "Left",
          63235: "Right",
          63272: "Delete",
          63273: "Home",
          63275: "End",
          63276: "PageUp",
          63277: "PageDown",
          63302: "Insert"
        };
        for (var i2 = 0; i2 < 10; i2++) {
          keyNames[i2 + 48] = keyNames[i2 + 96] = String(i2);
        }
        for (var i$1 = 65; i$1 <= 90; i$1++) {
          keyNames[i$1] = String.fromCharCode(i$1);
        }
        for (var i$2 = 1; i$2 <= 12; i$2++) {
          keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
        }
        var keyMap = {};
        keyMap.basic = {
          "Left": "goCharLeft",
          "Right": "goCharRight",
          "Up": "goLineUp",
          "Down": "goLineDown",
          "End": "goLineEnd",
          "Home": "goLineStartSmart",
          "PageUp": "goPageUp",
          "PageDown": "goPageDown",
          "Delete": "delCharAfter",
          "Backspace": "delCharBefore",
          "Shift-Backspace": "delCharBefore",
          "Tab": "defaultTab",
          "Shift-Tab": "indentAuto",
          "Enter": "newlineAndIndent",
          "Insert": "toggleOverwrite",
          "Esc": "singleSelection"
        };
        keyMap.pcDefault = {
          "Ctrl-A": "selectAll",
          "Ctrl-D": "deleteLine",
          "Ctrl-Z": "undo",
          "Shift-Ctrl-Z": "redo",
          "Ctrl-Y": "redo",
          "Ctrl-Home": "goDocStart",
          "Ctrl-End": "goDocEnd",
          "Ctrl-Up": "goLineUp",
          "Ctrl-Down": "goLineDown",
          "Ctrl-Left": "goGroupLeft",
          "Ctrl-Right": "goGroupRight",
          "Alt-Left": "goLineStart",
          "Alt-Right": "goLineEnd",
          "Ctrl-Backspace": "delGroupBefore",
          "Ctrl-Delete": "delGroupAfter",
          "Ctrl-S": "save",
          "Ctrl-F": "find",
          "Ctrl-G": "findNext",
          "Shift-Ctrl-G": "findPrev",
          "Shift-Ctrl-F": "replace",
          "Shift-Ctrl-R": "replaceAll",
          "Ctrl-[": "indentLess",
          "Ctrl-]": "indentMore",
          "Ctrl-U": "undoSelection",
          "Shift-Ctrl-U": "redoSelection",
          "Alt-U": "redoSelection",
          "fallthrough": "basic"
        };
        keyMap.emacsy = {
          "Ctrl-F": "goCharRight",
          "Ctrl-B": "goCharLeft",
          "Ctrl-P": "goLineUp",
          "Ctrl-N": "goLineDown",
          "Alt-F": "goWordRight",
          "Alt-B": "goWordLeft",
          "Ctrl-A": "goLineStart",
          "Ctrl-E": "goLineEnd",
          "Ctrl-V": "goPageDown",
          "Shift-Ctrl-V": "goPageUp",
          "Ctrl-D": "delCharAfter",
          "Ctrl-H": "delCharBefore",
          "Alt-D": "delWordAfter",
          "Alt-Backspace": "delWordBefore",
          "Ctrl-K": "killLine",
          "Ctrl-T": "transposeChars",
          "Ctrl-O": "openLine"
        };
        keyMap.macDefault = {
          "Cmd-A": "selectAll",
          "Cmd-D": "deleteLine",
          "Cmd-Z": "undo",
          "Shift-Cmd-Z": "redo",
          "Cmd-Y": "redo",
          "Cmd-Home": "goDocStart",
          "Cmd-Up": "goDocStart",
          "Cmd-End": "goDocEnd",
          "Cmd-Down": "goDocEnd",
          "Alt-Left": "goGroupLeft",
          "Alt-Right": "goGroupRight",
          "Cmd-Left": "goLineLeft",
          "Cmd-Right": "goLineRight",
          "Alt-Backspace": "delGroupBefore",
          "Ctrl-Alt-Backspace": "delGroupAfter",
          "Alt-Delete": "delGroupAfter",
          "Cmd-S": "save",
          "Cmd-F": "find",
          "Cmd-G": "findNext",
          "Shift-Cmd-G": "findPrev",
          "Cmd-Alt-F": "replace",
          "Shift-Cmd-Alt-F": "replaceAll",
          "Cmd-[": "indentLess",
          "Cmd-]": "indentMore",
          "Cmd-Backspace": "delWrappedLineLeft",
          "Cmd-Delete": "delWrappedLineRight",
          "Cmd-U": "undoSelection",
          "Shift-Cmd-U": "redoSelection",
          "Ctrl-Up": "goDocStart",
          "Ctrl-Down": "goDocEnd",
          "fallthrough": ["basic", "emacsy"]
        };
        keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
        function normalizeKeyName(name) {
          var parts = name.split(/-(?!$)/);
          name = parts[parts.length - 1];
          var alt, ctrl, shift, cmd;
          for (var i3 = 0; i3 < parts.length - 1; i3++) {
            var mod = parts[i3];
            if (/^(cmd|meta|m)$/i.test(mod)) {
              cmd = true;
            } else if (/^a(lt)?$/i.test(mod)) {
              alt = true;
            } else if (/^(c|ctrl|control)$/i.test(mod)) {
              ctrl = true;
            } else if (/^s(hift)?$/i.test(mod)) {
              shift = true;
            } else {
              throw new Error("Unrecognized modifier name: " + mod);
            }
          }
          if (alt) {
            name = "Alt-" + name;
          }
          if (ctrl) {
            name = "Ctrl-" + name;
          }
          if (cmd) {
            name = "Cmd-" + name;
          }
          if (shift) {
            name = "Shift-" + name;
          }
          return name;
        }
        function normalizeKeyMap(keymap) {
          var copy = {};
          for (var keyname in keymap) {
            if (keymap.hasOwnProperty(keyname)) {
              var value = keymap[keyname];
              if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
                continue;
              }
              if (value == "...") {
                delete keymap[keyname];
                continue;
              }
              var keys = map(keyname.split(" "), normalizeKeyName);
              for (var i3 = 0; i3 < keys.length; i3++) {
                var val = void 0, name = void 0;
                if (i3 == keys.length - 1) {
                  name = keys.join(" ");
                  val = value;
                } else {
                  name = keys.slice(0, i3 + 1).join(" ");
                  val = "...";
                }
                var prev = copy[name];
                if (!prev) {
                  copy[name] = val;
                } else if (prev != val) {
                  throw new Error("Inconsistent bindings for " + name);
                }
              }
              delete keymap[keyname];
            }
          }
          for (var prop2 in copy) {
            keymap[prop2] = copy[prop2];
          }
          return keymap;
        }
        function lookupKey(key, map2, handle, context) {
          map2 = getKeyMap(map2);
          var found = map2.call ? map2.call(key, context) : map2[key];
          if (found === false) {
            return "nothing";
          }
          if (found === "...") {
            return "multi";
          }
          if (found != null && handle(found)) {
            return "handled";
          }
          if (map2.fallthrough) {
            if (Object.prototype.toString.call(map2.fallthrough) != "[object Array]") {
              return lookupKey(key, map2.fallthrough, handle, context);
            }
            for (var i3 = 0; i3 < map2.fallthrough.length; i3++) {
              var result = lookupKey(key, map2.fallthrough[i3], handle, context);
              if (result) {
                return result;
              }
            }
          }
        }
        function isModifierKey(value) {
          var name = typeof value == "string" ? value : keyNames[value.keyCode];
          return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
        }
        function addModifierNames(name, event, noShift) {
          var base = name;
          if (event.altKey && base != "Alt") {
            name = "Alt-" + name;
          }
          if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") {
            name = "Ctrl-" + name;
          }
          if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Mod") {
            name = "Cmd-" + name;
          }
          if (!noShift && event.shiftKey && base != "Shift") {
            name = "Shift-" + name;
          }
          return name;
        }
        function keyName(event, noShift) {
          if (presto && event.keyCode == 34 && event["char"]) {
            return false;
          }
          var name = keyNames[event.keyCode];
          if (name == null || event.altGraphKey) {
            return false;
          }
          if (event.keyCode == 3 && event.code) {
            name = event.code;
          }
          return addModifierNames(name, event, noShift);
        }
        function getKeyMap(val) {
          return typeof val == "string" ? keyMap[val] : val;
        }
        function deleteNearSelection(cm, compute) {
          var ranges = cm.doc.sel.ranges, kill = [];
          for (var i3 = 0; i3 < ranges.length; i3++) {
            var toKill = compute(ranges[i3]);
            while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
              var replaced = kill.pop();
              if (cmp(replaced.from, toKill.from) < 0) {
                toKill.from = replaced.from;
                break;
              }
            }
            kill.push(toKill);
          }
          runInOp(cm, function() {
            for (var i4 = kill.length - 1; i4 >= 0; i4--) {
              replaceRange(cm.doc, "", kill[i4].from, kill[i4].to, "+delete");
            }
            ensureCursorVisible(cm);
          });
        }
        function moveCharLogically(line, ch, dir) {
          var target = skipExtendingChars(line.text, ch + dir, dir);
          return target < 0 || target > line.text.length ? null : target;
        }
        function moveLogically(line, start4, dir) {
          var ch = moveCharLogically(line, start4.ch, dir);
          return ch == null ? null : new Pos(start4.line, ch, dir < 0 ? "after" : "before");
        }
        function endOfLine(visually, cm, lineObj, lineNo2, dir) {
          if (visually) {
            if (cm.doc.direction == "rtl") {
              dir = -dir;
            }
            var order2 = getOrder(lineObj, cm.doc.direction);
            if (order2) {
              var part = dir < 0 ? lst(order2) : order2[0];
              var moveInStorageOrder = dir < 0 == (part.level == 1);
              var sticky = moveInStorageOrder ? "after" : "before";
              var ch;
              if (part.level > 0 || cm.doc.direction == "rtl") {
                var prep = prepareMeasureForLine(cm, lineObj);
                ch = dir < 0 ? lineObj.text.length - 1 : 0;
                var targetTop = measureCharPrepared(cm, prep, ch).top;
                ch = findFirst(function(ch2) {
                  return measureCharPrepared(cm, prep, ch2).top == targetTop;
                }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);
                if (sticky == "before") {
                  ch = moveCharLogically(lineObj, ch, 1);
                }
              } else {
                ch = dir < 0 ? part.to : part.from;
              }
              return new Pos(lineNo2, ch, sticky);
            }
          }
          return new Pos(lineNo2, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
        }
        function moveVisually(cm, line, start4, dir) {
          var bidi = getOrder(line, cm.doc.direction);
          if (!bidi) {
            return moveLogically(line, start4, dir);
          }
          if (start4.ch >= line.text.length) {
            start4.ch = line.text.length;
            start4.sticky = "before";
          } else if (start4.ch <= 0) {
            start4.ch = 0;
            start4.sticky = "after";
          }
          var partPos = getBidiPartAt(bidi, start4.ch, start4.sticky), part = bidi[partPos];
          if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start4.ch : part.from < start4.ch)) {
            return moveLogically(line, start4, dir);
          }
          var mv = function(pos, dir2) {
            return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir2);
          };
          var prep;
          var getWrappedLineExtent = function(ch2) {
            if (!cm.options.lineWrapping) {
              return { begin: 0, end: line.text.length };
            }
            prep = prep || prepareMeasureForLine(cm, line);
            return wrappedLineExtentChar(cm, line, prep, ch2);
          };
          var wrappedLineExtent2 = getWrappedLineExtent(start4.sticky == "before" ? mv(start4, -1) : start4.ch);
          if (cm.doc.direction == "rtl" || part.level == 1) {
            var moveInStorageOrder = part.level == 1 == dir < 0;
            var ch = mv(start4, moveInStorageOrder ? 1 : -1);
            if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent2.begin : ch <= part.to && ch <= wrappedLineExtent2.end)) {
              var sticky = moveInStorageOrder ? "before" : "after";
              return new Pos(start4.line, ch, sticky);
            }
          }
          var searchInVisualLine = function(partPos2, dir2, wrappedLineExtent3) {
            var getRes = function(ch3, moveInStorageOrder3) {
              return moveInStorageOrder3 ? new Pos(start4.line, mv(ch3, 1), "before") : new Pos(start4.line, ch3, "after");
            };
            for (; partPos2 >= 0 && partPos2 < bidi.length; partPos2 += dir2) {
              var part2 = bidi[partPos2];
              var moveInStorageOrder2 = dir2 > 0 == (part2.level != 1);
              var ch2 = moveInStorageOrder2 ? wrappedLineExtent3.begin : mv(wrappedLineExtent3.end, -1);
              if (part2.from <= ch2 && ch2 < part2.to) {
                return getRes(ch2, moveInStorageOrder2);
              }
              ch2 = moveInStorageOrder2 ? part2.from : mv(part2.to, -1);
              if (wrappedLineExtent3.begin <= ch2 && ch2 < wrappedLineExtent3.end) {
                return getRes(ch2, moveInStorageOrder2);
              }
            }
          };
          var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent2);
          if (res) {
            return res;
          }
          var nextCh = dir > 0 ? wrappedLineExtent2.end : mv(wrappedLineExtent2.begin, -1);
          if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
            res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
            if (res) {
              return res;
            }
          }
          return null;
        }
        var commands = {
          selectAll,
          singleSelection: function(cm) {
            return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
          },
          killLine: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              if (range2.empty()) {
                var len = getLine(cm.doc, range2.head.line).text.length;
                if (range2.head.ch == len && range2.head.line < cm.lastLine()) {
                  return { from: range2.head, to: Pos(range2.head.line + 1, 0) };
                } else {
                  return { from: range2.head, to: Pos(range2.head.line, len) };
                }
              } else {
                return { from: range2.from(), to: range2.to() };
              }
            });
          },
          deleteLine: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              return {
                from: Pos(range2.from().line, 0),
                to: clipPos(cm.doc, Pos(range2.to().line + 1, 0))
              };
            });
          },
          delLineLeft: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              return {
                from: Pos(range2.from().line, 0),
                to: range2.from()
              };
            });
          },
          delWrappedLineLeft: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              var top2 = cm.charCoords(range2.head, "div").top + 5;
              var leftPos = cm.coordsChar({ left: 0, top: top2 }, "div");
              return { from: leftPos, to: range2.from() };
            });
          },
          delWrappedLineRight: function(cm) {
            return deleteNearSelection(cm, function(range2) {
              var top2 = cm.charCoords(range2.head, "div").top + 5;
              var rightPos = cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top2 }, "div");
              return { from: range2.from(), to: rightPos };
            });
          },
          undo: function(cm) {
            return cm.undo();
          },
          redo: function(cm) {
            return cm.redo();
          },
          undoSelection: function(cm) {
            return cm.undoSelection();
          },
          redoSelection: function(cm) {
            return cm.redoSelection();
          },
          goDocStart: function(cm) {
            return cm.extendSelection(Pos(cm.firstLine(), 0));
          },
          goDocEnd: function(cm) {
            return cm.extendSelection(Pos(cm.lastLine()));
          },
          goLineStart: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              return lineStart(cm, range2.head.line);
            }, { origin: "+move", bias: 1 });
          },
          goLineStartSmart: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              return lineStartSmart(cm, range2.head);
            }, { origin: "+move", bias: 1 });
          },
          goLineEnd: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              return lineEnd(cm, range2.head.line);
            }, { origin: "+move", bias: -1 });
          },
          goLineRight: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              var top2 = cm.cursorCoords(range2.head, "div").top + 5;
              return cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top2 }, "div");
            }, sel_move);
          },
          goLineLeft: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              var top2 = cm.cursorCoords(range2.head, "div").top + 5;
              return cm.coordsChar({ left: 0, top: top2 }, "div");
            }, sel_move);
          },
          goLineLeftSmart: function(cm) {
            return cm.extendSelectionsBy(function(range2) {
              var top2 = cm.cursorCoords(range2.head, "div").top + 5;
              var pos = cm.coordsChar({ left: 0, top: top2 }, "div");
              if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
                return lineStartSmart(cm, range2.head);
              }
              return pos;
            }, sel_move);
          },
          goLineUp: function(cm) {
            return cm.moveV(-1, "line");
          },
          goLineDown: function(cm) {
            return cm.moveV(1, "line");
          },
          goPageUp: function(cm) {
            return cm.moveV(-1, "page");
          },
          goPageDown: function(cm) {
            return cm.moveV(1, "page");
          },
          goCharLeft: function(cm) {
            return cm.moveH(-1, "char");
          },
          goCharRight: function(cm) {
            return cm.moveH(1, "char");
          },
          goColumnLeft: function(cm) {
            return cm.moveH(-1, "column");
          },
          goColumnRight: function(cm) {
            return cm.moveH(1, "column");
          },
          goWordLeft: function(cm) {
            return cm.moveH(-1, "word");
          },
          goGroupRight: function(cm) {
            return cm.moveH(1, "group");
          },
          goGroupLeft: function(cm) {
            return cm.moveH(-1, "group");
          },
          goWordRight: function(cm) {
            return cm.moveH(1, "word");
          },
          delCharBefore: function(cm) {
            return cm.deleteH(-1, "codepoint");
          },
          delCharAfter: function(cm) {
            return cm.deleteH(1, "char");
          },
          delWordBefore: function(cm) {
            return cm.deleteH(-1, "word");
          },
          delWordAfter: function(cm) {
            return cm.deleteH(1, "word");
          },
          delGroupBefore: function(cm) {
            return cm.deleteH(-1, "group");
          },
          delGroupAfter: function(cm) {
            return cm.deleteH(1, "group");
          },
          indentAuto: function(cm) {
            return cm.indentSelection("smart");
          },
          indentMore: function(cm) {
            return cm.indentSelection("add");
          },
          indentLess: function(cm) {
            return cm.indentSelection("subtract");
          },
          insertTab: function(cm) {
            return cm.replaceSelection("	");
          },
          insertSoftTab: function(cm) {
            var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
            for (var i3 = 0; i3 < ranges.length; i3++) {
              var pos = ranges[i3].from();
              var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
              spaces.push(spaceStr(tabSize - col % tabSize));
            }
            cm.replaceSelections(spaces);
          },
          defaultTab: function(cm) {
            if (cm.somethingSelected()) {
              cm.indentSelection("add");
            } else {
              cm.execCommand("insertTab");
            }
          },
          transposeChars: function(cm) {
            return runInOp(cm, function() {
              var ranges = cm.listSelections(), newSel = [];
              for (var i3 = 0; i3 < ranges.length; i3++) {
                if (!ranges[i3].empty()) {
                  continue;
                }
                var cur = ranges[i3].head, line = getLine(cm.doc, cur.line).text;
                if (line) {
                  if (cur.ch == line.length) {
                    cur = new Pos(cur.line, cur.ch - 1);
                  }
                  if (cur.ch > 0) {
                    cur = new Pos(cur.line, cur.ch + 1);
                    cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
                  } else if (cur.line > cm.doc.first) {
                    var prev = getLine(cm.doc, cur.line - 1).text;
                    if (prev) {
                      cur = new Pos(cur.line, 1);
                      cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
                    }
                  }
                }
                newSel.push(new Range(cur, cur));
              }
              cm.setSelections(newSel);
            });
          },
          newlineAndIndent: function(cm) {
            return runInOp(cm, function() {
              var sels = cm.listSelections();
              for (var i3 = sels.length - 1; i3 >= 0; i3--) {
                cm.replaceRange(cm.doc.lineSeparator(), sels[i3].anchor, sels[i3].head, "+input");
              }
              sels = cm.listSelections();
              for (var i$12 = 0; i$12 < sels.length; i$12++) {
                cm.indentLine(sels[i$12].from().line, null, true);
              }
              ensureCursorVisible(cm);
            });
          },
          openLine: function(cm) {
            return cm.replaceSelection("\n", "start");
          },
          toggleOverwrite: function(cm) {
            return cm.toggleOverwrite();
          }
        };
        function lineStart(cm, lineN) {
          var line = getLine(cm.doc, lineN);
          var visual = visualLine(line);
          if (visual != line) {
            lineN = lineNo(visual);
          }
          return endOfLine(true, cm, visual, lineN, 1);
        }
        function lineEnd(cm, lineN) {
          var line = getLine(cm.doc, lineN);
          var visual = visualLineEnd(line);
          if (visual != line) {
            lineN = lineNo(visual);
          }
          return endOfLine(true, cm, line, lineN, -1);
        }
        function lineStartSmart(cm, pos) {
          var start4 = lineStart(cm, pos.line);
          var line = getLine(cm.doc, start4.line);
          var order2 = getOrder(line, cm.doc.direction);
          if (!order2 || order2[0].level == 0) {
            var firstNonWS = Math.max(start4.ch, line.text.search(/\S/));
            var inWS = pos.line == start4.line && pos.ch <= firstNonWS && pos.ch;
            return Pos(start4.line, inWS ? 0 : firstNonWS, start4.sticky);
          }
          return start4;
        }
        function doHandleBinding(cm, bound, dropShift) {
          if (typeof bound == "string") {
            bound = commands[bound];
            if (!bound) {
              return false;
            }
          }
          cm.display.input.ensurePolled();
          var prevShift = cm.display.shift, done = false;
          try {
            if (cm.isReadOnly()) {
              cm.state.suppressEdits = true;
            }
            if (dropShift) {
              cm.display.shift = false;
            }
            done = bound(cm) != Pass;
          } finally {
            cm.display.shift = prevShift;
            cm.state.suppressEdits = false;
          }
          return done;
        }
        function lookupKeyForEditor(cm, name, handle) {
          for (var i3 = 0; i3 < cm.state.keyMaps.length; i3++) {
            var result = lookupKey(name, cm.state.keyMaps[i3], handle, cm);
            if (result) {
              return result;
            }
          }
          return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
        }
        var stopSeq = new Delayed();
        function dispatchKey(cm, name, e2, handle) {
          var seq = cm.state.keySeq;
          if (seq) {
            if (isModifierKey(name)) {
              return "handled";
            }
            if (/\'$/.test(name)) {
              cm.state.keySeq = null;
            } else {
              stopSeq.set(50, function() {
                if (cm.state.keySeq == seq) {
                  cm.state.keySeq = null;
                  cm.display.input.reset();
                }
              });
            }
            if (dispatchKeyInner(cm, seq + " " + name, e2, handle)) {
              return true;
            }
          }
          return dispatchKeyInner(cm, name, e2, handle);
        }
        function dispatchKeyInner(cm, name, e2, handle) {
          var result = lookupKeyForEditor(cm, name, handle);
          if (result == "multi") {
            cm.state.keySeq = name;
          }
          if (result == "handled") {
            signalLater(cm, "keyHandled", cm, name, e2);
          }
          if (result == "handled" || result == "multi") {
            e_preventDefault(e2);
            restartBlink(cm);
          }
          return !!result;
        }
        function handleKeyBinding(cm, e2) {
          var name = keyName(e2, true);
          if (!name) {
            return false;
          }
          if (e2.shiftKey && !cm.state.keySeq) {
            return dispatchKey(cm, "Shift-" + name, e2, function(b2) {
              return doHandleBinding(cm, b2, true);
            }) || dispatchKey(cm, name, e2, function(b2) {
              if (typeof b2 == "string" ? /^go[A-Z]/.test(b2) : b2.motion) {
                return doHandleBinding(cm, b2);
              }
            });
          } else {
            return dispatchKey(cm, name, e2, function(b2) {
              return doHandleBinding(cm, b2);
            });
          }
        }
        function handleCharBinding(cm, e2, ch) {
          return dispatchKey(cm, "'" + ch + "'", e2, function(b2) {
            return doHandleBinding(cm, b2, true);
          });
        }
        var lastStoppedKey = null;
        function onKeyDown2(e2) {
          var cm = this;
          if (e2.target && e2.target != cm.display.input.getField()) {
            return;
          }
          cm.curOp.focus = activeElt();
          if (signalDOMEvent(cm, e2)) {
            return;
          }
          if (ie && ie_version < 11 && e2.keyCode == 27) {
            e2.returnValue = false;
          }
          var code3 = e2.keyCode;
          cm.display.shift = code3 == 16 || e2.shiftKey;
          var handled = handleKeyBinding(cm, e2);
          if (presto) {
            lastStoppedKey = handled ? code3 : null;
            if (!handled && code3 == 88 && !hasCopyEvent && (mac ? e2.metaKey : e2.ctrlKey)) {
              cm.replaceSelection("", null, "cut");
            }
          }
          if (gecko && !mac && !handled && code3 == 46 && e2.shiftKey && !e2.ctrlKey && document.execCommand) {
            document.execCommand("cut");
          }
          if (code3 == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
            showCrossHair(cm);
          }
        }
        function showCrossHair(cm) {
          var lineDiv = cm.display.lineDiv;
          addClass(lineDiv, "CodeMirror-crosshair");
          function up(e2) {
            if (e2.keyCode == 18 || !e2.altKey) {
              rmClass(lineDiv, "CodeMirror-crosshair");
              off(document, "keyup", up);
              off(document, "mouseover", up);
            }
          }
          on(document, "keyup", up);
          on(document, "mouseover", up);
        }
        function onKeyUp(e2) {
          if (e2.keyCode == 16) {
            this.doc.sel.shift = false;
          }
          signalDOMEvent(this, e2);
        }
        function onKeyPress(e2) {
          var cm = this;
          if (e2.target && e2.target != cm.display.input.getField()) {
            return;
          }
          if (eventInWidget(cm.display, e2) || signalDOMEvent(cm, e2) || e2.ctrlKey && !e2.altKey || mac && e2.metaKey) {
            return;
          }
          var keyCode = e2.keyCode, charCode = e2.charCode;
          if (presto && keyCode == lastStoppedKey) {
            lastStoppedKey = null;
            e_preventDefault(e2);
            return;
          }
          if (presto && (!e2.which || e2.which < 10) && handleKeyBinding(cm, e2)) {
            return;
          }
          var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
          if (ch == "\b") {
            return;
          }
          if (handleCharBinding(cm, e2, ch)) {
            return;
          }
          cm.display.input.onKeyPress(e2);
        }
        var DOUBLECLICK_DELAY = 400;
        var PastClick = function(time, pos, button) {
          this.time = time;
          this.pos = pos;
          this.button = button;
        };
        PastClick.prototype.compare = function(time, pos, button) {
          return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
        };
        var lastClick, lastDoubleClick;
        function clickRepeat(pos, button) {
          var now2 = +new Date();
          if (lastDoubleClick && lastDoubleClick.compare(now2, pos, button)) {
            lastClick = lastDoubleClick = null;
            return "triple";
          } else if (lastClick && lastClick.compare(now2, pos, button)) {
            lastDoubleClick = new PastClick(now2, pos, button);
            lastClick = null;
            return "double";
          } else {
            lastClick = new PastClick(now2, pos, button);
            lastDoubleClick = null;
            return "single";
          }
        }
        function onMouseDown(e2) {
          var cm = this, display = cm.display;
          if (signalDOMEvent(cm, e2) || display.activeTouch && display.input.supportsTouch()) {
            return;
          }
          display.input.ensurePolled();
          display.shift = e2.shiftKey;
          if (eventInWidget(display, e2)) {
            if (!webkit) {
              display.scroller.draggable = false;
              setTimeout(function() {
                return display.scroller.draggable = true;
              }, 100);
            }
            return;
          }
          if (clickInGutter(cm, e2)) {
            return;
          }
          var pos = posFromMouse(cm, e2), button = e_button(e2), repeat = pos ? clickRepeat(pos, button) : "single";
          window.focus();
          if (button == 1 && cm.state.selectingText) {
            cm.state.selectingText(e2);
          }
          if (pos && handleMappedButton(cm, button, pos, repeat, e2)) {
            return;
          }
          if (button == 1) {
            if (pos) {
              leftButtonDown(cm, pos, repeat, e2);
            } else if (e_target(e2) == display.scroller) {
              e_preventDefault(e2);
            }
          } else if (button == 2) {
            if (pos) {
              extendSelection(cm.doc, pos);
            }
            setTimeout(function() {
              return display.input.focus();
            }, 20);
          } else if (button == 3) {
            if (captureRightClick) {
              cm.display.input.onContextMenu(e2);
            } else {
              delayBlurEvent(cm);
            }
          }
        }
        function handleMappedButton(cm, button, pos, repeat, event) {
          var name = "Click";
          if (repeat == "double") {
            name = "Double" + name;
          } else if (repeat == "triple") {
            name = "Triple" + name;
          }
          name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;
          return dispatchKey(cm, addModifierNames(name, event), event, function(bound) {
            if (typeof bound == "string") {
              bound = commands[bound];
            }
            if (!bound) {
              return false;
            }
            var done = false;
            try {
              if (cm.isReadOnly()) {
                cm.state.suppressEdits = true;
              }
              done = bound(cm, pos) != Pass;
            } finally {
              cm.state.suppressEdits = false;
            }
            return done;
          });
        }
        function configureMouse(cm, repeat, event) {
          var option = cm.getOption("configureMouse");
          var value = option ? option(cm, repeat, event) : {};
          if (value.unit == null) {
            var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
            value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
          }
          if (value.extend == null || cm.doc.extend) {
            value.extend = cm.doc.extend || event.shiftKey;
          }
          if (value.addNew == null) {
            value.addNew = mac ? event.metaKey : event.ctrlKey;
          }
          if (value.moveOnDrag == null) {
            value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);
          }
          return value;
        }
        function leftButtonDown(cm, pos, repeat, event) {
          if (ie) {
            setTimeout(bind3(ensureFocus, cm), 0);
          } else {
            cm.curOp.focus = activeElt();
          }
          var behavior = configureMouse(cm, repeat, event);
          var sel = cm.doc.sel, contained;
          if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {
            leftButtonStartDrag(cm, event, pos, behavior);
          } else {
            leftButtonSelect(cm, event, pos, behavior);
          }
        }
        function leftButtonStartDrag(cm, event, pos, behavior) {
          var display = cm.display, moved = false;
          var dragEnd = operation(cm, function(e2) {
            if (webkit) {
              display.scroller.draggable = false;
            }
            cm.state.draggingText = false;
            if (cm.state.delayingBlurEvent) {
              if (cm.hasFocus()) {
                cm.state.delayingBlurEvent = false;
              } else {
                delayBlurEvent(cm);
              }
            }
            off(display.wrapper.ownerDocument, "mouseup", dragEnd);
            off(display.wrapper.ownerDocument, "mousemove", mouseMove);
            off(display.scroller, "dragstart", dragStart);
            off(display.scroller, "drop", dragEnd);
            if (!moved) {
              e_preventDefault(e2);
              if (!behavior.addNew) {
                extendSelection(cm.doc, pos, null, null, behavior.extend);
              }
              if (webkit && !safari || ie && ie_version == 9) {
                setTimeout(function() {
                  display.wrapper.ownerDocument.body.focus({ preventScroll: true });
                  display.input.focus();
                }, 20);
              } else {
                display.input.focus();
              }
            }
          });
          var mouseMove = function(e2) {
            moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
          };
          var dragStart = function() {
            return moved = true;
          };
          if (webkit) {
            display.scroller.draggable = true;
          }
          cm.state.draggingText = dragEnd;
          dragEnd.copy = !behavior.moveOnDrag;
          on(display.wrapper.ownerDocument, "mouseup", dragEnd);
          on(display.wrapper.ownerDocument, "mousemove", mouseMove);
          on(display.scroller, "dragstart", dragStart);
          on(display.scroller, "drop", dragEnd);
          cm.state.delayingBlurEvent = true;
          setTimeout(function() {
            return display.input.focus();
          }, 20);
          if (display.scroller.dragDrop) {
            display.scroller.dragDrop();
          }
        }
        function rangeForUnit(cm, pos, unit) {
          if (unit == "char") {
            return new Range(pos, pos);
          }
          if (unit == "word") {
            return cm.findWordAt(pos);
          }
          if (unit == "line") {
            return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
          }
          var result = unit(cm, pos);
          return new Range(result.from, result.to);
        }
        function leftButtonSelect(cm, event, start4, behavior) {
          if (ie) {
            delayBlurEvent(cm);
          }
          var display = cm.display, doc = cm.doc;
          e_preventDefault(event);
          var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
          if (behavior.addNew && !behavior.extend) {
            ourIndex = doc.sel.contains(start4);
            if (ourIndex > -1) {
              ourRange = ranges[ourIndex];
            } else {
              ourRange = new Range(start4, start4);
            }
          } else {
            ourRange = doc.sel.primary();
            ourIndex = doc.sel.primIndex;
          }
          if (behavior.unit == "rectangle") {
            if (!behavior.addNew) {
              ourRange = new Range(start4, start4);
            }
            start4 = posFromMouse(cm, event, true, true);
            ourIndex = -1;
          } else {
            var range2 = rangeForUnit(cm, start4, behavior.unit);
            if (behavior.extend) {
              ourRange = extendRange(ourRange, range2.anchor, range2.head, behavior.extend);
            } else {
              ourRange = range2;
            }
          }
          if (!behavior.addNew) {
            ourIndex = 0;
            setSelection(doc, new Selection([ourRange], 0), sel_mouse);
            startSel = doc.sel;
          } else if (ourIndex == -1) {
            ourIndex = ranges.length;
            setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex), { scroll: false, origin: "*mouse" });
          } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
            setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), { scroll: false, origin: "*mouse" });
            startSel = doc.sel;
          } else {
            replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
          }
          var lastPos = start4;
          function extendTo(pos) {
            if (cmp(lastPos, pos) == 0) {
              return;
            }
            lastPos = pos;
            if (behavior.unit == "rectangle") {
              var ranges2 = [], tabSize = cm.options.tabSize;
              var startCol = countColumn(getLine(doc, start4.line).text, start4.ch, tabSize);
              var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
              var left2 = Math.min(startCol, posCol), right2 = Math.max(startCol, posCol);
              for (var line = Math.min(start4.line, pos.line), end2 = Math.min(cm.lastLine(), Math.max(start4.line, pos.line)); line <= end2; line++) {
                var text = getLine(doc, line).text, leftPos = findColumn(text, left2, tabSize);
                if (left2 == right2) {
                  ranges2.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
                } else if (text.length > leftPos) {
                  ranges2.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right2, tabSize))));
                }
              }
              if (!ranges2.length) {
                ranges2.push(new Range(start4, start4));
              }
              setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges2), ourIndex), { origin: "*mouse", scroll: false });
              cm.scrollIntoView(pos);
            } else {
              var oldRange = ourRange;
              var range3 = rangeForUnit(cm, pos, behavior.unit);
              var anchor = oldRange.anchor, head;
              if (cmp(range3.anchor, anchor) > 0) {
                head = range3.head;
                anchor = minPos(oldRange.from(), range3.anchor);
              } else {
                head = range3.anchor;
                anchor = maxPos(oldRange.to(), range3.head);
              }
              var ranges$1 = startSel.ranges.slice(0);
              ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
              setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
            }
          }
          var editorSize = display.wrapper.getBoundingClientRect();
          var counter = 0;
          function extend3(e2) {
            var curCount = ++counter;
            var cur = posFromMouse(cm, e2, true, behavior.unit == "rectangle");
            if (!cur) {
              return;
            }
            if (cmp(cur, lastPos) != 0) {
              cm.curOp.focus = activeElt();
              extendTo(cur);
              var visible = visibleLines(display, doc);
              if (cur.line >= visible.to || cur.line < visible.from) {
                setTimeout(operation(cm, function() {
                  if (counter == curCount) {
                    extend3(e2);
                  }
                }), 150);
              }
            } else {
              var outside = e2.clientY < editorSize.top ? -20 : e2.clientY > editorSize.bottom ? 20 : 0;
              if (outside) {
                setTimeout(operation(cm, function() {
                  if (counter != curCount) {
                    return;
                  }
                  display.scroller.scrollTop += outside;
                  extend3(e2);
                }), 50);
              }
            }
          }
          function done(e2) {
            cm.state.selectingText = false;
            counter = Infinity;
            if (e2) {
              e_preventDefault(e2);
              display.input.focus();
            }
            off(display.wrapper.ownerDocument, "mousemove", move);
            off(display.wrapper.ownerDocument, "mouseup", up);
            doc.history.lastSelOrigin = null;
          }
          var move = operation(cm, function(e2) {
            if (e2.buttons === 0 || !e_button(e2)) {
              done(e2);
            } else {
              extend3(e2);
            }
          });
          var up = operation(cm, done);
          cm.state.selectingText = up;
          on(display.wrapper.ownerDocument, "mousemove", move);
          on(display.wrapper.ownerDocument, "mouseup", up);
        }
        function bidiSimplify(cm, range2) {
          var anchor = range2.anchor;
          var head = range2.head;
          var anchorLine = getLine(cm.doc, anchor.line);
          if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
            return range2;
          }
          var order2 = getOrder(anchorLine);
          if (!order2) {
            return range2;
          }
          var index = getBidiPartAt(order2, anchor.ch, anchor.sticky), part = order2[index];
          if (part.from != anchor.ch && part.to != anchor.ch) {
            return range2;
          }
          var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);
          if (boundary == 0 || boundary == order2.length) {
            return range2;
          }
          var leftSide;
          if (head.line != anchor.line) {
            leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
          } else {
            var headIndex = getBidiPartAt(order2, head.ch, head.sticky);
            var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
            if (headIndex == boundary - 1 || headIndex == boundary) {
              leftSide = dir < 0;
            } else {
              leftSide = dir > 0;
            }
          }
          var usePart = order2[boundary + (leftSide ? -1 : 0)];
          var from = leftSide == (usePart.level == 1);
          var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
          return anchor.ch == ch && anchor.sticky == sticky ? range2 : new Range(new Pos(anchor.line, ch, sticky), head);
        }
        function gutterEvent(cm, e2, type, prevent) {
          var mX, mY;
          if (e2.touches) {
            mX = e2.touches[0].clientX;
            mY = e2.touches[0].clientY;
          } else {
            try {
              mX = e2.clientX;
              mY = e2.clientY;
            } catch (e$1) {
              return false;
            }
          }
          if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
            return false;
          }
          if (prevent) {
            e_preventDefault(e2);
          }
          var display = cm.display;
          var lineBox = display.lineDiv.getBoundingClientRect();
          if (mY > lineBox.bottom || !hasHandler(cm, type)) {
            return e_defaultPrevented(e2);
          }
          mY -= lineBox.top - display.viewOffset;
          for (var i3 = 0; i3 < cm.display.gutterSpecs.length; ++i3) {
            var g2 = display.gutters.childNodes[i3];
            if (g2 && g2.getBoundingClientRect().right >= mX) {
              var line = lineAtHeight(cm.doc, mY);
              var gutter = cm.display.gutterSpecs[i3];
              signal(cm, type, cm, line, gutter.className, e2);
              return e_defaultPrevented(e2);
            }
          }
        }
        function clickInGutter(cm, e2) {
          return gutterEvent(cm, e2, "gutterClick", true);
        }
        function onContextMenu(cm, e2) {
          if (eventInWidget(cm.display, e2) || contextMenuInGutter(cm, e2)) {
            return;
          }
          if (signalDOMEvent(cm, e2, "contextmenu")) {
            return;
          }
          if (!captureRightClick) {
            cm.display.input.onContextMenu(e2);
          }
        }
        function contextMenuInGutter(cm, e2) {
          if (!hasHandler(cm, "gutterContextMenu")) {
            return false;
          }
          return gutterEvent(cm, e2, "gutterContextMenu", false);
        }
        function themeChanged(cm) {
          cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
          clearCaches(cm);
        }
        var Init = { toString: function() {
          return "CodeMirror.Init";
        } };
        var defaults2 = {};
        var optionHandlers = {};
        function defineOptions(CodeMirror4) {
          var optionHandlers2 = CodeMirror4.optionHandlers;
          function option(name, deflt, handle, notOnInit) {
            CodeMirror4.defaults[name] = deflt;
            if (handle) {
              optionHandlers2[name] = notOnInit ? function(cm, val, old) {
                if (old != Init) {
                  handle(cm, val, old);
                }
              } : handle;
            }
          }
          CodeMirror4.defineOption = option;
          CodeMirror4.Init = Init;
          option("value", "", function(cm, val) {
            return cm.setValue(val);
          }, true);
          option("mode", null, function(cm, val) {
            cm.doc.modeOption = val;
            loadMode(cm);
          }, true);
          option("indentUnit", 2, loadMode, true);
          option("indentWithTabs", false);
          option("smartIndent", true);
          option("tabSize", 4, function(cm) {
            resetModeState(cm);
            clearCaches(cm);
            regChange(cm);
          }, true);
          option("lineSeparator", null, function(cm, val) {
            cm.doc.lineSep = val;
            if (!val) {
              return;
            }
            var newBreaks = [], lineNo2 = cm.doc.first;
            cm.doc.iter(function(line) {
              for (var pos = 0; ; ) {
                var found = line.text.indexOf(val, pos);
                if (found == -1) {
                  break;
                }
                pos = found + val.length;
                newBreaks.push(Pos(lineNo2, found));
              }
              lineNo2++;
            });
            for (var i3 = newBreaks.length - 1; i3 >= 0; i3--) {
              replaceRange(cm.doc, val, newBreaks[i3], Pos(newBreaks[i3].line, newBreaks[i3].ch + val.length));
            }
          });
          option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200c\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function(cm, val, old) {
            cm.state.specialChars = new RegExp(val.source + (val.test("	") ? "" : "|	"), "g");
            if (old != Init) {
              cm.refresh();
            }
          });
          option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
            return cm.refresh();
          }, true);
          option("electricChars", true);
          option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
            throw new Error("inputStyle can not (yet) be changed in a running editor");
          }, true);
          option("spellcheck", false, function(cm, val) {
            return cm.getInputField().spellcheck = val;
          }, true);
          option("autocorrect", false, function(cm, val) {
            return cm.getInputField().autocorrect = val;
          }, true);
          option("autocapitalize", false, function(cm, val) {
            return cm.getInputField().autocapitalize = val;
          }, true);
          option("rtlMoveVisually", !windows);
          option("wholeLineUpdateBefore", true);
          option("theme", "default", function(cm) {
            themeChanged(cm);
            updateGutters(cm);
          }, true);
          option("keyMap", "default", function(cm, val, old) {
            var next = getKeyMap(val);
            var prev = old != Init && getKeyMap(old);
            if (prev && prev.detach) {
              prev.detach(cm, next);
            }
            if (next.attach) {
              next.attach(cm, prev || null);
            }
          });
          option("extraKeys", null);
          option("configureMouse", null);
          option("lineWrapping", false, wrappingChanged, true);
          option("gutters", [], function(cm, val) {
            cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
            updateGutters(cm);
          }, true);
          option("fixedGutter", true, function(cm, val) {
            cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
            cm.refresh();
          }, true);
          option("coverGutterNextToScrollbar", false, function(cm) {
            return updateScrollbars(cm);
          }, true);
          option("scrollbarStyle", "native", function(cm) {
            initScrollbars(cm);
            updateScrollbars(cm);
            cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
            cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
          }, true);
          option("lineNumbers", false, function(cm, val) {
            cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
            updateGutters(cm);
          }, true);
          option("firstLineNumber", 1, updateGutters, true);
          option("lineNumberFormatter", function(integer) {
            return integer;
          }, updateGutters, true);
          option("showCursorWhenSelecting", false, updateSelection, true);
          option("resetSelectionOnContextMenu", true);
          option("lineWiseCopyCut", true);
          option("pasteLinesPerSelection", true);
          option("selectionsMayTouch", false);
          option("readOnly", false, function(cm, val) {
            if (val == "nocursor") {
              onBlur(cm);
              cm.display.input.blur();
            }
            cm.display.input.readOnlyChanged(val);
          });
          option("screenReaderLabel", null, function(cm, val) {
            val = val === "" ? null : val;
            cm.display.input.screenReaderLabelChanged(val);
          });
          option("disableInput", false, function(cm, val) {
            if (!val) {
              cm.display.input.reset();
            }
          }, true);
          option("dragDrop", true, dragDropChanged);
          option("allowDropFileTypes", null);
          option("cursorBlinkRate", 530);
          option("cursorScrollMargin", 0);
          option("cursorHeight", 1, updateSelection, true);
          option("singleCursorHeightPerLine", true, updateSelection, true);
          option("workTime", 100);
          option("workDelay", 100);
          option("flattenSpans", true, resetModeState, true);
          option("addModeClass", false, resetModeState, true);
          option("pollInterval", 100);
          option("undoDepth", 200, function(cm, val) {
            return cm.doc.history.undoDepth = val;
          });
          option("historyEventDelay", 1250);
          option("viewportMargin", 10, function(cm) {
            return cm.refresh();
          }, true);
          option("maxHighlightLength", 1e4, resetModeState, true);
          option("moveInputWithCursor", true, function(cm, val) {
            if (!val) {
              cm.display.input.resetPosition();
            }
          });
          option("tabindex", null, function(cm, val) {
            return cm.display.input.getField().tabIndex = val || "";
          });
          option("autofocus", null);
          option("direction", "ltr", function(cm, val) {
            return cm.doc.setDirection(val);
          }, true);
          option("phrases", null);
        }
        function dragDropChanged(cm, value, old) {
          var wasOn = old && old != Init;
          if (!value != !wasOn) {
            var funcs = cm.display.dragFunctions;
            var toggle = value ? on : off;
            toggle(cm.display.scroller, "dragstart", funcs.start);
            toggle(cm.display.scroller, "dragenter", funcs.enter);
            toggle(cm.display.scroller, "dragover", funcs.over);
            toggle(cm.display.scroller, "dragleave", funcs.leave);
            toggle(cm.display.scroller, "drop", funcs.drop);
          }
        }
        function wrappingChanged(cm) {
          if (cm.options.lineWrapping) {
            addClass(cm.display.wrapper, "CodeMirror-wrap");
            cm.display.sizer.style.minWidth = "";
            cm.display.sizerWidth = null;
          } else {
            rmClass(cm.display.wrapper, "CodeMirror-wrap");
            findMaxLine(cm);
          }
          estimateLineHeights(cm);
          regChange(cm);
          clearCaches(cm);
          setTimeout(function() {
            return updateScrollbars(cm);
          }, 100);
        }
        function CodeMirror3(place, options) {
          var this$1 = this;
          if (!(this instanceof CodeMirror3)) {
            return new CodeMirror3(place, options);
          }
          this.options = options = options ? copyObj(options) : {};
          copyObj(defaults2, options, false);
          var doc = options.value;
          if (typeof doc == "string") {
            doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction);
          } else if (options.mode) {
            doc.modeOption = options.mode;
          }
          this.doc = doc;
          var input = new CodeMirror3.inputStyles[options.inputStyle](this);
          var display = this.display = new Display(place, doc, input, options);
          display.wrapper.CodeMirror = this;
          themeChanged(this);
          if (options.lineWrapping) {
            this.display.wrapper.className += " CodeMirror-wrap";
          }
          initScrollbars(this);
          this.state = {
            keyMaps: [],
            overlays: [],
            modeGen: 0,
            overwrite: false,
            delayingBlurEvent: false,
            focused: false,
            suppressEdits: false,
            pasteIncoming: -1,
            cutIncoming: -1,
            selectingText: false,
            draggingText: false,
            highlight: new Delayed(),
            keySeq: null,
            specialChars: null
          };
          if (options.autofocus && !mobile) {
            display.input.focus();
          }
          if (ie && ie_version < 11) {
            setTimeout(function() {
              return this$1.display.input.reset(true);
            }, 20);
          }
          registerEventHandlers(this);
          ensureGlobalHandlers();
          startOperation(this);
          this.curOp.forceUpdate = true;
          attachDoc(this, doc);
          if (options.autofocus && !mobile || this.hasFocus()) {
            setTimeout(function() {
              if (this$1.hasFocus() && !this$1.state.focused) {
                onFocus(this$1);
              }
            }, 20);
          } else {
            onBlur(this);
          }
          for (var opt in optionHandlers) {
            if (optionHandlers.hasOwnProperty(opt)) {
              optionHandlers[opt](this, options[opt], Init);
            }
          }
          maybeUpdateLineNumberWidth(this);
          if (options.finishInit) {
            options.finishInit(this);
          }
          for (var i3 = 0; i3 < initHooks.length; ++i3) {
            initHooks[i3](this);
          }
          endOperation(this);
          if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
            display.lineDiv.style.textRendering = "auto";
          }
        }
        CodeMirror3.defaults = defaults2;
        CodeMirror3.optionHandlers = optionHandlers;
        function registerEventHandlers(cm) {
          var d2 = cm.display;
          on(d2.scroller, "mousedown", operation(cm, onMouseDown));
          if (ie && ie_version < 11) {
            on(d2.scroller, "dblclick", operation(cm, function(e2) {
              if (signalDOMEvent(cm, e2)) {
                return;
              }
              var pos = posFromMouse(cm, e2);
              if (!pos || clickInGutter(cm, e2) || eventInWidget(cm.display, e2)) {
                return;
              }
              e_preventDefault(e2);
              var word = cm.findWordAt(pos);
              extendSelection(cm.doc, word.anchor, word.head);
            }));
          } else {
            on(d2.scroller, "dblclick", function(e2) {
              return signalDOMEvent(cm, e2) || e_preventDefault(e2);
            });
          }
          on(d2.scroller, "contextmenu", function(e2) {
            return onContextMenu(cm, e2);
          });
          on(d2.input.getField(), "contextmenu", function(e2) {
            if (!d2.scroller.contains(e2.target)) {
              onContextMenu(cm, e2);
            }
          });
          var touchFinished, prevTouch = { end: 0 };
          function finishTouch() {
            if (d2.activeTouch) {
              touchFinished = setTimeout(function() {
                return d2.activeTouch = null;
              }, 1e3);
              prevTouch = d2.activeTouch;
              prevTouch.end = +new Date();
            }
          }
          function isMouseLikeTouchEvent(e2) {
            if (e2.touches.length != 1) {
              return false;
            }
            var touch = e2.touches[0];
            return touch.radiusX <= 1 && touch.radiusY <= 1;
          }
          function farAway(touch, other) {
            if (other.left == null) {
              return true;
            }
            var dx = other.left - touch.left, dy = other.top - touch.top;
            return dx * dx + dy * dy > 20 * 20;
          }
          on(d2.scroller, "touchstart", function(e2) {
            if (!signalDOMEvent(cm, e2) && !isMouseLikeTouchEvent(e2) && !clickInGutter(cm, e2)) {
              d2.input.ensurePolled();
              clearTimeout(touchFinished);
              var now2 = +new Date();
              d2.activeTouch = {
                start: now2,
                moved: false,
                prev: now2 - prevTouch.end <= 300 ? prevTouch : null
              };
              if (e2.touches.length == 1) {
                d2.activeTouch.left = e2.touches[0].pageX;
                d2.activeTouch.top = e2.touches[0].pageY;
              }
            }
          });
          on(d2.scroller, "touchmove", function() {
            if (d2.activeTouch) {
              d2.activeTouch.moved = true;
            }
          });
          on(d2.scroller, "touchend", function(e2) {
            var touch = d2.activeTouch;
            if (touch && !eventInWidget(d2, e2) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {
              var pos = cm.coordsChar(d2.activeTouch, "page"), range2;
              if (!touch.prev || farAway(touch, touch.prev)) {
                range2 = new Range(pos, pos);
              } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) {
                range2 = cm.findWordAt(pos);
              } else {
                range2 = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
              }
              cm.setSelection(range2.anchor, range2.head);
              cm.focus();
              e_preventDefault(e2);
            }
            finishTouch();
          });
          on(d2.scroller, "touchcancel", finishTouch);
          on(d2.scroller, "scroll", function() {
            if (d2.scroller.clientHeight) {
              updateScrollTop(cm, d2.scroller.scrollTop);
              setScrollLeft(cm, d2.scroller.scrollLeft, true);
              signal(cm, "scroll", cm);
            }
          });
          on(d2.scroller, "mousewheel", function(e2) {
            return onScrollWheel(cm, e2);
          });
          on(d2.scroller, "DOMMouseScroll", function(e2) {
            return onScrollWheel(cm, e2);
          });
          on(d2.wrapper, "scroll", function() {
            return d2.wrapper.scrollTop = d2.wrapper.scrollLeft = 0;
          });
          d2.dragFunctions = {
            enter: function(e2) {
              if (!signalDOMEvent(cm, e2)) {
                e_stop(e2);
              }
            },
            over: function(e2) {
              if (!signalDOMEvent(cm, e2)) {
                onDragOver(cm, e2);
                e_stop(e2);
              }
            },
            start: function(e2) {
              return onDragStart(cm, e2);
            },
            drop: operation(cm, onDrop),
            leave: function(e2) {
              if (!signalDOMEvent(cm, e2)) {
                clearDragCursor(cm);
              }
            }
          };
          var inp = d2.input.getField();
          on(inp, "keyup", function(e2) {
            return onKeyUp.call(cm, e2);
          });
          on(inp, "keydown", operation(cm, onKeyDown2));
          on(inp, "keypress", operation(cm, onKeyPress));
          on(inp, "focus", function(e2) {
            return onFocus(cm, e2);
          });
          on(inp, "blur", function(e2) {
            return onBlur(cm, e2);
          });
        }
        var initHooks = [];
        CodeMirror3.defineInitHook = function(f2) {
          return initHooks.push(f2);
        };
        function indentLine(cm, n2, how, aggressive) {
          var doc = cm.doc, state;
          if (how == null) {
            how = "add";
          }
          if (how == "smart") {
            if (!doc.mode.indent) {
              how = "prev";
            } else {
              state = getContextBefore(cm, n2).state;
            }
          }
          var tabSize = cm.options.tabSize;
          var line = getLine(doc, n2), curSpace = countColumn(line.text, null, tabSize);
          if (line.stateAfter) {
            line.stateAfter = null;
          }
          var curSpaceString = line.text.match(/^\s*/)[0], indentation;
          if (!aggressive && !/\S/.test(line.text)) {
            indentation = 0;
            how = "not";
          } else if (how == "smart") {
            indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
            if (indentation == Pass || indentation > 150) {
              if (!aggressive) {
                return;
              }
              how = "prev";
            }
          }
          if (how == "prev") {
            if (n2 > doc.first) {
              indentation = countColumn(getLine(doc, n2 - 1).text, null, tabSize);
            } else {
              indentation = 0;
            }
          } else if (how == "add") {
            indentation = curSpace + cm.options.indentUnit;
          } else if (how == "subtract") {
            indentation = curSpace - cm.options.indentUnit;
          } else if (typeof how == "number") {
            indentation = curSpace + how;
          }
          indentation = Math.max(0, indentation);
          var indentString = "", pos = 0;
          if (cm.options.indentWithTabs) {
            for (var i3 = Math.floor(indentation / tabSize); i3; --i3) {
              pos += tabSize;
              indentString += "	";
            }
          }
          if (pos < indentation) {
            indentString += spaceStr(indentation - pos);
          }
          if (indentString != curSpaceString) {
            replaceRange(doc, indentString, Pos(n2, 0), Pos(n2, curSpaceString.length), "+input");
            line.stateAfter = null;
            return true;
          } else {
            for (var i$12 = 0; i$12 < doc.sel.ranges.length; i$12++) {
              var range2 = doc.sel.ranges[i$12];
              if (range2.head.line == n2 && range2.head.ch < curSpaceString.length) {
                var pos$1 = Pos(n2, curSpaceString.length);
                replaceOneSelection(doc, i$12, new Range(pos$1, pos$1));
                break;
              }
            }
          }
        }
        var lastCopied = null;
        function setLastCopied(newLastCopied) {
          lastCopied = newLastCopied;
        }
        function applyTextInput(cm, inserted, deleted, sel, origin) {
          var doc = cm.doc;
          cm.display.shift = false;
          if (!sel) {
            sel = doc.sel;
          }
          var recent = +new Date() - 200;
          var paste = origin == "paste" || cm.state.pasteIncoming > recent;
          var textLines = splitLinesAuto(inserted), multiPaste = null;
          if (paste && sel.ranges.length > 1) {
            if (lastCopied && lastCopied.text.join("\n") == inserted) {
              if (sel.ranges.length % lastCopied.text.length == 0) {
                multiPaste = [];
                for (var i3 = 0; i3 < lastCopied.text.length; i3++) {
                  multiPaste.push(doc.splitLines(lastCopied.text[i3]));
                }
              }
            } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
              multiPaste = map(textLines, function(l2) {
                return [l2];
              });
            }
          }
          var updateInput = cm.curOp.updateInput;
          for (var i$12 = sel.ranges.length - 1; i$12 >= 0; i$12--) {
            var range2 = sel.ranges[i$12];
            var from = range2.from(), to = range2.to();
            if (range2.empty()) {
              if (deleted && deleted > 0) {
                from = Pos(from.line, from.ch - deleted);
              } else if (cm.state.overwrite && !paste) {
                to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
              } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n")) {
                from = to = Pos(from.line, 0);
              }
            }
            var changeEvent = {
              from,
              to,
              text: multiPaste ? multiPaste[i$12 % multiPaste.length] : textLines,
              origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")
            };
            makeChange(cm.doc, changeEvent);
            signalLater(cm, "inputRead", cm, changeEvent);
          }
          if (inserted && !paste) {
            triggerElectric(cm, inserted);
          }
          ensureCursorVisible(cm);
          if (cm.curOp.updateInput < 2) {
            cm.curOp.updateInput = updateInput;
          }
          cm.curOp.typing = true;
          cm.state.pasteIncoming = cm.state.cutIncoming = -1;
        }
        function handlePaste(e2, cm) {
          var pasted = e2.clipboardData && e2.clipboardData.getData("Text");
          if (pasted) {
            e2.preventDefault();
            if (!cm.isReadOnly() && !cm.options.disableInput) {
              runInOp(cm, function() {
                return applyTextInput(cm, pasted, 0, null, "paste");
              });
            }
            return true;
          }
        }
        function triggerElectric(cm, inserted) {
          if (!cm.options.electricChars || !cm.options.smartIndent) {
            return;
          }
          var sel = cm.doc.sel;
          for (var i3 = sel.ranges.length - 1; i3 >= 0; i3--) {
            var range2 = sel.ranges[i3];
            if (range2.head.ch > 100 || i3 && sel.ranges[i3 - 1].head.line == range2.head.line) {
              continue;
            }
            var mode = cm.getModeAt(range2.head);
            var indented = false;
            if (mode.electricChars) {
              for (var j2 = 0; j2 < mode.electricChars.length; j2++) {
                if (inserted.indexOf(mode.electricChars.charAt(j2)) > -1) {
                  indented = indentLine(cm, range2.head.line, "smart");
                  break;
                }
              }
            } else if (mode.electricInput) {
              if (mode.electricInput.test(getLine(cm.doc, range2.head.line).text.slice(0, range2.head.ch))) {
                indented = indentLine(cm, range2.head.line, "smart");
              }
            }
            if (indented) {
              signalLater(cm, "electricInput", cm, range2.head.line);
            }
          }
        }
        function copyableRanges(cm) {
          var text = [], ranges = [];
          for (var i3 = 0; i3 < cm.doc.sel.ranges.length; i3++) {
            var line = cm.doc.sel.ranges[i3].head.line;
            var lineRange = { anchor: Pos(line, 0), head: Pos(line + 1, 0) };
            ranges.push(lineRange);
            text.push(cm.getRange(lineRange.anchor, lineRange.head));
          }
          return { text, ranges };
        }
        function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
          field.setAttribute("autocorrect", autocorrect ? "" : "off");
          field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
          field.setAttribute("spellcheck", !!spellcheck);
        }
        function hiddenTextarea() {
          var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
          var div2 = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
          if (webkit) {
            te.style.width = "1000px";
          } else {
            te.setAttribute("wrap", "off");
          }
          if (ios) {
            te.style.border = "1px solid black";
          }
          disableBrowserMagic(te);
          return div2;
        }
        function addEditorMethods(CodeMirror4) {
          var optionHandlers2 = CodeMirror4.optionHandlers;
          var helpers = CodeMirror4.helpers = {};
          CodeMirror4.prototype = {
            constructor: CodeMirror4,
            focus: function() {
              window.focus();
              this.display.input.focus();
            },
            setOption: function(option, value) {
              var options = this.options, old = options[option];
              if (options[option] == value && option != "mode") {
                return;
              }
              options[option] = value;
              if (optionHandlers2.hasOwnProperty(option)) {
                operation(this, optionHandlers2[option])(this, value, old);
              }
              signal(this, "optionChange", this, option);
            },
            getOption: function(option) {
              return this.options[option];
            },
            getDoc: function() {
              return this.doc;
            },
            addKeyMap: function(map2, bottom2) {
              this.state.keyMaps[bottom2 ? "push" : "unshift"](getKeyMap(map2));
            },
            removeKeyMap: function(map2) {
              var maps = this.state.keyMaps;
              for (var i3 = 0; i3 < maps.length; ++i3) {
                if (maps[i3] == map2 || maps[i3].name == map2) {
                  maps.splice(i3, 1);
                  return true;
                }
              }
            },
            addOverlay: methodOp(function(spec, options) {
              var mode = spec.token ? spec : CodeMirror4.getMode(this.options, spec);
              if (mode.startState) {
                throw new Error("Overlays may not be stateful.");
              }
              insertSorted(this.state.overlays, {
                mode,
                modeSpec: spec,
                opaque: options && options.opaque,
                priority: options && options.priority || 0
              }, function(overlay) {
                return overlay.priority;
              });
              this.state.modeGen++;
              regChange(this);
            }),
            removeOverlay: methodOp(function(spec) {
              var overlays = this.state.overlays;
              for (var i3 = 0; i3 < overlays.length; ++i3) {
                var cur = overlays[i3].modeSpec;
                if (cur == spec || typeof spec == "string" && cur.name == spec) {
                  overlays.splice(i3, 1);
                  this.state.modeGen++;
                  regChange(this);
                  return;
                }
              }
            }),
            indentLine: methodOp(function(n2, dir, aggressive) {
              if (typeof dir != "string" && typeof dir != "number") {
                if (dir == null) {
                  dir = this.options.smartIndent ? "smart" : "prev";
                } else {
                  dir = dir ? "add" : "subtract";
                }
              }
              if (isLine(this.doc, n2)) {
                indentLine(this, n2, dir, aggressive);
              }
            }),
            indentSelection: methodOp(function(how) {
              var ranges = this.doc.sel.ranges, end2 = -1;
              for (var i3 = 0; i3 < ranges.length; i3++) {
                var range2 = ranges[i3];
                if (!range2.empty()) {
                  var from = range2.from(), to = range2.to();
                  var start4 = Math.max(end2, from.line);
                  end2 = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
                  for (var j2 = start4; j2 < end2; ++j2) {
                    indentLine(this, j2, how);
                  }
                  var newRanges = this.doc.sel.ranges;
                  if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i3].from().ch > 0) {
                    replaceOneSelection(this.doc, i3, new Range(from, newRanges[i3].to()), sel_dontScroll);
                  }
                } else if (range2.head.line > end2) {
                  indentLine(this, range2.head.line, how, true);
                  end2 = range2.head.line;
                  if (i3 == this.doc.sel.primIndex) {
                    ensureCursorVisible(this);
                  }
                }
              }
            }),
            getTokenAt: function(pos, precise) {
              return takeToken(this, pos, precise);
            },
            getLineTokens: function(line, precise) {
              return takeToken(this, Pos(line), precise, true);
            },
            getTokenTypeAt: function(pos) {
              pos = clipPos(this.doc, pos);
              var styles = getLineStyles(this, getLine(this.doc, pos.line));
              var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
              var type;
              if (ch == 0) {
                type = styles[2];
              } else {
                for (; ; ) {
                  var mid = before + after >> 1;
                  if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {
                    after = mid;
                  } else if (styles[mid * 2 + 1] < ch) {
                    before = mid + 1;
                  } else {
                    type = styles[mid * 2 + 2];
                    break;
                  }
                }
              }
              var cut = type ? type.indexOf("overlay ") : -1;
              return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
            },
            getModeAt: function(pos) {
              var mode = this.doc.mode;
              if (!mode.innerMode) {
                return mode;
              }
              return CodeMirror4.innerMode(mode, this.getTokenAt(pos).state).mode;
            },
            getHelper: function(pos, type) {
              return this.getHelpers(pos, type)[0];
            },
            getHelpers: function(pos, type) {
              var found = [];
              if (!helpers.hasOwnProperty(type)) {
                return found;
              }
              var help = helpers[type], mode = this.getModeAt(pos);
              if (typeof mode[type] == "string") {
                if (help[mode[type]]) {
                  found.push(help[mode[type]]);
                }
              } else if (mode[type]) {
                for (var i3 = 0; i3 < mode[type].length; i3++) {
                  var val = help[mode[type][i3]];
                  if (val) {
                    found.push(val);
                  }
                }
              } else if (mode.helperType && help[mode.helperType]) {
                found.push(help[mode.helperType]);
              } else if (help[mode.name]) {
                found.push(help[mode.name]);
              }
              for (var i$12 = 0; i$12 < help._global.length; i$12++) {
                var cur = help._global[i$12];
                if (cur.pred(mode, this) && indexOf2(found, cur.val) == -1) {
                  found.push(cur.val);
                }
              }
              return found;
            },
            getStateAfter: function(line, precise) {
              var doc = this.doc;
              line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
              return getContextBefore(this, line + 1, precise).state;
            },
            cursorCoords: function(start4, mode) {
              var pos, range2 = this.doc.sel.primary();
              if (start4 == null) {
                pos = range2.head;
              } else if (typeof start4 == "object") {
                pos = clipPos(this.doc, start4);
              } else {
                pos = start4 ? range2.from() : range2.to();
              }
              return cursorCoords(this, pos, mode || "page");
            },
            charCoords: function(pos, mode) {
              return charCoords(this, clipPos(this.doc, pos), mode || "page");
            },
            coordsChar: function(coords, mode) {
              coords = fromCoordSystem(this, coords, mode || "page");
              return coordsChar(this, coords.left, coords.top);
            },
            lineAtHeight: function(height, mode) {
              height = fromCoordSystem(this, { top: height, left: 0 }, mode || "page").top;
              return lineAtHeight(this.doc, height + this.display.viewOffset);
            },
            heightAtLine: function(line, mode, includeWidgets) {
              var end2 = false, lineObj;
              if (typeof line == "number") {
                var last = this.doc.first + this.doc.size - 1;
                if (line < this.doc.first) {
                  line = this.doc.first;
                } else if (line > last) {
                  line = last;
                  end2 = true;
                }
                lineObj = getLine(this.doc, line);
              } else {
                lineObj = line;
              }
              return intoCoordSystem(this, lineObj, { top: 0, left: 0 }, mode || "page", includeWidgets || end2).top + (end2 ? this.doc.height - heightAtLine(lineObj) : 0);
            },
            defaultTextHeight: function() {
              return textHeight(this.display);
            },
            defaultCharWidth: function() {
              return charWidth(this.display);
            },
            getViewport: function() {
              return { from: this.display.viewFrom, to: this.display.viewTo };
            },
            addWidget: function(pos, node, scroll, vert, horiz) {
              var display = this.display;
              pos = cursorCoords(this, clipPos(this.doc, pos));
              var top2 = pos.bottom, left2 = pos.left;
              node.style.position = "absolute";
              node.setAttribute("cm-ignore-events", "true");
              this.display.input.setUneditable(node);
              display.sizer.appendChild(node);
              if (vert == "over") {
                top2 = pos.top;
              } else if (vert == "above" || vert == "near") {
                var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
                if ((vert == "above" || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
                  top2 = pos.top - node.offsetHeight;
                } else if (pos.bottom + node.offsetHeight <= vspace) {
                  top2 = pos.bottom;
                }
                if (left2 + node.offsetWidth > hspace) {
                  left2 = hspace - node.offsetWidth;
                }
              }
              node.style.top = top2 + "px";
              node.style.left = node.style.right = "";
              if (horiz == "right") {
                left2 = display.sizer.clientWidth - node.offsetWidth;
                node.style.right = "0px";
              } else {
                if (horiz == "left") {
                  left2 = 0;
                } else if (horiz == "middle") {
                  left2 = (display.sizer.clientWidth - node.offsetWidth) / 2;
                }
                node.style.left = left2 + "px";
              }
              if (scroll) {
                scrollIntoView(this, { left: left2, top: top2, right: left2 + node.offsetWidth, bottom: top2 + node.offsetHeight });
              }
            },
            triggerOnKeyDown: methodOp(onKeyDown2),
            triggerOnKeyPress: methodOp(onKeyPress),
            triggerOnKeyUp: onKeyUp,
            triggerOnMouseDown: methodOp(onMouseDown),
            execCommand: function(cmd) {
              if (commands.hasOwnProperty(cmd)) {
                return commands[cmd].call(null, this);
              }
            },
            triggerElectric: methodOp(function(text) {
              triggerElectric(this, text);
            }),
            findPosH: function(from, amount, unit, visually) {
              var dir = 1;
              if (amount < 0) {
                dir = -1;
                amount = -amount;
              }
              var cur = clipPos(this.doc, from);
              for (var i3 = 0; i3 < amount; ++i3) {
                cur = findPosH(this.doc, cur, dir, unit, visually);
                if (cur.hitSide) {
                  break;
                }
              }
              return cur;
            },
            moveH: methodOp(function(dir, unit) {
              var this$1 = this;
              this.extendSelectionsBy(function(range2) {
                if (this$1.display.shift || this$1.doc.extend || range2.empty()) {
                  return findPosH(this$1.doc, range2.head, dir, unit, this$1.options.rtlMoveVisually);
                } else {
                  return dir < 0 ? range2.from() : range2.to();
                }
              }, sel_move);
            }),
            deleteH: methodOp(function(dir, unit) {
              var sel = this.doc.sel, doc = this.doc;
              if (sel.somethingSelected()) {
                doc.replaceSelection("", null, "+delete");
              } else {
                deleteNearSelection(this, function(range2) {
                  var other = findPosH(doc, range2.head, dir, unit, false);
                  return dir < 0 ? { from: other, to: range2.head } : { from: range2.head, to: other };
                });
              }
            }),
            findPosV: function(from, amount, unit, goalColumn) {
              var dir = 1, x2 = goalColumn;
              if (amount < 0) {
                dir = -1;
                amount = -amount;
              }
              var cur = clipPos(this.doc, from);
              for (var i3 = 0; i3 < amount; ++i3) {
                var coords = cursorCoords(this, cur, "div");
                if (x2 == null) {
                  x2 = coords.left;
                } else {
                  coords.left = x2;
                }
                cur = findPosV(this, coords, dir, unit);
                if (cur.hitSide) {
                  break;
                }
              }
              return cur;
            },
            moveV: methodOp(function(dir, unit) {
              var this$1 = this;
              var doc = this.doc, goals = [];
              var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
              doc.extendSelectionsBy(function(range2) {
                if (collapse) {
                  return dir < 0 ? range2.from() : range2.to();
                }
                var headPos = cursorCoords(this$1, range2.head, "div");
                if (range2.goalColumn != null) {
                  headPos.left = range2.goalColumn;
                }
                goals.push(headPos.left);
                var pos = findPosV(this$1, headPos, dir, unit);
                if (unit == "page" && range2 == doc.sel.primary()) {
                  addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top);
                }
                return pos;
              }, sel_move);
              if (goals.length) {
                for (var i3 = 0; i3 < doc.sel.ranges.length; i3++) {
                  doc.sel.ranges[i3].goalColumn = goals[i3];
                }
              }
            }),
            findWordAt: function(pos) {
              var doc = this.doc, line = getLine(doc, pos.line).text;
              var start4 = pos.ch, end2 = pos.ch;
              if (line) {
                var helper = this.getHelper(pos, "wordChars");
                if ((pos.sticky == "before" || end2 == line.length) && start4) {
                  --start4;
                } else {
                  ++end2;
                }
                var startChar = line.charAt(start4);
                var check = isWordChar(startChar, helper) ? function(ch) {
                  return isWordChar(ch, helper);
                } : /\s/.test(startChar) ? function(ch) {
                  return /\s/.test(ch);
                } : function(ch) {
                  return !/\s/.test(ch) && !isWordChar(ch);
                };
                while (start4 > 0 && check(line.charAt(start4 - 1))) {
                  --start4;
                }
                while (end2 < line.length && check(line.charAt(end2))) {
                  ++end2;
                }
              }
              return new Range(Pos(pos.line, start4), Pos(pos.line, end2));
            },
            toggleOverwrite: function(value) {
              if (value != null && value == this.state.overwrite) {
                return;
              }
              if (this.state.overwrite = !this.state.overwrite) {
                addClass(this.display.cursorDiv, "CodeMirror-overwrite");
              } else {
                rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
              }
              signal(this, "overwriteToggle", this, this.state.overwrite);
            },
            hasFocus: function() {
              return this.display.input.getField() == activeElt();
            },
            isReadOnly: function() {
              return !!(this.options.readOnly || this.doc.cantEdit);
            },
            scrollTo: methodOp(function(x2, y2) {
              scrollToCoords(this, x2, y2);
            }),
            getScrollInfo: function() {
              var scroller = this.display.scroller;
              return {
                left: scroller.scrollLeft,
                top: scroller.scrollTop,
                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                clientHeight: displayHeight(this),
                clientWidth: displayWidth(this)
              };
            },
            scrollIntoView: methodOp(function(range2, margin) {
              if (range2 == null) {
                range2 = { from: this.doc.sel.primary().head, to: null };
                if (margin == null) {
                  margin = this.options.cursorScrollMargin;
                }
              } else if (typeof range2 == "number") {
                range2 = { from: Pos(range2, 0), to: null };
              } else if (range2.from == null) {
                range2 = { from: range2, to: null };
              }
              if (!range2.to) {
                range2.to = range2.from;
              }
              range2.margin = margin || 0;
              if (range2.from.line != null) {
                scrollToRange(this, range2);
              } else {
                scrollToCoordsRange(this, range2.from, range2.to, range2.margin);
              }
            }),
            setSize: methodOp(function(width, height) {
              var this$1 = this;
              var interpret = function(val) {
                return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
              };
              if (width != null) {
                this.display.wrapper.style.width = interpret(width);
              }
              if (height != null) {
                this.display.wrapper.style.height = interpret(height);
              }
              if (this.options.lineWrapping) {
                clearLineMeasurementCache(this);
              }
              var lineNo2 = this.display.viewFrom;
              this.doc.iter(lineNo2, this.display.viewTo, function(line) {
                if (line.widgets) {
                  for (var i3 = 0; i3 < line.widgets.length; i3++) {
                    if (line.widgets[i3].noHScroll) {
                      regLineChange(this$1, lineNo2, "widget");
                      break;
                    }
                  }
                }
                ++lineNo2;
              });
              this.curOp.forceUpdate = true;
              signal(this, "refresh", this);
            }),
            operation: function(f2) {
              return runInOp(this, f2);
            },
            startOperation: function() {
              return startOperation(this);
            },
            endOperation: function() {
              return endOperation(this);
            },
            refresh: methodOp(function() {
              var oldHeight = this.display.cachedTextHeight;
              regChange(this);
              this.curOp.forceUpdate = true;
              clearCaches(this);
              scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
              updateGutterSpace(this.display);
              if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > 0.5 || this.options.lineWrapping) {
                estimateLineHeights(this);
              }
              signal(this, "refresh", this);
            }),
            swapDoc: methodOp(function(doc) {
              var old = this.doc;
              old.cm = null;
              if (this.state.selectingText) {
                this.state.selectingText();
              }
              attachDoc(this, doc);
              clearCaches(this);
              this.display.input.reset();
              scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
              this.curOp.forceScroll = true;
              signalLater(this, "swapDoc", this, old);
              return old;
            }),
            phrase: function(phraseText) {
              var phrases = this.options.phrases;
              return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
            },
            getInputField: function() {
              return this.display.input.getField();
            },
            getWrapperElement: function() {
              return this.display.wrapper;
            },
            getScrollerElement: function() {
              return this.display.scroller;
            },
            getGutterElement: function() {
              return this.display.gutters;
            }
          };
          eventMixin(CodeMirror4);
          CodeMirror4.registerHelper = function(type, name, value) {
            if (!helpers.hasOwnProperty(type)) {
              helpers[type] = CodeMirror4[type] = { _global: [] };
            }
            helpers[type][name] = value;
          };
          CodeMirror4.registerGlobalHelper = function(type, name, predicate, value) {
            CodeMirror4.registerHelper(type, name, value);
            helpers[type]._global.push({ pred: predicate, val: value });
          };
        }
        function findPosH(doc, pos, dir, unit, visually) {
          var oldPos = pos;
          var origDir = dir;
          var lineObj = getLine(doc, pos.line);
          var lineDir = visually && doc.direction == "rtl" ? -dir : dir;
          function findNextLine() {
            var l2 = pos.line + lineDir;
            if (l2 < doc.first || l2 >= doc.first + doc.size) {
              return false;
            }
            pos = new Pos(l2, pos.ch, pos.sticky);
            return lineObj = getLine(doc, l2);
          }
          function moveOnce(boundToLine) {
            var next;
            if (unit == "codepoint") {
              var ch = lineObj.text.charCodeAt(pos.ch + (unit > 0 ? 0 : -1));
              if (isNaN(ch)) {
                next = null;
              } else {
                var astral = dir > 0 ? ch >= 55296 && ch < 56320 : ch >= 56320 && ch < 57343;
                next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
              }
            } else if (visually) {
              next = moveVisually(doc.cm, lineObj, pos, dir);
            } else {
              next = moveLogically(lineObj, pos, dir);
            }
            if (next == null) {
              if (!boundToLine && findNextLine()) {
                pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir);
              } else {
                return false;
              }
            } else {
              pos = next;
            }
            return true;
          }
          if (unit == "char" || unit == "codepoint") {
            moveOnce();
          } else if (unit == "column") {
            moveOnce(true);
          } else if (unit == "word" || unit == "group") {
            var sawType = null, group = unit == "group";
            var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
            for (var first = true; ; first = false) {
              if (dir < 0 && !moveOnce(!first)) {
                break;
              }
              var cur = lineObj.text.charAt(pos.ch) || "\n";
              var type = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";
              if (group && !first && !type) {
                type = "s";
              }
              if (sawType && sawType != type) {
                if (dir < 0) {
                  dir = 1;
                  moveOnce();
                  pos.sticky = "after";
                }
                break;
              }
              if (type) {
                sawType = type;
              }
              if (dir > 0 && !moveOnce(!first)) {
                break;
              }
            }
          }
          var result = skipAtomic(doc, pos, oldPos, origDir, true);
          if (equalCursorPos(oldPos, result)) {
            result.hitSide = true;
          }
          return result;
        }
        function findPosV(cm, pos, dir, unit) {
          var doc = cm.doc, x2 = pos.left, y2;
          if (unit == "page") {
            var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
            var moveAmount = Math.max(pageSize - 0.5 * textHeight(cm.display), 3);
            y2 = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
          } else if (unit == "line") {
            y2 = dir > 0 ? pos.bottom + 3 : pos.top - 3;
          }
          var target;
          for (; ; ) {
            target = coordsChar(cm, x2, y2);
            if (!target.outside) {
              break;
            }
            if (dir < 0 ? y2 <= 0 : y2 >= doc.height) {
              target.hitSide = true;
              break;
            }
            y2 += dir * 5;
          }
          return target;
        }
        var ContentEditableInput = function(cm) {
          this.cm = cm;
          this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
          this.polling = new Delayed();
          this.composing = null;
          this.gracePeriod = false;
          this.readDOMTimeout = null;
        };
        ContentEditableInput.prototype.init = function(display) {
          var this$1 = this;
          var input = this, cm = input.cm;
          var div2 = input.div = display.lineDiv;
          disableBrowserMagic(div2, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);
          function belongsToInput(e2) {
            for (var t2 = e2.target; t2; t2 = t2.parentNode) {
              if (t2 == div2) {
                return true;
              }
              if (/\bCodeMirror-(?:line)?widget\b/.test(t2.className)) {
                break;
              }
            }
            return false;
          }
          on(div2, "paste", function(e2) {
            if (!belongsToInput(e2) || signalDOMEvent(cm, e2) || handlePaste(e2, cm)) {
              return;
            }
            if (ie_version <= 11) {
              setTimeout(operation(cm, function() {
                return this$1.updateFromDOM();
              }), 20);
            }
          });
          on(div2, "compositionstart", function(e2) {
            this$1.composing = { data: e2.data, done: false };
          });
          on(div2, "compositionupdate", function(e2) {
            if (!this$1.composing) {
              this$1.composing = { data: e2.data, done: false };
            }
          });
          on(div2, "compositionend", function(e2) {
            if (this$1.composing) {
              if (e2.data != this$1.composing.data) {
                this$1.readFromDOMSoon();
              }
              this$1.composing.done = true;
            }
          });
          on(div2, "touchstart", function() {
            return input.forceCompositionEnd();
          });
          on(div2, "input", function() {
            if (!this$1.composing) {
              this$1.readFromDOMSoon();
            }
          });
          function onCopyCut(e2) {
            if (!belongsToInput(e2) || signalDOMEvent(cm, e2)) {
              return;
            }
            if (cm.somethingSelected()) {
              setLastCopied({ lineWise: false, text: cm.getSelections() });
              if (e2.type == "cut") {
                cm.replaceSelection("", null, "cut");
              }
            } else if (!cm.options.lineWiseCopyCut) {
              return;
            } else {
              var ranges = copyableRanges(cm);
              setLastCopied({ lineWise: true, text: ranges.text });
              if (e2.type == "cut") {
                cm.operation(function() {
                  cm.setSelections(ranges.ranges, 0, sel_dontScroll);
                  cm.replaceSelection("", null, "cut");
                });
              }
            }
            if (e2.clipboardData) {
              e2.clipboardData.clearData();
              var content = lastCopied.text.join("\n");
              e2.clipboardData.setData("Text", content);
              if (e2.clipboardData.getData("Text") == content) {
                e2.preventDefault();
                return;
              }
            }
            var kludge = hiddenTextarea(), te = kludge.firstChild;
            cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
            te.value = lastCopied.text.join("\n");
            var hadFocus = document.activeElement;
            selectInput(te);
            setTimeout(function() {
              cm.display.lineSpace.removeChild(kludge);
              hadFocus.focus();
              if (hadFocus == div2) {
                input.showPrimarySelection();
              }
            }, 50);
          }
          on(div2, "copy", onCopyCut);
          on(div2, "cut", onCopyCut);
        };
        ContentEditableInput.prototype.screenReaderLabelChanged = function(label) {
          if (label) {
            this.div.setAttribute("aria-label", label);
          } else {
            this.div.removeAttribute("aria-label");
          }
        };
        ContentEditableInput.prototype.prepareSelection = function() {
          var result = prepareSelection(this.cm, false);
          result.focus = document.activeElement == this.div;
          return result;
        };
        ContentEditableInput.prototype.showSelection = function(info, takeFocus) {
          if (!info || !this.cm.display.view.length) {
            return;
          }
          if (info.focus || takeFocus) {
            this.showPrimarySelection();
          }
          this.showMultipleSelections(info);
        };
        ContentEditableInput.prototype.getSelection = function() {
          return this.cm.display.wrapper.ownerDocument.getSelection();
        };
        ContentEditableInput.prototype.showPrimarySelection = function() {
          var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
          var from = prim.from(), to = prim.to();
          if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
            sel.removeAllRanges();
            return;
          }
          var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
          var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
          if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {
            return;
          }
          var view = cm.display.view;
          var start4 = from.line >= cm.display.viewFrom && posToDOM(cm, from) || { node: view[0].measure.map[2], offset: 0 };
          var end2 = to.line < cm.display.viewTo && posToDOM(cm, to);
          if (!end2) {
            var measure = view[view.length - 1].measure;
            var map2 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
            end2 = { node: map2[map2.length - 1], offset: map2[map2.length - 2] - map2[map2.length - 3] };
          }
          if (!start4 || !end2) {
            sel.removeAllRanges();
            return;
          }
          var old = sel.rangeCount && sel.getRangeAt(0), rng;
          try {
            rng = range(start4.node, start4.offset, end2.offset, end2.node);
          } catch (e2) {
          }
          if (rng) {
            if (!gecko && cm.state.focused) {
              sel.collapse(start4.node, start4.offset);
              if (!rng.collapsed) {
                sel.removeAllRanges();
                sel.addRange(rng);
              }
            } else {
              sel.removeAllRanges();
              sel.addRange(rng);
            }
            if (old && sel.anchorNode == null) {
              sel.addRange(old);
            } else if (gecko) {
              this.startGracePeriod();
            }
          }
          this.rememberSelection();
        };
        ContentEditableInput.prototype.startGracePeriod = function() {
          var this$1 = this;
          clearTimeout(this.gracePeriod);
          this.gracePeriod = setTimeout(function() {
            this$1.gracePeriod = false;
            if (this$1.selectionChanged()) {
              this$1.cm.operation(function() {
                return this$1.cm.curOp.selectionChanged = true;
              });
            }
          }, 20);
        };
        ContentEditableInput.prototype.showMultipleSelections = function(info) {
          removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
          removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
        };
        ContentEditableInput.prototype.rememberSelection = function() {
          var sel = this.getSelection();
          this.lastAnchorNode = sel.anchorNode;
          this.lastAnchorOffset = sel.anchorOffset;
          this.lastFocusNode = sel.focusNode;
          this.lastFocusOffset = sel.focusOffset;
        };
        ContentEditableInput.prototype.selectionInEditor = function() {
          var sel = this.getSelection();
          if (!sel.rangeCount) {
            return false;
          }
          var node = sel.getRangeAt(0).commonAncestorContainer;
          return contains2(this.div, node);
        };
        ContentEditableInput.prototype.focus = function() {
          if (this.cm.options.readOnly != "nocursor") {
            if (!this.selectionInEditor() || document.activeElement != this.div) {
              this.showSelection(this.prepareSelection(), true);
            }
            this.div.focus();
          }
        };
        ContentEditableInput.prototype.blur = function() {
          this.div.blur();
        };
        ContentEditableInput.prototype.getField = function() {
          return this.div;
        };
        ContentEditableInput.prototype.supportsTouch = function() {
          return true;
        };
        ContentEditableInput.prototype.receivedFocus = function() {
          var input = this;
          if (this.selectionInEditor()) {
            this.pollSelection();
          } else {
            runInOp(this.cm, function() {
              return input.cm.curOp.selectionChanged = true;
            });
          }
          function poll() {
            if (input.cm.state.focused) {
              input.pollSelection();
              input.polling.set(input.cm.options.pollInterval, poll);
            }
          }
          this.polling.set(this.cm.options.pollInterval, poll);
        };
        ContentEditableInput.prototype.selectionChanged = function() {
          var sel = this.getSelection();
          return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
        };
        ContentEditableInput.prototype.pollSelection = function() {
          if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
            return;
          }
          var sel = this.getSelection(), cm = this.cm;
          if (android && chrome2 && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
            this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs });
            this.blur();
            this.focus();
            return;
          }
          if (this.composing) {
            return;
          }
          this.rememberSelection();
          var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
          var head = domToPos(cm, sel.focusNode, sel.focusOffset);
          if (anchor && head) {
            runInOp(cm, function() {
              setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
              if (anchor.bad || head.bad) {
                cm.curOp.selectionChanged = true;
              }
            });
          }
        };
        ContentEditableInput.prototype.pollContent = function() {
          if (this.readDOMTimeout != null) {
            clearTimeout(this.readDOMTimeout);
            this.readDOMTimeout = null;
          }
          var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
          var from = sel.from(), to = sel.to();
          if (from.ch == 0 && from.line > cm.firstLine()) {
            from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);
          }
          if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
            to = Pos(to.line + 1, 0);
          }
          if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
            return false;
          }
          var fromIndex, fromLine, fromNode;
          if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
            fromLine = lineNo(display.view[0].line);
            fromNode = display.view[0].node;
          } else {
            fromLine = lineNo(display.view[fromIndex].line);
            fromNode = display.view[fromIndex - 1].node.nextSibling;
          }
          var toIndex = findViewIndex(cm, to.line);
          var toLine, toNode;
          if (toIndex == display.view.length - 1) {
            toLine = display.viewTo - 1;
            toNode = display.lineDiv.lastChild;
          } else {
            toLine = lineNo(display.view[toIndex + 1].line) - 1;
            toNode = display.view[toIndex + 1].node.previousSibling;
          }
          if (!fromNode) {
            return false;
          }
          var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
          var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
          while (newText.length > 1 && oldText.length > 1) {
            if (lst(newText) == lst(oldText)) {
              newText.pop();
              oldText.pop();
              toLine--;
            } else if (newText[0] == oldText[0]) {
              newText.shift();
              oldText.shift();
              fromLine++;
            } else {
              break;
            }
          }
          var cutFront = 0, cutEnd = 0;
          var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
          while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
            ++cutFront;
          }
          var newBot = lst(newText), oldBot = lst(oldText);
          var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));
          while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
            ++cutEnd;
          }
          if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
            while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
              cutFront--;
              cutEnd++;
            }
          }
          newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
          newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
          var chFrom = Pos(fromLine, cutFront);
          var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
          if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
            replaceRange(cm.doc, newText, chFrom, chTo, "+input");
            return true;
          }
        };
        ContentEditableInput.prototype.ensurePolled = function() {
          this.forceCompositionEnd();
        };
        ContentEditableInput.prototype.reset = function() {
          this.forceCompositionEnd();
        };
        ContentEditableInput.prototype.forceCompositionEnd = function() {
          if (!this.composing) {
            return;
          }
          clearTimeout(this.readDOMTimeout);
          this.composing = null;
          this.updateFromDOM();
          this.div.blur();
          this.div.focus();
        };
        ContentEditableInput.prototype.readFromDOMSoon = function() {
          var this$1 = this;
          if (this.readDOMTimeout != null) {
            return;
          }
          this.readDOMTimeout = setTimeout(function() {
            this$1.readDOMTimeout = null;
            if (this$1.composing) {
              if (this$1.composing.done) {
                this$1.composing = null;
              } else {
                return;
              }
            }
            this$1.updateFromDOM();
          }, 80);
        };
        ContentEditableInput.prototype.updateFromDOM = function() {
          var this$1 = this;
          if (this.cm.isReadOnly() || !this.pollContent()) {
            runInOp(this.cm, function() {
              return regChange(this$1.cm);
            });
          }
        };
        ContentEditableInput.prototype.setUneditable = function(node) {
          node.contentEditable = "false";
        };
        ContentEditableInput.prototype.onKeyPress = function(e2) {
          if (e2.charCode == 0 || this.composing) {
            return;
          }
          e2.preventDefault();
          if (!this.cm.isReadOnly()) {
            operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e2.charCode == null ? e2.keyCode : e2.charCode), 0);
          }
        };
        ContentEditableInput.prototype.readOnlyChanged = function(val) {
          this.div.contentEditable = String(val != "nocursor");
        };
        ContentEditableInput.prototype.onContextMenu = function() {
        };
        ContentEditableInput.prototype.resetPosition = function() {
        };
        ContentEditableInput.prototype.needsContentAttribute = true;
        function posToDOM(cm, pos) {
          var view = findViewForLine(cm, pos.line);
          if (!view || view.hidden) {
            return null;
          }
          var line = getLine(cm.doc, pos.line);
          var info = mapFromLineView(view, line, pos.line);
          var order2 = getOrder(line, cm.doc.direction), side = "left";
          if (order2) {
            var partPos = getBidiPartAt(order2, pos.ch);
            side = partPos % 2 ? "right" : "left";
          }
          var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
          result.offset = result.collapse == "right" ? result.end : result.start;
          return result;
        }
        function isInGutter(node) {
          for (var scan = node; scan; scan = scan.parentNode) {
            if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
              return true;
            }
          }
          return false;
        }
        function badPos(pos, bad) {
          if (bad) {
            pos.bad = true;
          }
          return pos;
        }
        function domTextBetween(cm, from, to, fromLine, toLine) {
          var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
          function recognizeMarker(id) {
            return function(marker) {
              return marker.id == id;
            };
          }
          function close() {
            if (closing) {
              text += lineSep;
              if (extraLinebreak) {
                text += lineSep;
              }
              closing = extraLinebreak = false;
            }
          }
          function addText(str) {
            if (str) {
              close();
              text += str;
            }
          }
          function walk(node) {
            if (node.nodeType == 1) {
              var cmText = node.getAttribute("cm-text");
              if (cmText) {
                addText(cmText);
                return;
              }
              var markerID = node.getAttribute("cm-marker"), range2;
              if (markerID) {
                var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
                if (found.length && (range2 = found[0].find(0))) {
                  addText(getBetween(cm.doc, range2.from, range2.to).join(lineSep));
                }
                return;
              }
              if (node.getAttribute("contenteditable") == "false") {
                return;
              }
              var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
              if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {
                return;
              }
              if (isBlock) {
                close();
              }
              for (var i3 = 0; i3 < node.childNodes.length; i3++) {
                walk(node.childNodes[i3]);
              }
              if (/^(pre|p)$/i.test(node.nodeName)) {
                extraLinebreak = true;
              }
              if (isBlock) {
                closing = true;
              }
            } else if (node.nodeType == 3) {
              addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
            }
          }
          for (; ; ) {
            walk(from);
            if (from == to) {
              break;
            }
            from = from.nextSibling;
            extraLinebreak = false;
          }
          return text;
        }
        function domToPos(cm, node, offset2) {
          var lineNode;
          if (node == cm.display.lineDiv) {
            lineNode = cm.display.lineDiv.childNodes[offset2];
            if (!lineNode) {
              return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
            }
            node = null;
            offset2 = 0;
          } else {
            for (lineNode = node; ; lineNode = lineNode.parentNode) {
              if (!lineNode || lineNode == cm.display.lineDiv) {
                return null;
              }
              if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
                break;
              }
            }
          }
          for (var i3 = 0; i3 < cm.display.view.length; i3++) {
            var lineView = cm.display.view[i3];
            if (lineView.node == lineNode) {
              return locateNodeInLineView(lineView, node, offset2);
            }
          }
        }
        function locateNodeInLineView(lineView, node, offset2) {
          var wrapper = lineView.text.firstChild, bad = false;
          if (!node || !contains2(wrapper, node)) {
            return badPos(Pos(lineNo(lineView.line), 0), true);
          }
          if (node == wrapper) {
            bad = true;
            node = wrapper.childNodes[offset2];
            offset2 = 0;
            if (!node) {
              var line = lineView.rest ? lst(lineView.rest) : lineView.line;
              return badPos(Pos(lineNo(line), line.text.length), bad);
            }
          }
          var textNode = node.nodeType == 3 ? node : null, topNode = node;
          if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
            textNode = node.firstChild;
            if (offset2) {
              offset2 = textNode.nodeValue.length;
            }
          }
          while (topNode.parentNode != wrapper) {
            topNode = topNode.parentNode;
          }
          var measure = lineView.measure, maps = measure.maps;
          function find(textNode2, topNode2, offset3) {
            for (var i3 = -1; i3 < (maps ? maps.length : 0); i3++) {
              var map2 = i3 < 0 ? measure.map : maps[i3];
              for (var j2 = 0; j2 < map2.length; j2 += 3) {
                var curNode = map2[j2 + 2];
                if (curNode == textNode2 || curNode == topNode2) {
                  var line2 = lineNo(i3 < 0 ? lineView.line : lineView.rest[i3]);
                  var ch = map2[j2] + offset3;
                  if (offset3 < 0 || curNode != textNode2) {
                    ch = map2[j2 + (offset3 ? 1 : 0)];
                  }
                  return Pos(line2, ch);
                }
              }
            }
          }
          var found = find(textNode, topNode, offset2);
          if (found) {
            return badPos(found, bad);
          }
          for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset2 : 0; after; after = after.nextSibling) {
            found = find(after, after.firstChild, 0);
            if (found) {
              return badPos(Pos(found.line, found.ch - dist), bad);
            } else {
              dist += after.textContent.length;
            }
          }
          for (var before = topNode.previousSibling, dist$1 = offset2; before; before = before.previousSibling) {
            found = find(before, before.firstChild, -1);
            if (found) {
              return badPos(Pos(found.line, found.ch + dist$1), bad);
            } else {
              dist$1 += before.textContent.length;
            }
          }
        }
        var TextareaInput = function(cm) {
          this.cm = cm;
          this.prevInput = "";
          this.pollingFast = false;
          this.polling = new Delayed();
          this.hasSelection = false;
          this.composing = null;
        };
        TextareaInput.prototype.init = function(display) {
          var this$1 = this;
          var input = this, cm = this.cm;
          this.createField(display);
          var te = this.textarea;
          display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);
          if (ios) {
            te.style.width = "0px";
          }
          on(te, "input", function() {
            if (ie && ie_version >= 9 && this$1.hasSelection) {
              this$1.hasSelection = null;
            }
            input.poll();
          });
          on(te, "paste", function(e2) {
            if (signalDOMEvent(cm, e2) || handlePaste(e2, cm)) {
              return;
            }
            cm.state.pasteIncoming = +new Date();
            input.fastPoll();
          });
          function prepareCopyCut(e2) {
            if (signalDOMEvent(cm, e2)) {
              return;
            }
            if (cm.somethingSelected()) {
              setLastCopied({ lineWise: false, text: cm.getSelections() });
            } else if (!cm.options.lineWiseCopyCut) {
              return;
            } else {
              var ranges = copyableRanges(cm);
              setLastCopied({ lineWise: true, text: ranges.text });
              if (e2.type == "cut") {
                cm.setSelections(ranges.ranges, null, sel_dontScroll);
              } else {
                input.prevInput = "";
                te.value = ranges.text.join("\n");
                selectInput(te);
              }
            }
            if (e2.type == "cut") {
              cm.state.cutIncoming = +new Date();
            }
          }
          on(te, "cut", prepareCopyCut);
          on(te, "copy", prepareCopyCut);
          on(display.scroller, "paste", function(e2) {
            if (eventInWidget(display, e2) || signalDOMEvent(cm, e2)) {
              return;
            }
            if (!te.dispatchEvent) {
              cm.state.pasteIncoming = +new Date();
              input.focus();
              return;
            }
            var event = new Event("paste");
            event.clipboardData = e2.clipboardData;
            te.dispatchEvent(event);
          });
          on(display.lineSpace, "selectstart", function(e2) {
            if (!eventInWidget(display, e2)) {
              e_preventDefault(e2);
            }
          });
          on(te, "compositionstart", function() {
            var start4 = cm.getCursor("from");
            if (input.composing) {
              input.composing.range.clear();
            }
            input.composing = {
              start: start4,
              range: cm.markText(start4, cm.getCursor("to"), { className: "CodeMirror-composing" })
            };
          });
          on(te, "compositionend", function() {
            if (input.composing) {
              input.poll();
              input.composing.range.clear();
              input.composing = null;
            }
          });
        };
        TextareaInput.prototype.createField = function(_display) {
          this.wrapper = hiddenTextarea();
          this.textarea = this.wrapper.firstChild;
        };
        TextareaInput.prototype.screenReaderLabelChanged = function(label) {
          if (label) {
            this.textarea.setAttribute("aria-label", label);
          } else {
            this.textarea.removeAttribute("aria-label");
          }
        };
        TextareaInput.prototype.prepareSelection = function() {
          var cm = this.cm, display = cm.display, doc = cm.doc;
          var result = prepareSelection(cm);
          if (cm.options.moveInputWithCursor) {
            var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
            var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
            result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
            result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
          }
          return result;
        };
        TextareaInput.prototype.showSelection = function(drawn) {
          var cm = this.cm, display = cm.display;
          removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
          removeChildrenAndAdd(display.selectionDiv, drawn.selection);
          if (drawn.teTop != null) {
            this.wrapper.style.top = drawn.teTop + "px";
            this.wrapper.style.left = drawn.teLeft + "px";
          }
        };
        TextareaInput.prototype.reset = function(typing) {
          if (this.contextMenuPending || this.composing) {
            return;
          }
          var cm = this.cm;
          if (cm.somethingSelected()) {
            this.prevInput = "";
            var content = cm.getSelection();
            this.textarea.value = content;
            if (cm.state.focused) {
              selectInput(this.textarea);
            }
            if (ie && ie_version >= 9) {
              this.hasSelection = content;
            }
          } else if (!typing) {
            this.prevInput = this.textarea.value = "";
            if (ie && ie_version >= 9) {
              this.hasSelection = null;
            }
          }
        };
        TextareaInput.prototype.getField = function() {
          return this.textarea;
        };
        TextareaInput.prototype.supportsTouch = function() {
          return false;
        };
        TextareaInput.prototype.focus = function() {
          if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
            try {
              this.textarea.focus();
            } catch (e2) {
            }
          }
        };
        TextareaInput.prototype.blur = function() {
          this.textarea.blur();
        };
        TextareaInput.prototype.resetPosition = function() {
          this.wrapper.style.top = this.wrapper.style.left = 0;
        };
        TextareaInput.prototype.receivedFocus = function() {
          this.slowPoll();
        };
        TextareaInput.prototype.slowPoll = function() {
          var this$1 = this;
          if (this.pollingFast) {
            return;
          }
          this.polling.set(this.cm.options.pollInterval, function() {
            this$1.poll();
            if (this$1.cm.state.focused) {
              this$1.slowPoll();
            }
          });
        };
        TextareaInput.prototype.fastPoll = function() {
          var missed = false, input = this;
          input.pollingFast = true;
          function p2() {
            var changed = input.poll();
            if (!changed && !missed) {
              missed = true;
              input.polling.set(60, p2);
            } else {
              input.pollingFast = false;
              input.slowPoll();
            }
          }
          input.polling.set(20, p2);
        };
        TextareaInput.prototype.poll = function() {
          var this$1 = this;
          var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
          if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
            return false;
          }
          var text = input.value;
          if (text == prevInput && !cm.somethingSelected()) {
            return false;
          }
          if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) {
            cm.display.input.reset();
            return false;
          }
          if (cm.doc.sel == cm.display.selForContextMenu) {
            var first = text.charCodeAt(0);
            if (first == 8203 && !prevInput) {
              prevInput = "\u200B";
            }
            if (first == 8666) {
              this.reset();
              return this.cm.execCommand("undo");
            }
          }
          var same = 0, l2 = Math.min(prevInput.length, text.length);
          while (same < l2 && prevInput.charCodeAt(same) == text.charCodeAt(same)) {
            ++same;
          }
          runInOp(cm, function() {
            applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? "*compose" : null);
            if (text.length > 1e3 || text.indexOf("\n") > -1) {
              input.value = this$1.prevInput = "";
            } else {
              this$1.prevInput = text;
            }
            if (this$1.composing) {
              this$1.composing.range.clear();
              this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"), { className: "CodeMirror-composing" });
            }
          });
          return true;
        };
        TextareaInput.prototype.ensurePolled = function() {
          if (this.pollingFast && this.poll()) {
            this.pollingFast = false;
          }
        };
        TextareaInput.prototype.onKeyPress = function() {
          if (ie && ie_version >= 9) {
            this.hasSelection = null;
          }
          this.fastPoll();
        };
        TextareaInput.prototype.onContextMenu = function(e2) {
          var input = this, cm = input.cm, display = cm.display, te = input.textarea;
          if (input.contextMenuPending) {
            input.contextMenuPending();
          }
          var pos = posFromMouse(cm, e2), scrollPos = display.scroller.scrollTop;
          if (!pos || presto) {
            return;
          }
          var reset = cm.options.resetSelectionOnContextMenu;
          if (reset && cm.doc.sel.contains(pos) == -1) {
            operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
          }
          var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
          var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
          input.wrapper.style.cssText = "position: static";
          te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e2.clientY - wrapperBox.top - 5) + "px; left: " + (e2.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
          var oldScrollY;
          if (webkit) {
            oldScrollY = window.scrollY;
          }
          display.input.focus();
          if (webkit) {
            window.scrollTo(null, oldScrollY);
          }
          display.input.reset();
          if (!cm.somethingSelected()) {
            te.value = input.prevInput = " ";
          }
          input.contextMenuPending = rehide;
          display.selForContextMenu = cm.doc.sel;
          clearTimeout(display.detectingSelectAll);
          function prepareSelectAllHack() {
            if (te.selectionStart != null) {
              var selected = cm.somethingSelected();
              var extval = "\u200B" + (selected ? te.value : "");
              te.value = "\u21DA";
              te.value = extval;
              input.prevInput = selected ? "" : "\u200B";
              te.selectionStart = 1;
              te.selectionEnd = extval.length;
              display.selForContextMenu = cm.doc.sel;
            }
          }
          function rehide() {
            if (input.contextMenuPending != rehide) {
              return;
            }
            input.contextMenuPending = false;
            input.wrapper.style.cssText = oldWrapperCSS;
            te.style.cssText = oldCSS;
            if (ie && ie_version < 9) {
              display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
            }
            if (te.selectionStart != null) {
              if (!ie || ie && ie_version < 9) {
                prepareSelectAllHack();
              }
              var i3 = 0, poll = function() {
                if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "\u200B") {
                  operation(cm, selectAll)(cm);
                } else if (i3++ < 10) {
                  display.detectingSelectAll = setTimeout(poll, 500);
                } else {
                  display.selForContextMenu = null;
                  display.input.reset();
                }
              };
              display.detectingSelectAll = setTimeout(poll, 200);
            }
          }
          if (ie && ie_version >= 9) {
            prepareSelectAllHack();
          }
          if (captureRightClick) {
            e_stop(e2);
            var mouseup = function() {
              off(window, "mouseup", mouseup);
              setTimeout(rehide, 20);
            };
            on(window, "mouseup", mouseup);
          } else {
            setTimeout(rehide, 50);
          }
        };
        TextareaInput.prototype.readOnlyChanged = function(val) {
          if (!val) {
            this.reset();
          }
          this.textarea.disabled = val == "nocursor";
          this.textarea.readOnly = !!val;
        };
        TextareaInput.prototype.setUneditable = function() {
        };
        TextareaInput.prototype.needsContentAttribute = false;
        function fromTextArea(textarea, options) {
          options = options ? copyObj(options) : {};
          options.value = textarea.value;
          if (!options.tabindex && textarea.tabIndex) {
            options.tabindex = textarea.tabIndex;
          }
          if (!options.placeholder && textarea.placeholder) {
            options.placeholder = textarea.placeholder;
          }
          if (options.autofocus == null) {
            var hasFocus = activeElt();
            options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
          }
          function save() {
            textarea.value = cm.getValue();
          }
          var realSubmit;
          if (textarea.form) {
            on(textarea.form, "submit", save);
            if (!options.leaveSubmitMethodAlone) {
              var form = textarea.form;
              realSubmit = form.submit;
              try {
                var wrappedSubmit = form.submit = function() {
                  save();
                  form.submit = realSubmit;
                  form.submit();
                  form.submit = wrappedSubmit;
                };
              } catch (e2) {
              }
            }
          }
          options.finishInit = function(cm2) {
            cm2.save = save;
            cm2.getTextArea = function() {
              return textarea;
            };
            cm2.toTextArea = function() {
              cm2.toTextArea = isNaN;
              save();
              textarea.parentNode.removeChild(cm2.getWrapperElement());
              textarea.style.display = "";
              if (textarea.form) {
                off(textarea.form, "submit", save);
                if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function") {
                  textarea.form.submit = realSubmit;
                }
              }
            };
          };
          textarea.style.display = "none";
          var cm = CodeMirror3(function(node) {
            return textarea.parentNode.insertBefore(node, textarea.nextSibling);
          }, options);
          return cm;
        }
        function addLegacyProps(CodeMirror4) {
          CodeMirror4.off = off;
          CodeMirror4.on = on;
          CodeMirror4.wheelEventPixels = wheelEventPixels;
          CodeMirror4.Doc = Doc;
          CodeMirror4.splitLines = splitLinesAuto;
          CodeMirror4.countColumn = countColumn;
          CodeMirror4.findColumn = findColumn;
          CodeMirror4.isWordChar = isWordCharBasic;
          CodeMirror4.Pass = Pass;
          CodeMirror4.signal = signal;
          CodeMirror4.Line = Line;
          CodeMirror4.changeEnd = changeEnd;
          CodeMirror4.scrollbarModel = scrollbarModel;
          CodeMirror4.Pos = Pos;
          CodeMirror4.cmpPos = cmp;
          CodeMirror4.modes = modes;
          CodeMirror4.mimeModes = mimeModes;
          CodeMirror4.resolveMode = resolveMode;
          CodeMirror4.getMode = getMode;
          CodeMirror4.modeExtensions = modeExtensions;
          CodeMirror4.extendMode = extendMode;
          CodeMirror4.copyState = copyState;
          CodeMirror4.startState = startState;
          CodeMirror4.innerMode = innerMode;
          CodeMirror4.commands = commands;
          CodeMirror4.keyMap = keyMap;
          CodeMirror4.keyName = keyName;
          CodeMirror4.isModifierKey = isModifierKey;
          CodeMirror4.lookupKey = lookupKey;
          CodeMirror4.normalizeKeyMap = normalizeKeyMap;
          CodeMirror4.StringStream = StringStream;
          CodeMirror4.SharedTextMarker = SharedTextMarker;
          CodeMirror4.TextMarker = TextMarker;
          CodeMirror4.LineWidget = LineWidget;
          CodeMirror4.e_preventDefault = e_preventDefault;
          CodeMirror4.e_stopPropagation = e_stopPropagation;
          CodeMirror4.e_stop = e_stop;
          CodeMirror4.addClass = addClass;
          CodeMirror4.contains = contains2;
          CodeMirror4.rmClass = rmClass;
          CodeMirror4.keyNames = keyNames;
        }
        defineOptions(CodeMirror3);
        addEditorMethods(CodeMirror3);
        var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
        for (var prop in Doc.prototype) {
          if (Doc.prototype.hasOwnProperty(prop) && indexOf2(dontDelegate, prop) < 0) {
            CodeMirror3.prototype[prop] = function(method) {
              return function() {
                return method.apply(this.doc, arguments);
              };
            }(Doc.prototype[prop]);
          }
        }
        eventMixin(Doc);
        CodeMirror3.inputStyles = { "textarea": TextareaInput, "contenteditable": ContentEditableInput };
        CodeMirror3.defineMode = function(name) {
          if (!CodeMirror3.defaults.mode && name != "null") {
            CodeMirror3.defaults.mode = name;
          }
          defineMode.apply(this, arguments);
        };
        CodeMirror3.defineMIME = defineMIME;
        CodeMirror3.defineMode("null", function() {
          return { token: function(stream) {
            return stream.skipToEnd();
          } };
        });
        CodeMirror3.defineMIME("text/plain", "null");
        CodeMirror3.defineExtension = function(name, func) {
          CodeMirror3.prototype[name] = func;
        };
        CodeMirror3.defineDocExtension = function(name, func) {
          Doc.prototype[name] = func;
        };
        CodeMirror3.fromTextArea = fromTextArea;
        addLegacyProps(CodeMirror3);
        CodeMirror3.version = "5.59.1";
        return CodeMirror3;
      });
    }
  });

  // node_modules/simplemde/node_modules/codemirror/addon/edit/continuelist.js
  var require_continuelist = __commonJS({
    "node_modules/simplemde/node_modules/codemirror/addon/edit/continuelist.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror2());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        var listRE = /^(\s*)(>[> ]*|[*+-] \[[x ]\]\s|[*+-]\s|(\d+)([.)]))(\s*)/, emptyListRE = /^(\s*)(>[> ]*|[*+-] \[[x ]\]|[*+-]|(\d+)[.)])(\s*)$/, unorderedListRE = /[*+-]\s/;
        CodeMirror3.commands.newlineAndIndentContinueMarkdownList = function(cm) {
          if (cm.getOption("disableInput"))
            return CodeMirror3.Pass;
          var ranges = cm.listSelections(), replacements = [];
          for (var i2 = 0; i2 < ranges.length; i2++) {
            var pos = ranges[i2].head;
            var eolState = cm.getStateAfter(pos.line);
            var inner = CodeMirror3.innerMode(cm.getMode(), eolState);
            if (inner.mode.name !== "markdown") {
              cm.execCommand("newlineAndIndent");
              return;
            } else {
              eolState = inner.state;
            }
            var inList = eolState.list !== false;
            var inQuote = eolState.quote !== 0;
            var line = cm.getLine(pos.line), match = listRE.exec(line);
            var cursorBeforeBullet = /^\s*$/.test(line.slice(0, pos.ch));
            if (!ranges[i2].empty() || !inList && !inQuote || !match || cursorBeforeBullet) {
              cm.execCommand("newlineAndIndent");
              return;
            }
            if (emptyListRE.test(line)) {
              var endOfQuote = inQuote && />\s*$/.test(line);
              var endOfList = !/>\s*$/.test(line);
              if (endOfQuote || endOfList)
                cm.replaceRange("", {
                  line: pos.line,
                  ch: 0
                }, {
                  line: pos.line,
                  ch: pos.ch + 1
                });
              replacements[i2] = "\n";
            } else {
              var indent = match[1], after = match[5];
              var numbered = !(unorderedListRE.test(match[2]) || match[2].indexOf(">") >= 0);
              var bullet = numbered ? parseInt(match[3], 10) + 1 + match[4] : match[2].replace("x", " ");
              replacements[i2] = "\n" + indent + bullet + after;
              if (numbered)
                incrementRemainingMarkdownListNumbers(cm, pos);
            }
          }
          cm.replaceSelections(replacements);
        };
        function incrementRemainingMarkdownListNumbers(cm, pos) {
          var startLine = pos.line, lookAhead = 0, skipCount = 0;
          var startItem = listRE.exec(cm.getLine(startLine)), startIndent = startItem[1];
          do {
            lookAhead += 1;
            var nextLineNumber = startLine + lookAhead;
            var nextLine = cm.getLine(nextLineNumber), nextItem = listRE.exec(nextLine);
            if (nextItem) {
              var nextIndent = nextItem[1];
              var newNumber = parseInt(startItem[3], 10) + lookAhead - skipCount;
              var nextNumber = parseInt(nextItem[3], 10), itemNumber = nextNumber;
              if (startIndent === nextIndent && !isNaN(nextNumber)) {
                if (newNumber === nextNumber)
                  itemNumber = nextNumber + 1;
                if (newNumber > nextNumber)
                  itemNumber = newNumber + 1;
                cm.replaceRange(nextLine.replace(listRE, nextIndent + itemNumber + nextItem[4] + nextItem[5]), {
                  line: nextLineNumber,
                  ch: 0
                }, {
                  line: nextLineNumber,
                  ch: nextLine.length
                });
              } else {
                if (startIndent.length > nextIndent.length)
                  return;
                if (startIndent.length < nextIndent.length && lookAhead === 1)
                  return;
                skipCount += 1;
              }
            }
          } while (nextItem);
        }
      });
    }
  });

  // node_modules/simplemde/src/js/codemirror/tablist.js
  var require_tablist = __commonJS({
    "node_modules/simplemde/src/js/codemirror/tablist.js"() {
      var CodeMirror3 = require_codemirror2();
      CodeMirror3.commands.tabAndIndentMarkdownList = function(cm) {
        var ranges = cm.listSelections();
        var pos = ranges[0].head;
        var eolState = cm.getStateAfter(pos.line);
        var inList = eolState.list !== false;
        if (inList) {
          cm.execCommand("indentMore");
          return;
        }
        if (cm.options.indentWithTabs) {
          cm.execCommand("insertTab");
        } else {
          var spaces = Array(cm.options.tabSize + 1).join(" ");
          cm.replaceSelection(spaces);
        }
      };
      CodeMirror3.commands.shiftTabAndUnindentMarkdownList = function(cm) {
        var ranges = cm.listSelections();
        var pos = ranges[0].head;
        var eolState = cm.getStateAfter(pos.line);
        var inList = eolState.list !== false;
        if (inList) {
          cm.execCommand("indentLess");
          return;
        }
        if (cm.options.indentWithTabs) {
          cm.execCommand("insertTab");
        } else {
          var spaces = Array(cm.options.tabSize + 1).join(" ");
          cm.replaceSelection(spaces);
        }
      };
    }
  });

  // node_modules/simplemde/node_modules/codemirror/addon/display/fullscreen.js
  var require_fullscreen = __commonJS({
    "node_modules/simplemde/node_modules/codemirror/addon/display/fullscreen.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror2());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.defineOption("fullScreen", false, function(cm, val, old) {
          if (old == CodeMirror3.Init)
            old = false;
          if (!old == !val)
            return;
          if (val)
            setFullscreen(cm);
          else
            setNormal(cm);
        });
        function setFullscreen(cm) {
          var wrap2 = cm.getWrapperElement();
          cm.state.fullScreenRestore = {
            scrollTop: window.pageYOffset,
            scrollLeft: window.pageXOffset,
            width: wrap2.style.width,
            height: wrap2.style.height
          };
          wrap2.style.width = "";
          wrap2.style.height = "auto";
          wrap2.className += " CodeMirror-fullscreen";
          document.documentElement.style.overflow = "hidden";
          cm.refresh();
        }
        function setNormal(cm) {
          var wrap2 = cm.getWrapperElement();
          wrap2.className = wrap2.className.replace(/\s*CodeMirror-fullscreen\b/, "");
          document.documentElement.style.overflow = "";
          var info = cm.state.fullScreenRestore;
          wrap2.style.width = info.width;
          wrap2.style.height = info.height;
          window.scrollTo(info.scrollLeft, info.scrollTop);
          cm.refresh();
        }
      });
    }
  });

  // node_modules/simplemde/node_modules/codemirror/mode/xml/xml.js
  var require_xml2 = __commonJS({
    "node_modules/simplemde/node_modules/codemirror/mode/xml/xml.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror2());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        var htmlConfig = {
          autoSelfClosers: {
            "area": true,
            "base": true,
            "br": true,
            "col": true,
            "command": true,
            "embed": true,
            "frame": true,
            "hr": true,
            "img": true,
            "input": true,
            "keygen": true,
            "link": true,
            "meta": true,
            "param": true,
            "source": true,
            "track": true,
            "wbr": true,
            "menuitem": true
          },
          implicitlyClosed: {
            "dd": true,
            "li": true,
            "optgroup": true,
            "option": true,
            "p": true,
            "rp": true,
            "rt": true,
            "tbody": true,
            "td": true,
            "tfoot": true,
            "th": true,
            "tr": true
          },
          contextGrabbers: {
            "dd": { "dd": true, "dt": true },
            "dt": { "dd": true, "dt": true },
            "li": { "li": true },
            "option": { "option": true, "optgroup": true },
            "optgroup": { "optgroup": true },
            "p": {
              "address": true,
              "article": true,
              "aside": true,
              "blockquote": true,
              "dir": true,
              "div": true,
              "dl": true,
              "fieldset": true,
              "footer": true,
              "form": true,
              "h1": true,
              "h2": true,
              "h3": true,
              "h4": true,
              "h5": true,
              "h6": true,
              "header": true,
              "hgroup": true,
              "hr": true,
              "menu": true,
              "nav": true,
              "ol": true,
              "p": true,
              "pre": true,
              "section": true,
              "table": true,
              "ul": true
            },
            "rp": { "rp": true, "rt": true },
            "rt": { "rp": true, "rt": true },
            "tbody": { "tbody": true, "tfoot": true },
            "td": { "td": true, "th": true },
            "tfoot": { "tbody": true },
            "th": { "td": true, "th": true },
            "thead": { "tbody": true, "tfoot": true },
            "tr": { "tr": true }
          },
          doNotIndent: { "pre": true },
          allowUnquoted: true,
          allowMissing: true,
          caseFold: true
        };
        var xmlConfig = {
          autoSelfClosers: {},
          implicitlyClosed: {},
          contextGrabbers: {},
          doNotIndent: {},
          allowUnquoted: false,
          allowMissing: false,
          allowMissingTagName: false,
          caseFold: false
        };
        CodeMirror3.defineMode("xml", function(editorConf, config_) {
          var indentUnit = editorConf.indentUnit;
          var config = {};
          var defaults2 = config_.htmlMode ? htmlConfig : xmlConfig;
          for (var prop in defaults2)
            config[prop] = defaults2[prop];
          for (var prop in config_)
            config[prop] = config_[prop];
          var type, setStyle2;
          function inText(stream, state) {
            function chain(parser) {
              state.tokenize = parser;
              return parser(stream, state);
            }
            var ch = stream.next();
            if (ch == "<") {
              if (stream.eat("!")) {
                if (stream.eat("[")) {
                  if (stream.match("CDATA["))
                    return chain(inBlock("atom", "]]>"));
                  else
                    return null;
                } else if (stream.match("--")) {
                  return chain(inBlock("comment", "-->"));
                } else if (stream.match("DOCTYPE", true, true)) {
                  stream.eatWhile(/[\w\._\-]/);
                  return chain(doctype(1));
                } else {
                  return null;
                }
              } else if (stream.eat("?")) {
                stream.eatWhile(/[\w\._\-]/);
                state.tokenize = inBlock("meta", "?>");
                return "meta";
              } else {
                type = stream.eat("/") ? "closeTag" : "openTag";
                state.tokenize = inTag;
                return "tag bracket";
              }
            } else if (ch == "&") {
              var ok;
              if (stream.eat("#")) {
                if (stream.eat("x")) {
                  ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
                } else {
                  ok = stream.eatWhile(/[\d]/) && stream.eat(";");
                }
              } else {
                ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
              }
              return ok ? "atom" : "error";
            } else {
              stream.eatWhile(/[^&<]/);
              return null;
            }
          }
          inText.isInText = true;
          function inTag(stream, state) {
            var ch = stream.next();
            if (ch == ">" || ch == "/" && stream.eat(">")) {
              state.tokenize = inText;
              type = ch == ">" ? "endTag" : "selfcloseTag";
              return "tag bracket";
            } else if (ch == "=") {
              type = "equals";
              return null;
            } else if (ch == "<") {
              state.tokenize = inText;
              state.state = baseState;
              state.tagName = state.tagStart = null;
              var next = state.tokenize(stream, state);
              return next ? next + " tag error" : "tag error";
            } else if (/[\'\"]/.test(ch)) {
              state.tokenize = inAttribute(ch);
              state.stringStartCol = stream.column();
              return state.tokenize(stream, state);
            } else {
              stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
              return "word";
            }
          }
          function inAttribute(quote) {
            var closure = function(stream, state) {
              while (!stream.eol()) {
                if (stream.next() == quote) {
                  state.tokenize = inTag;
                  break;
                }
              }
              return "string";
            };
            closure.isInAttribute = true;
            return closure;
          }
          function inBlock(style, terminator) {
            return function(stream, state) {
              while (!stream.eol()) {
                if (stream.match(terminator)) {
                  state.tokenize = inText;
                  break;
                }
                stream.next();
              }
              return style;
            };
          }
          function doctype(depth) {
            return function(stream, state) {
              var ch;
              while ((ch = stream.next()) != null) {
                if (ch == "<") {
                  state.tokenize = doctype(depth + 1);
                  return state.tokenize(stream, state);
                } else if (ch == ">") {
                  if (depth == 1) {
                    state.tokenize = inText;
                    break;
                  } else {
                    state.tokenize = doctype(depth - 1);
                    return state.tokenize(stream, state);
                  }
                }
              }
              return "meta";
            };
          }
          function Context2(state, tagName, startOfLine) {
            this.prev = state.context;
            this.tagName = tagName || "";
            this.indent = state.indented;
            this.startOfLine = startOfLine;
            if (config.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent)
              this.noIndent = true;
          }
          function popContext(state) {
            if (state.context)
              state.context = state.context.prev;
          }
          function maybePopContext(state, nextTagName) {
            var parentTagName;
            while (true) {
              if (!state.context) {
                return;
              }
              parentTagName = state.context.tagName;
              if (!config.contextGrabbers.hasOwnProperty(parentTagName) || !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
                return;
              }
              popContext(state);
            }
          }
          function baseState(type2, stream, state) {
            if (type2 == "openTag") {
              state.tagStart = stream.column();
              return tagNameState;
            } else if (type2 == "closeTag") {
              return closeTagNameState;
            } else {
              return baseState;
            }
          }
          function tagNameState(type2, stream, state) {
            if (type2 == "word") {
              state.tagName = stream.current();
              setStyle2 = "tag";
              return attrState;
            } else if (config.allowMissingTagName && type2 == "endTag") {
              setStyle2 = "tag bracket";
              return attrState(type2, stream, state);
            } else {
              setStyle2 = "error";
              return tagNameState;
            }
          }
          function closeTagNameState(type2, stream, state) {
            if (type2 == "word") {
              var tagName = stream.current();
              if (state.context && state.context.tagName != tagName && config.implicitlyClosed.hasOwnProperty(state.context.tagName))
                popContext(state);
              if (state.context && state.context.tagName == tagName || config.matchClosing === false) {
                setStyle2 = "tag";
                return closeState;
              } else {
                setStyle2 = "tag error";
                return closeStateErr;
              }
            } else if (config.allowMissingTagName && type2 == "endTag") {
              setStyle2 = "tag bracket";
              return closeState(type2, stream, state);
            } else {
              setStyle2 = "error";
              return closeStateErr;
            }
          }
          function closeState(type2, _stream, state) {
            if (type2 != "endTag") {
              setStyle2 = "error";
              return closeState;
            }
            popContext(state);
            return baseState;
          }
          function closeStateErr(type2, stream, state) {
            setStyle2 = "error";
            return closeState(type2, stream, state);
          }
          function attrState(type2, _stream, state) {
            if (type2 == "word") {
              setStyle2 = "attribute";
              return attrEqState;
            } else if (type2 == "endTag" || type2 == "selfcloseTag") {
              var tagName = state.tagName, tagStart = state.tagStart;
              state.tagName = state.tagStart = null;
              if (type2 == "selfcloseTag" || config.autoSelfClosers.hasOwnProperty(tagName)) {
                maybePopContext(state, tagName);
              } else {
                maybePopContext(state, tagName);
                state.context = new Context2(state, tagName, tagStart == state.indented);
              }
              return baseState;
            }
            setStyle2 = "error";
            return attrState;
          }
          function attrEqState(type2, stream, state) {
            if (type2 == "equals")
              return attrValueState;
            if (!config.allowMissing)
              setStyle2 = "error";
            return attrState(type2, stream, state);
          }
          function attrValueState(type2, stream, state) {
            if (type2 == "string")
              return attrContinuedState;
            if (type2 == "word" && config.allowUnquoted) {
              setStyle2 = "string";
              return attrState;
            }
            setStyle2 = "error";
            return attrState(type2, stream, state);
          }
          function attrContinuedState(type2, stream, state) {
            if (type2 == "string")
              return attrContinuedState;
            return attrState(type2, stream, state);
          }
          return {
            startState: function(baseIndent) {
              var state = {
                tokenize: inText,
                state: baseState,
                indented: baseIndent || 0,
                tagName: null,
                tagStart: null,
                context: null
              };
              if (baseIndent != null)
                state.baseIndent = baseIndent;
              return state;
            },
            token: function(stream, state) {
              if (!state.tagName && stream.sol())
                state.indented = stream.indentation();
              if (stream.eatSpace())
                return null;
              type = null;
              var style = state.tokenize(stream, state);
              if ((style || type) && style != "comment") {
                setStyle2 = null;
                state.state = state.state(type || style, stream, state);
                if (setStyle2)
                  style = setStyle2 == "error" ? style + " error" : setStyle2;
              }
              return style;
            },
            indent: function(state, textAfter, fullLine) {
              var context = state.context;
              if (state.tokenize.isInAttribute) {
                if (state.tagStart == state.indented)
                  return state.stringStartCol + 1;
                else
                  return state.indented + indentUnit;
              }
              if (context && context.noIndent)
                return CodeMirror3.Pass;
              if (state.tokenize != inTag && state.tokenize != inText)
                return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
              if (state.tagName) {
                if (config.multilineTagIndentPastTag !== false)
                  return state.tagStart + state.tagName.length + 2;
                else
                  return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
              }
              if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter))
                return 0;
              var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
              if (tagAfter && tagAfter[1]) {
                while (context) {
                  if (context.tagName == tagAfter[2]) {
                    context = context.prev;
                    break;
                  } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {
                    context = context.prev;
                  } else {
                    break;
                  }
                }
              } else if (tagAfter) {
                while (context) {
                  var grabbers = config.contextGrabbers[context.tagName];
                  if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))
                    context = context.prev;
                  else
                    break;
                }
              }
              while (context && context.prev && !context.startOfLine)
                context = context.prev;
              if (context)
                return context.indent + indentUnit;
              else
                return state.baseIndent || 0;
            },
            electricInput: /<\/[\s\w:]+>$/,
            blockCommentStart: "<!--",
            blockCommentEnd: "-->",
            configuration: config.htmlMode ? "html" : "xml",
            helperType: config.htmlMode ? "html" : "xml",
            skipAttribute: function(state) {
              if (state.state == attrValueState)
                state.state = attrState;
            },
            xmlCurrentTag: function(state) {
              return state.tagName ? { name: state.tagName, close: state.type == "closeTag" } : null;
            },
            xmlCurrentContext: function(state) {
              var context = [];
              for (var cx = state.context; cx; cx = cx.prev)
                context.push(cx.tagName);
              return context.reverse();
            }
          };
        });
        CodeMirror3.defineMIME("text/xml", "xml");
        CodeMirror3.defineMIME("application/xml", "xml");
        if (!CodeMirror3.mimeModes.hasOwnProperty("text/html"))
          CodeMirror3.defineMIME("text/html", { name: "xml", htmlMode: true });
      });
    }
  });

  // node_modules/simplemde/node_modules/codemirror/mode/meta.js
  var require_meta2 = __commonJS({
    "node_modules/simplemde/node_modules/codemirror/mode/meta.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror2());
        else if (typeof define == "function" && define.amd)
          define(["../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.modeInfo = [
          { name: "APL", mime: "text/apl", mode: "apl", ext: ["dyalog", "apl"] },
          { name: "PGP", mimes: ["application/pgp", "application/pgp-encrypted", "application/pgp-keys", "application/pgp-signature"], mode: "asciiarmor", ext: ["asc", "pgp", "sig"] },
          { name: "ASN.1", mime: "text/x-ttcn-asn", mode: "asn.1", ext: ["asn", "asn1"] },
          { name: "Asterisk", mime: "text/x-asterisk", mode: "asterisk", file: /^extensions\.conf$/i },
          { name: "Brainfuck", mime: "text/x-brainfuck", mode: "brainfuck", ext: ["b", "bf"] },
          { name: "C", mime: "text/x-csrc", mode: "clike", ext: ["c", "h", "ino"] },
          { name: "C++", mime: "text/x-c++src", mode: "clike", ext: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"], alias: ["cpp"] },
          { name: "Cobol", mime: "text/x-cobol", mode: "cobol", ext: ["cob", "cpy"] },
          { name: "C#", mime: "text/x-csharp", mode: "clike", ext: ["cs"], alias: ["csharp", "cs"] },
          { name: "Clojure", mime: "text/x-clojure", mode: "clojure", ext: ["clj", "cljc", "cljx"] },
          { name: "ClojureScript", mime: "text/x-clojurescript", mode: "clojure", ext: ["cljs"] },
          { name: "Closure Stylesheets (GSS)", mime: "text/x-gss", mode: "css", ext: ["gss"] },
          { name: "CMake", mime: "text/x-cmake", mode: "cmake", ext: ["cmake", "cmake.in"], file: /^CMakeLists\.txt$/ },
          { name: "CoffeeScript", mimes: ["application/vnd.coffeescript", "text/coffeescript", "text/x-coffeescript"], mode: "coffeescript", ext: ["coffee"], alias: ["coffee", "coffee-script"] },
          { name: "Common Lisp", mime: "text/x-common-lisp", mode: "commonlisp", ext: ["cl", "lisp", "el"], alias: ["lisp"] },
          { name: "Cypher", mime: "application/x-cypher-query", mode: "cypher", ext: ["cyp", "cypher"] },
          { name: "Cython", mime: "text/x-cython", mode: "python", ext: ["pyx", "pxd", "pxi"] },
          { name: "Crystal", mime: "text/x-crystal", mode: "crystal", ext: ["cr"] },
          { name: "CSS", mime: "text/css", mode: "css", ext: ["css"] },
          { name: "CQL", mime: "text/x-cassandra", mode: "sql", ext: ["cql"] },
          { name: "D", mime: "text/x-d", mode: "d", ext: ["d"] },
          { name: "Dart", mimes: ["application/dart", "text/x-dart"], mode: "dart", ext: ["dart"] },
          { name: "diff", mime: "text/x-diff", mode: "diff", ext: ["diff", "patch"] },
          { name: "Django", mime: "text/x-django", mode: "django" },
          { name: "Dockerfile", mime: "text/x-dockerfile", mode: "dockerfile", file: /^Dockerfile$/ },
          { name: "DTD", mime: "application/xml-dtd", mode: "dtd", ext: ["dtd"] },
          { name: "Dylan", mime: "text/x-dylan", mode: "dylan", ext: ["dylan", "dyl", "intr"] },
          { name: "EBNF", mime: "text/x-ebnf", mode: "ebnf" },
          { name: "ECL", mime: "text/x-ecl", mode: "ecl", ext: ["ecl"] },
          { name: "edn", mime: "application/edn", mode: "clojure", ext: ["edn"] },
          { name: "Eiffel", mime: "text/x-eiffel", mode: "eiffel", ext: ["e"] },
          { name: "Elm", mime: "text/x-elm", mode: "elm", ext: ["elm"] },
          { name: "Embedded Javascript", mime: "application/x-ejs", mode: "htmlembedded", ext: ["ejs"] },
          { name: "Embedded Ruby", mime: "application/x-erb", mode: "htmlembedded", ext: ["erb"] },
          { name: "Erlang", mime: "text/x-erlang", mode: "erlang", ext: ["erl"] },
          { name: "Esper", mime: "text/x-esper", mode: "sql" },
          { name: "Factor", mime: "text/x-factor", mode: "factor", ext: ["factor"] },
          { name: "FCL", mime: "text/x-fcl", mode: "fcl" },
          { name: "Forth", mime: "text/x-forth", mode: "forth", ext: ["forth", "fth", "4th"] },
          { name: "Fortran", mime: "text/x-fortran", mode: "fortran", ext: ["f", "for", "f77", "f90", "f95"] },
          { name: "F#", mime: "text/x-fsharp", mode: "mllike", ext: ["fs"], alias: ["fsharp"] },
          { name: "Gas", mime: "text/x-gas", mode: "gas", ext: ["s"] },
          { name: "Gherkin", mime: "text/x-feature", mode: "gherkin", ext: ["feature"] },
          { name: "GitHub Flavored Markdown", mime: "text/x-gfm", mode: "gfm", file: /^(readme|contributing|history)\.md$/i },
          { name: "Go", mime: "text/x-go", mode: "go", ext: ["go"] },
          { name: "Groovy", mime: "text/x-groovy", mode: "groovy", ext: ["groovy", "gradle"], file: /^Jenkinsfile$/ },
          { name: "HAML", mime: "text/x-haml", mode: "haml", ext: ["haml"] },
          { name: "Haskell", mime: "text/x-haskell", mode: "haskell", ext: ["hs"] },
          { name: "Haskell (Literate)", mime: "text/x-literate-haskell", mode: "haskell-literate", ext: ["lhs"] },
          { name: "Haxe", mime: "text/x-haxe", mode: "haxe", ext: ["hx"] },
          { name: "HXML", mime: "text/x-hxml", mode: "haxe", ext: ["hxml"] },
          { name: "ASP.NET", mime: "application/x-aspx", mode: "htmlembedded", ext: ["aspx"], alias: ["asp", "aspx"] },
          { name: "HTML", mime: "text/html", mode: "htmlmixed", ext: ["html", "htm", "handlebars", "hbs"], alias: ["xhtml"] },
          { name: "HTTP", mime: "message/http", mode: "http" },
          { name: "IDL", mime: "text/x-idl", mode: "idl", ext: ["pro"] },
          { name: "Pug", mime: "text/x-pug", mode: "pug", ext: ["jade", "pug"], alias: ["jade"] },
          { name: "Java", mime: "text/x-java", mode: "clike", ext: ["java"] },
          { name: "Java Server Pages", mime: "application/x-jsp", mode: "htmlembedded", ext: ["jsp"], alias: ["jsp"] },
          {
            name: "JavaScript",
            mimes: ["text/javascript", "text/ecmascript", "application/javascript", "application/x-javascript", "application/ecmascript"],
            mode: "javascript",
            ext: ["js"],
            alias: ["ecmascript", "js", "node"]
          },
          { name: "JSON", mimes: ["application/json", "application/x-json"], mode: "javascript", ext: ["json", "map"], alias: ["json5"] },
          { name: "JSON-LD", mime: "application/ld+json", mode: "javascript", ext: ["jsonld"], alias: ["jsonld"] },
          { name: "JSX", mime: "text/jsx", mode: "jsx", ext: ["jsx"] },
          { name: "Jinja2", mime: "text/jinja2", mode: "jinja2", ext: ["j2", "jinja", "jinja2"] },
          { name: "Julia", mime: "text/x-julia", mode: "julia", ext: ["jl"] },
          { name: "Kotlin", mime: "text/x-kotlin", mode: "clike", ext: ["kt"] },
          { name: "LESS", mime: "text/x-less", mode: "css", ext: ["less"] },
          { name: "LiveScript", mime: "text/x-livescript", mode: "livescript", ext: ["ls"], alias: ["ls"] },
          { name: "Lua", mime: "text/x-lua", mode: "lua", ext: ["lua"] },
          { name: "Markdown", mime: "text/x-markdown", mode: "markdown", ext: ["markdown", "md", "mkd"] },
          { name: "mIRC", mime: "text/mirc", mode: "mirc" },
          { name: "MariaDB SQL", mime: "text/x-mariadb", mode: "sql" },
          { name: "Mathematica", mime: "text/x-mathematica", mode: "mathematica", ext: ["m", "nb", "wl", "wls"] },
          { name: "Modelica", mime: "text/x-modelica", mode: "modelica", ext: ["mo"] },
          { name: "MUMPS", mime: "text/x-mumps", mode: "mumps", ext: ["mps"] },
          { name: "MS SQL", mime: "text/x-mssql", mode: "sql" },
          { name: "mbox", mime: "application/mbox", mode: "mbox", ext: ["mbox"] },
          { name: "MySQL", mime: "text/x-mysql", mode: "sql" },
          { name: "Nginx", mime: "text/x-nginx-conf", mode: "nginx", file: /nginx.*\.conf$/i },
          { name: "NSIS", mime: "text/x-nsis", mode: "nsis", ext: ["nsh", "nsi"] },
          {
            name: "NTriples",
            mimes: ["application/n-triples", "application/n-quads", "text/n-triples"],
            mode: "ntriples",
            ext: ["nt", "nq"]
          },
          { name: "Objective-C", mime: "text/x-objectivec", mode: "clike", ext: ["m"], alias: ["objective-c", "objc"] },
          { name: "Objective-C++", mime: "text/x-objectivec++", mode: "clike", ext: ["mm"], alias: ["objective-c++", "objc++"] },
          { name: "OCaml", mime: "text/x-ocaml", mode: "mllike", ext: ["ml", "mli", "mll", "mly"] },
          { name: "Octave", mime: "text/x-octave", mode: "octave", ext: ["m"] },
          { name: "Oz", mime: "text/x-oz", mode: "oz", ext: ["oz"] },
          { name: "Pascal", mime: "text/x-pascal", mode: "pascal", ext: ["p", "pas"] },
          { name: "PEG.js", mime: "null", mode: "pegjs", ext: ["jsonld"] },
          { name: "Perl", mime: "text/x-perl", mode: "perl", ext: ["pl", "pm"] },
          { name: "PHP", mimes: ["text/x-php", "application/x-httpd-php", "application/x-httpd-php-open"], mode: "php", ext: ["php", "php3", "php4", "php5", "php7", "phtml"] },
          { name: "Pig", mime: "text/x-pig", mode: "pig", ext: ["pig"] },
          { name: "Plain Text", mime: "text/plain", mode: "null", ext: ["txt", "text", "conf", "def", "list", "log"] },
          { name: "PLSQL", mime: "text/x-plsql", mode: "sql", ext: ["pls"] },
          { name: "PostgreSQL", mime: "text/x-pgsql", mode: "sql" },
          { name: "PowerShell", mime: "application/x-powershell", mode: "powershell", ext: ["ps1", "psd1", "psm1"] },
          { name: "Properties files", mime: "text/x-properties", mode: "properties", ext: ["properties", "ini", "in"], alias: ["ini", "properties"] },
          { name: "ProtoBuf", mime: "text/x-protobuf", mode: "protobuf", ext: ["proto"] },
          { name: "Python", mime: "text/x-python", mode: "python", ext: ["BUILD", "bzl", "py", "pyw"], file: /^(BUCK|BUILD)$/ },
          { name: "Puppet", mime: "text/x-puppet", mode: "puppet", ext: ["pp"] },
          { name: "Q", mime: "text/x-q", mode: "q", ext: ["q"] },
          { name: "R", mime: "text/x-rsrc", mode: "r", ext: ["r", "R"], alias: ["rscript"] },
          { name: "reStructuredText", mime: "text/x-rst", mode: "rst", ext: ["rst"], alias: ["rst"] },
          { name: "RPM Changes", mime: "text/x-rpm-changes", mode: "rpm" },
          { name: "RPM Spec", mime: "text/x-rpm-spec", mode: "rpm", ext: ["spec"] },
          { name: "Ruby", mime: "text/x-ruby", mode: "ruby", ext: ["rb"], alias: ["jruby", "macruby", "rake", "rb", "rbx"] },
          { name: "Rust", mime: "text/x-rustsrc", mode: "rust", ext: ["rs"] },
          { name: "SAS", mime: "text/x-sas", mode: "sas", ext: ["sas"] },
          { name: "Sass", mime: "text/x-sass", mode: "sass", ext: ["sass"] },
          { name: "Scala", mime: "text/x-scala", mode: "clike", ext: ["scala"] },
          { name: "Scheme", mime: "text/x-scheme", mode: "scheme", ext: ["scm", "ss"] },
          { name: "SCSS", mime: "text/x-scss", mode: "css", ext: ["scss"] },
          { name: "Shell", mimes: ["text/x-sh", "application/x-sh"], mode: "shell", ext: ["sh", "ksh", "bash"], alias: ["bash", "sh", "zsh"], file: /^PKGBUILD$/ },
          { name: "Sieve", mime: "application/sieve", mode: "sieve", ext: ["siv", "sieve"] },
          { name: "Slim", mimes: ["text/x-slim", "application/x-slim"], mode: "slim", ext: ["slim"] },
          { name: "Smalltalk", mime: "text/x-stsrc", mode: "smalltalk", ext: ["st"] },
          { name: "Smarty", mime: "text/x-smarty", mode: "smarty", ext: ["tpl"] },
          { name: "Solr", mime: "text/x-solr", mode: "solr" },
          { name: "SML", mime: "text/x-sml", mode: "mllike", ext: ["sml", "sig", "fun", "smackspec"] },
          { name: "Soy", mime: "text/x-soy", mode: "soy", ext: ["soy"], alias: ["closure template"] },
          { name: "SPARQL", mime: "application/sparql-query", mode: "sparql", ext: ["rq", "sparql"], alias: ["sparul"] },
          { name: "Spreadsheet", mime: "text/x-spreadsheet", mode: "spreadsheet", alias: ["excel", "formula"] },
          { name: "SQL", mime: "text/x-sql", mode: "sql", ext: ["sql"] },
          { name: "SQLite", mime: "text/x-sqlite", mode: "sql" },
          { name: "Squirrel", mime: "text/x-squirrel", mode: "clike", ext: ["nut"] },
          { name: "Stylus", mime: "text/x-styl", mode: "stylus", ext: ["styl"] },
          { name: "Swift", mime: "text/x-swift", mode: "swift", ext: ["swift"] },
          { name: "sTeX", mime: "text/x-stex", mode: "stex" },
          { name: "LaTeX", mime: "text/x-latex", mode: "stex", ext: ["text", "ltx", "tex"], alias: ["tex"] },
          { name: "SystemVerilog", mime: "text/x-systemverilog", mode: "verilog", ext: ["v", "sv", "svh"] },
          { name: "Tcl", mime: "text/x-tcl", mode: "tcl", ext: ["tcl"] },
          { name: "Textile", mime: "text/x-textile", mode: "textile", ext: ["textile"] },
          { name: "TiddlyWiki", mime: "text/x-tiddlywiki", mode: "tiddlywiki" },
          { name: "Tiki wiki", mime: "text/tiki", mode: "tiki" },
          { name: "TOML", mime: "text/x-toml", mode: "toml", ext: ["toml"] },
          { name: "Tornado", mime: "text/x-tornado", mode: "tornado" },
          { name: "troff", mime: "text/troff", mode: "troff", ext: ["1", "2", "3", "4", "5", "6", "7", "8", "9"] },
          { name: "TTCN", mime: "text/x-ttcn", mode: "ttcn", ext: ["ttcn", "ttcn3", "ttcnpp"] },
          { name: "TTCN_CFG", mime: "text/x-ttcn-cfg", mode: "ttcn-cfg", ext: ["cfg"] },
          { name: "Turtle", mime: "text/turtle", mode: "turtle", ext: ["ttl"] },
          { name: "TypeScript", mime: "application/typescript", mode: "javascript", ext: ["ts"], alias: ["ts"] },
          { name: "TypeScript-JSX", mime: "text/typescript-jsx", mode: "jsx", ext: ["tsx"], alias: ["tsx"] },
          { name: "Twig", mime: "text/x-twig", mode: "twig" },
          { name: "Web IDL", mime: "text/x-webidl", mode: "webidl", ext: ["webidl"] },
          { name: "VB.NET", mime: "text/x-vb", mode: "vb", ext: ["vb"] },
          { name: "VBScript", mime: "text/vbscript", mode: "vbscript", ext: ["vbs"] },
          { name: "Velocity", mime: "text/velocity", mode: "velocity", ext: ["vtl"] },
          { name: "Verilog", mime: "text/x-verilog", mode: "verilog", ext: ["v"] },
          { name: "VHDL", mime: "text/x-vhdl", mode: "vhdl", ext: ["vhd", "vhdl"] },
          { name: "Vue.js Component", mimes: ["script/x-vue", "text/x-vue"], mode: "vue", ext: ["vue"] },
          { name: "XML", mimes: ["application/xml", "text/xml"], mode: "xml", ext: ["xml", "xsl", "xsd", "svg"], alias: ["rss", "wsdl", "xsd"] },
          { name: "XQuery", mime: "application/xquery", mode: "xquery", ext: ["xy", "xquery"] },
          { name: "Yacas", mime: "text/x-yacas", mode: "yacas", ext: ["ys"] },
          { name: "YAML", mimes: ["text/x-yaml", "text/yaml"], mode: "yaml", ext: ["yaml", "yml"], alias: ["yml"] },
          { name: "Z80", mime: "text/x-z80", mode: "z80", ext: ["z80"] },
          { name: "mscgen", mime: "text/x-mscgen", mode: "mscgen", ext: ["mscgen", "mscin", "msc"] },
          { name: "xu", mime: "text/x-xu", mode: "mscgen", ext: ["xu"] },
          { name: "msgenny", mime: "text/x-msgenny", mode: "mscgen", ext: ["msgenny"] },
          { name: "WebAssembly", mime: "text/webassembly", mode: "wast", ext: ["wat", "wast"] }
        ];
        for (var i2 = 0; i2 < CodeMirror3.modeInfo.length; i2++) {
          var info = CodeMirror3.modeInfo[i2];
          if (info.mimes)
            info.mime = info.mimes[0];
        }
        CodeMirror3.findModeByMIME = function(mime) {
          mime = mime.toLowerCase();
          for (var i3 = 0; i3 < CodeMirror3.modeInfo.length; i3++) {
            var info2 = CodeMirror3.modeInfo[i3];
            if (info2.mime == mime)
              return info2;
            if (info2.mimes) {
              for (var j2 = 0; j2 < info2.mimes.length; j2++)
                if (info2.mimes[j2] == mime)
                  return info2;
            }
          }
          if (/\+xml$/.test(mime))
            return CodeMirror3.findModeByMIME("application/xml");
          if (/\+json$/.test(mime))
            return CodeMirror3.findModeByMIME("application/json");
        };
        CodeMirror3.findModeByExtension = function(ext) {
          ext = ext.toLowerCase();
          for (var i3 = 0; i3 < CodeMirror3.modeInfo.length; i3++) {
            var info2 = CodeMirror3.modeInfo[i3];
            if (info2.ext) {
              for (var j2 = 0; j2 < info2.ext.length; j2++)
                if (info2.ext[j2] == ext)
                  return info2;
            }
          }
        };
        CodeMirror3.findModeByFileName = function(filename) {
          for (var i3 = 0; i3 < CodeMirror3.modeInfo.length; i3++) {
            var info2 = CodeMirror3.modeInfo[i3];
            if (info2.file && info2.file.test(filename))
              return info2;
          }
          var dot = filename.lastIndexOf(".");
          var ext = dot > -1 && filename.substring(dot + 1, filename.length);
          if (ext)
            return CodeMirror3.findModeByExtension(ext);
        };
        CodeMirror3.findModeByName = function(name) {
          name = name.toLowerCase();
          for (var i3 = 0; i3 < CodeMirror3.modeInfo.length; i3++) {
            var info2 = CodeMirror3.modeInfo[i3];
            if (info2.name.toLowerCase() == name)
              return info2;
            if (info2.alias) {
              for (var j2 = 0; j2 < info2.alias.length; j2++)
                if (info2.alias[j2].toLowerCase() == name)
                  return info2;
            }
          }
        };
      });
    }
  });

  // node_modules/simplemde/node_modules/codemirror/mode/markdown/markdown.js
  var require_markdown2 = __commonJS({
    "node_modules/simplemde/node_modules/codemirror/mode/markdown/markdown.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror2(), require_xml2(), require_meta2());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror", "../xml/xml", "../meta"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.defineMode("markdown", function(cmCfg, modeCfg) {
          var htmlMode = CodeMirror3.getMode(cmCfg, "text/html");
          var htmlModeMissing = htmlMode.name == "null";
          function getMode(name) {
            if (CodeMirror3.findModeByName) {
              var found = CodeMirror3.findModeByName(name);
              if (found)
                name = found.mime || found.mimes[0];
            }
            var mode2 = CodeMirror3.getMode(cmCfg, name);
            return mode2.name == "null" ? null : mode2;
          }
          if (modeCfg.highlightFormatting === void 0)
            modeCfg.highlightFormatting = false;
          if (modeCfg.maxBlockquoteDepth === void 0)
            modeCfg.maxBlockquoteDepth = 0;
          if (modeCfg.taskLists === void 0)
            modeCfg.taskLists = false;
          if (modeCfg.strikethrough === void 0)
            modeCfg.strikethrough = false;
          if (modeCfg.emoji === void 0)
            modeCfg.emoji = false;
          if (modeCfg.fencedCodeBlockHighlighting === void 0)
            modeCfg.fencedCodeBlockHighlighting = true;
          if (modeCfg.fencedCodeBlockDefaultMode === void 0)
            modeCfg.fencedCodeBlockDefaultMode = "text/plain";
          if (modeCfg.xml === void 0)
            modeCfg.xml = true;
          if (modeCfg.tokenTypeOverrides === void 0)
            modeCfg.tokenTypeOverrides = {};
          var tokenTypes = {
            header: "header",
            code: "comment",
            quote: "quote",
            list1: "variable-2",
            list2: "variable-3",
            list3: "keyword",
            hr: "hr",
            image: "image",
            imageAltText: "image-alt-text",
            imageMarker: "image-marker",
            formatting: "formatting",
            linkInline: "link",
            linkEmail: "link",
            linkText: "link",
            linkHref: "string",
            em: "em",
            strong: "strong",
            strikethrough: "strikethrough",
            emoji: "builtin"
          };
          for (var tokenType in tokenTypes) {
            if (tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType]) {
              tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];
            }
          }
          var hrRE = /^([*\-_])(?:\s*\1){2,}\s*$/, listRE = /^(?:[*\-+]|^[0-9]+([.)]))\s+/, taskListRE = /^\[(x| )\](?=\s)/i, atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/, setextHeaderRE = /^ {0,3}(?:\={1,}|-{2,})\s*$/, textRE = /^[^#!\[\]*_\\<>` "'(~:]+/, fencedCodeRE = /^(~~~+|```+)[ \t]*([\w\/+#-]*)[^\n`]*$/, linkDefRE = /^\s*\[[^\]]+?\]:.*$/, punctuation = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/, expandedTab = "    ";
          function switchInline(stream, state, f2) {
            state.f = state.inline = f2;
            return f2(stream, state);
          }
          function switchBlock(stream, state, f2) {
            state.f = state.block = f2;
            return f2(stream, state);
          }
          function lineIsEmpty(line) {
            return !line || !/\S/.test(line.string);
          }
          function blankLine(state) {
            state.linkTitle = false;
            state.linkHref = false;
            state.linkText = false;
            state.em = false;
            state.strong = false;
            state.strikethrough = false;
            state.quote = 0;
            state.indentedCode = false;
            if (state.f == htmlBlock) {
              var exit = htmlModeMissing;
              if (!exit) {
                var inner = CodeMirror3.innerMode(htmlMode, state.htmlState);
                exit = inner.mode.name == "xml" && inner.state.tagStart === null && (!inner.state.context && inner.state.tokenize.isInText);
              }
              if (exit) {
                state.f = inlineNormal;
                state.block = blockNormal;
                state.htmlState = null;
              }
            }
            state.trailingSpace = 0;
            state.trailingSpaceNewLine = false;
            state.prevLine = state.thisLine;
            state.thisLine = { stream: null };
            return null;
          }
          function blockNormal(stream, state) {
            var firstTokenOnLine = stream.column() === state.indentation;
            var prevLineLineIsEmpty = lineIsEmpty(state.prevLine.stream);
            var prevLineIsIndentedCode = state.indentedCode;
            var prevLineIsHr = state.prevLine.hr;
            var prevLineIsList = state.list !== false;
            var maxNonCodeIndentation = (state.listStack[state.listStack.length - 1] || 0) + 3;
            state.indentedCode = false;
            var lineIndentation = state.indentation;
            if (state.indentationDiff === null) {
              state.indentationDiff = state.indentation;
              if (prevLineIsList) {
                state.list = null;
                while (lineIndentation < state.listStack[state.listStack.length - 1]) {
                  state.listStack.pop();
                  if (state.listStack.length) {
                    state.indentation = state.listStack[state.listStack.length - 1];
                  } else {
                    state.list = false;
                  }
                }
                if (state.list !== false) {
                  state.indentationDiff = lineIndentation - state.listStack[state.listStack.length - 1];
                }
              }
            }
            var allowsInlineContinuation = !prevLineLineIsEmpty && !prevLineIsHr && !state.prevLine.header && (!prevLineIsList || !prevLineIsIndentedCode) && !state.prevLine.fencedCodeEnd;
            var isHr = (state.list === false || prevLineIsHr || prevLineLineIsEmpty) && state.indentation <= maxNonCodeIndentation && stream.match(hrRE);
            var match = null;
            if (state.indentationDiff >= 4 && (prevLineIsIndentedCode || state.prevLine.fencedCodeEnd || state.prevLine.header || prevLineLineIsEmpty)) {
              stream.skipToEnd();
              state.indentedCode = true;
              return tokenTypes.code;
            } else if (stream.eatSpace()) {
              return null;
            } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(atxHeaderRE)) && match[1].length <= 6) {
              state.quote = 0;
              state.header = match[1].length;
              state.thisLine.header = true;
              if (modeCfg.highlightFormatting)
                state.formatting = "header";
              state.f = state.inline;
              return getType(state);
            } else if (state.indentation <= maxNonCodeIndentation && stream.eat(">")) {
              state.quote = firstTokenOnLine ? 1 : state.quote + 1;
              if (modeCfg.highlightFormatting)
                state.formatting = "quote";
              stream.eatSpace();
              return getType(state);
            } else if (!isHr && !state.setext && firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(listRE))) {
              var listType = match[1] ? "ol" : "ul";
              state.indentation = lineIndentation + stream.current().length;
              state.list = true;
              state.quote = 0;
              state.listStack.push(state.indentation);
              state.em = false;
              state.strong = false;
              state.code = false;
              state.strikethrough = false;
              if (modeCfg.taskLists && stream.match(taskListRE, false)) {
                state.taskList = true;
              }
              state.f = state.inline;
              if (modeCfg.highlightFormatting)
                state.formatting = ["list", "list-" + listType];
              return getType(state);
            } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(fencedCodeRE, true))) {
              state.quote = 0;
              state.fencedEndRE = new RegExp(match[1] + "+ *$");
              state.localMode = modeCfg.fencedCodeBlockHighlighting && getMode(match[2] || modeCfg.fencedCodeBlockDefaultMode);
              if (state.localMode)
                state.localState = CodeMirror3.startState(state.localMode);
              state.f = state.block = local;
              if (modeCfg.highlightFormatting)
                state.formatting = "code-block";
              state.code = -1;
              return getType(state);
            } else if (state.setext || (!allowsInlineContinuation || !prevLineIsList) && !state.quote && state.list === false && !state.code && !isHr && !linkDefRE.test(stream.string) && (match = stream.lookAhead(1)) && (match = match.match(setextHeaderRE))) {
              if (!state.setext) {
                state.header = match[0].charAt(0) == "=" ? 1 : 2;
                state.setext = state.header;
              } else {
                state.header = state.setext;
                state.setext = 0;
                stream.skipToEnd();
                if (modeCfg.highlightFormatting)
                  state.formatting = "header";
              }
              state.thisLine.header = true;
              state.f = state.inline;
              return getType(state);
            } else if (isHr) {
              stream.skipToEnd();
              state.hr = true;
              state.thisLine.hr = true;
              return tokenTypes.hr;
            } else if (stream.peek() === "[") {
              return switchInline(stream, state, footnoteLink);
            }
            return switchInline(stream, state, state.inline);
          }
          function htmlBlock(stream, state) {
            var style = htmlMode.token(stream, state.htmlState);
            if (!htmlModeMissing) {
              var inner = CodeMirror3.innerMode(htmlMode, state.htmlState);
              if (inner.mode.name == "xml" && inner.state.tagStart === null && (!inner.state.context && inner.state.tokenize.isInText) || state.md_inside && stream.current().indexOf(">") > -1) {
                state.f = inlineNormal;
                state.block = blockNormal;
                state.htmlState = null;
              }
            }
            return style;
          }
          function local(stream, state) {
            var currListInd = state.listStack[state.listStack.length - 1] || 0;
            var hasExitedList = state.indentation < currListInd;
            var maxFencedEndInd = currListInd + 3;
            if (state.fencedEndRE && state.indentation <= maxFencedEndInd && (hasExitedList || stream.match(state.fencedEndRE))) {
              if (modeCfg.highlightFormatting)
                state.formatting = "code-block";
              var returnType;
              if (!hasExitedList)
                returnType = getType(state);
              state.localMode = state.localState = null;
              state.block = blockNormal;
              state.f = inlineNormal;
              state.fencedEndRE = null;
              state.code = 0;
              state.thisLine.fencedCodeEnd = true;
              if (hasExitedList)
                return switchBlock(stream, state, state.block);
              return returnType;
            } else if (state.localMode) {
              return state.localMode.token(stream, state.localState);
            } else {
              stream.skipToEnd();
              return tokenTypes.code;
            }
          }
          function getType(state) {
            var styles = [];
            if (state.formatting) {
              styles.push(tokenTypes.formatting);
              if (typeof state.formatting === "string")
                state.formatting = [state.formatting];
              for (var i2 = 0; i2 < state.formatting.length; i2++) {
                styles.push(tokenTypes.formatting + "-" + state.formatting[i2]);
                if (state.formatting[i2] === "header") {
                  styles.push(tokenTypes.formatting + "-" + state.formatting[i2] + "-" + state.header);
                }
                if (state.formatting[i2] === "quote") {
                  if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
                    styles.push(tokenTypes.formatting + "-" + state.formatting[i2] + "-" + state.quote);
                  } else {
                    styles.push("error");
                  }
                }
              }
            }
            if (state.taskOpen) {
              styles.push("meta");
              return styles.length ? styles.join(" ") : null;
            }
            if (state.taskClosed) {
              styles.push("property");
              return styles.length ? styles.join(" ") : null;
            }
            if (state.linkHref) {
              styles.push(tokenTypes.linkHref, "url");
            } else {
              if (state.strong) {
                styles.push(tokenTypes.strong);
              }
              if (state.em) {
                styles.push(tokenTypes.em);
              }
              if (state.strikethrough) {
                styles.push(tokenTypes.strikethrough);
              }
              if (state.emoji) {
                styles.push(tokenTypes.emoji);
              }
              if (state.linkText) {
                styles.push(tokenTypes.linkText);
              }
              if (state.code) {
                styles.push(tokenTypes.code);
              }
              if (state.image) {
                styles.push(tokenTypes.image);
              }
              if (state.imageAltText) {
                styles.push(tokenTypes.imageAltText, "link");
              }
              if (state.imageMarker) {
                styles.push(tokenTypes.imageMarker);
              }
            }
            if (state.header) {
              styles.push(tokenTypes.header, tokenTypes.header + "-" + state.header);
            }
            if (state.quote) {
              styles.push(tokenTypes.quote);
              if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
                styles.push(tokenTypes.quote + "-" + state.quote);
              } else {
                styles.push(tokenTypes.quote + "-" + modeCfg.maxBlockquoteDepth);
              }
            }
            if (state.list !== false) {
              var listMod = (state.listStack.length - 1) % 3;
              if (!listMod) {
                styles.push(tokenTypes.list1);
              } else if (listMod === 1) {
                styles.push(tokenTypes.list2);
              } else {
                styles.push(tokenTypes.list3);
              }
            }
            if (state.trailingSpaceNewLine) {
              styles.push("trailing-space-new-line");
            } else if (state.trailingSpace) {
              styles.push("trailing-space-" + (state.trailingSpace % 2 ? "a" : "b"));
            }
            return styles.length ? styles.join(" ") : null;
          }
          function handleText(stream, state) {
            if (stream.match(textRE, true)) {
              return getType(state);
            }
            return void 0;
          }
          function inlineNormal(stream, state) {
            var style = state.text(stream, state);
            if (typeof style !== "undefined")
              return style;
            if (state.list) {
              state.list = null;
              return getType(state);
            }
            if (state.taskList) {
              var taskOpen = stream.match(taskListRE, true)[1] === " ";
              if (taskOpen)
                state.taskOpen = true;
              else
                state.taskClosed = true;
              if (modeCfg.highlightFormatting)
                state.formatting = "task";
              state.taskList = false;
              return getType(state);
            }
            state.taskOpen = false;
            state.taskClosed = false;
            if (state.header && stream.match(/^#+$/, true)) {
              if (modeCfg.highlightFormatting)
                state.formatting = "header";
              return getType(state);
            }
            var ch = stream.next();
            if (state.linkTitle) {
              state.linkTitle = false;
              var matchCh = ch;
              if (ch === "(") {
                matchCh = ")";
              }
              matchCh = (matchCh + "").replace(/([.?*+^\[\]\\(){}|-])/g, "\\$1");
              var regex = "^\\s*(?:[^" + matchCh + "\\\\]+|\\\\\\\\|\\\\.)" + matchCh;
              if (stream.match(new RegExp(regex), true)) {
                return tokenTypes.linkHref;
              }
            }
            if (ch === "`") {
              var previousFormatting = state.formatting;
              if (modeCfg.highlightFormatting)
                state.formatting = "code";
              stream.eatWhile("`");
              var count = stream.current().length;
              if (state.code == 0 && (!state.quote || count == 1)) {
                state.code = count;
                return getType(state);
              } else if (count == state.code) {
                var t2 = getType(state);
                state.code = 0;
                return t2;
              } else {
                state.formatting = previousFormatting;
                return getType(state);
              }
            } else if (state.code) {
              return getType(state);
            }
            if (ch === "\\") {
              stream.next();
              if (modeCfg.highlightFormatting) {
                var type = getType(state);
                var formattingEscape = tokenTypes.formatting + "-escape";
                return type ? type + " " + formattingEscape : formattingEscape;
              }
            }
            if (ch === "!" && stream.match(/\[[^\]]*\] ?(?:\(|\[)/, false)) {
              state.imageMarker = true;
              state.image = true;
              if (modeCfg.highlightFormatting)
                state.formatting = "image";
              return getType(state);
            }
            if (ch === "[" && state.imageMarker && stream.match(/[^\]]*\](\(.*?\)| ?\[.*?\])/, false)) {
              state.imageMarker = false;
              state.imageAltText = true;
              if (modeCfg.highlightFormatting)
                state.formatting = "image";
              return getType(state);
            }
            if (ch === "]" && state.imageAltText) {
              if (modeCfg.highlightFormatting)
                state.formatting = "image";
              var type = getType(state);
              state.imageAltText = false;
              state.image = false;
              state.inline = state.f = linkHref;
              return type;
            }
            if (ch === "[" && !state.image) {
              if (state.linkText && stream.match(/^.*?\]/))
                return getType(state);
              state.linkText = true;
              if (modeCfg.highlightFormatting)
                state.formatting = "link";
              return getType(state);
            }
            if (ch === "]" && state.linkText) {
              if (modeCfg.highlightFormatting)
                state.formatting = "link";
              var type = getType(state);
              state.linkText = false;
              state.inline = state.f = stream.match(/\(.*?\)| ?\[.*?\]/, false) ? linkHref : inlineNormal;
              return type;
            }
            if (ch === "<" && stream.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, false)) {
              state.f = state.inline = linkInline;
              if (modeCfg.highlightFormatting)
                state.formatting = "link";
              var type = getType(state);
              if (type) {
                type += " ";
              } else {
                type = "";
              }
              return type + tokenTypes.linkInline;
            }
            if (ch === "<" && stream.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, false)) {
              state.f = state.inline = linkInline;
              if (modeCfg.highlightFormatting)
                state.formatting = "link";
              var type = getType(state);
              if (type) {
                type += " ";
              } else {
                type = "";
              }
              return type + tokenTypes.linkEmail;
            }
            if (modeCfg.xml && ch === "<" && stream.match(/^(!--|\?|!\[CDATA\[|[a-z][a-z0-9-]*(?:\s+[a-z_:.\-]+(?:\s*=\s*[^>]+)?)*\s*(?:>|$))/i, false)) {
              var end2 = stream.string.indexOf(">", stream.pos);
              if (end2 != -1) {
                var atts = stream.string.substring(stream.start, end2);
                if (/markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(atts))
                  state.md_inside = true;
              }
              stream.backUp(1);
              state.htmlState = CodeMirror3.startState(htmlMode);
              return switchBlock(stream, state, htmlBlock);
            }
            if (modeCfg.xml && ch === "<" && stream.match(/^\/\w*?>/)) {
              state.md_inside = false;
              return "tag";
            } else if (ch === "*" || ch === "_") {
              var len = 1, before = stream.pos == 1 ? " " : stream.string.charAt(stream.pos - 2);
              while (len < 3 && stream.eat(ch))
                len++;
              var after = stream.peek() || " ";
              var leftFlanking = !/\s/.test(after) && (!punctuation.test(after) || /\s/.test(before) || punctuation.test(before));
              var rightFlanking = !/\s/.test(before) && (!punctuation.test(before) || /\s/.test(after) || punctuation.test(after));
              var setEm = null, setStrong = null;
              if (len % 2) {
                if (!state.em && leftFlanking && (ch === "*" || !rightFlanking || punctuation.test(before)))
                  setEm = true;
                else if (state.em == ch && rightFlanking && (ch === "*" || !leftFlanking || punctuation.test(after)))
                  setEm = false;
              }
              if (len > 1) {
                if (!state.strong && leftFlanking && (ch === "*" || !rightFlanking || punctuation.test(before)))
                  setStrong = true;
                else if (state.strong == ch && rightFlanking && (ch === "*" || !leftFlanking || punctuation.test(after)))
                  setStrong = false;
              }
              if (setStrong != null || setEm != null) {
                if (modeCfg.highlightFormatting)
                  state.formatting = setEm == null ? "strong" : setStrong == null ? "em" : "strong em";
                if (setEm === true)
                  state.em = ch;
                if (setStrong === true)
                  state.strong = ch;
                var t2 = getType(state);
                if (setEm === false)
                  state.em = false;
                if (setStrong === false)
                  state.strong = false;
                return t2;
              }
            } else if (ch === " ") {
              if (stream.eat("*") || stream.eat("_")) {
                if (stream.peek() === " ") {
                  return getType(state);
                } else {
                  stream.backUp(1);
                }
              }
            }
            if (modeCfg.strikethrough) {
              if (ch === "~" && stream.eatWhile(ch)) {
                if (state.strikethrough) {
                  if (modeCfg.highlightFormatting)
                    state.formatting = "strikethrough";
                  var t2 = getType(state);
                  state.strikethrough = false;
                  return t2;
                } else if (stream.match(/^[^\s]/, false)) {
                  state.strikethrough = true;
                  if (modeCfg.highlightFormatting)
                    state.formatting = "strikethrough";
                  return getType(state);
                }
              } else if (ch === " ") {
                if (stream.match(/^~~/, true)) {
                  if (stream.peek() === " ") {
                    return getType(state);
                  } else {
                    stream.backUp(2);
                  }
                }
              }
            }
            if (modeCfg.emoji && ch === ":" && stream.match(/^(?:[a-z_\d+][a-z_\d+-]*|\-[a-z_\d+][a-z_\d+-]*):/)) {
              state.emoji = true;
              if (modeCfg.highlightFormatting)
                state.formatting = "emoji";
              var retType = getType(state);
              state.emoji = false;
              return retType;
            }
            if (ch === " ") {
              if (stream.match(/^ +$/, false)) {
                state.trailingSpace++;
              } else if (state.trailingSpace) {
                state.trailingSpaceNewLine = true;
              }
            }
            return getType(state);
          }
          function linkInline(stream, state) {
            var ch = stream.next();
            if (ch === ">") {
              state.f = state.inline = inlineNormal;
              if (modeCfg.highlightFormatting)
                state.formatting = "link";
              var type = getType(state);
              if (type) {
                type += " ";
              } else {
                type = "";
              }
              return type + tokenTypes.linkInline;
            }
            stream.match(/^[^>]+/, true);
            return tokenTypes.linkInline;
          }
          function linkHref(stream, state) {
            if (stream.eatSpace()) {
              return null;
            }
            var ch = stream.next();
            if (ch === "(" || ch === "[") {
              state.f = state.inline = getLinkHrefInside(ch === "(" ? ")" : "]");
              if (modeCfg.highlightFormatting)
                state.formatting = "link-string";
              state.linkHref = true;
              return getType(state);
            }
            return "error";
          }
          var linkRE = {
            ")": /^(?:[^\\\(\)]|\\.|\((?:[^\\\(\)]|\\.)*\))*?(?=\))/,
            "]": /^(?:[^\\\[\]]|\\.|\[(?:[^\\\[\]]|\\.)*\])*?(?=\])/
          };
          function getLinkHrefInside(endChar) {
            return function(stream, state) {
              var ch = stream.next();
              if (ch === endChar) {
                state.f = state.inline = inlineNormal;
                if (modeCfg.highlightFormatting)
                  state.formatting = "link-string";
                var returnState = getType(state);
                state.linkHref = false;
                return returnState;
              }
              stream.match(linkRE[endChar]);
              state.linkHref = true;
              return getType(state);
            };
          }
          function footnoteLink(stream, state) {
            if (stream.match(/^([^\]\\]|\\.)*\]:/, false)) {
              state.f = footnoteLinkInside;
              stream.next();
              if (modeCfg.highlightFormatting)
                state.formatting = "link";
              state.linkText = true;
              return getType(state);
            }
            return switchInline(stream, state, inlineNormal);
          }
          function footnoteLinkInside(stream, state) {
            if (stream.match(/^\]:/, true)) {
              state.f = state.inline = footnoteUrl;
              if (modeCfg.highlightFormatting)
                state.formatting = "link";
              var returnType = getType(state);
              state.linkText = false;
              return returnType;
            }
            stream.match(/^([^\]\\]|\\.)+/, true);
            return tokenTypes.linkText;
          }
          function footnoteUrl(stream, state) {
            if (stream.eatSpace()) {
              return null;
            }
            stream.match(/^[^\s]+/, true);
            if (stream.peek() === void 0) {
              state.linkTitle = true;
            } else {
              stream.match(/^(?:\s+(?:"(?:[^"\\]|\\\\|\\.)+"|'(?:[^'\\]|\\\\|\\.)+'|\((?:[^)\\]|\\\\|\\.)+\)))?/, true);
            }
            state.f = state.inline = inlineNormal;
            return tokenTypes.linkHref + " url";
          }
          var mode = {
            startState: function() {
              return {
                f: blockNormal,
                prevLine: { stream: null },
                thisLine: { stream: null },
                block: blockNormal,
                htmlState: null,
                indentation: 0,
                inline: inlineNormal,
                text: handleText,
                formatting: false,
                linkText: false,
                linkHref: false,
                linkTitle: false,
                code: 0,
                em: false,
                strong: false,
                header: 0,
                setext: 0,
                hr: false,
                taskList: false,
                list: false,
                listStack: [],
                quote: 0,
                trailingSpace: 0,
                trailingSpaceNewLine: false,
                strikethrough: false,
                emoji: false,
                fencedEndRE: null
              };
            },
            copyState: function(s2) {
              return {
                f: s2.f,
                prevLine: s2.prevLine,
                thisLine: s2.thisLine,
                block: s2.block,
                htmlState: s2.htmlState && CodeMirror3.copyState(htmlMode, s2.htmlState),
                indentation: s2.indentation,
                localMode: s2.localMode,
                localState: s2.localMode ? CodeMirror3.copyState(s2.localMode, s2.localState) : null,
                inline: s2.inline,
                text: s2.text,
                formatting: false,
                linkText: s2.linkText,
                linkTitle: s2.linkTitle,
                linkHref: s2.linkHref,
                code: s2.code,
                em: s2.em,
                strong: s2.strong,
                strikethrough: s2.strikethrough,
                emoji: s2.emoji,
                header: s2.header,
                setext: s2.setext,
                hr: s2.hr,
                taskList: s2.taskList,
                list: s2.list,
                listStack: s2.listStack.slice(0),
                quote: s2.quote,
                indentedCode: s2.indentedCode,
                trailingSpace: s2.trailingSpace,
                trailingSpaceNewLine: s2.trailingSpaceNewLine,
                md_inside: s2.md_inside,
                fencedEndRE: s2.fencedEndRE
              };
            },
            token: function(stream, state) {
              state.formatting = false;
              if (stream != state.thisLine.stream) {
                state.header = 0;
                state.hr = false;
                if (stream.match(/^\s*$/, true)) {
                  blankLine(state);
                  return null;
                }
                state.prevLine = state.thisLine;
                state.thisLine = { stream };
                state.taskList = false;
                state.trailingSpace = 0;
                state.trailingSpaceNewLine = false;
                if (!state.localState) {
                  state.f = state.block;
                  if (state.f != htmlBlock) {
                    var indentation = stream.match(/^\s*/, true)[0].replace(/\t/g, expandedTab).length;
                    state.indentation = indentation;
                    state.indentationDiff = null;
                    if (indentation > 0)
                      return null;
                  }
                }
              }
              return state.f(stream, state);
            },
            innerMode: function(state) {
              if (state.block == htmlBlock)
                return { state: state.htmlState, mode: htmlMode };
              if (state.localState)
                return { state: state.localState, mode: state.localMode };
              return { state, mode };
            },
            indent: function(state, textAfter, line) {
              if (state.block == htmlBlock && htmlMode.indent)
                return htmlMode.indent(state.htmlState, textAfter, line);
              if (state.localState && state.localMode.indent)
                return state.localMode.indent(state.localState, textAfter, line);
              return CodeMirror3.Pass;
            },
            blankLine,
            getType,
            blockCommentStart: "<!--",
            blockCommentEnd: "-->",
            closeBrackets: "()[]{}''\"\"``",
            fold: "markdown"
          };
          return mode;
        }, "xml");
        CodeMirror3.defineMIME("text/markdown", "markdown");
        CodeMirror3.defineMIME("text/x-markdown", "markdown");
      });
    }
  });

  // node_modules/simplemde/node_modules/codemirror/addon/mode/overlay.js
  var require_overlay2 = __commonJS({
    "node_modules/simplemde/node_modules/codemirror/addon/mode/overlay.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror2());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.overlayMode = function(base, overlay, combine) {
          return {
            startState: function() {
              return {
                base: CodeMirror3.startState(base),
                overlay: CodeMirror3.startState(overlay),
                basePos: 0,
                baseCur: null,
                overlayPos: 0,
                overlayCur: null,
                streamSeen: null
              };
            },
            copyState: function(state) {
              return {
                base: CodeMirror3.copyState(base, state.base),
                overlay: CodeMirror3.copyState(overlay, state.overlay),
                basePos: state.basePos,
                baseCur: null,
                overlayPos: state.overlayPos,
                overlayCur: null
              };
            },
            token: function(stream, state) {
              if (stream != state.streamSeen || Math.min(state.basePos, state.overlayPos) < stream.start) {
                state.streamSeen = stream;
                state.basePos = state.overlayPos = stream.start;
              }
              if (stream.start == state.basePos) {
                state.baseCur = base.token(stream, state.base);
                state.basePos = stream.pos;
              }
              if (stream.start == state.overlayPos) {
                stream.pos = stream.start;
                state.overlayCur = overlay.token(stream, state.overlay);
                state.overlayPos = stream.pos;
              }
              stream.pos = Math.min(state.basePos, state.overlayPos);
              if (state.overlayCur == null)
                return state.baseCur;
              else if (state.baseCur != null && state.overlay.combineTokens || combine && state.overlay.combineTokens == null)
                return state.baseCur + " " + state.overlayCur;
              else
                return state.overlayCur;
            },
            indent: base.indent && function(state, textAfter, line) {
              return base.indent(state.base, textAfter, line);
            },
            electricChars: base.electricChars,
            innerMode: function(state) {
              return { state: state.base, mode: base };
            },
            blankLine: function(state) {
              var baseToken, overlayToken;
              if (base.blankLine)
                baseToken = base.blankLine(state.base);
              if (overlay.blankLine)
                overlayToken = overlay.blankLine(state.overlay);
              return overlayToken == null ? baseToken : combine && baseToken != null ? baseToken + " " + overlayToken : overlayToken;
            }
          };
        };
      });
    }
  });

  // node_modules/simplemde/node_modules/codemirror/addon/display/placeholder.js
  var require_placeholder = __commonJS({
    "node_modules/simplemde/node_modules/codemirror/addon/display/placeholder.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror2());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        CodeMirror3.defineOption("placeholder", "", function(cm, val, old) {
          var prev = old && old != CodeMirror3.Init;
          if (val && !prev) {
            cm.on("blur", onBlur);
            cm.on("change", onChange);
            cm.on("swapDoc", onChange);
            CodeMirror3.on(cm.getInputField(), "compositionupdate", cm.state.placeholderCompose = function() {
              onComposition(cm);
            });
            onChange(cm);
          } else if (!val && prev) {
            cm.off("blur", onBlur);
            cm.off("change", onChange);
            cm.off("swapDoc", onChange);
            CodeMirror3.off(cm.getInputField(), "compositionupdate", cm.state.placeholderCompose);
            clearPlaceholder(cm);
            var wrapper = cm.getWrapperElement();
            wrapper.className = wrapper.className.replace(" CodeMirror-empty", "");
          }
          if (val && !cm.hasFocus())
            onBlur(cm);
        });
        function clearPlaceholder(cm) {
          if (cm.state.placeholder) {
            cm.state.placeholder.parentNode.removeChild(cm.state.placeholder);
            cm.state.placeholder = null;
          }
        }
        function setPlaceholder(cm) {
          clearPlaceholder(cm);
          var elt = cm.state.placeholder = document.createElement("pre");
          elt.style.cssText = "height: 0; overflow: visible";
          elt.style.direction = cm.getOption("direction");
          elt.className = "CodeMirror-placeholder CodeMirror-line-like";
          var placeHolder = cm.getOption("placeholder");
          if (typeof placeHolder == "string")
            placeHolder = document.createTextNode(placeHolder);
          elt.appendChild(placeHolder);
          cm.display.lineSpace.insertBefore(elt, cm.display.lineSpace.firstChild);
        }
        function onComposition(cm) {
          setTimeout(function() {
            var empty = false;
            if (cm.lineCount() == 1) {
              var input = cm.getInputField();
              empty = input.nodeName == "TEXTAREA" ? !cm.getLine(0).length : !/[^\u200b]/.test(input.querySelector(".CodeMirror-line").textContent);
            }
            if (empty)
              setPlaceholder(cm);
            else
              clearPlaceholder(cm);
          }, 20);
        }
        function onBlur(cm) {
          if (isEmpty(cm))
            setPlaceholder(cm);
        }
        function onChange(cm) {
          var wrapper = cm.getWrapperElement(), empty = isEmpty(cm);
          wrapper.className = wrapper.className.replace(" CodeMirror-empty", "") + (empty ? " CodeMirror-empty" : "");
          if (empty)
            setPlaceholder(cm);
          else
            clearPlaceholder(cm);
        }
        function isEmpty(cm) {
          return cm.lineCount() === 1 && cm.getLine(0) === "";
        }
      });
    }
  });

  // node_modules/simplemde/node_modules/codemirror/addon/selection/mark-selection.js
  var require_mark_selection = __commonJS({
    "node_modules/simplemde/node_modules/codemirror/addon/selection/mark-selection.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror2());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        CodeMirror3.defineOption("styleSelectedText", false, function(cm, val, old) {
          var prev = old && old != CodeMirror3.Init;
          if (val && !prev) {
            cm.state.markedSelection = [];
            cm.state.markedSelectionStyle = typeof val == "string" ? val : "CodeMirror-selectedtext";
            reset(cm);
            cm.on("cursorActivity", onCursorActivity);
            cm.on("change", onChange);
          } else if (!val && prev) {
            cm.off("cursorActivity", onCursorActivity);
            cm.off("change", onChange);
            clear(cm);
            cm.state.markedSelection = cm.state.markedSelectionStyle = null;
          }
        });
        function onCursorActivity(cm) {
          if (cm.state.markedSelection)
            cm.operation(function() {
              update(cm);
            });
        }
        function onChange(cm) {
          if (cm.state.markedSelection && cm.state.markedSelection.length)
            cm.operation(function() {
              clear(cm);
            });
        }
        var CHUNK_SIZE = 8;
        var Pos = CodeMirror3.Pos;
        var cmp = CodeMirror3.cmpPos;
        function coverRange(cm, from, to, addAt) {
          if (cmp(from, to) == 0)
            return;
          var array = cm.state.markedSelection;
          var cls = cm.state.markedSelectionStyle;
          for (var line = from.line; ; ) {
            var start4 = line == from.line ? from : Pos(line, 0);
            var endLine = line + CHUNK_SIZE, atEnd = endLine >= to.line;
            var end2 = atEnd ? to : Pos(endLine, 0);
            var mark = cm.markText(start4, end2, { className: cls });
            if (addAt == null)
              array.push(mark);
            else
              array.splice(addAt++, 0, mark);
            if (atEnd)
              break;
            line = endLine;
          }
        }
        function clear(cm) {
          var array = cm.state.markedSelection;
          for (var i2 = 0; i2 < array.length; ++i2)
            array[i2].clear();
          array.length = 0;
        }
        function reset(cm) {
          clear(cm);
          var ranges = cm.listSelections();
          for (var i2 = 0; i2 < ranges.length; i2++)
            coverRange(cm, ranges[i2].from(), ranges[i2].to());
        }
        function update(cm) {
          if (!cm.somethingSelected())
            return clear(cm);
          if (cm.listSelections().length > 1)
            return reset(cm);
          var from = cm.getCursor("start"), to = cm.getCursor("end");
          var array = cm.state.markedSelection;
          if (!array.length)
            return coverRange(cm, from, to);
          var coverStart = array[0].find(), coverEnd = array[array.length - 1].find();
          if (!coverStart || !coverEnd || to.line - from.line <= CHUNK_SIZE || cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0)
            return reset(cm);
          while (cmp(from, coverStart.from) > 0) {
            array.shift().clear();
            coverStart = array[0].find();
          }
          if (cmp(from, coverStart.from) < 0) {
            if (coverStart.to.line - from.line < CHUNK_SIZE) {
              array.shift().clear();
              coverRange(cm, from, coverStart.to, 0);
            } else {
              coverRange(cm, from, coverStart.from, 0);
            }
          }
          while (cmp(to, coverEnd.to) < 0) {
            array.pop().clear();
            coverEnd = array[array.length - 1].find();
          }
          if (cmp(to, coverEnd.to) > 0) {
            if (to.line - coverEnd.from.line < CHUNK_SIZE) {
              array.pop().clear();
              coverRange(cm, coverEnd.from, to);
            } else {
              coverRange(cm, coverEnd.to, to);
            }
          }
        }
      });
    }
  });

  // node_modules/simplemde/node_modules/codemirror/mode/gfm/gfm.js
  var require_gfm = __commonJS({
    "node_modules/simplemde/node_modules/codemirror/mode/gfm/gfm.js"(exports, module) {
      (function(mod) {
        if (typeof exports == "object" && typeof module == "object")
          mod(require_codemirror2(), require_markdown2(), require_overlay2());
        else if (typeof define == "function" && define.amd)
          define(["../../lib/codemirror", "../markdown/markdown", "../../addon/mode/overlay"], mod);
        else
          mod(CodeMirror);
      })(function(CodeMirror3) {
        "use strict";
        var urlRE = /^((?:(?:aaas?|about|acap|adiumxtra|af[ps]|aim|apt|attachment|aw|beshare|bitcoin|bolo|callto|cap|chrome(?:-extension)?|cid|coap|com-eventbrite-attendee|content|crid|cvs|data|dav|dict|dlna-(?:playcontainer|playsingle)|dns|doi|dtn|dvb|ed2k|facetime|feed|file|finger|fish|ftp|geo|gg|git|gizmoproject|go|gopher|gtalk|h323|hcp|https?|iax|icap|icon|im|imap|info|ipn|ipp|irc[6s]?|iris(?:\.beep|\.lwz|\.xpc|\.xpcs)?|itms|jar|javascript|jms|keyparc|lastfm|ldaps?|magnet|mailto|maps|market|message|mid|mms|ms-help|msnim|msrps?|mtqp|mumble|mupdate|mvn|news|nfs|nih?|nntp|notes|oid|opaquelocktoken|palm|paparazzi|platform|pop|pres|proxy|psyc|query|res(?:ource)?|rmi|rsync|rtmp|rtsp|secondlife|service|session|sftp|sgn|shttp|sieve|sips?|skype|sm[bs]|snmp|soap\.beeps?|soldat|spotify|ssh|steam|svn|tag|teamspeak|tel(?:net)?|tftp|things|thismessage|tip|tn3270|tv|udp|unreal|urn|ut2004|vemmi|ventrilo|view-source|webcal|wss?|wtai|wyciwyg|xcon(?:-userid)?|xfire|xmlrpc\.beeps?|xmpp|xri|ymsgr|z39\.50[rs]?):(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]|\([^\s()<>]*\))+(?:\([^\s()<>]*\)|[^\s`*!()\[\]{};:'".,<>?]))/i;
        CodeMirror3.defineMode("gfm", function(config, modeConfig) {
          var codeDepth = 0;
          function blankLine(state) {
            state.code = false;
            return null;
          }
          var gfmOverlay = {
            startState: function() {
              return {
                code: false,
                codeBlock: false,
                ateSpace: false
              };
            },
            copyState: function(s2) {
              return {
                code: s2.code,
                codeBlock: s2.codeBlock,
                ateSpace: s2.ateSpace
              };
            },
            token: function(stream, state) {
              state.combineTokens = null;
              if (state.codeBlock) {
                if (stream.match(/^```+/)) {
                  state.codeBlock = false;
                  return null;
                }
                stream.skipToEnd();
                return null;
              }
              if (stream.sol()) {
                state.code = false;
              }
              if (stream.sol() && stream.match(/^```+/)) {
                stream.skipToEnd();
                state.codeBlock = true;
                return null;
              }
              if (stream.peek() === "`") {
                stream.next();
                var before = stream.pos;
                stream.eatWhile("`");
                var difference = 1 + stream.pos - before;
                if (!state.code) {
                  codeDepth = difference;
                  state.code = true;
                } else {
                  if (difference === codeDepth) {
                    state.code = false;
                  }
                }
                return null;
              } else if (state.code) {
                stream.next();
                return null;
              }
              if (stream.eatSpace()) {
                state.ateSpace = true;
                return null;
              }
              if (stream.sol() || state.ateSpace) {
                state.ateSpace = false;
                if (modeConfig.gitHubSpice !== false) {
                  if (stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+@)?(?=.{0,6}\d)(?:[a-f0-9]{7,40}\b)/)) {
                    state.combineTokens = true;
                    return "link";
                  } else if (stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+)?#[0-9]+\b/)) {
                    state.combineTokens = true;
                    return "link";
                  }
                }
              }
              if (stream.match(urlRE) && stream.string.slice(stream.start - 2, stream.start) != "](" && (stream.start == 0 || /\W/.test(stream.string.charAt(stream.start - 1)))) {
                state.combineTokens = true;
                return "link";
              }
              stream.next();
              return null;
            },
            blankLine
          };
          var markdownConfig = {
            taskLists: true,
            strikethrough: true,
            emoji: true
          };
          for (var attr in modeConfig) {
            markdownConfig[attr] = modeConfig[attr];
          }
          markdownConfig.name = "markdown";
          return CodeMirror3.overlayMode(CodeMirror3.getMode(config, markdownConfig), gfmOverlay);
        }, "markdown");
        CodeMirror3.defineMIME("text/x-gfm", "gfm");
      });
    }
  });

  // (disabled):fs
  var require_fs = __commonJS({
    "(disabled):fs"() {
    }
  });

  // node_modules/typo-js/typo.js
  var require_typo = __commonJS({
    "node_modules/typo-js/typo.js"(exports, module) {
      var Typo;
      (function() {
        "use strict";
        Typo = function(dictionary, affData, wordsData, settings) {
          settings = settings || {};
          this.dictionary = null;
          this.rules = {};
          this.dictionaryTable = {};
          this.compoundRules = [];
          this.compoundRuleCodes = {};
          this.replacementTable = [];
          this.flags = settings.flags || {};
          this.memoized = {};
          this.loaded = false;
          var self2 = this;
          var path;
          var i2, j2, _len, _jlen;
          if (dictionary) {
            self2.dictionary = dictionary;
            if (affData && wordsData) {
              setup();
            } else if (typeof window !== "undefined" && "chrome" in window && "extension" in window.chrome && "getURL" in window.chrome.extension) {
              if (settings.dictionaryPath) {
                path = settings.dictionaryPath;
              } else {
                path = "typo/dictionaries";
              }
              if (!affData)
                readDataFile(chrome.extension.getURL(path + "/" + dictionary + "/" + dictionary + ".aff"), setAffData);
              if (!wordsData)
                readDataFile(chrome.extension.getURL(path + "/" + dictionary + "/" + dictionary + ".dic"), setWordsData);
            } else {
              if (settings.dictionaryPath) {
                path = settings.dictionaryPath;
              } else if (typeof __dirname !== "undefined") {
                path = __dirname + "/dictionaries";
              } else {
                path = "./dictionaries";
              }
              if (!affData)
                readDataFile(path + "/" + dictionary + "/" + dictionary + ".aff", setAffData);
              if (!wordsData)
                readDataFile(path + "/" + dictionary + "/" + dictionary + ".dic", setWordsData);
            }
          }
          function readDataFile(url, setFunc) {
            var response = self2._readFile(url, null, settings.asyncLoad);
            if (settings.asyncLoad) {
              response.then(function(data) {
                setFunc(data);
              });
            } else {
              setFunc(response);
            }
          }
          function setAffData(data) {
            affData = data;
            if (wordsData) {
              setup();
            }
          }
          function setWordsData(data) {
            wordsData = data;
            if (affData) {
              setup();
            }
          }
          function setup() {
            self2.rules = self2._parseAFF(affData);
            self2.compoundRuleCodes = {};
            for (i2 = 0, _len = self2.compoundRules.length; i2 < _len; i2++) {
              var rule = self2.compoundRules[i2];
              for (j2 = 0, _jlen = rule.length; j2 < _jlen; j2++) {
                self2.compoundRuleCodes[rule[j2]] = [];
              }
            }
            if ("ONLYINCOMPOUND" in self2.flags) {
              self2.compoundRuleCodes[self2.flags.ONLYINCOMPOUND] = [];
            }
            self2.dictionaryTable = self2._parseDIC(wordsData);
            for (i2 in self2.compoundRuleCodes) {
              if (self2.compoundRuleCodes[i2].length === 0) {
                delete self2.compoundRuleCodes[i2];
              }
            }
            for (i2 = 0, _len = self2.compoundRules.length; i2 < _len; i2++) {
              var ruleText = self2.compoundRules[i2];
              var expressionText = "";
              for (j2 = 0, _jlen = ruleText.length; j2 < _jlen; j2++) {
                var character = ruleText[j2];
                if (character in self2.compoundRuleCodes) {
                  expressionText += "(" + self2.compoundRuleCodes[character].join("|") + ")";
                } else {
                  expressionText += character;
                }
              }
              self2.compoundRules[i2] = new RegExp(expressionText, "i");
            }
            self2.loaded = true;
            if (settings.asyncLoad && settings.loadedCallback) {
              settings.loadedCallback(self2);
            }
          }
          return this;
        };
        Typo.prototype = {
          load: function(obj) {
            for (var i2 in obj) {
              if (obj.hasOwnProperty(i2)) {
                this[i2] = obj[i2];
              }
            }
            return this;
          },
          _readFile: function(path, charset, async) {
            charset = charset || "utf8";
            if (typeof XMLHttpRequest !== "undefined") {
              var promise;
              var req = new XMLHttpRequest();
              req.open("GET", path, async);
              if (async) {
                promise = new Promise(function(resolve2, reject) {
                  req.onload = function() {
                    if (req.status === 200) {
                      resolve2(req.responseText);
                    } else {
                      reject(req.statusText);
                    }
                  };
                  req.onerror = function() {
                    reject(req.statusText);
                  };
                });
              }
              if (req.overrideMimeType)
                req.overrideMimeType("text/plain; charset=" + charset);
              req.send(null);
              return async ? promise : req.responseText;
            } else if (typeof __require !== "undefined") {
              var fs = require_fs();
              try {
                if (fs.existsSync(path)) {
                  return fs.readFileSync(path, charset);
                } else {
                  console.log("Path " + path + " does not exist.");
                }
              } catch (e2) {
                console.log(e2);
                return "";
              }
            }
          },
          _parseAFF: function(data) {
            var rules = {};
            var line, subline, numEntries, lineParts;
            var i2, j2, _len, _jlen;
            data = this._removeAffixComments(data);
            var lines = data.split(/\r?\n/);
            for (i2 = 0, _len = lines.length; i2 < _len; i2++) {
              line = lines[i2];
              var definitionParts = line.split(/\s+/);
              var ruleType = definitionParts[0];
              if (ruleType == "PFX" || ruleType == "SFX") {
                var ruleCode = definitionParts[1];
                var combineable = definitionParts[2];
                numEntries = parseInt(definitionParts[3], 10);
                var entries = [];
                for (j2 = i2 + 1, _jlen = i2 + 1 + numEntries; j2 < _jlen; j2++) {
                  subline = lines[j2];
                  lineParts = subline.split(/\s+/);
                  var charactersToRemove = lineParts[2];
                  var additionParts = lineParts[3].split("/");
                  var charactersToAdd = additionParts[0];
                  if (charactersToAdd === "0")
                    charactersToAdd = "";
                  var continuationClasses = this.parseRuleCodes(additionParts[1]);
                  var regexToMatch = lineParts[4];
                  var entry = {};
                  entry.add = charactersToAdd;
                  if (continuationClasses.length > 0)
                    entry.continuationClasses = continuationClasses;
                  if (regexToMatch !== ".") {
                    if (ruleType === "SFX") {
                      entry.match = new RegExp(regexToMatch + "$");
                    } else {
                      entry.match = new RegExp("^" + regexToMatch);
                    }
                  }
                  if (charactersToRemove != "0") {
                    if (ruleType === "SFX") {
                      entry.remove = new RegExp(charactersToRemove + "$");
                    } else {
                      entry.remove = charactersToRemove;
                    }
                  }
                  entries.push(entry);
                }
                rules[ruleCode] = { "type": ruleType, "combineable": combineable == "Y", "entries": entries };
                i2 += numEntries;
              } else if (ruleType === "COMPOUNDRULE") {
                numEntries = parseInt(definitionParts[1], 10);
                for (j2 = i2 + 1, _jlen = i2 + 1 + numEntries; j2 < _jlen; j2++) {
                  line = lines[j2];
                  lineParts = line.split(/\s+/);
                  this.compoundRules.push(lineParts[1]);
                }
                i2 += numEntries;
              } else if (ruleType === "REP") {
                lineParts = line.split(/\s+/);
                if (lineParts.length === 3) {
                  this.replacementTable.push([lineParts[1], lineParts[2]]);
                }
              } else {
                this.flags[ruleType] = definitionParts[1];
              }
            }
            return rules;
          },
          _removeAffixComments: function(data) {
            data = data.replace(/^\s*#.*$/mg, "");
            data = data.replace(/^\s\s*/m, "").replace(/\s\s*$/m, "");
            data = data.replace(/\n{2,}/g, "\n");
            data = data.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
            return data;
          },
          _parseDIC: function(data) {
            data = this._removeDicComments(data);
            var lines = data.split(/\r?\n/);
            var dictionaryTable = {};
            function addWord(word2, rules) {
              if (!dictionaryTable.hasOwnProperty(word2)) {
                dictionaryTable[word2] = null;
              }
              if (rules.length > 0) {
                if (dictionaryTable[word2] === null) {
                  dictionaryTable[word2] = [];
                }
                dictionaryTable[word2].push(rules);
              }
            }
            for (var i2 = 1, _len = lines.length; i2 < _len; i2++) {
              var line = lines[i2];
              if (!line) {
                continue;
              }
              var parts = line.split("/", 2);
              var word = parts[0];
              if (parts.length > 1) {
                var ruleCodesArray = this.parseRuleCodes(parts[1]);
                if (!("NEEDAFFIX" in this.flags) || ruleCodesArray.indexOf(this.flags.NEEDAFFIX) == -1) {
                  addWord(word, ruleCodesArray);
                }
                for (var j2 = 0, _jlen = ruleCodesArray.length; j2 < _jlen; j2++) {
                  var code3 = ruleCodesArray[j2];
                  var rule = this.rules[code3];
                  if (rule) {
                    var newWords = this._applyRule(word, rule);
                    for (var ii = 0, _iilen = newWords.length; ii < _iilen; ii++) {
                      var newWord = newWords[ii];
                      addWord(newWord, []);
                      if (rule.combineable) {
                        for (var k2 = j2 + 1; k2 < _jlen; k2++) {
                          var combineCode = ruleCodesArray[k2];
                          var combineRule = this.rules[combineCode];
                          if (combineRule) {
                            if (combineRule.combineable && rule.type != combineRule.type) {
                              var otherNewWords = this._applyRule(newWord, combineRule);
                              for (var iii = 0, _iiilen = otherNewWords.length; iii < _iiilen; iii++) {
                                var otherNewWord = otherNewWords[iii];
                                addWord(otherNewWord, []);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  if (code3 in this.compoundRuleCodes) {
                    this.compoundRuleCodes[code3].push(word);
                  }
                }
              } else {
                addWord(word.trim(), []);
              }
            }
            return dictionaryTable;
          },
          _removeDicComments: function(data) {
            data = data.replace(/^\t.*$/mg, "");
            return data;
          },
          parseRuleCodes: function(textCodes) {
            if (!textCodes) {
              return [];
            } else if (!("FLAG" in this.flags)) {
              return textCodes.split("");
            } else if (this.flags.FLAG === "long") {
              var flags = [];
              for (var i2 = 0, _len = textCodes.length; i2 < _len; i2 += 2) {
                flags.push(textCodes.substr(i2, 2));
              }
              return flags;
            } else if (this.flags.FLAG === "num") {
              return textCodes.split(",");
            }
          },
          _applyRule: function(word, rule) {
            var entries = rule.entries;
            var newWords = [];
            for (var i2 = 0, _len = entries.length; i2 < _len; i2++) {
              var entry = entries[i2];
              if (!entry.match || word.match(entry.match)) {
                var newWord = word;
                if (entry.remove) {
                  newWord = newWord.replace(entry.remove, "");
                }
                if (rule.type === "SFX") {
                  newWord = newWord + entry.add;
                } else {
                  newWord = entry.add + newWord;
                }
                newWords.push(newWord);
                if ("continuationClasses" in entry) {
                  for (var j2 = 0, _jlen = entry.continuationClasses.length; j2 < _jlen; j2++) {
                    var continuationRule = this.rules[entry.continuationClasses[j2]];
                    if (continuationRule) {
                      newWords = newWords.concat(this._applyRule(newWord, continuationRule));
                    }
                  }
                }
              }
            }
            return newWords;
          },
          check: function(aWord) {
            if (!this.loaded) {
              throw "Dictionary not loaded.";
            }
            var trimmedWord = aWord.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
            if (this.checkExact(trimmedWord)) {
              return true;
            }
            if (trimmedWord.toUpperCase() === trimmedWord) {
              var capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();
              if (this.hasFlag(capitalizedWord, "KEEPCASE")) {
                return false;
              }
              if (this.checkExact(capitalizedWord)) {
                return true;
              }
              if (this.checkExact(trimmedWord.toLowerCase())) {
                return true;
              }
            }
            var uncapitalizedWord = trimmedWord[0].toLowerCase() + trimmedWord.substring(1);
            if (uncapitalizedWord !== trimmedWord) {
              if (this.hasFlag(uncapitalizedWord, "KEEPCASE")) {
                return false;
              }
              if (this.checkExact(uncapitalizedWord)) {
                return true;
              }
            }
            return false;
          },
          checkExact: function(word) {
            if (!this.loaded) {
              throw "Dictionary not loaded.";
            }
            var ruleCodes = this.dictionaryTable[word];
            var i2, _len;
            if (typeof ruleCodes === "undefined") {
              if ("COMPOUNDMIN" in this.flags && word.length >= this.flags.COMPOUNDMIN) {
                for (i2 = 0, _len = this.compoundRules.length; i2 < _len; i2++) {
                  if (word.match(this.compoundRules[i2])) {
                    return true;
                  }
                }
              }
            } else if (ruleCodes === null) {
              return true;
            } else if (typeof ruleCodes === "object") {
              for (i2 = 0, _len = ruleCodes.length; i2 < _len; i2++) {
                if (!this.hasFlag(word, "ONLYINCOMPOUND", ruleCodes[i2])) {
                  return true;
                }
              }
            }
            return false;
          },
          hasFlag: function(word, flag, wordFlags) {
            if (!this.loaded) {
              throw "Dictionary not loaded.";
            }
            if (flag in this.flags) {
              if (typeof wordFlags === "undefined") {
                wordFlags = Array.prototype.concat.apply([], this.dictionaryTable[word]);
              }
              if (wordFlags && wordFlags.indexOf(this.flags[flag]) !== -1) {
                return true;
              }
            }
            return false;
          },
          alphabet: "",
          suggest: function(word, limit) {
            if (!this.loaded) {
              throw "Dictionary not loaded.";
            }
            limit = limit || 5;
            if (this.memoized.hasOwnProperty(word)) {
              var memoizedLimit = this.memoized[word]["limit"];
              if (limit <= memoizedLimit || this.memoized[word]["suggestions"].length < memoizedLimit) {
                return this.memoized[word]["suggestions"].slice(0, limit);
              }
            }
            if (this.check(word))
              return [];
            for (var i2 = 0, _len = this.replacementTable.length; i2 < _len; i2++) {
              var replacementEntry = this.replacementTable[i2];
              if (word.indexOf(replacementEntry[0]) !== -1) {
                var correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);
                if (this.check(correctedWord)) {
                  return [correctedWord];
                }
              }
            }
            var self2 = this;
            self2.alphabet = "abcdefghijklmnopqrstuvwxyz";
            function edits1(words, known_only) {
              var rv = {};
              var i3, j2, _iilen, _len2, _jlen, _edit;
              var alphabetLength = self2.alphabet.length;
              if (typeof words == "string") {
                var word2 = words;
                words = {};
                words[word2] = true;
              }
              for (var word2 in words) {
                for (i3 = 0, _len2 = word2.length + 1; i3 < _len2; i3++) {
                  var s2 = [word2.substring(0, i3), word2.substring(i3)];
                  if (s2[1]) {
                    _edit = s2[0] + s2[1].substring(1);
                    if (!known_only || self2.check(_edit)) {
                      if (!(_edit in rv)) {
                        rv[_edit] = 1;
                      } else {
                        rv[_edit] += 1;
                      }
                    }
                  }
                  if (s2[1].length > 1 && s2[1][1] !== s2[1][0]) {
                    _edit = s2[0] + s2[1][1] + s2[1][0] + s2[1].substring(2);
                    if (!known_only || self2.check(_edit)) {
                      if (!(_edit in rv)) {
                        rv[_edit] = 1;
                      } else {
                        rv[_edit] += 1;
                      }
                    }
                  }
                  if (s2[1]) {
                    var lettercase = s2[1].substring(0, 1).toUpperCase() === s2[1].substring(0, 1) ? "uppercase" : "lowercase";
                    for (j2 = 0; j2 < alphabetLength; j2++) {
                      var replacementLetter = self2.alphabet[j2];
                      if (lettercase === "uppercase") {
                        replacementLetter = replacementLetter.toUpperCase();
                      }
                      if (replacementLetter != s2[1].substring(0, 1)) {
                        _edit = s2[0] + replacementLetter + s2[1].substring(1);
                        if (!known_only || self2.check(_edit)) {
                          if (!(_edit in rv)) {
                            rv[_edit] = 1;
                          } else {
                            rv[_edit] += 1;
                          }
                        }
                      }
                    }
                  }
                  if (s2[1]) {
                    for (j2 = 0; j2 < alphabetLength; j2++) {
                      var lettercase = s2[0].substring(-1).toUpperCase() === s2[0].substring(-1) && s2[1].substring(0, 1).toUpperCase() === s2[1].substring(0, 1) ? "uppercase" : "lowercase";
                      var replacementLetter = self2.alphabet[j2];
                      if (lettercase === "uppercase") {
                        replacementLetter = replacementLetter.toUpperCase();
                      }
                      _edit = s2[0] + replacementLetter + s2[1];
                      if (!known_only || self2.check(_edit)) {
                        if (!(_edit in rv)) {
                          rv[_edit] = 1;
                        } else {
                          rv[_edit] += 1;
                        }
                      }
                    }
                  }
                }
              }
              return rv;
            }
            function correct(word2) {
              var ed1 = edits1(word2);
              var ed2 = edits1(ed1, true);
              var weighted_corrections = ed2;
              for (var ed1word in ed1) {
                if (!self2.check(ed1word)) {
                  continue;
                }
                if (ed1word in weighted_corrections) {
                  weighted_corrections[ed1word] += ed1[ed1word];
                } else {
                  weighted_corrections[ed1word] = ed1[ed1word];
                }
              }
              var i3, _len2;
              var sorted_corrections = [];
              for (i3 in weighted_corrections) {
                if (weighted_corrections.hasOwnProperty(i3)) {
                  sorted_corrections.push([i3, weighted_corrections[i3]]);
                }
              }
              function sorter(a2, b2) {
                var a_val = a2[1];
                var b_val = b2[1];
                if (a_val < b_val) {
                  return -1;
                } else if (a_val > b_val) {
                  return 1;
                }
                return b2[0].localeCompare(a2[0]);
              }
              sorted_corrections.sort(sorter).reverse();
              var rv = [];
              var capitalization_scheme = "lowercase";
              if (word2.toUpperCase() === word2) {
                capitalization_scheme = "uppercase";
              } else if (word2.substr(0, 1).toUpperCase() + word2.substr(1).toLowerCase() === word2) {
                capitalization_scheme = "capitalized";
              }
              var working_limit = limit;
              for (i3 = 0; i3 < Math.min(working_limit, sorted_corrections.length); i3++) {
                if (capitalization_scheme === "uppercase") {
                  sorted_corrections[i3][0] = sorted_corrections[i3][0].toUpperCase();
                } else if (capitalization_scheme === "capitalized") {
                  sorted_corrections[i3][0] = sorted_corrections[i3][0].substr(0, 1).toUpperCase() + sorted_corrections[i3][0].substr(1);
                }
                if (!self2.hasFlag(sorted_corrections[i3][0], "NOSUGGEST") && rv.indexOf(sorted_corrections[i3][0]) == -1) {
                  rv.push(sorted_corrections[i3][0]);
                } else {
                  working_limit++;
                }
              }
              return rv;
            }
            this.memoized[word] = {
              "suggestions": correct(word),
              "limit": limit
            };
            return this.memoized[word]["suggestions"];
          }
        };
      })();
      if (typeof module !== "undefined") {
        module.exports = Typo;
      }
    }
  });

  // node_modules/codemirror-spell-checker/src/js/spell-checker.js
  var require_spell_checker = __commonJS({
    "node_modules/codemirror-spell-checker/src/js/spell-checker.js"(exports, module) {
      "use strict";
      var Typo = require_typo();
      function CodeMirrorSpellChecker(options) {
        options = options || {};
        if (typeof options.codeMirrorInstance !== "function" || typeof options.codeMirrorInstance.defineMode !== "function") {
          console.log("CodeMirror Spell Checker: You must provide an instance of CodeMirror via the option `codeMirrorInstance`");
          return;
        }
        if (!String.prototype.includes) {
          String.prototype.includes = function() {
            "use strict";
            return String.prototype.indexOf.apply(this, arguments) !== -1;
          };
        }
        options.codeMirrorInstance.defineMode("spell-checker", function(config) {
          if (!CodeMirrorSpellChecker.aff_loading) {
            CodeMirrorSpellChecker.aff_loading = true;
            var xhr_aff = new XMLHttpRequest();
            xhr_aff.open("GET", "https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.aff", true);
            xhr_aff.onload = function() {
              if (xhr_aff.readyState === 4 && xhr_aff.status === 200) {
                CodeMirrorSpellChecker.aff_data = xhr_aff.responseText;
                CodeMirrorSpellChecker.num_loaded++;
                if (CodeMirrorSpellChecker.num_loaded == 2) {
                  CodeMirrorSpellChecker.typo = new Typo("en_US", CodeMirrorSpellChecker.aff_data, CodeMirrorSpellChecker.dic_data, {
                    platform: "any"
                  });
                }
              }
            };
            xhr_aff.send(null);
          }
          if (!CodeMirrorSpellChecker.dic_loading) {
            CodeMirrorSpellChecker.dic_loading = true;
            var xhr_dic = new XMLHttpRequest();
            xhr_dic.open("GET", "https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.dic", true);
            xhr_dic.onload = function() {
              if (xhr_dic.readyState === 4 && xhr_dic.status === 200) {
                CodeMirrorSpellChecker.dic_data = xhr_dic.responseText;
                CodeMirrorSpellChecker.num_loaded++;
                if (CodeMirrorSpellChecker.num_loaded == 2) {
                  CodeMirrorSpellChecker.typo = new Typo("en_US", CodeMirrorSpellChecker.aff_data, CodeMirrorSpellChecker.dic_data, {
                    platform: "any"
                  });
                }
              }
            };
            xhr_dic.send(null);
          }
          var rx_word = '!"#$%&()*+,-./:;<=>?@[\\]^_`{|}~ ';
          var overlay = {
            token: function(stream) {
              var ch = stream.peek();
              var word = "";
              if (rx_word.includes(ch)) {
                stream.next();
                return null;
              }
              while ((ch = stream.peek()) != null && !rx_word.includes(ch)) {
                word += ch;
                stream.next();
              }
              if (CodeMirrorSpellChecker.typo && !CodeMirrorSpellChecker.typo.check(word))
                return "spell-error";
              return null;
            }
          };
          var mode = options.codeMirrorInstance.getMode(config, config.backdrop || "text/plain");
          return options.codeMirrorInstance.overlayMode(mode, overlay, true);
        });
      }
      CodeMirrorSpellChecker.num_loaded = 0;
      CodeMirrorSpellChecker.aff_loading = false;
      CodeMirrorSpellChecker.dic_loading = false;
      CodeMirrorSpellChecker.aff_data = "";
      CodeMirrorSpellChecker.dic_data = "";
      CodeMirrorSpellChecker.typo;
      module.exports = CodeMirrorSpellChecker;
    }
  });

  // node_modules/marked/lib/marked.cjs
  var require_marked = __commonJS({
    "node_modules/marked/lib/marked.cjs"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", {
          writable: false
        });
        return Constructor;
      }
      function _unsupportedIterableToArray11(o2, minLen) {
        if (!o2)
          return;
        if (typeof o2 === "string")
          return _arrayLikeToArray11(o2, minLen);
        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n2 === "Object" && o2.constructor)
          n2 = o2.constructor.name;
        if (n2 === "Map" || n2 === "Set")
          return Array.from(o2);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
          return _arrayLikeToArray11(o2, minLen);
      }
      function _arrayLikeToArray11(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
          arr2[i2] = arr[i2];
        return arr2;
      }
      function _createForOfIteratorHelperLoose(o2, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
        if (it)
          return (it = it.call(o2)).next.bind(it);
        if (Array.isArray(o2) || (it = _unsupportedIterableToArray11(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
          if (it)
            o2 = it;
          var i2 = 0;
          return function() {
            if (i2 >= o2.length)
              return {
                done: true
              };
            return {
              done: false,
              value: o2[i2++]
            };
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function getDefaults() {
        return {
          baseUrl: null,
          breaks: false,
          extensions: null,
          gfm: true,
          headerIds: true,
          headerPrefix: "",
          highlight: null,
          langPrefix: "language-",
          mangle: true,
          pedantic: false,
          renderer: null,
          sanitize: false,
          sanitizer: null,
          silent: false,
          smartLists: false,
          smartypants: false,
          tokenizer: null,
          walkTokens: null,
          xhtml: false
        };
      }
      exports.defaults = getDefaults();
      function changeDefaults(newDefaults) {
        exports.defaults = newDefaults;
      }
      var escapeTest = /[&<>"']/;
      var escapeReplace = /[&<>"']/g;
      var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
      var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
      var escapeReplacements = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var getEscapeReplacement = function getEscapeReplacement2(ch) {
        return escapeReplacements[ch];
      };
      function escape2(html, encode) {
        if (encode) {
          if (escapeTest.test(html)) {
            return html.replace(escapeReplace, getEscapeReplacement);
          }
        } else {
          if (escapeTestNoEncode.test(html)) {
            return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
          }
        }
        return html;
      }
      var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
      function unescape3(html) {
        return html.replace(unescapeTest, function(_2, n2) {
          n2 = n2.toLowerCase();
          if (n2 === "colon")
            return ":";
          if (n2.charAt(0) === "#") {
            return n2.charAt(1) === "x" ? String.fromCharCode(parseInt(n2.substring(2), 16)) : String.fromCharCode(+n2.substring(1));
          }
          return "";
        });
      }
      var caret = /(^|[^\[])\^/g;
      function edit(regex, opt) {
        regex = regex.source || regex;
        opt = opt || "";
        var obj = {
          replace: function replace(name, val) {
            val = val.source || val;
            val = val.replace(caret, "$1");
            regex = regex.replace(name, val);
            return obj;
          },
          getRegex: function getRegex() {
            return new RegExp(regex, opt);
          }
        };
        return obj;
      }
      var nonWordAndColonTest = /[^\w:]/g;
      var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
      function cleanUrl(sanitize, base, href) {
        if (sanitize) {
          var prot;
          try {
            prot = decodeURIComponent(unescape3(href)).replace(nonWordAndColonTest, "").toLowerCase();
          } catch (e2) {
            return null;
          }
          if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
            return null;
          }
        }
        if (base && !originIndependentUrl.test(href)) {
          href = resolveUrl(base, href);
        }
        try {
          href = encodeURI(href).replace(/%25/g, "%");
        } catch (e2) {
          return null;
        }
        return href;
      }
      var baseUrls = {};
      var justDomain = /^[^:]+:\/*[^/]*$/;
      var protocol = /^([^:]+:)[\s\S]*$/;
      var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
      function resolveUrl(base, href) {
        if (!baseUrls[" " + base]) {
          if (justDomain.test(base)) {
            baseUrls[" " + base] = base + "/";
          } else {
            baseUrls[" " + base] = rtrim(base, "/", true);
          }
        }
        base = baseUrls[" " + base];
        var relativeBase = base.indexOf(":") === -1;
        if (href.substring(0, 2) === "//") {
          if (relativeBase) {
            return href;
          }
          return base.replace(protocol, "$1") + href;
        } else if (href.charAt(0) === "/") {
          if (relativeBase) {
            return href;
          }
          return base.replace(domain, "$1") + href;
        } else {
          return base + href;
        }
      }
      var noopTest = {
        exec: function noopTest2() {
        }
      };
      function merge(obj) {
        var i2 = 1, target, key;
        for (; i2 < arguments.length; i2++) {
          target = arguments[i2];
          for (key in target) {
            if (Object.prototype.hasOwnProperty.call(target, key)) {
              obj[key] = target[key];
            }
          }
        }
        return obj;
      }
      function splitCells(tableRow, count) {
        var row = tableRow.replace(/\|/g, function(match, offset2, str) {
          var escaped = false, curr = offset2;
          while (--curr >= 0 && str[curr] === "\\") {
            escaped = !escaped;
          }
          if (escaped) {
            return "|";
          } else {
            return " |";
          }
        }), cells = row.split(/ \|/);
        var i2 = 0;
        if (!cells[0].trim()) {
          cells.shift();
        }
        if (!cells[cells.length - 1].trim()) {
          cells.pop();
        }
        if (cells.length > count) {
          cells.splice(count);
        } else {
          while (cells.length < count) {
            cells.push("");
          }
        }
        for (; i2 < cells.length; i2++) {
          cells[i2] = cells[i2].trim().replace(/\\\|/g, "|");
        }
        return cells;
      }
      function rtrim(str, c2, invert) {
        var l2 = str.length;
        if (l2 === 0) {
          return "";
        }
        var suffLen = 0;
        while (suffLen < l2) {
          var currChar = str.charAt(l2 - suffLen - 1);
          if (currChar === c2 && !invert) {
            suffLen++;
          } else if (currChar !== c2 && invert) {
            suffLen++;
          } else {
            break;
          }
        }
        return str.substr(0, l2 - suffLen);
      }
      function findClosingBracket(str, b2) {
        if (str.indexOf(b2[1]) === -1) {
          return -1;
        }
        var l2 = str.length;
        var level = 0, i2 = 0;
        for (; i2 < l2; i2++) {
          if (str[i2] === "\\") {
            i2++;
          } else if (str[i2] === b2[0]) {
            level++;
          } else if (str[i2] === b2[1]) {
            level--;
            if (level < 0) {
              return i2;
            }
          }
        }
        return -1;
      }
      function checkSanitizeDeprecation(opt) {
        if (opt && opt.sanitize && !opt.silent) {
          console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
        }
      }
      function repeatString(pattern, count) {
        if (count < 1) {
          return "";
        }
        var result = "";
        while (count > 1) {
          if (count & 1) {
            result += pattern;
          }
          count >>= 1;
          pattern += pattern;
        }
        return result + pattern;
      }
      function outputLink(cap, link, raw, lexer2) {
        var href = link.href;
        var title = link.title ? escape2(link.title) : null;
        var text = cap[1].replace(/\\([\[\]])/g, "$1");
        if (cap[0].charAt(0) !== "!") {
          lexer2.state.inLink = true;
          var token = {
            type: "link",
            raw,
            href,
            title,
            text,
            tokens: lexer2.inlineTokens(text, [])
          };
          lexer2.state.inLink = false;
          return token;
        } else {
          return {
            type: "image",
            raw,
            href,
            title,
            text: escape2(text)
          };
        }
      }
      function indentCodeCompensation(raw, text) {
        var matchIndentToCode = raw.match(/^(\s+)(?:```)/);
        if (matchIndentToCode === null) {
          return text;
        }
        var indentToCode = matchIndentToCode[1];
        return text.split("\n").map(function(node) {
          var matchIndentInNode = node.match(/^\s+/);
          if (matchIndentInNode === null) {
            return node;
          }
          var indentInNode = matchIndentInNode[0];
          if (indentInNode.length >= indentToCode.length) {
            return node.slice(indentToCode.length);
          }
          return node;
        }).join("\n");
      }
      var Tokenizer = /* @__PURE__ */ function() {
        function Tokenizer2(options2) {
          this.options = options2 || exports.defaults;
        }
        var _proto = Tokenizer2.prototype;
        _proto.space = function space(src) {
          var cap = this.rules.block.newline.exec(src);
          if (cap && cap[0].length > 0) {
            return {
              type: "space",
              raw: cap[0]
            };
          }
        };
        _proto.code = function code3(src) {
          var cap = this.rules.block.code.exec(src);
          if (cap) {
            var text = cap[0].replace(/^ {1,4}/gm, "");
            return {
              type: "code",
              raw: cap[0],
              codeBlockStyle: "indented",
              text: !this.options.pedantic ? rtrim(text, "\n") : text
            };
          }
        };
        _proto.fences = function fences(src) {
          var cap = this.rules.block.fences.exec(src);
          if (cap) {
            var raw = cap[0];
            var text = indentCodeCompensation(raw, cap[3] || "");
            return {
              type: "code",
              raw,
              lang: cap[2] ? cap[2].trim() : cap[2],
              text
            };
          }
        };
        _proto.heading = function heading(src) {
          var cap = this.rules.block.heading.exec(src);
          if (cap) {
            var text = cap[2].trim();
            if (/#$/.test(text)) {
              var trimmed = rtrim(text, "#");
              if (this.options.pedantic) {
                text = trimmed.trim();
              } else if (!trimmed || / $/.test(trimmed)) {
                text = trimmed.trim();
              }
            }
            var token = {
              type: "heading",
              raw: cap[0],
              depth: cap[1].length,
              text,
              tokens: []
            };
            this.lexer.inline(token.text, token.tokens);
            return token;
          }
        };
        _proto.hr = function hr(src) {
          var cap = this.rules.block.hr.exec(src);
          if (cap) {
            return {
              type: "hr",
              raw: cap[0]
            };
          }
        };
        _proto.blockquote = function blockquote(src) {
          var cap = this.rules.block.blockquote.exec(src);
          if (cap) {
            var text = cap[0].replace(/^ *> ?/gm, "");
            return {
              type: "blockquote",
              raw: cap[0],
              tokens: this.lexer.blockTokens(text, []),
              text
            };
          }
        };
        _proto.list = function list(src) {
          var cap = this.rules.block.list.exec(src);
          if (cap) {
            var raw, istask, ischecked, indent, i2, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
            var bull = cap[1].trim();
            var isordered = bull.length > 1;
            var list2 = {
              type: "list",
              raw: "",
              ordered: isordered,
              start: isordered ? +bull.slice(0, -1) : "",
              loose: false,
              items: []
            };
            bull = isordered ? "\\d{1,9}\\" + bull.slice(-1) : "\\" + bull;
            if (this.options.pedantic) {
              bull = isordered ? bull : "[*+-]";
            }
            var itemRegex = new RegExp("^( {0,3}" + bull + ")((?: [^\\n]*)?(?:\\n|$))");
            while (src) {
              endEarly = false;
              if (!(cap = itemRegex.exec(src))) {
                break;
              }
              if (this.rules.block.hr.test(src)) {
                break;
              }
              raw = cap[0];
              src = src.substring(raw.length);
              line = cap[2].split("\n", 1)[0];
              nextLine = src.split("\n", 1)[0];
              if (this.options.pedantic) {
                indent = 2;
                itemContents = line.trimLeft();
              } else {
                indent = cap[2].search(/[^ ]/);
                indent = indent > 4 ? 1 : indent;
                itemContents = line.slice(indent);
                indent += cap[1].length;
              }
              blankLine = false;
              if (!line && /^ *$/.test(nextLine)) {
                raw += nextLine + "\n";
                src = src.substring(nextLine.length + 1);
                endEarly = true;
              }
              if (!endEarly) {
                var nextBulletRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}(?:[*+-]|\\d{1,9}[.)])");
                while (src) {
                  rawLine = src.split("\n", 1)[0];
                  line = rawLine;
                  if (this.options.pedantic) {
                    line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
                  }
                  if (nextBulletRegex.test(line)) {
                    break;
                  }
                  if (line.search(/[^ ]/) >= indent || !line.trim()) {
                    itemContents += "\n" + line.slice(indent);
                  } else if (!blankLine) {
                    itemContents += "\n" + line;
                  } else {
                    break;
                  }
                  if (!blankLine && !line.trim()) {
                    blankLine = true;
                  }
                  raw += rawLine + "\n";
                  src = src.substring(rawLine.length + 1);
                }
              }
              if (!list2.loose) {
                if (endsWithBlankLine) {
                  list2.loose = true;
                } else if (/\n *\n *$/.test(raw)) {
                  endsWithBlankLine = true;
                }
              }
              if (this.options.gfm) {
                istask = /^\[[ xX]\] /.exec(itemContents);
                if (istask) {
                  ischecked = istask[0] !== "[ ] ";
                  itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
                }
              }
              list2.items.push({
                type: "list_item",
                raw,
                task: !!istask,
                checked: ischecked,
                loose: false,
                text: itemContents
              });
              list2.raw += raw;
            }
            list2.items[list2.items.length - 1].raw = raw.trimRight();
            list2.items[list2.items.length - 1].text = itemContents.trimRight();
            list2.raw = list2.raw.trimRight();
            var l2 = list2.items.length;
            for (i2 = 0; i2 < l2; i2++) {
              this.lexer.state.top = false;
              list2.items[i2].tokens = this.lexer.blockTokens(list2.items[i2].text, []);
              var spacers = list2.items[i2].tokens.filter(function(t2) {
                return t2.type === "space";
              });
              var hasMultipleLineBreaks = spacers.every(function(t2) {
                var chars = t2.raw.split("");
                var lineBreaks = 0;
                for (var _iterator = _createForOfIteratorHelperLoose(chars), _step; !(_step = _iterator()).done; ) {
                  var _char = _step.value;
                  if (_char === "\n") {
                    lineBreaks += 1;
                  }
                  if (lineBreaks > 1) {
                    return true;
                  }
                }
                return false;
              });
              if (!list2.loose && spacers.length && hasMultipleLineBreaks) {
                list2.loose = true;
                list2.items[i2].loose = true;
              }
            }
            return list2;
          }
        };
        _proto.html = function html(src) {
          var cap = this.rules.block.html.exec(src);
          if (cap) {
            var token = {
              type: "html",
              raw: cap[0],
              pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
              text: cap[0]
            };
            if (this.options.sanitize) {
              token.type = "paragraph";
              token.text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape2(cap[0]);
              token.tokens = [];
              this.lexer.inline(token.text, token.tokens);
            }
            return token;
          }
        };
        _proto.def = function def(src) {
          var cap = this.rules.block.def.exec(src);
          if (cap) {
            if (cap[3])
              cap[3] = cap[3].substring(1, cap[3].length - 1);
            var tag = cap[1].toLowerCase().replace(/\s+/g, " ");
            return {
              type: "def",
              tag,
              raw: cap[0],
              href: cap[2],
              title: cap[3]
            };
          }
        };
        _proto.table = function table(src) {
          var cap = this.rules.block.table.exec(src);
          if (cap) {
            var item = {
              type: "table",
              header: splitCells(cap[1]).map(function(c2) {
                return {
                  text: c2
                };
              }),
              align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
              rows: cap[3] ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
            };
            if (item.header.length === item.align.length) {
              item.raw = cap[0];
              var l2 = item.align.length;
              var i2, j2, k2, row;
              for (i2 = 0; i2 < l2; i2++) {
                if (/^ *-+: *$/.test(item.align[i2])) {
                  item.align[i2] = "right";
                } else if (/^ *:-+: *$/.test(item.align[i2])) {
                  item.align[i2] = "center";
                } else if (/^ *:-+ *$/.test(item.align[i2])) {
                  item.align[i2] = "left";
                } else {
                  item.align[i2] = null;
                }
              }
              l2 = item.rows.length;
              for (i2 = 0; i2 < l2; i2++) {
                item.rows[i2] = splitCells(item.rows[i2], item.header.length).map(function(c2) {
                  return {
                    text: c2
                  };
                });
              }
              l2 = item.header.length;
              for (j2 = 0; j2 < l2; j2++) {
                item.header[j2].tokens = [];
                this.lexer.inlineTokens(item.header[j2].text, item.header[j2].tokens);
              }
              l2 = item.rows.length;
              for (j2 = 0; j2 < l2; j2++) {
                row = item.rows[j2];
                for (k2 = 0; k2 < row.length; k2++) {
                  row[k2].tokens = [];
                  this.lexer.inlineTokens(row[k2].text, row[k2].tokens);
                }
              }
              return item;
            }
          }
        };
        _proto.lheading = function lheading(src) {
          var cap = this.rules.block.lheading.exec(src);
          if (cap) {
            var token = {
              type: "heading",
              raw: cap[0],
              depth: cap[2].charAt(0) === "=" ? 1 : 2,
              text: cap[1],
              tokens: []
            };
            this.lexer.inline(token.text, token.tokens);
            return token;
          }
        };
        _proto.paragraph = function paragraph(src) {
          var cap = this.rules.block.paragraph.exec(src);
          if (cap) {
            var token = {
              type: "paragraph",
              raw: cap[0],
              text: cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1],
              tokens: []
            };
            this.lexer.inline(token.text, token.tokens);
            return token;
          }
        };
        _proto.text = function text(src) {
          var cap = this.rules.block.text.exec(src);
          if (cap) {
            var token = {
              type: "text",
              raw: cap[0],
              text: cap[0],
              tokens: []
            };
            this.lexer.inline(token.text, token.tokens);
            return token;
          }
        };
        _proto.escape = function escape$1(src) {
          var cap = this.rules.inline.escape.exec(src);
          if (cap) {
            return {
              type: "escape",
              raw: cap[0],
              text: escape2(cap[1])
            };
          }
        };
        _proto.tag = function tag(src) {
          var cap = this.rules.inline.tag.exec(src);
          if (cap) {
            if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
              this.lexer.state.inLink = true;
            } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
              this.lexer.state.inLink = false;
            }
            if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
              this.lexer.state.inRawBlock = true;
            } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
              this.lexer.state.inRawBlock = false;
            }
            return {
              type: this.options.sanitize ? "text" : "html",
              raw: cap[0],
              inLink: this.lexer.state.inLink,
              inRawBlock: this.lexer.state.inRawBlock,
              text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape2(cap[0]) : cap[0]
            };
          }
        };
        _proto.link = function link(src) {
          var cap = this.rules.inline.link.exec(src);
          if (cap) {
            var trimmedUrl = cap[2].trim();
            if (!this.options.pedantic && /^</.test(trimmedUrl)) {
              if (!/>$/.test(trimmedUrl)) {
                return;
              }
              var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
              if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
                return;
              }
            } else {
              var lastParenIndex = findClosingBracket(cap[2], "()");
              if (lastParenIndex > -1) {
                var start4 = cap[0].indexOf("!") === 0 ? 5 : 4;
                var linkLen = start4 + cap[1].length + lastParenIndex;
                cap[2] = cap[2].substring(0, lastParenIndex);
                cap[0] = cap[0].substring(0, linkLen).trim();
                cap[3] = "";
              }
            }
            var href = cap[2];
            var title = "";
            if (this.options.pedantic) {
              var link2 = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
              if (link2) {
                href = link2[1];
                title = link2[3];
              }
            } else {
              title = cap[3] ? cap[3].slice(1, -1) : "";
            }
            href = href.trim();
            if (/^</.test(href)) {
              if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
                href = href.slice(1);
              } else {
                href = href.slice(1, -1);
              }
            }
            return outputLink(cap, {
              href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
              title: title ? title.replace(this.rules.inline._escapes, "$1") : title
            }, cap[0], this.lexer);
          }
        };
        _proto.reflink = function reflink(src, links) {
          var cap;
          if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
            var link = (cap[2] || cap[1]).replace(/\s+/g, " ");
            link = links[link.toLowerCase()];
            if (!link || !link.href) {
              var text = cap[0].charAt(0);
              return {
                type: "text",
                raw: text,
                text
              };
            }
            return outputLink(cap, link, cap[0], this.lexer);
          }
        };
        _proto.emStrong = function emStrong(src, maskedSrc, prevChar) {
          if (prevChar === void 0) {
            prevChar = "";
          }
          var match = this.rules.inline.emStrong.lDelim.exec(src);
          if (!match)
            return;
          if (match[3] && prevChar.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDF70-\uDF81\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/))
            return;
          var nextChar = match[1] || match[2] || "";
          if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
            var lLength = match[0].length - 1;
            var rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
            var endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
            endReg.lastIndex = 0;
            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
            while ((match = endReg.exec(maskedSrc)) != null) {
              rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
              if (!rDelim)
                continue;
              rLength = rDelim.length;
              if (match[3] || match[4]) {
                delimTotal += rLength;
                continue;
              } else if (match[5] || match[6]) {
                if (lLength % 3 && !((lLength + rLength) % 3)) {
                  midDelimTotal += rLength;
                  continue;
                }
              }
              delimTotal -= rLength;
              if (delimTotal > 0)
                continue;
              rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
              if (Math.min(lLength, rLength) % 2) {
                var _text = src.slice(1, lLength + match.index + rLength);
                return {
                  type: "em",
                  raw: src.slice(0, lLength + match.index + rLength + 1),
                  text: _text,
                  tokens: this.lexer.inlineTokens(_text, [])
                };
              }
              var text = src.slice(2, lLength + match.index + rLength - 1);
              return {
                type: "strong",
                raw: src.slice(0, lLength + match.index + rLength + 1),
                text,
                tokens: this.lexer.inlineTokens(text, [])
              };
            }
          }
        };
        _proto.codespan = function codespan(src) {
          var cap = this.rules.inline.code.exec(src);
          if (cap) {
            var text = cap[2].replace(/\n/g, " ");
            var hasNonSpaceChars = /[^ ]/.test(text);
            var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
              text = text.substring(1, text.length - 1);
            }
            text = escape2(text, true);
            return {
              type: "codespan",
              raw: cap[0],
              text
            };
          }
        };
        _proto.br = function br(src) {
          var cap = this.rules.inline.br.exec(src);
          if (cap) {
            return {
              type: "br",
              raw: cap[0]
            };
          }
        };
        _proto.del = function del3(src) {
          var cap = this.rules.inline.del.exec(src);
          if (cap) {
            return {
              type: "del",
              raw: cap[0],
              text: cap[2],
              tokens: this.lexer.inlineTokens(cap[2], [])
            };
          }
        };
        _proto.autolink = function autolink(src, mangle2) {
          var cap = this.rules.inline.autolink.exec(src);
          if (cap) {
            var text, href;
            if (cap[2] === "@") {
              text = escape2(this.options.mangle ? mangle2(cap[1]) : cap[1]);
              href = "mailto:" + text;
            } else {
              text = escape2(cap[1]);
              href = text;
            }
            return {
              type: "link",
              raw: cap[0],
              text,
              href,
              tokens: [{
                type: "text",
                raw: text,
                text
              }]
            };
          }
        };
        _proto.url = function url(src, mangle2) {
          var cap;
          if (cap = this.rules.inline.url.exec(src)) {
            var text, href;
            if (cap[2] === "@") {
              text = escape2(this.options.mangle ? mangle2(cap[0]) : cap[0]);
              href = "mailto:" + text;
            } else {
              var prevCapZero;
              do {
                prevCapZero = cap[0];
                cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
              } while (prevCapZero !== cap[0]);
              text = escape2(cap[0]);
              if (cap[1] === "www.") {
                href = "http://" + text;
              } else {
                href = text;
              }
            }
            return {
              type: "link",
              raw: cap[0],
              text,
              href,
              tokens: [{
                type: "text",
                raw: text,
                text
              }]
            };
          }
        };
        _proto.inlineText = function inlineText(src, smartypants2) {
          var cap = this.rules.inline.text.exec(src);
          if (cap) {
            var text;
            if (this.lexer.state.inRawBlock) {
              text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape2(cap[0]) : cap[0];
            } else {
              text = escape2(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
            }
            return {
              type: "text",
              raw: cap[0],
              text
            };
          }
        };
        return Tokenizer2;
      }();
      var block = {
        newline: /^(?: *(?:\n|$))+/,
        code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
        fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
        hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
        heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
        blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
        list: /^( {0,3}bull)( [^\n]+?)?(?:\n|$)/,
        html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
        def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
        table: noopTest,
        lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
        _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
        text: /^[^\n]+/
      };
      block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
      block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
      block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
      block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
      block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
      block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
      block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
      block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
      block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
      block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
      block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
      block.normal = merge({}, block);
      block.gfm = merge({}, block.normal, {
        table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
      });
      block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
      block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
      block.pedantic = merge({}, block.normal, {
        html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
        def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
        heading: /^(#{1,6})(.*)(?:\n+|$)/,
        fences: noopTest,
        paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
      });
      var inline = {
        escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
        autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
        url: noopTest,
        tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
        link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
        reflink: /^!?\[(label)\]\[(ref)\]/,
        nolink: /^!?\[(ref)\](?:\[\])?/,
        reflinkSearch: "reflink|nolink(?!\\()",
        emStrong: {
          lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
          rDelimAst: /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
          rDelimUnd: /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
        },
        code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
        br: /^( {2,}|\\)\n(?!\s*$)/,
        del: noopTest,
        text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
        punctuation: /^([\spunctuation])/
      };
      inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
      inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
      inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
      inline.escapedEmSt = /\\\*|\\_/g;
      inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
      inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
      inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
      inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
      inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
      inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
      inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
      inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
      inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
      inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
      inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
      inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
      inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
      inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
      inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
      inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
      inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
      inline.normal = merge({}, inline);
      inline.pedantic = merge({}, inline.normal, {
        strong: {
          start: /^__|\*\*/,
          middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
          endAst: /\*\*(?!\*)/g,
          endUnd: /__(?!_)/g
        },
        em: {
          start: /^_|\*/,
          middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
          endAst: /\*(?!\*)/g,
          endUnd: /_(?!_)/g
        },
        link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
        reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
      });
      inline.gfm = merge({}, inline.normal, {
        escape: edit(inline.escape).replace("])", "~|])").getRegex(),
        _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
        url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
        _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
        del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
        text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
      });
      inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
      inline.breaks = merge({}, inline.gfm, {
        br: edit(inline.br).replace("{2,}", "*").getRegex(),
        text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
      });
      function smartypants(text) {
        return text.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
      }
      function mangle(text) {
        var out = "", i2, ch;
        var l2 = text.length;
        for (i2 = 0; i2 < l2; i2++) {
          ch = text.charCodeAt(i2);
          if (Math.random() > 0.5) {
            ch = "x" + ch.toString(16);
          }
          out += "&#" + ch + ";";
        }
        return out;
      }
      var Lexer = /* @__PURE__ */ function() {
        function Lexer2(options2) {
          this.tokens = [];
          this.tokens.links = /* @__PURE__ */ Object.create(null);
          this.options = options2 || exports.defaults;
          this.options.tokenizer = this.options.tokenizer || new Tokenizer();
          this.tokenizer = this.options.tokenizer;
          this.tokenizer.options = this.options;
          this.tokenizer.lexer = this;
          this.inlineQueue = [];
          this.state = {
            inLink: false,
            inRawBlock: false,
            top: true
          };
          var rules = {
            block: block.normal,
            inline: inline.normal
          };
          if (this.options.pedantic) {
            rules.block = block.pedantic;
            rules.inline = inline.pedantic;
          } else if (this.options.gfm) {
            rules.block = block.gfm;
            if (this.options.breaks) {
              rules.inline = inline.breaks;
            } else {
              rules.inline = inline.gfm;
            }
          }
          this.tokenizer.rules = rules;
        }
        Lexer2.lex = function lex(src, options2) {
          var lexer2 = new Lexer2(options2);
          return lexer2.lex(src);
        };
        Lexer2.lexInline = function lexInline(src, options2) {
          var lexer2 = new Lexer2(options2);
          return lexer2.inlineTokens(src);
        };
        var _proto = Lexer2.prototype;
        _proto.lex = function lex(src) {
          src = src.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    ");
          this.blockTokens(src, this.tokens);
          var next;
          while (next = this.inlineQueue.shift()) {
            this.inlineTokens(next.src, next.tokens);
          }
          return this.tokens;
        };
        _proto.blockTokens = function blockTokens(src, tokens) {
          var _this = this;
          if (tokens === void 0) {
            tokens = [];
          }
          if (this.options.pedantic) {
            src = src.replace(/^ +$/gm, "");
          }
          var token, lastToken, cutSrc, lastParagraphClipped;
          while (src) {
            if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(function(extTokenizer) {
              if (token = extTokenizer.call({
                lexer: _this
              }, src, tokens)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                return true;
              }
              return false;
            })) {
              continue;
            }
            if (token = this.tokenizer.space(src)) {
              src = src.substring(token.raw.length);
              if (token.raw.length === 1 && tokens.length > 0) {
                tokens[tokens.length - 1].raw += "\n";
              } else {
                tokens.push(token);
              }
              continue;
            }
            if (token = this.tokenizer.code(src)) {
              src = src.substring(token.raw.length);
              lastToken = tokens[tokens.length - 1];
              if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
                lastToken.raw += "\n" + token.raw;
                lastToken.text += "\n" + token.text;
                this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
              } else {
                tokens.push(token);
              }
              continue;
            }
            if (token = this.tokenizer.fences(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.heading(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.hr(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.blockquote(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.list(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.html(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.def(src)) {
              src = src.substring(token.raw.length);
              lastToken = tokens[tokens.length - 1];
              if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
                lastToken.raw += "\n" + token.raw;
                lastToken.text += "\n" + token.raw;
                this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
              } else if (!this.tokens.links[token.tag]) {
                this.tokens.links[token.tag] = {
                  href: token.href,
                  title: token.title
                };
              }
              continue;
            }
            if (token = this.tokenizer.table(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.lheading(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            cutSrc = src;
            if (this.options.extensions && this.options.extensions.startBlock) {
              (function() {
                var startIndex = Infinity;
                var tempSrc = src.slice(1);
                var tempStart = void 0;
                _this.options.extensions.startBlock.forEach(function(getStartIndex) {
                  tempStart = getStartIndex.call({
                    lexer: this
                  }, tempSrc);
                  if (typeof tempStart === "number" && tempStart >= 0) {
                    startIndex = Math.min(startIndex, tempStart);
                  }
                });
                if (startIndex < Infinity && startIndex >= 0) {
                  cutSrc = src.substring(0, startIndex + 1);
                }
              })();
            }
            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
              lastToken = tokens[tokens.length - 1];
              if (lastParagraphClipped && lastToken.type === "paragraph") {
                lastToken.raw += "\n" + token.raw;
                lastToken.text += "\n" + token.text;
                this.inlineQueue.pop();
                this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
              } else {
                tokens.push(token);
              }
              lastParagraphClipped = cutSrc.length !== src.length;
              src = src.substring(token.raw.length);
              continue;
            }
            if (token = this.tokenizer.text(src)) {
              src = src.substring(token.raw.length);
              lastToken = tokens[tokens.length - 1];
              if (lastToken && lastToken.type === "text") {
                lastToken.raw += "\n" + token.raw;
                lastToken.text += "\n" + token.text;
                this.inlineQueue.pop();
                this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
              } else {
                tokens.push(token);
              }
              continue;
            }
            if (src) {
              var errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
              if (this.options.silent) {
                console.error(errMsg);
                break;
              } else {
                throw new Error(errMsg);
              }
            }
          }
          this.state.top = true;
          return tokens;
        };
        _proto.inline = function inline2(src, tokens) {
          this.inlineQueue.push({
            src,
            tokens
          });
        };
        _proto.inlineTokens = function inlineTokens(src, tokens) {
          var _this2 = this;
          if (tokens === void 0) {
            tokens = [];
          }
          var token, lastToken, cutSrc;
          var maskedSrc = src;
          var match;
          var keepPrevChar, prevChar;
          if (this.tokens.links) {
            var links = Object.keys(this.tokens.links);
            if (links.length > 0) {
              while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
                if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
                  maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
                }
              }
            }
          }
          while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
          }
          while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
            maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
          }
          while (src) {
            if (!keepPrevChar) {
              prevChar = "";
            }
            keepPrevChar = false;
            if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(function(extTokenizer) {
              if (token = extTokenizer.call({
                lexer: _this2
              }, src, tokens)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                return true;
              }
              return false;
            })) {
              continue;
            }
            if (token = this.tokenizer.escape(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.tag(src)) {
              src = src.substring(token.raw.length);
              lastToken = tokens[tokens.length - 1];
              if (lastToken && token.type === "text" && lastToken.type === "text") {
                lastToken.raw += token.raw;
                lastToken.text += token.text;
              } else {
                tokens.push(token);
              }
              continue;
            }
            if (token = this.tokenizer.link(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.reflink(src, this.tokens.links)) {
              src = src.substring(token.raw.length);
              lastToken = tokens[tokens.length - 1];
              if (lastToken && token.type === "text" && lastToken.type === "text") {
                lastToken.raw += token.raw;
                lastToken.text += token.text;
              } else {
                tokens.push(token);
              }
              continue;
            }
            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.codespan(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.br(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.del(src)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (token = this.tokenizer.autolink(src, mangle)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              continue;
            }
            cutSrc = src;
            if (this.options.extensions && this.options.extensions.startInline) {
              (function() {
                var startIndex = Infinity;
                var tempSrc = src.slice(1);
                var tempStart = void 0;
                _this2.options.extensions.startInline.forEach(function(getStartIndex) {
                  tempStart = getStartIndex.call({
                    lexer: this
                  }, tempSrc);
                  if (typeof tempStart === "number" && tempStart >= 0) {
                    startIndex = Math.min(startIndex, tempStart);
                  }
                });
                if (startIndex < Infinity && startIndex >= 0) {
                  cutSrc = src.substring(0, startIndex + 1);
                }
              })();
            }
            if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
              src = src.substring(token.raw.length);
              if (token.raw.slice(-1) !== "_") {
                prevChar = token.raw.slice(-1);
              }
              keepPrevChar = true;
              lastToken = tokens[tokens.length - 1];
              if (lastToken && lastToken.type === "text") {
                lastToken.raw += token.raw;
                lastToken.text += token.text;
              } else {
                tokens.push(token);
              }
              continue;
            }
            if (src) {
              var errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
              if (this.options.silent) {
                console.error(errMsg);
                break;
              } else {
                throw new Error(errMsg);
              }
            }
          }
          return tokens;
        };
        _createClass(Lexer2, null, [{
          key: "rules",
          get: function get() {
            return {
              block,
              inline
            };
          }
        }]);
        return Lexer2;
      }();
      var Renderer2 = /* @__PURE__ */ function() {
        function Renderer3(options2) {
          this.options = options2 || exports.defaults;
        }
        var _proto = Renderer3.prototype;
        _proto.code = function code3(_code, infostring, escaped) {
          var lang = (infostring || "").match(/\S*/)[0];
          if (this.options.highlight) {
            var out = this.options.highlight(_code, lang);
            if (out != null && out !== _code) {
              escaped = true;
              _code = out;
            }
          }
          _code = _code.replace(/\n$/, "") + "\n";
          if (!lang) {
            return "<pre><code>" + (escaped ? _code : escape2(_code, true)) + "</code></pre>\n";
          }
          return '<pre><code class="' + this.options.langPrefix + escape2(lang, true) + '">' + (escaped ? _code : escape2(_code, true)) + "</code></pre>\n";
        };
        _proto.blockquote = function blockquote(quote) {
          return "<blockquote>\n" + quote + "</blockquote>\n";
        };
        _proto.html = function html(_html) {
          return _html;
        };
        _proto.heading = function heading(text, level, raw, slugger) {
          if (this.options.headerIds) {
            return "<h" + level + ' id="' + this.options.headerPrefix + slugger.slug(raw) + '">' + text + "</h" + level + ">\n";
          }
          return "<h" + level + ">" + text + "</h" + level + ">\n";
        };
        _proto.hr = function hr() {
          return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
        };
        _proto.list = function list(body, ordered, start4) {
          var type = ordered ? "ol" : "ul", startatt = ordered && start4 !== 1 ? ' start="' + start4 + '"' : "";
          return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
        };
        _proto.listitem = function listitem(text) {
          return "<li>" + text + "</li>\n";
        };
        _proto.checkbox = function checkbox(checked) {
          return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
        };
        _proto.paragraph = function paragraph(text) {
          return "<p>" + text + "</p>\n";
        };
        _proto.table = function table(header, body) {
          if (body)
            body = "<tbody>" + body + "</tbody>";
          return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
        };
        _proto.tablerow = function tablerow(content) {
          return "<tr>\n" + content + "</tr>\n";
        };
        _proto.tablecell = function tablecell(content, flags) {
          var type = flags.header ? "th" : "td";
          var tag = flags.align ? "<" + type + ' align="' + flags.align + '">' : "<" + type + ">";
          return tag + content + "</" + type + ">\n";
        };
        _proto.strong = function strong(text) {
          return "<strong>" + text + "</strong>";
        };
        _proto.em = function em(text) {
          return "<em>" + text + "</em>";
        };
        _proto.codespan = function codespan(text) {
          return "<code>" + text + "</code>";
        };
        _proto.br = function br() {
          return this.options.xhtml ? "<br/>" : "<br>";
        };
        _proto.del = function del3(text) {
          return "<del>" + text + "</del>";
        };
        _proto.link = function link(href, title, text) {
          href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
          if (href === null) {
            return text;
          }
          var out = '<a href="' + escape2(href) + '"';
          if (title) {
            out += ' title="' + title + '"';
          }
          out += ">" + text + "</a>";
          return out;
        };
        _proto.image = function image(href, title, text) {
          href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
          if (href === null) {
            return text;
          }
          var out = '<img src="' + href + '" alt="' + text + '"';
          if (title) {
            out += ' title="' + title + '"';
          }
          out += this.options.xhtml ? "/>" : ">";
          return out;
        };
        _proto.text = function text(_text) {
          return _text;
        };
        return Renderer3;
      }();
      var TextRenderer = /* @__PURE__ */ function() {
        function TextRenderer2() {
        }
        var _proto = TextRenderer2.prototype;
        _proto.strong = function strong(text) {
          return text;
        };
        _proto.em = function em(text) {
          return text;
        };
        _proto.codespan = function codespan(text) {
          return text;
        };
        _proto.del = function del3(text) {
          return text;
        };
        _proto.html = function html(text) {
          return text;
        };
        _proto.text = function text(_text) {
          return _text;
        };
        _proto.link = function link(href, title, text) {
          return "" + text;
        };
        _proto.image = function image(href, title, text) {
          return "" + text;
        };
        _proto.br = function br() {
          return "";
        };
        return TextRenderer2;
      }();
      var Slugger = /* @__PURE__ */ function() {
        function Slugger2() {
          this.seen = {};
        }
        var _proto = Slugger2.prototype;
        _proto.serialize = function serialize(value) {
          return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
        };
        _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {
          var slug = originalSlug;
          var occurenceAccumulator = 0;
          if (this.seen.hasOwnProperty(slug)) {
            occurenceAccumulator = this.seen[originalSlug];
            do {
              occurenceAccumulator++;
              slug = originalSlug + "-" + occurenceAccumulator;
            } while (this.seen.hasOwnProperty(slug));
          }
          if (!isDryRun) {
            this.seen[originalSlug] = occurenceAccumulator;
            this.seen[slug] = 0;
          }
          return slug;
        };
        _proto.slug = function slug(value, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var slug2 = this.serialize(value);
          return this.getNextSafeSlug(slug2, options2.dryrun);
        };
        return Slugger2;
      }();
      var Parser = /* @__PURE__ */ function() {
        function Parser2(options2) {
          this.options = options2 || exports.defaults;
          this.options.renderer = this.options.renderer || new Renderer2();
          this.renderer = this.options.renderer;
          this.renderer.options = this.options;
          this.textRenderer = new TextRenderer();
          this.slugger = new Slugger();
        }
        Parser2.parse = function parse2(tokens, options2) {
          var parser2 = new Parser2(options2);
          return parser2.parse(tokens);
        };
        Parser2.parseInline = function parseInline2(tokens, options2) {
          var parser2 = new Parser2(options2);
          return parser2.parseInline(tokens);
        };
        var _proto = Parser2.prototype;
        _proto.parse = function parse2(tokens, top2) {
          if (top2 === void 0) {
            top2 = true;
          }
          var out = "", i2, j2, k2, l2, l3, row, cell, header, body, token, ordered, start4, loose, itemBody, item, checked, task, checkbox, ret;
          var l4 = tokens.length;
          for (i2 = 0; i2 < l4; i2++) {
            token = tokens[i2];
            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
              ret = this.options.extensions.renderers[token.type].call({
                parser: this
              }, token);
              if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
                out += ret || "";
                continue;
              }
            }
            switch (token.type) {
              case "space": {
                continue;
              }
              case "hr": {
                out += this.renderer.hr();
                continue;
              }
              case "heading": {
                out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape3(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
                continue;
              }
              case "code": {
                out += this.renderer.code(token.text, token.lang, token.escaped);
                continue;
              }
              case "table": {
                header = "";
                cell = "";
                l2 = token.header.length;
                for (j2 = 0; j2 < l2; j2++) {
                  cell += this.renderer.tablecell(this.parseInline(token.header[j2].tokens), {
                    header: true,
                    align: token.align[j2]
                  });
                }
                header += this.renderer.tablerow(cell);
                body = "";
                l2 = token.rows.length;
                for (j2 = 0; j2 < l2; j2++) {
                  row = token.rows[j2];
                  cell = "";
                  l3 = row.length;
                  for (k2 = 0; k2 < l3; k2++) {
                    cell += this.renderer.tablecell(this.parseInline(row[k2].tokens), {
                      header: false,
                      align: token.align[k2]
                    });
                  }
                  body += this.renderer.tablerow(cell);
                }
                out += this.renderer.table(header, body);
                continue;
              }
              case "blockquote": {
                body = this.parse(token.tokens);
                out += this.renderer.blockquote(body);
                continue;
              }
              case "list": {
                ordered = token.ordered;
                start4 = token.start;
                loose = token.loose;
                l2 = token.items.length;
                body = "";
                for (j2 = 0; j2 < l2; j2++) {
                  item = token.items[j2];
                  checked = item.checked;
                  task = item.task;
                  itemBody = "";
                  if (item.task) {
                    checkbox = this.renderer.checkbox(checked);
                    if (loose) {
                      if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                        item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                        if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                          item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                        }
                      } else {
                        item.tokens.unshift({
                          type: "text",
                          text: checkbox
                        });
                      }
                    } else {
                      itemBody += checkbox;
                    }
                  }
                  itemBody += this.parse(item.tokens, loose);
                  body += this.renderer.listitem(itemBody, task, checked);
                }
                out += this.renderer.list(body, ordered, start4);
                continue;
              }
              case "html": {
                out += this.renderer.html(token.text);
                continue;
              }
              case "paragraph": {
                out += this.renderer.paragraph(this.parseInline(token.tokens));
                continue;
              }
              case "text": {
                body = token.tokens ? this.parseInline(token.tokens) : token.text;
                while (i2 + 1 < l4 && tokens[i2 + 1].type === "text") {
                  token = tokens[++i2];
                  body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
                }
                out += top2 ? this.renderer.paragraph(body) : body;
                continue;
              }
              default: {
                var errMsg = 'Token with "' + token.type + '" type was not found.';
                if (this.options.silent) {
                  console.error(errMsg);
                  return;
                } else {
                  throw new Error(errMsg);
                }
              }
            }
          }
          return out;
        };
        _proto.parseInline = function parseInline2(tokens, renderer) {
          renderer = renderer || this.renderer;
          var out = "", i2, token, ret;
          var l2 = tokens.length;
          for (i2 = 0; i2 < l2; i2++) {
            token = tokens[i2];
            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
              ret = this.options.extensions.renderers[token.type].call({
                parser: this
              }, token);
              if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
                out += ret || "";
                continue;
              }
            }
            switch (token.type) {
              case "escape": {
                out += renderer.text(token.text);
                break;
              }
              case "html": {
                out += renderer.html(token.text);
                break;
              }
              case "link": {
                out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
                break;
              }
              case "image": {
                out += renderer.image(token.href, token.title, token.text);
                break;
              }
              case "strong": {
                out += renderer.strong(this.parseInline(token.tokens, renderer));
                break;
              }
              case "em": {
                out += renderer.em(this.parseInline(token.tokens, renderer));
                break;
              }
              case "codespan": {
                out += renderer.codespan(token.text);
                break;
              }
              case "br": {
                out += renderer.br();
                break;
              }
              case "del": {
                out += renderer.del(this.parseInline(token.tokens, renderer));
                break;
              }
              case "text": {
                out += renderer.text(token.text);
                break;
              }
              default: {
                var errMsg = 'Token with "' + token.type + '" type was not found.';
                if (this.options.silent) {
                  console.error(errMsg);
                  return;
                } else {
                  throw new Error(errMsg);
                }
              }
            }
          }
          return out;
        };
        return Parser2;
      }();
      function marked(src, opt, callback) {
        if (typeof src === "undefined" || src === null) {
          throw new Error("marked(): input parameter is undefined or null");
        }
        if (typeof src !== "string") {
          throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
        }
        if (typeof opt === "function") {
          callback = opt;
          opt = null;
        }
        opt = merge({}, marked.defaults, opt || {});
        checkSanitizeDeprecation(opt);
        if (callback) {
          var highlight = opt.highlight;
          var tokens;
          try {
            tokens = Lexer.lex(src, opt);
          } catch (e2) {
            return callback(e2);
          }
          var done = function done2(err) {
            var out;
            if (!err) {
              try {
                if (opt.walkTokens) {
                  marked.walkTokens(tokens, opt.walkTokens);
                }
                out = Parser.parse(tokens, opt);
              } catch (e2) {
                err = e2;
              }
            }
            opt.highlight = highlight;
            return err ? callback(err) : callback(null, out);
          };
          if (!highlight || highlight.length < 3) {
            return done();
          }
          delete opt.highlight;
          if (!tokens.length)
            return done();
          var pending = 0;
          marked.walkTokens(tokens, function(token) {
            if (token.type === "code") {
              pending++;
              setTimeout(function() {
                highlight(token.text, token.lang, function(err, code3) {
                  if (err) {
                    return done(err);
                  }
                  if (code3 != null && code3 !== token.text) {
                    token.text = code3;
                    token.escaped = true;
                  }
                  pending--;
                  if (pending === 0) {
                    done();
                  }
                });
              }, 0);
            }
          });
          if (pending === 0) {
            done();
          }
          return;
        }
        try {
          var _tokens = Lexer.lex(src, opt);
          if (opt.walkTokens) {
            marked.walkTokens(_tokens, opt.walkTokens);
          }
          return Parser.parse(_tokens, opt);
        } catch (e2) {
          e2.message += "\nPlease report this to https://github.com/markedjs/marked.";
          if (opt.silent) {
            return "<p>An error occurred:</p><pre>" + escape2(e2.message + "", true) + "</pre>";
          }
          throw e2;
        }
      }
      marked.options = marked.setOptions = function(opt) {
        merge(marked.defaults, opt);
        changeDefaults(marked.defaults);
        return marked;
      };
      marked.getDefaults = getDefaults;
      marked.defaults = exports.defaults;
      marked.use = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var opts = merge.apply(void 0, [{}].concat(args));
        var extensions = marked.defaults.extensions || {
          renderers: {},
          childTokens: {}
        };
        var hasExtensions;
        args.forEach(function(pack) {
          if (pack.extensions) {
            hasExtensions = true;
            pack.extensions.forEach(function(ext) {
              if (!ext.name) {
                throw new Error("extension name required");
              }
              if (ext.renderer) {
                var prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;
                if (prevRenderer) {
                  extensions.renderers[ext.name] = function() {
                    for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                      args2[_key2] = arguments[_key2];
                    }
                    var ret = ext.renderer.apply(this, args2);
                    if (ret === false) {
                      ret = prevRenderer.apply(this, args2);
                    }
                    return ret;
                  };
                } else {
                  extensions.renderers[ext.name] = ext.renderer;
                }
              }
              if (ext.tokenizer) {
                if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                  throw new Error("extension level must be 'block' or 'inline'");
                }
                if (extensions[ext.level]) {
                  extensions[ext.level].unshift(ext.tokenizer);
                } else {
                  extensions[ext.level] = [ext.tokenizer];
                }
                if (ext.start) {
                  if (ext.level === "block") {
                    if (extensions.startBlock) {
                      extensions.startBlock.push(ext.start);
                    } else {
                      extensions.startBlock = [ext.start];
                    }
                  } else if (ext.level === "inline") {
                    if (extensions.startInline) {
                      extensions.startInline.push(ext.start);
                    } else {
                      extensions.startInline = [ext.start];
                    }
                  }
                }
              }
              if (ext.childTokens) {
                extensions.childTokens[ext.name] = ext.childTokens;
              }
            });
          }
          if (pack.renderer) {
            (function() {
              var renderer = marked.defaults.renderer || new Renderer2();
              var _loop = function _loop2(prop2) {
                var prevRenderer = renderer[prop2];
                renderer[prop2] = function() {
                  for (var _len3 = arguments.length, args2 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                    args2[_key3] = arguments[_key3];
                  }
                  var ret = pack.renderer[prop2].apply(renderer, args2);
                  if (ret === false) {
                    ret = prevRenderer.apply(renderer, args2);
                  }
                  return ret;
                };
              };
              for (var prop in pack.renderer) {
                _loop(prop);
              }
              opts.renderer = renderer;
            })();
          }
          if (pack.tokenizer) {
            (function() {
              var tokenizer = marked.defaults.tokenizer || new Tokenizer();
              var _loop2 = function _loop22(prop2) {
                var prevTokenizer = tokenizer[prop2];
                tokenizer[prop2] = function() {
                  for (var _len4 = arguments.length, args2 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                    args2[_key4] = arguments[_key4];
                  }
                  var ret = pack.tokenizer[prop2].apply(tokenizer, args2);
                  if (ret === false) {
                    ret = prevTokenizer.apply(tokenizer, args2);
                  }
                  return ret;
                };
              };
              for (var prop in pack.tokenizer) {
                _loop2(prop);
              }
              opts.tokenizer = tokenizer;
            })();
          }
          if (pack.walkTokens) {
            var _walkTokens = marked.defaults.walkTokens;
            opts.walkTokens = function(token) {
              pack.walkTokens.call(this, token);
              if (_walkTokens) {
                _walkTokens.call(this, token);
              }
            };
          }
          if (hasExtensions) {
            opts.extensions = extensions;
          }
          marked.setOptions(opts);
        });
      };
      marked.walkTokens = function(tokens, callback) {
        var _loop3 = function _loop32() {
          var token = _step.value;
          callback.call(marked, token);
          switch (token.type) {
            case "table": {
              for (var _iterator2 = _createForOfIteratorHelperLoose(token.header), _step2; !(_step2 = _iterator2()).done; ) {
                var cell = _step2.value;
                marked.walkTokens(cell.tokens, callback);
              }
              for (var _iterator3 = _createForOfIteratorHelperLoose(token.rows), _step3; !(_step3 = _iterator3()).done; ) {
                var row = _step3.value;
                for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done; ) {
                  var _cell = _step4.value;
                  marked.walkTokens(_cell.tokens, callback);
                }
              }
              break;
            }
            case "list": {
              marked.walkTokens(token.items, callback);
              break;
            }
            default: {
              if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
                marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
                  marked.walkTokens(token[childTokens], callback);
                });
              } else if (token.tokens) {
                marked.walkTokens(token.tokens, callback);
              }
            }
          }
        };
        for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done; ) {
          _loop3();
        }
      };
      marked.parseInline = function(src, opt) {
        if (typeof src === "undefined" || src === null) {
          throw new Error("marked.parseInline(): input parameter is undefined or null");
        }
        if (typeof src !== "string") {
          throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
        }
        opt = merge({}, marked.defaults, opt || {});
        checkSanitizeDeprecation(opt);
        try {
          var tokens = Lexer.lexInline(src, opt);
          if (opt.walkTokens) {
            marked.walkTokens(tokens, opt.walkTokens);
          }
          return Parser.parseInline(tokens, opt);
        } catch (e2) {
          e2.message += "\nPlease report this to https://github.com/markedjs/marked.";
          if (opt.silent) {
            return "<p>An error occurred:</p><pre>" + escape2(e2.message + "", true) + "</pre>";
          }
          throw e2;
        }
      };
      marked.Parser = Parser;
      marked.parser = Parser.parse;
      marked.Renderer = Renderer2;
      marked.TextRenderer = TextRenderer;
      marked.Lexer = Lexer;
      marked.lexer = Lexer.lex;
      marked.Tokenizer = Tokenizer;
      marked.Slugger = Slugger;
      marked.parse = marked;
      var options = marked.options;
      var setOptions = marked.setOptions;
      var use = marked.use;
      var walkTokens = marked.walkTokens;
      var parseInline = marked.parseInline;
      var parse = marked;
      var parser = Parser.parse;
      var lexer = Lexer.lex;
      exports.Lexer = Lexer;
      exports.Parser = Parser;
      exports.Renderer = Renderer2;
      exports.Slugger = Slugger;
      exports.TextRenderer = TextRenderer;
      exports.Tokenizer = Tokenizer;
      exports.getDefaults = getDefaults;
      exports.lexer = lexer;
      exports.marked = marked;
      exports.options = options;
      exports.parse = parse;
      exports.parseInline = parseInline;
      exports.parser = parser;
      exports.setOptions = setOptions;
      exports.use = use;
      exports.walkTokens = walkTokens;
    }
  });

  // node_modules/simplemde/src/js/simplemde.js
  var require_simplemde = __commonJS({
    "node_modules/simplemde/src/js/simplemde.js"(exports, module) {
      "use strict";
      var CodeMirror3 = require_codemirror2();
      require_continuelist();
      require_tablist();
      require_fullscreen();
      require_markdown2();
      require_overlay2();
      require_placeholder();
      require_mark_selection();
      require_gfm();
      require_xml2();
      var CodeMirrorSpellChecker = require_spell_checker();
      var marked = require_marked();
      var isMac2 = /Mac/.test(navigator.platform);
      var bindings = {
        "toggleBold": toggleBold,
        "toggleItalic": toggleItalic,
        "drawLink": drawLink,
        "toggleHeadingSmaller": toggleHeadingSmaller,
        "toggleHeadingBigger": toggleHeadingBigger,
        "drawImage": drawImage,
        "toggleBlockquote": toggleBlockquote,
        "toggleOrderedList": toggleOrderedList,
        "toggleUnorderedList": toggleUnorderedList,
        "toggleCodeBlock": toggleCodeBlock,
        "togglePreview": togglePreview,
        "toggleStrikethrough": toggleStrikethrough,
        "toggleHeading1": toggleHeading1,
        "toggleHeading2": toggleHeading2,
        "toggleHeading3": toggleHeading3,
        "cleanBlock": cleanBlock,
        "drawTable": drawTable,
        "drawHorizontalRule": drawHorizontalRule,
        "undo": undo,
        "redo": redo,
        "toggleSideBySide": toggleSideBySide,
        "toggleFullScreen": toggleFullScreen
      };
      var shortcuts = {
        "toggleBold": "Cmd-B",
        "toggleItalic": "Cmd-I",
        "drawLink": "Cmd-K",
        "toggleHeadingSmaller": "Cmd-H",
        "toggleHeadingBigger": "Shift-Cmd-H",
        "cleanBlock": "Cmd-E",
        "drawImage": "Cmd-Alt-I",
        "toggleBlockquote": "Cmd-'",
        "toggleOrderedList": "Cmd-Alt-L",
        "toggleUnorderedList": "Cmd-L",
        "toggleCodeBlock": "Cmd-Alt-C",
        "togglePreview": "Cmd-P",
        "toggleSideBySide": "F9",
        "toggleFullScreen": "F11"
      };
      var getBindingName = function(f2) {
        for (var key in bindings) {
          if (bindings[key] === f2) {
            return key;
          }
        }
        return null;
      };
      var isMobile = function() {
        var check = false;
        (function(a2) {
          if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a2) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a2.substr(0, 4)))
            check = true;
        })(navigator.userAgent || navigator.vendor || window.opera);
        return check;
      };
      function fixShortcut(name) {
        if (isMac2) {
          name = name.replace("Ctrl", "Cmd");
        } else {
          name = name.replace("Cmd", "Ctrl");
        }
        return name;
      }
      function createIcon(options, enableTooltips, shortcuts2) {
        options = options || {};
        var el = document.createElement("a");
        enableTooltips = enableTooltips == void 0 ? true : enableTooltips;
        if (options.title && enableTooltips) {
          el.title = createTootlip(options.title, options.action, shortcuts2);
          if (isMac2) {
            el.title = el.title.replace("Ctrl", "\u2318");
            el.title = el.title.replace("Alt", "\u2325");
          }
        }
        el.tabIndex = -1;
        el.className = options.className;
        return el;
      }
      function createSep() {
        var el = document.createElement("i");
        el.className = "separator";
        el.innerHTML = "|";
        return el;
      }
      function createTootlip(title, action, shortcuts2) {
        var actionName;
        var tooltip = title;
        if (action) {
          actionName = getBindingName(action);
          if (shortcuts2[actionName]) {
            tooltip += " (" + fixShortcut(shortcuts2[actionName]) + ")";
          }
        }
        return tooltip;
      }
      function getState(cm, pos) {
        pos = pos || cm.getCursor("start");
        var stat = cm.getTokenAt(pos);
        if (!stat.type)
          return {};
        var types = stat.type.split(" ");
        var ret = {}, data, text;
        for (var i2 = 0; i2 < types.length; i2++) {
          data = types[i2];
          if (data === "strong") {
            ret.bold = true;
          } else if (data === "variable-2") {
            text = cm.getLine(pos.line);
            if (/^\s*\d+\.\s/.test(text)) {
              ret["ordered-list"] = true;
            } else {
              ret["unordered-list"] = true;
            }
          } else if (data === "atom") {
            ret.quote = true;
          } else if (data === "em") {
            ret.italic = true;
          } else if (data === "quote") {
            ret.quote = true;
          } else if (data === "strikethrough") {
            ret.strikethrough = true;
          } else if (data === "comment") {
            ret.code = true;
          } else if (data === "link") {
            ret.link = true;
          } else if (data === "tag") {
            ret.image = true;
          } else if (data.match(/^header(\-[1-6])?$/)) {
            ret[data.replace("header", "heading")] = true;
          }
        }
        return ret;
      }
      var saved_overflow = "";
      function toggleFullScreen(editor) {
        var cm = editor.codemirror;
        cm.setOption("fullScreen", !cm.getOption("fullScreen"));
        if (cm.getOption("fullScreen")) {
          saved_overflow = document.body.style.overflow;
          document.body.style.overflow = "hidden";
        } else {
          document.body.style.overflow = saved_overflow;
        }
        var wrap2 = cm.getWrapperElement();
        if (!/fullscreen/.test(wrap2.previousSibling.className)) {
          wrap2.previousSibling.className += " fullscreen";
        } else {
          wrap2.previousSibling.className = wrap2.previousSibling.className.replace(/\s*fullscreen\b/, "");
        }
        var toolbarButton = editor.toolbarElements.fullscreen;
        if (!/active/.test(toolbarButton.className)) {
          toolbarButton.className += " active";
        } else {
          toolbarButton.className = toolbarButton.className.replace(/\s*active\s*/g, "");
        }
        var sidebyside = cm.getWrapperElement().nextSibling;
        if (/editor-preview-active-side/.test(sidebyside.className))
          toggleSideBySide(editor);
      }
      function toggleBold(editor) {
        _toggleBlock(editor, "bold", editor.options.blockStyles.bold);
      }
      function toggleItalic(editor) {
        _toggleBlock(editor, "italic", editor.options.blockStyles.italic);
      }
      function toggleStrikethrough(editor) {
        _toggleBlock(editor, "strikethrough", "~~");
      }
      function toggleCodeBlock(editor) {
        var fenceCharsToInsert = editor.options.blockStyles.code;
        function fencing_line(line2) {
          if (typeof line2 !== "object") {
            throw "fencing_line() takes a 'line' object (not a line number, or line text).  Got: " + typeof line2 + ": " + line2;
          }
          return line2.styles && line2.styles[2] && line2.styles[2].indexOf("formatting-code-block") !== -1;
        }
        function token_state(token) {
          return token.state.base.base || token.state.base;
        }
        function code_type(cm2, line_num, line2, firstTok, lastTok) {
          line2 = line2 || cm2.getLineHandle(line_num);
          firstTok = firstTok || cm2.getTokenAt({
            line: line_num,
            ch: 1
          });
          lastTok = lastTok || !!line2.text && cm2.getTokenAt({
            line: line_num,
            ch: line2.text.length - 1
          });
          var types = firstTok.type ? firstTok.type.split(" ") : [];
          if (lastTok && token_state(lastTok).indentedCode) {
            return "indented";
          } else if (types.indexOf("comment") === -1) {
            return false;
          } else if (token_state(firstTok).fencedChars || token_state(lastTok).fencedChars || fencing_line(line2)) {
            return "fenced";
          } else {
            return "single";
          }
        }
        function insertFencingAtSelection(cm2, cur_start2, cur_end2, fenceCharsToInsert2) {
          var start_line_sel = cur_start2.line + 1, end_line_sel = cur_end2.line + 1, sel_multi2 = cur_start2.line !== cur_end2.line, repl_start = fenceCharsToInsert2 + "\n", repl_end = "\n" + fenceCharsToInsert2;
          if (sel_multi2) {
            end_line_sel++;
          }
          if (sel_multi2 && cur_end2.ch === 0) {
            repl_end = fenceCharsToInsert2 + "\n";
            end_line_sel--;
          }
          _replaceSelection(cm2, false, [repl_start, repl_end]);
          cm2.setSelection({
            line: start_line_sel,
            ch: 0
          }, {
            line: end_line_sel,
            ch: 0
          });
        }
        var cm = editor.codemirror, cur_start = cm.getCursor("start"), cur_end = cm.getCursor("end"), tok = cm.getTokenAt({
          line: cur_start.line,
          ch: cur_start.ch || 1
        }), line = cm.getLineHandle(cur_start.line), is_code = code_type(cm, cur_start.line, line, tok);
        var block_start, block_end, lineCount;
        if (is_code === "single") {
          var start4 = line.text.slice(0, cur_start.ch).replace("`", ""), end2 = line.text.slice(cur_start.ch).replace("`", "");
          cm.replaceRange(start4 + end2, {
            line: cur_start.line,
            ch: 0
          }, {
            line: cur_start.line,
            ch: 99999999999999
          });
          cur_start.ch--;
          if (cur_start !== cur_end) {
            cur_end.ch--;
          }
          cm.setSelection(cur_start, cur_end);
          cm.focus();
        } else if (is_code === "fenced") {
          if (cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {
            for (block_start = cur_start.line; block_start >= 0; block_start--) {
              line = cm.getLineHandle(block_start);
              if (fencing_line(line)) {
                break;
              }
            }
            var fencedTok = cm.getTokenAt({
              line: block_start,
              ch: 1
            });
            var fence_chars = token_state(fencedTok).fencedChars;
            var start_text, start_line;
            var end_text, end_line;
            if (fencing_line(cm.getLineHandle(cur_start.line))) {
              start_text = "";
              start_line = cur_start.line;
            } else if (fencing_line(cm.getLineHandle(cur_start.line - 1))) {
              start_text = "";
              start_line = cur_start.line - 1;
            } else {
              start_text = fence_chars + "\n";
              start_line = cur_start.line;
            }
            if (fencing_line(cm.getLineHandle(cur_end.line))) {
              end_text = "";
              end_line = cur_end.line;
              if (cur_end.ch === 0) {
                end_line += 1;
              }
            } else if (cur_end.ch !== 0 && fencing_line(cm.getLineHandle(cur_end.line + 1))) {
              end_text = "";
              end_line = cur_end.line + 1;
            } else {
              end_text = fence_chars + "\n";
              end_line = cur_end.line + 1;
            }
            if (cur_end.ch === 0) {
              end_line -= 1;
            }
            cm.operation(function() {
              cm.replaceRange(end_text, {
                line: end_line,
                ch: 0
              }, {
                line: end_line + (end_text ? 0 : 1),
                ch: 0
              });
              cm.replaceRange(start_text, {
                line: start_line,
                ch: 0
              }, {
                line: start_line + (start_text ? 0 : 1),
                ch: 0
              });
            });
            cm.setSelection({
              line: start_line + (start_text ? 1 : 0),
              ch: 0
            }, {
              line: end_line + (start_text ? 1 : -1),
              ch: 0
            });
            cm.focus();
          } else {
            var search_from = cur_start.line;
            if (fencing_line(cm.getLineHandle(cur_start.line))) {
              if (code_type(cm, cur_start.line + 1) === "fenced") {
                block_start = cur_start.line;
                search_from = cur_start.line + 1;
              } else {
                block_end = cur_start.line;
                search_from = cur_start.line - 1;
              }
            }
            if (block_start === void 0) {
              for (block_start = search_from; block_start >= 0; block_start--) {
                line = cm.getLineHandle(block_start);
                if (fencing_line(line)) {
                  break;
                }
              }
            }
            if (block_end === void 0) {
              lineCount = cm.lineCount();
              for (block_end = search_from; block_end < lineCount; block_end++) {
                line = cm.getLineHandle(block_end);
                if (fencing_line(line)) {
                  break;
                }
              }
            }
            cm.operation(function() {
              cm.replaceRange("", {
                line: block_start,
                ch: 0
              }, {
                line: block_start + 1,
                ch: 0
              });
              cm.replaceRange("", {
                line: block_end - 1,
                ch: 0
              }, {
                line: block_end,
                ch: 0
              });
            });
            cm.focus();
          }
        } else if (is_code === "indented") {
          if (cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {
            block_start = cur_start.line;
            block_end = cur_end.line;
            if (cur_end.ch === 0) {
              block_end--;
            }
          } else {
            for (block_start = cur_start.line; block_start >= 0; block_start--) {
              line = cm.getLineHandle(block_start);
              if (line.text.match(/^\s*$/)) {
                continue;
              } else {
                if (code_type(cm, block_start, line) !== "indented") {
                  block_start += 1;
                  break;
                }
              }
            }
            lineCount = cm.lineCount();
            for (block_end = cur_start.line; block_end < lineCount; block_end++) {
              line = cm.getLineHandle(block_end);
              if (line.text.match(/^\s*$/)) {
                continue;
              } else {
                if (code_type(cm, block_end, line) !== "indented") {
                  block_end -= 1;
                  break;
                }
              }
            }
          }
          var next_line = cm.getLineHandle(block_end + 1), next_line_last_tok = next_line && cm.getTokenAt({
            line: block_end + 1,
            ch: next_line.text.length - 1
          }), next_line_indented = next_line_last_tok && token_state(next_line_last_tok).indentedCode;
          if (next_line_indented) {
            cm.replaceRange("\n", {
              line: block_end + 1,
              ch: 0
            });
          }
          for (var i2 = block_start; i2 <= block_end; i2++) {
            cm.indentLine(i2, "subtract");
          }
          cm.focus();
        } else {
          var no_sel_and_starting_of_line = cur_start.line === cur_end.line && cur_start.ch === cur_end.ch && cur_start.ch === 0;
          var sel_multi = cur_start.line !== cur_end.line;
          if (no_sel_and_starting_of_line || sel_multi) {
            insertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert);
          } else {
            _replaceSelection(cm, false, ["`", "`"]);
          }
        }
      }
      function toggleBlockquote(editor) {
        var cm = editor.codemirror;
        _toggleLine(cm, "quote");
      }
      function toggleHeadingSmaller(editor) {
        var cm = editor.codemirror;
        _toggleHeading(cm, "smaller");
      }
      function toggleHeadingBigger(editor) {
        var cm = editor.codemirror;
        _toggleHeading(cm, "bigger");
      }
      function toggleHeading1(editor) {
        var cm = editor.codemirror;
        _toggleHeading(cm, void 0, 1);
      }
      function toggleHeading2(editor) {
        var cm = editor.codemirror;
        _toggleHeading(cm, void 0, 2);
      }
      function toggleHeading3(editor) {
        var cm = editor.codemirror;
        _toggleHeading(cm, void 0, 3);
      }
      function toggleUnorderedList(editor) {
        var cm = editor.codemirror;
        _toggleLine(cm, "unordered-list");
      }
      function toggleOrderedList(editor) {
        var cm = editor.codemirror;
        _toggleLine(cm, "ordered-list");
      }
      function cleanBlock(editor) {
        var cm = editor.codemirror;
        _cleanBlock(cm);
      }
      function drawLink(editor) {
        var cm = editor.codemirror;
        var stat = getState(cm);
        var options = editor.options;
        var url = "http://";
        if (options.promptURLs) {
          url = prompt(options.promptTexts.link);
          if (!url) {
            return false;
          }
        }
        _replaceSelection(cm, stat.link, options.insertTexts.link, url);
      }
      function drawImage(editor) {
        var cm = editor.codemirror;
        var stat = getState(cm);
        var options = editor.options;
        var url = "http://";
        if (options.promptURLs) {
          url = prompt(options.promptTexts.image);
          if (!url) {
            return false;
          }
        }
        _replaceSelection(cm, stat.image, options.insertTexts.image, url);
      }
      function drawTable(editor) {
        var cm = editor.codemirror;
        var stat = getState(cm);
        var options = editor.options;
        _replaceSelection(cm, stat.table, options.insertTexts.table);
      }
      function drawHorizontalRule(editor) {
        var cm = editor.codemirror;
        var stat = getState(cm);
        var options = editor.options;
        _replaceSelection(cm, stat.image, options.insertTexts.horizontalRule);
      }
      function undo(editor) {
        var cm = editor.codemirror;
        cm.undo();
        cm.focus();
      }
      function redo(editor) {
        var cm = editor.codemirror;
        cm.redo();
        cm.focus();
      }
      function toggleSideBySide(editor) {
        var cm = editor.codemirror;
        var wrapper = cm.getWrapperElement();
        var preview = wrapper.nextSibling;
        var toolbarButton = editor.toolbarElements["side-by-side"];
        var useSideBySideListener = false;
        if (/editor-preview-active-side/.test(preview.className)) {
          preview.className = preview.className.replace(/\s*editor-preview-active-side\s*/g, "");
          toolbarButton.className = toolbarButton.className.replace(/\s*active\s*/g, "");
          wrapper.className = wrapper.className.replace(/\s*CodeMirror-sided\s*/g, " ");
        } else {
          setTimeout(function() {
            if (!cm.getOption("fullScreen"))
              toggleFullScreen(editor);
            preview.className += " editor-preview-active-side";
          }, 1);
          toolbarButton.className += " active";
          wrapper.className += " CodeMirror-sided";
          useSideBySideListener = true;
        }
        var previewNormal = wrapper.lastChild;
        if (/editor-preview-active/.test(previewNormal.className)) {
          previewNormal.className = previewNormal.className.replace(/\s*editor-preview-active\s*/g, "");
          var toolbar = editor.toolbarElements.preview;
          var toolbar_div = wrapper.previousSibling;
          toolbar.className = toolbar.className.replace(/\s*active\s*/g, "");
          toolbar_div.className = toolbar_div.className.replace(/\s*disabled-for-preview*/g, "");
        }
        var sideBySideRenderingFunction = function() {
          preview.innerHTML = editor.options.previewRender(editor.value(), preview);
        };
        if (!cm.sideBySideRenderingFunction) {
          cm.sideBySideRenderingFunction = sideBySideRenderingFunction;
        }
        if (useSideBySideListener) {
          preview.innerHTML = editor.options.previewRender(editor.value(), preview);
          cm.on("update", cm.sideBySideRenderingFunction);
        } else {
          cm.off("update", cm.sideBySideRenderingFunction);
        }
        cm.refresh();
      }
      function togglePreview(editor) {
        var cm = editor.codemirror;
        var wrapper = cm.getWrapperElement();
        var toolbar_div = wrapper.previousSibling;
        var toolbar = editor.options.toolbar ? editor.toolbarElements.preview : false;
        var preview = wrapper.lastChild;
        if (!preview || !/editor-preview/.test(preview.className)) {
          preview = document.createElement("div");
          preview.className = "editor-preview";
          wrapper.appendChild(preview);
        }
        if (/editor-preview-active/.test(preview.className)) {
          preview.className = preview.className.replace(/\s*editor-preview-active\s*/g, "");
          if (toolbar) {
            toolbar.className = toolbar.className.replace(/\s*active\s*/g, "");
            toolbar_div.className = toolbar_div.className.replace(/\s*disabled-for-preview*/g, "");
          }
        } else {
          setTimeout(function() {
            preview.className += " editor-preview-active";
          }, 1);
          if (toolbar) {
            toolbar.className += " active";
            toolbar_div.className += " disabled-for-preview";
          }
        }
        preview.innerHTML = editor.options.previewRender(editor.value(), preview);
        var sidebyside = cm.getWrapperElement().nextSibling;
        if (/editor-preview-active-side/.test(sidebyside.className))
          toggleSideBySide(editor);
      }
      function _replaceSelection(cm, active, startEnd, url) {
        if (/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))
          return;
        var text;
        var start4 = startEnd[0];
        var end2 = startEnd[1];
        var startPoint = cm.getCursor("start");
        var endPoint = cm.getCursor("end");
        if (url) {
          end2 = end2.replace("#url#", url);
        }
        if (active) {
          text = cm.getLine(startPoint.line);
          start4 = text.slice(0, startPoint.ch);
          end2 = text.slice(startPoint.ch);
          cm.replaceRange(start4 + end2, {
            line: startPoint.line,
            ch: 0
          });
        } else {
          text = cm.getSelection();
          cm.replaceSelection(start4 + text + end2);
          startPoint.ch += start4.length;
          if (startPoint !== endPoint) {
            endPoint.ch += start4.length;
          }
        }
        cm.setSelection(startPoint, endPoint);
        cm.focus();
      }
      function _toggleHeading(cm, direction, size) {
        if (/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))
          return;
        var startPoint = cm.getCursor("start");
        var endPoint = cm.getCursor("end");
        for (var i2 = startPoint.line; i2 <= endPoint.line; i2++) {
          (function(i3) {
            var text = cm.getLine(i3);
            var currHeadingLevel = text.search(/[^#]/);
            if (direction !== void 0) {
              if (currHeadingLevel <= 0) {
                if (direction == "bigger") {
                  text = "###### " + text;
                } else {
                  text = "# " + text;
                }
              } else if (currHeadingLevel == 6 && direction == "smaller") {
                text = text.substr(7);
              } else if (currHeadingLevel == 1 && direction == "bigger") {
                text = text.substr(2);
              } else {
                if (direction == "bigger") {
                  text = text.substr(1);
                } else {
                  text = "#" + text;
                }
              }
            } else {
              if (size == 1) {
                if (currHeadingLevel <= 0) {
                  text = "# " + text;
                } else if (currHeadingLevel == size) {
                  text = text.substr(currHeadingLevel + 1);
                } else {
                  text = "# " + text.substr(currHeadingLevel + 1);
                }
              } else if (size == 2) {
                if (currHeadingLevel <= 0) {
                  text = "## " + text;
                } else if (currHeadingLevel == size) {
                  text = text.substr(currHeadingLevel + 1);
                } else {
                  text = "## " + text.substr(currHeadingLevel + 1);
                }
              } else {
                if (currHeadingLevel <= 0) {
                  text = "### " + text;
                } else if (currHeadingLevel == size) {
                  text = text.substr(currHeadingLevel + 1);
                } else {
                  text = "### " + text.substr(currHeadingLevel + 1);
                }
              }
            }
            cm.replaceRange(text, {
              line: i3,
              ch: 0
            }, {
              line: i3,
              ch: 99999999999999
            });
          })(i2);
        }
        cm.focus();
      }
      function _toggleLine(cm, name) {
        if (/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))
          return;
        var stat = getState(cm);
        var startPoint = cm.getCursor("start");
        var endPoint = cm.getCursor("end");
        var repl = {
          "quote": /^(\s*)\>\s+/,
          "unordered-list": /^(\s*)(\*|\-|\+)\s+/,
          "ordered-list": /^(\s*)\d+\.\s+/
        };
        var map = {
          "quote": "> ",
          "unordered-list": "* ",
          "ordered-list": "1. "
        };
        for (var i2 = startPoint.line; i2 <= endPoint.line; i2++) {
          (function(i3) {
            var text = cm.getLine(i3);
            if (stat[name]) {
              text = text.replace(repl[name], "$1");
            } else {
              text = map[name] + text;
            }
            cm.replaceRange(text, {
              line: i3,
              ch: 0
            }, {
              line: i3,
              ch: 99999999999999
            });
          })(i2);
        }
        cm.focus();
      }
      function _toggleBlock(editor, type, start_chars, end_chars) {
        if (/editor-preview-active/.test(editor.codemirror.getWrapperElement().lastChild.className))
          return;
        end_chars = typeof end_chars === "undefined" ? start_chars : end_chars;
        var cm = editor.codemirror;
        var stat = getState(cm);
        var text;
        var start4 = start_chars;
        var end2 = end_chars;
        var startPoint = cm.getCursor("start");
        var endPoint = cm.getCursor("end");
        if (stat[type]) {
          text = cm.getLine(startPoint.line);
          start4 = text.slice(0, startPoint.ch);
          end2 = text.slice(startPoint.ch);
          if (type == "bold") {
            start4 = start4.replace(/(\*\*|__)(?![\s\S]*(\*\*|__))/, "");
            end2 = end2.replace(/(\*\*|__)/, "");
          } else if (type == "italic") {
            start4 = start4.replace(/(\*|_)(?![\s\S]*(\*|_))/, "");
            end2 = end2.replace(/(\*|_)/, "");
          } else if (type == "strikethrough") {
            start4 = start4.replace(/(\*\*|~~)(?![\s\S]*(\*\*|~~))/, "");
            end2 = end2.replace(/(\*\*|~~)/, "");
          }
          cm.replaceRange(start4 + end2, {
            line: startPoint.line,
            ch: 0
          }, {
            line: startPoint.line,
            ch: 99999999999999
          });
          if (type == "bold" || type == "strikethrough") {
            startPoint.ch -= 2;
            if (startPoint !== endPoint) {
              endPoint.ch -= 2;
            }
          } else if (type == "italic") {
            startPoint.ch -= 1;
            if (startPoint !== endPoint) {
              endPoint.ch -= 1;
            }
          }
        } else {
          text = cm.getSelection();
          if (type == "bold") {
            text = text.split("**").join("");
            text = text.split("__").join("");
          } else if (type == "italic") {
            text = text.split("*").join("");
            text = text.split("_").join("");
          } else if (type == "strikethrough") {
            text = text.split("~~").join("");
          }
          cm.replaceSelection(start4 + text + end2);
          startPoint.ch += start_chars.length;
          endPoint.ch = startPoint.ch + text.length;
        }
        cm.setSelection(startPoint, endPoint);
        cm.focus();
      }
      function _cleanBlock(cm) {
        if (/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))
          return;
        var startPoint = cm.getCursor("start");
        var endPoint = cm.getCursor("end");
        var text;
        for (var line = startPoint.line; line <= endPoint.line; line++) {
          text = cm.getLine(line);
          text = text.replace(/^[ ]*([# ]+|\*|\-|[> ]+|[0-9]+(.|\)))[ ]*/, "");
          cm.replaceRange(text, {
            line,
            ch: 0
          }, {
            line,
            ch: 99999999999999
          });
        }
      }
      function _mergeProperties(target, source) {
        for (var property in source) {
          if (source.hasOwnProperty(property)) {
            if (source[property] instanceof Array) {
              target[property] = source[property].concat(target[property] instanceof Array ? target[property] : []);
            } else if (source[property] !== null && typeof source[property] === "object" && source[property].constructor === Object) {
              target[property] = _mergeProperties(target[property] || {}, source[property]);
            } else {
              target[property] = source[property];
            }
          }
        }
        return target;
      }
      function extend3(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          target = _mergeProperties(target, arguments[i2]);
        }
        return target;
      }
      function wordCount(data) {
        var pattern = /[a-zA-Z0-9_\u0392-\u03c9\u0410-\u04F9]+|[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af]+/g;
        var m2 = data.match(pattern);
        var count = 0;
        if (m2 === null)
          return count;
        for (var i2 = 0; i2 < m2.length; i2++) {
          if (m2[i2].charCodeAt(0) >= 19968) {
            count += m2[i2].length;
          } else {
            count += 1;
          }
        }
        return count;
      }
      var toolbarBuiltInButtons = {
        "bold": {
          name: "bold",
          action: toggleBold,
          className: "fa fa-bold",
          title: "Bold",
          default: true
        },
        "italic": {
          name: "italic",
          action: toggleItalic,
          className: "fa fa-italic",
          title: "Italic",
          default: true
        },
        "strikethrough": {
          name: "strikethrough",
          action: toggleStrikethrough,
          className: "fa fa-strikethrough",
          title: "Strikethrough"
        },
        "heading": {
          name: "heading",
          action: toggleHeadingSmaller,
          className: "fa fa-header",
          title: "Heading",
          default: true
        },
        "heading-smaller": {
          name: "heading-smaller",
          action: toggleHeadingSmaller,
          className: "fa fa-header fa-header-x fa-header-smaller",
          title: "Smaller Heading"
        },
        "heading-bigger": {
          name: "heading-bigger",
          action: toggleHeadingBigger,
          className: "fa fa-header fa-header-x fa-header-bigger",
          title: "Bigger Heading"
        },
        "heading-1": {
          name: "heading-1",
          action: toggleHeading1,
          className: "fa fa-header fa-header-x fa-header-1",
          title: "Big Heading"
        },
        "heading-2": {
          name: "heading-2",
          action: toggleHeading2,
          className: "fa fa-header fa-header-x fa-header-2",
          title: "Medium Heading"
        },
        "heading-3": {
          name: "heading-3",
          action: toggleHeading3,
          className: "fa fa-header fa-header-x fa-header-3",
          title: "Small Heading"
        },
        "separator-1": {
          name: "separator-1"
        },
        "code": {
          name: "code",
          action: toggleCodeBlock,
          className: "fa fa-code",
          title: "Code"
        },
        "quote": {
          name: "quote",
          action: toggleBlockquote,
          className: "fa fa-quote-left",
          title: "Quote",
          default: true
        },
        "unordered-list": {
          name: "unordered-list",
          action: toggleUnorderedList,
          className: "fa fa-list-ul",
          title: "Generic List",
          default: true
        },
        "ordered-list": {
          name: "ordered-list",
          action: toggleOrderedList,
          className: "fa fa-list-ol",
          title: "Numbered List",
          default: true
        },
        "clean-block": {
          name: "clean-block",
          action: cleanBlock,
          className: "fa fa-eraser fa-clean-block",
          title: "Clean block"
        },
        "separator-2": {
          name: "separator-2"
        },
        "link": {
          name: "link",
          action: drawLink,
          className: "fa fa-link",
          title: "Create Link",
          default: true
        },
        "image": {
          name: "image",
          action: drawImage,
          className: "fa fa-picture-o",
          title: "Insert Image",
          default: true
        },
        "table": {
          name: "table",
          action: drawTable,
          className: "fa fa-table",
          title: "Insert Table"
        },
        "horizontal-rule": {
          name: "horizontal-rule",
          action: drawHorizontalRule,
          className: "fa fa-minus",
          title: "Insert Horizontal Line"
        },
        "separator-3": {
          name: "separator-3"
        },
        "preview": {
          name: "preview",
          action: togglePreview,
          className: "fa fa-eye no-disable",
          title: "Toggle Preview",
          default: true
        },
        "side-by-side": {
          name: "side-by-side",
          action: toggleSideBySide,
          className: "fa fa-columns no-disable no-mobile",
          title: "Toggle Side by Side",
          default: true
        },
        "fullscreen": {
          name: "fullscreen",
          action: toggleFullScreen,
          className: "fa fa-arrows-alt no-disable no-mobile",
          title: "Toggle Fullscreen",
          default: true
        },
        "separator-4": {
          name: "separator-4"
        },
        "guide": {
          name: "guide",
          action: "https://simplemde.com/markdown-guide",
          className: "fa fa-question-circle",
          title: "Markdown Guide",
          default: true
        },
        "separator-5": {
          name: "separator-5"
        },
        "undo": {
          name: "undo",
          action: undo,
          className: "fa fa-undo no-disable",
          title: "Undo"
        },
        "redo": {
          name: "redo",
          action: redo,
          className: "fa fa-repeat no-disable",
          title: "Redo"
        }
      };
      var insertTexts = {
        link: ["[", "](#url#)"],
        image: ["![](", "#url#)"],
        table: ["", "\n\n| Column 1 | Column 2 | Column 3 |\n| -------- | -------- | -------- |\n| Text     | Text     | Text     |\n\n"],
        horizontalRule: ["", "\n\n-----\n\n"]
      };
      var promptTexts = {
        link: "URL for the link:",
        image: "URL of the image:"
      };
      var blockStyles = {
        "bold": "**",
        "code": "```",
        "italic": "*"
      };
      function SimpleMDE2(options) {
        options = options || {};
        options.parent = this;
        var autoDownloadFA = true;
        if (options.autoDownloadFontAwesome === false) {
          autoDownloadFA = false;
        }
        if (options.autoDownloadFontAwesome !== true) {
          var styleSheets = document.styleSheets;
          for (var i2 = 0; i2 < styleSheets.length; i2++) {
            if (!styleSheets[i2].href)
              continue;
            if (styleSheets[i2].href.indexOf("//maxcdn.bootstrapcdn.com/font-awesome/") > -1) {
              autoDownloadFA = false;
            }
          }
        }
        if (autoDownloadFA) {
          var link = document.createElement("link");
          link.rel = "stylesheet";
          link.href = "https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css";
          document.getElementsByTagName("head")[0].appendChild(link);
        }
        if (options.element) {
          this.element = options.element;
        } else if (options.element === null) {
          console.log("SimpleMDE: Error. No element was found.");
          return;
        }
        if (options.toolbar === void 0) {
          options.toolbar = [];
          for (var key in toolbarBuiltInButtons) {
            if (toolbarBuiltInButtons.hasOwnProperty(key)) {
              if (key.indexOf("separator-") != -1) {
                options.toolbar.push("|");
              }
              if (toolbarBuiltInButtons[key].default === true || options.showIcons && options.showIcons.constructor === Array && options.showIcons.indexOf(key) != -1) {
                options.toolbar.push(key);
              }
            }
          }
        }
        if (!options.hasOwnProperty("status")) {
          options.status = ["autosave", "lines", "words", "cursor"];
        }
        if (!options.previewRender) {
          options.previewRender = function(plainText) {
            return this.parent.markdown(plainText);
          };
        }
        options.parsingConfig = extend3({
          highlightFormatting: true
        }, options.parsingConfig || {});
        options.insertTexts = extend3({}, insertTexts, options.insertTexts || {});
        options.promptTexts = promptTexts;
        options.blockStyles = extend3({}, blockStyles, options.blockStyles || {});
        options.shortcuts = extend3({}, shortcuts, options.shortcuts || {});
        if (options.autosave != void 0 && options.autosave.unique_id != void 0 && options.autosave.unique_id != "")
          options.autosave.uniqueId = options.autosave.unique_id;
        this.options = options;
        this.render();
        if (options.initialValue && (!this.options.autosave || this.options.autosave.foundSavedValue !== true)) {
          this.value(options.initialValue);
        }
      }
      SimpleMDE2.prototype.markdown = function(text) {
        if (marked) {
          var markedOptions = {};
          if (this.options && this.options.renderingConfig && this.options.renderingConfig.singleLineBreaks === false) {
            markedOptions.breaks = false;
          } else {
            markedOptions.breaks = true;
          }
          if (this.options && this.options.renderingConfig && this.options.renderingConfig.codeSyntaxHighlighting === true && window.hljs) {
            markedOptions.highlight = function(code3) {
              return window.hljs.highlightAuto(code3).value;
            };
          }
          marked.setOptions(markedOptions);
          return marked(text);
        }
      };
      SimpleMDE2.prototype.render = function(el) {
        if (!el) {
          el = this.element || document.getElementsByTagName("textarea")[0];
        }
        if (this._rendered && this._rendered === el) {
          return;
        }
        this.element = el;
        var options = this.options;
        var self2 = this;
        var keyMaps = {};
        for (var key in options.shortcuts) {
          if (options.shortcuts[key] !== null && bindings[key] !== null) {
            (function(key2) {
              keyMaps[fixShortcut(options.shortcuts[key2])] = function() {
                bindings[key2](self2);
              };
            })(key);
          }
        }
        keyMaps["Enter"] = "newlineAndIndentContinueMarkdownList";
        keyMaps["Tab"] = "tabAndIndentMarkdownList";
        keyMaps["Shift-Tab"] = "shiftTabAndUnindentMarkdownList";
        keyMaps["Esc"] = function(cm2) {
          if (cm2.getOption("fullScreen"))
            toggleFullScreen(self2);
        };
        document.addEventListener("keydown", function(e2) {
          e2 = e2 || window.event;
          if (e2.keyCode == 27) {
            if (self2.codemirror.getOption("fullScreen"))
              toggleFullScreen(self2);
          }
        }, false);
        var mode, backdrop;
        if (options.spellChecker !== false) {
          mode = "spell-checker";
          backdrop = options.parsingConfig;
          backdrop.name = "gfm";
          backdrop.gitHubSpice = false;
          CodeMirrorSpellChecker({
            codeMirrorInstance: CodeMirror3
          });
        } else {
          mode = options.parsingConfig;
          mode.name = "gfm";
          mode.gitHubSpice = false;
        }
        this.codemirror = CodeMirror3.fromTextArea(el, {
          mode,
          backdrop,
          theme: "paper",
          tabSize: options.tabSize != void 0 ? options.tabSize : 2,
          indentUnit: options.tabSize != void 0 ? options.tabSize : 2,
          indentWithTabs: options.indentWithTabs === false ? false : true,
          lineNumbers: false,
          autofocus: options.autofocus === true ? true : false,
          extraKeys: keyMaps,
          lineWrapping: options.lineWrapping === false ? false : true,
          allowDropFileTypes: ["text/plain"],
          placeholder: options.placeholder || el.getAttribute("placeholder") || "",
          styleSelectedText: options.styleSelectedText != void 0 ? options.styleSelectedText : true
        });
        if (options.forceSync === true) {
          var cm = this.codemirror;
          cm.on("change", function() {
            cm.save();
          });
        }
        this.gui = {};
        if (options.toolbar !== false) {
          this.gui.toolbar = this.createToolbar();
        }
        if (options.status !== false) {
          this.gui.statusbar = this.createStatusbar();
        }
        if (options.autosave != void 0 && options.autosave.enabled === true) {
          this.autosave();
        }
        this.gui.sideBySide = this.createSideBySide();
        this._rendered = this.element;
        var temp_cm = this.codemirror;
        setTimeout(function() {
          temp_cm.refresh();
        }.bind(temp_cm), 0);
      };
      function isLocalStorageAvailable() {
        if (typeof localStorage === "object") {
          try {
            localStorage.setItem("smde_localStorage", 1);
            localStorage.removeItem("smde_localStorage");
          } catch (e2) {
            return false;
          }
        } else {
          return false;
        }
        return true;
      }
      SimpleMDE2.prototype.autosave = function() {
        if (isLocalStorageAvailable()) {
          var simplemde = this;
          if (this.options.autosave.uniqueId == void 0 || this.options.autosave.uniqueId == "") {
            console.log("SimpleMDE: You must set a uniqueId to use the autosave feature");
            return;
          }
          if (simplemde.element.form != null && simplemde.element.form != void 0) {
            simplemde.element.form.addEventListener("submit", function() {
              localStorage.removeItem("smde_" + simplemde.options.autosave.uniqueId);
            });
          }
          if (this.options.autosave.loaded !== true) {
            if (typeof localStorage.getItem("smde_" + this.options.autosave.uniqueId) == "string" && localStorage.getItem("smde_" + this.options.autosave.uniqueId) != "") {
              this.codemirror.setValue(localStorage.getItem("smde_" + this.options.autosave.uniqueId));
              this.options.autosave.foundSavedValue = true;
            }
            this.options.autosave.loaded = true;
          }
          localStorage.setItem("smde_" + this.options.autosave.uniqueId, simplemde.value());
          var el = document.getElementById("autosaved");
          if (el != null && el != void 0 && el != "") {
            var d2 = new Date();
            var hh = d2.getHours();
            var m2 = d2.getMinutes();
            var dd = "am";
            var h = hh;
            if (h >= 12) {
              h = hh - 12;
              dd = "pm";
            }
            if (h == 0) {
              h = 12;
            }
            m2 = m2 < 10 ? "0" + m2 : m2;
            el.innerHTML = "Autosaved: " + h + ":" + m2 + " " + dd;
          }
          this.autosaveTimeoutId = setTimeout(function() {
            simplemde.autosave();
          }, this.options.autosave.delay || 1e4);
        } else {
          console.log("SimpleMDE: localStorage not available, cannot autosave");
        }
      };
      SimpleMDE2.prototype.clearAutosavedValue = function() {
        if (isLocalStorageAvailable()) {
          if (this.options.autosave == void 0 || this.options.autosave.uniqueId == void 0 || this.options.autosave.uniqueId == "") {
            console.log("SimpleMDE: You must set a uniqueId to clear the autosave value");
            return;
          }
          localStorage.removeItem("smde_" + this.options.autosave.uniqueId);
        } else {
          console.log("SimpleMDE: localStorage not available, cannot autosave");
        }
      };
      SimpleMDE2.prototype.createSideBySide = function() {
        var cm = this.codemirror;
        var wrapper = cm.getWrapperElement();
        var preview = wrapper.nextSibling;
        if (!preview || !/editor-preview-side/.test(preview.className)) {
          preview = document.createElement("div");
          preview.className = "editor-preview-side";
          wrapper.parentNode.insertBefore(preview, wrapper.nextSibling);
        }
        var cScroll = false;
        var pScroll = false;
        cm.on("scroll", function(v2) {
          if (cScroll) {
            cScroll = false;
            return;
          }
          pScroll = true;
          var height = v2.getScrollInfo().height - v2.getScrollInfo().clientHeight;
          var ratio = parseFloat(v2.getScrollInfo().top) / height;
          var move = (preview.scrollHeight - preview.clientHeight) * ratio;
          preview.scrollTop = move;
        });
        preview.onscroll = function() {
          if (pScroll) {
            pScroll = false;
            return;
          }
          cScroll = true;
          var height = preview.scrollHeight - preview.clientHeight;
          var ratio = parseFloat(preview.scrollTop) / height;
          var move = (cm.getScrollInfo().height - cm.getScrollInfo().clientHeight) * ratio;
          cm.scrollTo(0, move);
        };
        return preview;
      };
      SimpleMDE2.prototype.createToolbar = function(items) {
        items = items || this.options.toolbar;
        if (!items || items.length === 0) {
          return;
        }
        var i2;
        for (i2 = 0; i2 < items.length; i2++) {
          if (toolbarBuiltInButtons[items[i2]] != void 0) {
            items[i2] = toolbarBuiltInButtons[items[i2]];
          }
        }
        var bar = document.createElement("div");
        bar.className = "editor-toolbar";
        var self2 = this;
        var toolbarData = {};
        self2.toolbar = items;
        for (i2 = 0; i2 < items.length; i2++) {
          if (items[i2].name == "guide" && self2.options.toolbarGuideIcon === false)
            continue;
          if (self2.options.hideIcons && self2.options.hideIcons.indexOf(items[i2].name) != -1)
            continue;
          if ((items[i2].name == "fullscreen" || items[i2].name == "side-by-side") && isMobile())
            continue;
          if (items[i2] === "|") {
            var nonSeparatorIconsFollow = false;
            for (var x2 = i2 + 1; x2 < items.length; x2++) {
              if (items[x2] !== "|" && (!self2.options.hideIcons || self2.options.hideIcons.indexOf(items[x2].name) == -1)) {
                nonSeparatorIconsFollow = true;
              }
            }
            if (!nonSeparatorIconsFollow)
              continue;
          }
          (function(item) {
            var el;
            if (item === "|") {
              el = createSep();
            } else {
              el = createIcon(item, self2.options.toolbarTips, self2.options.shortcuts);
            }
            if (item.action) {
              if (typeof item.action === "function") {
                el.onclick = function(e2) {
                  e2.preventDefault();
                  item.action(self2);
                };
              } else if (typeof item.action === "string") {
                el.href = item.action;
                el.target = "_blank";
              }
            }
            toolbarData[item.name || item] = el;
            bar.appendChild(el);
          })(items[i2]);
        }
        self2.toolbarElements = toolbarData;
        var cm = this.codemirror;
        cm.on("cursorActivity", function() {
          var stat = getState(cm);
          for (var key in toolbarData) {
            (function(key2) {
              var el = toolbarData[key2];
              if (stat[key2]) {
                el.className += " active";
              } else if (key2 != "fullscreen" && key2 != "side-by-side") {
                el.className = el.className.replace(/\s*active\s*/g, "");
              }
            })(key);
          }
        });
        var cmWrapper = cm.getWrapperElement();
        cmWrapper.parentNode.insertBefore(bar, cmWrapper);
        return bar;
      };
      SimpleMDE2.prototype.createStatusbar = function(status) {
        status = status || this.options.status;
        var options = this.options;
        var cm = this.codemirror;
        if (!status || status.length === 0)
          return;
        var items = [];
        var i2, onUpdate, defaultValue;
        for (i2 = 0; i2 < status.length; i2++) {
          onUpdate = void 0;
          defaultValue = void 0;
          if (typeof status[i2] === "object") {
            items.push({
              className: status[i2].className,
              defaultValue: status[i2].defaultValue,
              onUpdate: status[i2].onUpdate
            });
          } else {
            var name = status[i2];
            if (name === "words") {
              defaultValue = function(el2) {
                el2.innerHTML = wordCount(cm.getValue());
              };
              onUpdate = function(el2) {
                el2.innerHTML = wordCount(cm.getValue());
              };
            } else if (name === "lines") {
              defaultValue = function(el2) {
                el2.innerHTML = cm.lineCount();
              };
              onUpdate = function(el2) {
                el2.innerHTML = cm.lineCount();
              };
            } else if (name === "cursor") {
              defaultValue = function(el2) {
                el2.innerHTML = "0:0";
              };
              onUpdate = function(el2) {
                var pos = cm.getCursor();
                el2.innerHTML = pos.line + ":" + pos.ch;
              };
            } else if (name === "autosave") {
              defaultValue = function(el2) {
                if (options.autosave != void 0 && options.autosave.enabled === true) {
                  el2.setAttribute("id", "autosaved");
                }
              };
            }
            items.push({
              className: name,
              defaultValue,
              onUpdate
            });
          }
        }
        var bar = document.createElement("div");
        bar.className = "editor-statusbar";
        for (i2 = 0; i2 < items.length; i2++) {
          var item = items[i2];
          var el = document.createElement("span");
          el.className = item.className;
          if (typeof item.defaultValue === "function") {
            item.defaultValue(el);
          }
          if (typeof item.onUpdate === "function") {
            this.codemirror.on("update", function(el2, item2) {
              return function() {
                item2.onUpdate(el2);
              };
            }(el, item));
          }
          bar.appendChild(el);
        }
        var cmWrapper = this.codemirror.getWrapperElement();
        cmWrapper.parentNode.insertBefore(bar, cmWrapper.nextSibling);
        return bar;
      };
      SimpleMDE2.prototype.value = function(val) {
        if (val === void 0) {
          return this.codemirror.getValue();
        } else {
          this.codemirror.getDoc().setValue(val);
          return this;
        }
      };
      SimpleMDE2.toggleBold = toggleBold;
      SimpleMDE2.toggleItalic = toggleItalic;
      SimpleMDE2.toggleStrikethrough = toggleStrikethrough;
      SimpleMDE2.toggleBlockquote = toggleBlockquote;
      SimpleMDE2.toggleHeadingSmaller = toggleHeadingSmaller;
      SimpleMDE2.toggleHeadingBigger = toggleHeadingBigger;
      SimpleMDE2.toggleHeading1 = toggleHeading1;
      SimpleMDE2.toggleHeading2 = toggleHeading2;
      SimpleMDE2.toggleHeading3 = toggleHeading3;
      SimpleMDE2.toggleCodeBlock = toggleCodeBlock;
      SimpleMDE2.toggleUnorderedList = toggleUnorderedList;
      SimpleMDE2.toggleOrderedList = toggleOrderedList;
      SimpleMDE2.cleanBlock = cleanBlock;
      SimpleMDE2.drawLink = drawLink;
      SimpleMDE2.drawImage = drawImage;
      SimpleMDE2.drawTable = drawTable;
      SimpleMDE2.drawHorizontalRule = drawHorizontalRule;
      SimpleMDE2.undo = undo;
      SimpleMDE2.redo = redo;
      SimpleMDE2.togglePreview = togglePreview;
      SimpleMDE2.toggleSideBySide = toggleSideBySide;
      SimpleMDE2.toggleFullScreen = toggleFullScreen;
      SimpleMDE2.prototype.toggleBold = function() {
        toggleBold(this);
      };
      SimpleMDE2.prototype.toggleItalic = function() {
        toggleItalic(this);
      };
      SimpleMDE2.prototype.toggleStrikethrough = function() {
        toggleStrikethrough(this);
      };
      SimpleMDE2.prototype.toggleBlockquote = function() {
        toggleBlockquote(this);
      };
      SimpleMDE2.prototype.toggleHeadingSmaller = function() {
        toggleHeadingSmaller(this);
      };
      SimpleMDE2.prototype.toggleHeadingBigger = function() {
        toggleHeadingBigger(this);
      };
      SimpleMDE2.prototype.toggleHeading1 = function() {
        toggleHeading1(this);
      };
      SimpleMDE2.prototype.toggleHeading2 = function() {
        toggleHeading2(this);
      };
      SimpleMDE2.prototype.toggleHeading3 = function() {
        toggleHeading3(this);
      };
      SimpleMDE2.prototype.toggleCodeBlock = function() {
        toggleCodeBlock(this);
      };
      SimpleMDE2.prototype.toggleUnorderedList = function() {
        toggleUnorderedList(this);
      };
      SimpleMDE2.prototype.toggleOrderedList = function() {
        toggleOrderedList(this);
      };
      SimpleMDE2.prototype.cleanBlock = function() {
        cleanBlock(this);
      };
      SimpleMDE2.prototype.drawLink = function() {
        drawLink(this);
      };
      SimpleMDE2.prototype.drawImage = function() {
        drawImage(this);
      };
      SimpleMDE2.prototype.drawTable = function() {
        drawTable(this);
      };
      SimpleMDE2.prototype.drawHorizontalRule = function() {
        drawHorizontalRule(this);
      };
      SimpleMDE2.prototype.undo = function() {
        undo(this);
      };
      SimpleMDE2.prototype.redo = function() {
        redo(this);
      };
      SimpleMDE2.prototype.togglePreview = function() {
        togglePreview(this);
      };
      SimpleMDE2.prototype.toggleSideBySide = function() {
        toggleSideBySide(this);
      };
      SimpleMDE2.prototype.toggleFullScreen = function() {
        toggleFullScreen(this);
      };
      SimpleMDE2.prototype.isPreviewActive = function() {
        var cm = this.codemirror;
        var wrapper = cm.getWrapperElement();
        var preview = wrapper.lastChild;
        return /editor-preview-active/.test(preview.className);
      };
      SimpleMDE2.prototype.isSideBySideActive = function() {
        var cm = this.codemirror;
        var wrapper = cm.getWrapperElement();
        var preview = wrapper.nextSibling;
        return /editor-preview-active-side/.test(preview.className);
      };
      SimpleMDE2.prototype.isFullscreenActive = function() {
        var cm = this.codemirror;
        return cm.getOption("fullScreen");
      };
      SimpleMDE2.prototype.getState = function() {
        var cm = this.codemirror;
        return getState(cm);
      };
      SimpleMDE2.prototype.toTextArea = function() {
        var cm = this.codemirror;
        var wrapper = cm.getWrapperElement();
        if (wrapper.parentNode) {
          if (this.gui.toolbar) {
            wrapper.parentNode.removeChild(this.gui.toolbar);
          }
          if (this.gui.statusbar) {
            wrapper.parentNode.removeChild(this.gui.statusbar);
          }
          if (this.gui.sideBySide) {
            wrapper.parentNode.removeChild(this.gui.sideBySide);
          }
        }
        cm.toTextArea();
        if (this.autosaveTimeoutId) {
          clearTimeout(this.autosaveTimeoutId);
          this.autosaveTimeoutId = void 0;
          this.clearAutosavedValue();
        }
      };
      module.exports = SimpleMDE2;
    }
  });

  // node_modules/trix/dist/trix.js
  var require_trix = __commonJS({
    "node_modules/trix/dist/trix.js"(exports, module) {
      (function() {
      }).call(exports), function() {
        var t2;
        window.Set == null && (window.Set = t2 = function() {
          function t3() {
            this.clear();
          }
          return t3.prototype.clear = function() {
            return this.values = [];
          }, t3.prototype.has = function(t4) {
            return this.values.indexOf(t4) !== -1;
          }, t3.prototype.add = function(t4) {
            return this.has(t4) || this.values.push(t4), this;
          }, t3.prototype["delete"] = function(t4) {
            var e2;
            return (e2 = this.values.indexOf(t4)) === -1 ? false : (this.values.splice(e2, 1), true);
          }, t3.prototype.forEach = function() {
            var t4;
            return (t4 = this.values).forEach.apply(t4, arguments);
          }, t3;
        }());
      }.call(exports), function(t2) {
        function e2() {
        }
        function n2(t3, e3) {
          return function() {
            t3.apply(e3, arguments);
          };
        }
        function i2(t3) {
          if (typeof this != "object")
            throw new TypeError("Promises must be constructed via new");
          if (typeof t3 != "function")
            throw new TypeError("not a function");
          this._state = 0, this._handled = false, this._value = void 0, this._deferreds = [], c2(t3, this);
        }
        function o2(t3, e3) {
          for (; t3._state === 3; )
            t3 = t3._value;
          return t3._state === 0 ? void t3._deferreds.push(e3) : (t3._handled = true, void h(function() {
            var n3 = t3._state === 1 ? e3.onFulfilled : e3.onRejected;
            if (n3 === null)
              return void (t3._state === 1 ? r2 : s2)(e3.promise, t3._value);
            var i3;
            try {
              i3 = n3(t3._value);
            } catch (o3) {
              return void s2(e3.promise, o3);
            }
            r2(e3.promise, i3);
          }));
        }
        function r2(t3, e3) {
          try {
            if (e3 === t3)
              throw new TypeError("A promise cannot be resolved with itself.");
            if (e3 && (typeof e3 == "object" || typeof e3 == "function")) {
              var o3 = e3.then;
              if (e3 instanceof i2)
                return t3._state = 3, t3._value = e3, void a2(t3);
              if (typeof o3 == "function")
                return void c2(n2(o3, e3), t3);
            }
            t3._state = 1, t3._value = e3, a2(t3);
          } catch (r3) {
            s2(t3, r3);
          }
        }
        function s2(t3, e3) {
          t3._state = 2, t3._value = e3, a2(t3);
        }
        function a2(t3) {
          t3._state === 2 && t3._deferreds.length === 0 && setTimeout(function() {
            t3._handled || p2(t3._value);
          }, 1);
          for (var e3 = 0, n3 = t3._deferreds.length; n3 > e3; e3++)
            o2(t3, t3._deferreds[e3]);
          t3._deferreds = null;
        }
        function u2(t3, e3, n3) {
          this.onFulfilled = typeof t3 == "function" ? t3 : null, this.onRejected = typeof e3 == "function" ? e3 : null, this.promise = n3;
        }
        function c2(t3, e3) {
          var n3 = false;
          try {
            t3(function(t4) {
              n3 || (n3 = true, r2(e3, t4));
            }, function(t4) {
              n3 || (n3 = true, s2(e3, t4));
            });
          } catch (i3) {
            if (n3)
              return;
            n3 = true, s2(e3, i3);
          }
        }
        var l2 = setTimeout, h = typeof setImmediate == "function" && setImmediate || function(t3) {
          l2(t3, 1);
        }, p2 = function(t3) {
          typeof console != "undefined" && console && console.warn("Possible Unhandled Promise Rejection:", t3);
        };
        i2.prototype["catch"] = function(t3) {
          return this.then(null, t3);
        }, i2.prototype.then = function(t3, n3) {
          var r3 = new i2(e2);
          return o2(this, new u2(t3, n3, r3)), r3;
        }, i2.all = function(t3) {
          var e3 = Array.prototype.slice.call(t3);
          return new i2(function(t4, n3) {
            function i3(r4, s3) {
              try {
                if (s3 && (typeof s3 == "object" || typeof s3 == "function")) {
                  var a3 = s3.then;
                  if (typeof a3 == "function")
                    return void a3.call(s3, function(t5) {
                      i3(r4, t5);
                    }, n3);
                }
                e3[r4] = s3, --o3 === 0 && t4(e3);
              } catch (u3) {
                n3(u3);
              }
            }
            if (e3.length === 0)
              return t4([]);
            for (var o3 = e3.length, r3 = 0; r3 < e3.length; r3++)
              i3(r3, e3[r3]);
          });
        }, i2.resolve = function(t3) {
          return t3 && typeof t3 == "object" && t3.constructor === i2 ? t3 : new i2(function(e3) {
            e3(t3);
          });
        }, i2.reject = function(t3) {
          return new i2(function(e3, n3) {
            n3(t3);
          });
        }, i2.race = function(t3) {
          return new i2(function(e3, n3) {
            for (var i3 = 0, o3 = t3.length; o3 > i3; i3++)
              t3[i3].then(e3, n3);
          });
        }, i2._setImmediateFn = function(t3) {
          h = t3;
        }, i2._setUnhandledRejectionFn = function(t3) {
          p2 = t3;
        }, typeof module != "undefined" && module.exports ? module.exports = i2 : t2.Promise || (t2.Promise = i2);
      }(exports), function() {
        var t2 = typeof window.customElements == "object", e2 = typeof document.registerElement == "function", n2 = t2 || e2;
        n2 || (typeof WeakMap == "undefined" && !function() {
          var t3 = Object.defineProperty, e3 = Date.now() % 1e9, n3 = function() {
            this.name = "__st" + (1e9 * Math.random() >>> 0) + (e3++ + "__");
          };
          n3.prototype = { set: function(e4, n4) {
            var i2 = e4[this.name];
            return i2 && i2[0] === e4 ? i2[1] = n4 : t3(e4, this.name, { value: [e4, n4], writable: true }), this;
          }, get: function(t4) {
            var e4;
            return (e4 = t4[this.name]) && e4[0] === t4 ? e4[1] : void 0;
          }, "delete": function(t4) {
            var e4 = t4[this.name];
            return e4 && e4[0] === t4 ? (e4[0] = e4[1] = void 0, true) : false;
          }, has: function(t4) {
            var e4 = t4[this.name];
            return e4 ? e4[0] === t4 : false;
          } }, window.WeakMap = n3;
        }(), function(t3) {
          function e3(t4) {
            A2.push(t4), b2 || (b2 = true, g2(i2));
          }
          function n3(t4) {
            return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(t4) || t4;
          }
          function i2() {
            b2 = false;
            var t4 = A2;
            A2 = [], t4.sort(function(t5, e5) {
              return t5.uid_ - e5.uid_;
            });
            var e4 = false;
            t4.forEach(function(t5) {
              var n4 = t5.takeRecords();
              o2(t5), n4.length && (t5.callback_(n4, t5), e4 = true);
            }), e4 && i2();
          }
          function o2(t4) {
            t4.nodes_.forEach(function(e4) {
              var n4 = m2.get(e4);
              n4 && n4.forEach(function(e5) {
                e5.observer === t4 && e5.removeTransientObservers();
              });
            });
          }
          function r2(t4, e4) {
            for (var n4 = t4; n4; n4 = n4.parentNode) {
              var i3 = m2.get(n4);
              if (i3)
                for (var o3 = 0; o3 < i3.length; o3++) {
                  var r3 = i3[o3], s3 = r3.options;
                  if (n4 === t4 || s3.subtree) {
                    var a3 = e4(s3);
                    a3 && r3.enqueue(a3);
                  }
                }
            }
          }
          function s2(t4) {
            this.callback_ = t4, this.nodes_ = [], this.records_ = [], this.uid_ = ++C2;
          }
          function a2(t4, e4) {
            this.type = t4, this.target = e4, this.addedNodes = [], this.removedNodes = [], this.previousSibling = null, this.nextSibling = null, this.attributeName = null, this.attributeNamespace = null, this.oldValue = null;
          }
          function u2(t4) {
            var e4 = new a2(t4.type, t4.target);
            return e4.addedNodes = t4.addedNodes.slice(), e4.removedNodes = t4.removedNodes.slice(), e4.previousSibling = t4.previousSibling, e4.nextSibling = t4.nextSibling, e4.attributeName = t4.attributeName, e4.attributeNamespace = t4.attributeNamespace, e4.oldValue = t4.oldValue, e4;
          }
          function c2(t4, e4) {
            return x2 = new a2(t4, e4);
          }
          function l2(t4) {
            return w ? w : (w = u2(x2), w.oldValue = t4, w);
          }
          function h() {
            x2 = w = void 0;
          }
          function p2(t4) {
            return t4 === w || t4 === x2;
          }
          function d2(t4, e4) {
            return t4 === e4 ? t4 : w && p2(t4) ? w : null;
          }
          function f2(t4, e4, n4) {
            this.observer = t4, this.target = e4, this.options = n4, this.transientObservedNodes = [];
          }
          if (!t3.JsMutationObserver) {
            var g2, m2 = /* @__PURE__ */ new WeakMap();
            if (/Trident|Edge/.test(navigator.userAgent))
              g2 = setTimeout;
            else if (window.setImmediate)
              g2 = window.setImmediate;
            else {
              var v2 = [], y2 = String(Math.random());
              window.addEventListener("message", function(t4) {
                if (t4.data === y2) {
                  var e4 = v2;
                  v2 = [], e4.forEach(function(t5) {
                    t5();
                  });
                }
              }), g2 = function(t4) {
                v2.push(t4), window.postMessage(y2, "*");
              };
            }
            var b2 = false, A2 = [], C2 = 0;
            s2.prototype = { observe: function(t4, e4) {
              if (t4 = n3(t4), !e4.childList && !e4.attributes && !e4.characterData || e4.attributeOldValue && !e4.attributes || e4.attributeFilter && e4.attributeFilter.length && !e4.attributes || e4.characterDataOldValue && !e4.characterData)
                throw new SyntaxError();
              var i3 = m2.get(t4);
              i3 || m2.set(t4, i3 = []);
              for (var o3, r3 = 0; r3 < i3.length; r3++)
                if (i3[r3].observer === this) {
                  o3 = i3[r3], o3.removeListeners(), o3.options = e4;
                  break;
                }
              o3 || (o3 = new f2(this, t4, e4), i3.push(o3), this.nodes_.push(t4)), o3.addListeners();
            }, disconnect: function() {
              this.nodes_.forEach(function(t4) {
                for (var e4 = m2.get(t4), n4 = 0; n4 < e4.length; n4++) {
                  var i3 = e4[n4];
                  if (i3.observer === this) {
                    i3.removeListeners(), e4.splice(n4, 1);
                    break;
                  }
                }
              }, this), this.records_ = [];
            }, takeRecords: function() {
              var t4 = this.records_;
              return this.records_ = [], t4;
            } };
            var x2, w;
            f2.prototype = { enqueue: function(t4) {
              var n4 = this.observer.records_, i3 = n4.length;
              if (n4.length > 0) {
                var o3 = n4[i3 - 1], r3 = d2(o3, t4);
                if (r3)
                  return void (n4[i3 - 1] = r3);
              } else
                e3(this.observer);
              n4[i3] = t4;
            }, addListeners: function() {
              this.addListeners_(this.target);
            }, addListeners_: function(t4) {
              var e4 = this.options;
              e4.attributes && t4.addEventListener("DOMAttrModified", this, true), e4.characterData && t4.addEventListener("DOMCharacterDataModified", this, true), e4.childList && t4.addEventListener("DOMNodeInserted", this, true), (e4.childList || e4.subtree) && t4.addEventListener("DOMNodeRemoved", this, true);
            }, removeListeners: function() {
              this.removeListeners_(this.target);
            }, removeListeners_: function(t4) {
              var e4 = this.options;
              e4.attributes && t4.removeEventListener("DOMAttrModified", this, true), e4.characterData && t4.removeEventListener("DOMCharacterDataModified", this, true), e4.childList && t4.removeEventListener("DOMNodeInserted", this, true), (e4.childList || e4.subtree) && t4.removeEventListener("DOMNodeRemoved", this, true);
            }, addTransientObserver: function(t4) {
              if (t4 !== this.target) {
                this.addListeners_(t4), this.transientObservedNodes.push(t4);
                var e4 = m2.get(t4);
                e4 || m2.set(t4, e4 = []), e4.push(this);
              }
            }, removeTransientObservers: function() {
              var t4 = this.transientObservedNodes;
              this.transientObservedNodes = [], t4.forEach(function(t5) {
                this.removeListeners_(t5);
                for (var e4 = m2.get(t5), n4 = 0; n4 < e4.length; n4++)
                  if (e4[n4] === this) {
                    e4.splice(n4, 1);
                    break;
                  }
              }, this);
            }, handleEvent: function(t4) {
              switch (t4.stopImmediatePropagation(), t4.type) {
                case "DOMAttrModified":
                  var e4 = t4.attrName, n4 = t4.relatedNode.namespaceURI, i3 = t4.target, o3 = new c2("attributes", i3);
                  o3.attributeName = e4, o3.attributeNamespace = n4;
                  var s3 = t4.attrChange === MutationEvent.ADDITION ? null : t4.prevValue;
                  r2(i3, function(t5) {
                    return !t5.attributes || t5.attributeFilter && t5.attributeFilter.length && t5.attributeFilter.indexOf(e4) === -1 && t5.attributeFilter.indexOf(n4) === -1 ? void 0 : t5.attributeOldValue ? l2(s3) : o3;
                  });
                  break;
                case "DOMCharacterDataModified":
                  var i3 = t4.target, o3 = c2("characterData", i3), s3 = t4.prevValue;
                  r2(i3, function(t5) {
                    return t5.characterData ? t5.characterDataOldValue ? l2(s3) : o3 : void 0;
                  });
                  break;
                case "DOMNodeRemoved":
                  this.addTransientObserver(t4.target);
                case "DOMNodeInserted":
                  var a3, u3, p3 = t4.target;
                  t4.type === "DOMNodeInserted" ? (a3 = [p3], u3 = []) : (a3 = [], u3 = [p3]);
                  var d3 = p3.previousSibling, f3 = p3.nextSibling, o3 = c2("childList", t4.target.parentNode);
                  o3.addedNodes = a3, o3.removedNodes = u3, o3.previousSibling = d3, o3.nextSibling = f3, r2(t4.relatedNode, function(t5) {
                    return t5.childList ? o3 : void 0;
                  });
              }
              h();
            } }, t3.JsMutationObserver = s2, t3.MutationObserver || (t3.MutationObserver = s2, s2._isPolyfilled = true);
          }
        }(self), function() {
          "use strict";
          if (!window.performance || !window.performance.now) {
            var t3 = Date.now();
            window.performance = { now: function() {
              return Date.now() - t3;
            } };
          }
          window.requestAnimationFrame || (window.requestAnimationFrame = function() {
            var t4 = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
            return t4 ? function(e4) {
              return t4(function() {
                e4(performance.now());
              });
            } : function(t5) {
              return window.setTimeout(t5, 1e3 / 60);
            };
          }()), window.cancelAnimationFrame || (window.cancelAnimationFrame = function() {
            return window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function(t4) {
              clearTimeout(t4);
            };
          }());
          var e3 = function() {
            var t4 = document.createEvent("Event");
            return t4.initEvent("foo", true, true), t4.preventDefault(), t4.defaultPrevented;
          }();
          if (!e3) {
            var n3 = Event.prototype.preventDefault;
            Event.prototype.preventDefault = function() {
              this.cancelable && (n3.call(this), Object.defineProperty(this, "defaultPrevented", { get: function() {
                return true;
              }, configurable: true }));
            };
          }
          var i2 = /Trident/.test(navigator.userAgent);
          if ((!window.CustomEvent || i2 && typeof window.CustomEvent != "function") && (window.CustomEvent = function(t4, e4) {
            e4 = e4 || {};
            var n4 = document.createEvent("CustomEvent");
            return n4.initCustomEvent(t4, Boolean(e4.bubbles), Boolean(e4.cancelable), e4.detail), n4;
          }, window.CustomEvent.prototype = window.Event.prototype), !window.Event || i2 && typeof window.Event != "function") {
            var o2 = window.Event;
            window.Event = function(t4, e4) {
              e4 = e4 || {};
              var n4 = document.createEvent("Event");
              return n4.initEvent(t4, Boolean(e4.bubbles), Boolean(e4.cancelable)), n4;
            }, window.Event.prototype = o2.prototype;
          }
        }(window.WebComponents), window.CustomElements = window.CustomElements || { flags: {} }, function(t3) {
          var e3 = t3.flags, n3 = [], i2 = function(t4) {
            n3.push(t4);
          }, o2 = function() {
            n3.forEach(function(e4) {
              e4(t3);
            });
          };
          t3.addModule = i2, t3.initializeModules = o2, t3.hasNative = Boolean(document.registerElement), t3.isIE = /Trident/.test(navigator.userAgent), t3.useNative = !e3.register && t3.hasNative && !window.ShadowDOMPolyfill && (!window.HTMLImports || window.HTMLImports.useNative);
        }(window.CustomElements), window.CustomElements.addModule(function(t3) {
          function e3(t4, e4) {
            n3(t4, function(t5) {
              return e4(t5) ? true : void i2(t5, e4);
            }), i2(t4, e4);
          }
          function n3(t4, e4, i3) {
            var o3 = t4.firstElementChild;
            if (!o3)
              for (o3 = t4.firstChild; o3 && o3.nodeType !== Node.ELEMENT_NODE; )
                o3 = o3.nextSibling;
            for (; o3; )
              e4(o3, i3) !== true && n3(o3, e4, i3), o3 = o3.nextElementSibling;
            return null;
          }
          function i2(t4, n4) {
            for (var i3 = t4.shadowRoot; i3; )
              e3(i3, n4), i3 = i3.olderShadowRoot;
          }
          function o2(t4, e4) {
            r2(t4, e4, []);
          }
          function r2(t4, e4, n4) {
            if (t4 = window.wrap(t4), !(n4.indexOf(t4) >= 0)) {
              n4.push(t4);
              for (var i3, o3 = t4.querySelectorAll("link[rel=" + s2 + "]"), a2 = 0, u2 = o3.length; u2 > a2 && (i3 = o3[a2]); a2++)
                i3.import && r2(i3.import, e4, n4);
              e4(t4);
            }
          }
          var s2 = window.HTMLImports ? window.HTMLImports.IMPORT_LINK_TYPE : "none";
          t3.forDocumentTree = o2, t3.forSubtree = e3;
        }), window.CustomElements.addModule(function(t3) {
          function e3(t4, e4) {
            return n3(t4, e4) || i2(t4, e4);
          }
          function n3(e4, n4) {
            return t3.upgrade(e4, n4) ? true : void (n4 && s2(e4));
          }
          function i2(t4, e4) {
            b2(t4, function(t5) {
              return n3(t5, e4) ? true : void 0;
            });
          }
          function o2(t4) {
            w.push(t4), x2 || (x2 = true, setTimeout(r2));
          }
          function r2() {
            x2 = false;
            for (var t4, e4 = w, n4 = 0, i3 = e4.length; i3 > n4 && (t4 = e4[n4]); n4++)
              t4();
            w = [];
          }
          function s2(t4) {
            C2 ? o2(function() {
              a2(t4);
            }) : a2(t4);
          }
          function a2(t4) {
            t4.__upgraded__ && !t4.__attached && (t4.__attached = true, t4.attachedCallback && t4.attachedCallback());
          }
          function u2(t4) {
            c2(t4), b2(t4, function(t5) {
              c2(t5);
            });
          }
          function c2(t4) {
            C2 ? o2(function() {
              l2(t4);
            }) : l2(t4);
          }
          function l2(t4) {
            t4.__upgraded__ && t4.__attached && (t4.__attached = false, t4.detachedCallback && t4.detachedCallback());
          }
          function h(t4) {
            for (var e4 = t4, n4 = window.wrap(document); e4; ) {
              if (e4 == n4)
                return true;
              e4 = e4.parentNode || e4.nodeType === Node.DOCUMENT_FRAGMENT_NODE && e4.host;
            }
          }
          function p2(t4) {
            if (t4.shadowRoot && !t4.shadowRoot.__watched) {
              y2.dom && console.log("watching shadow-root for: ", t4.localName);
              for (var e4 = t4.shadowRoot; e4; )
                g2(e4), e4 = e4.olderShadowRoot;
            }
          }
          function d2(t4, n4) {
            if (y2.dom) {
              var i3 = n4[0];
              if (i3 && i3.type === "childList" && i3.addedNodes && i3.addedNodes) {
                for (var o3 = i3.addedNodes[0]; o3 && o3 !== document && !o3.host; )
                  o3 = o3.parentNode;
                var r3 = o3 && (o3.URL || o3._URL || o3.host && o3.host.localName) || "";
                r3 = r3.split("/?").shift().split("/").pop();
              }
              console.group("mutations (%d) [%s]", n4.length, r3 || "");
            }
            var s3 = h(t4);
            n4.forEach(function(t5) {
              t5.type === "childList" && (E(t5.addedNodes, function(t6) {
                t6.localName && e3(t6, s3);
              }), E(t5.removedNodes, function(t6) {
                t6.localName && u2(t6);
              }));
            }), y2.dom && console.groupEnd();
          }
          function f2(t4) {
            for (t4 = window.wrap(t4), t4 || (t4 = window.wrap(document)); t4.parentNode; )
              t4 = t4.parentNode;
            var e4 = t4.__observer;
            e4 && (d2(t4, e4.takeRecords()), r2());
          }
          function g2(t4) {
            if (!t4.__observer) {
              var e4 = new MutationObserver(d2.bind(this, t4));
              e4.observe(t4, { childList: true, subtree: true }), t4.__observer = e4;
            }
          }
          function m2(t4) {
            t4 = window.wrap(t4), y2.dom && console.group("upgradeDocument: ", t4.baseURI.split("/").pop());
            var n4 = t4 === window.wrap(document);
            e3(t4, n4), g2(t4), y2.dom && console.groupEnd();
          }
          function v2(t4) {
            A2(t4, m2);
          }
          var y2 = t3.flags, b2 = t3.forSubtree, A2 = t3.forDocumentTree, C2 = window.MutationObserver._isPolyfilled && y2["throttle-attached"];
          t3.hasPolyfillMutations = C2, t3.hasThrottledAttached = C2;
          var x2 = false, w = [], E = Array.prototype.forEach.call.bind(Array.prototype.forEach), S = Element.prototype.createShadowRoot;
          S && (Element.prototype.createShadowRoot = function() {
            var t4 = S.call(this);
            return window.CustomElements.watchShadow(this), t4;
          }), t3.watchShadow = p2, t3.upgradeDocumentTree = v2, t3.upgradeDocument = m2, t3.upgradeSubtree = i2, t3.upgradeAll = e3, t3.attached = s2, t3.takeRecords = f2;
        }), window.CustomElements.addModule(function(t3) {
          function e3(e4, i3) {
            if (e4.localName === "template" && window.HTMLTemplateElement && HTMLTemplateElement.decorate && HTMLTemplateElement.decorate(e4), !e4.__upgraded__ && e4.nodeType === Node.ELEMENT_NODE) {
              var o3 = e4.getAttribute("is"), r3 = t3.getRegisteredDefinition(e4.localName) || t3.getRegisteredDefinition(o3);
              if (r3 && (o3 && r3.tag == e4.localName || !o3 && !r3.extends))
                return n3(e4, r3, i3);
            }
          }
          function n3(e4, n4, o3) {
            return s2.upgrade && console.group("upgrade:", e4.localName), n4.is && e4.setAttribute("is", n4.is), i2(e4, n4), e4.__upgraded__ = true, r2(e4), o3 && t3.attached(e4), t3.upgradeSubtree(e4, o3), s2.upgrade && console.groupEnd(), e4;
          }
          function i2(t4, e4) {
            Object.__proto__ ? t4.__proto__ = e4.prototype : (o2(t4, e4.prototype, e4.native), t4.__proto__ = e4.prototype);
          }
          function o2(t4, e4, n4) {
            for (var i3 = {}, o3 = e4; o3 !== n4 && o3 !== HTMLElement.prototype; ) {
              for (var r3, s3 = Object.getOwnPropertyNames(o3), a2 = 0; r3 = s3[a2]; a2++)
                i3[r3] || (Object.defineProperty(t4, r3, Object.getOwnPropertyDescriptor(o3, r3)), i3[r3] = 1);
              o3 = Object.getPrototypeOf(o3);
            }
          }
          function r2(t4) {
            t4.createdCallback && t4.createdCallback();
          }
          var s2 = t3.flags;
          t3.upgrade = e3, t3.upgradeWithDefinition = n3, t3.implementPrototype = i2;
        }), window.CustomElements.addModule(function(t3) {
          function e3(e4, i3) {
            var u3 = i3 || {};
            if (!e4)
              throw new Error("document.registerElement: first argument `name` must not be empty");
            if (e4.indexOf("-") < 0)
              throw new Error("document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '" + String(e4) + "'.");
            if (o2(e4))
              throw new Error("Failed to execute 'registerElement' on 'Document': Registration failed for type '" + String(e4) + "'. The type name is invalid.");
            if (c2(e4))
              throw new Error("DuplicateDefinitionError: a type with name '" + String(e4) + "' is already registered");
            return u3.prototype || (u3.prototype = Object.create(HTMLElement.prototype)), u3.__name = e4.toLowerCase(), u3.extends && (u3.extends = u3.extends.toLowerCase()), u3.lifecycle = u3.lifecycle || {}, u3.ancestry = r2(u3.extends), s2(u3), a2(u3), n3(u3.prototype), l2(u3.__name, u3), u3.ctor = h(u3), u3.ctor.prototype = u3.prototype, u3.prototype.constructor = u3.ctor, t3.ready && m2(document), u3.ctor;
          }
          function n3(t4) {
            if (!t4.setAttribute._polyfilled) {
              var e4 = t4.setAttribute;
              t4.setAttribute = function(t5, n5) {
                i2.call(this, t5, n5, e4);
              };
              var n4 = t4.removeAttribute;
              t4.removeAttribute = function(t5) {
                i2.call(this, t5, null, n4);
              }, t4.setAttribute._polyfilled = true;
            }
          }
          function i2(t4, e4, n4) {
            t4 = t4.toLowerCase();
            var i3 = this.getAttribute(t4);
            n4.apply(this, arguments);
            var o3 = this.getAttribute(t4);
            this.attributeChangedCallback && o3 !== i3 && this.attributeChangedCallback(t4, i3, o3);
          }
          function o2(t4) {
            for (var e4 = 0; e4 < C2.length; e4++)
              if (t4 === C2[e4])
                return true;
          }
          function r2(t4) {
            var e4 = c2(t4);
            return e4 ? r2(e4.extends).concat([e4]) : [];
          }
          function s2(t4) {
            for (var e4, n4 = t4.extends, i3 = 0; e4 = t4.ancestry[i3]; i3++)
              n4 = e4.is && e4.tag;
            t4.tag = n4 || t4.__name, n4 && (t4.is = t4.__name);
          }
          function a2(t4) {
            if (!Object.__proto__) {
              var e4 = HTMLElement.prototype;
              if (t4.is) {
                var n4 = document.createElement(t4.tag);
                e4 = Object.getPrototypeOf(n4);
              }
              for (var i3, o3 = t4.prototype, r3 = false; o3; )
                o3 == e4 && (r3 = true), i3 = Object.getPrototypeOf(o3), i3 && (o3.__proto__ = i3), o3 = i3;
              r3 || console.warn(t4.tag + " prototype not found in prototype chain for " + t4.is), t4.native = e4;
            }
          }
          function u2(t4) {
            return y2(E(t4.tag), t4);
          }
          function c2(t4) {
            return t4 ? x2[t4.toLowerCase()] : void 0;
          }
          function l2(t4, e4) {
            x2[t4] = e4;
          }
          function h(t4) {
            return function() {
              return u2(t4);
            };
          }
          function p2(t4, e4, n4) {
            return t4 === w ? d2(e4, n4) : S(t4, e4);
          }
          function d2(t4, e4) {
            t4 && (t4 = t4.toLowerCase()), e4 && (e4 = e4.toLowerCase());
            var n4 = c2(e4 || t4);
            if (n4) {
              if (t4 == n4.tag && e4 == n4.is)
                return new n4.ctor();
              if (!e4 && !n4.is)
                return new n4.ctor();
            }
            var i3;
            return e4 ? (i3 = d2(t4), i3.setAttribute("is", e4), i3) : (i3 = E(t4), t4.indexOf("-") >= 0 && b2(i3, HTMLElement), i3);
          }
          function f2(t4, e4) {
            var n4 = t4[e4];
            t4[e4] = function() {
              var t5 = n4.apply(this, arguments);
              return v2(t5), t5;
            };
          }
          var g2, m2 = (t3.isIE, t3.upgradeDocumentTree), v2 = t3.upgradeAll, y2 = t3.upgradeWithDefinition, b2 = t3.implementPrototype, A2 = t3.useNative, C2 = ["annotation-xml", "color-profile", "font-face", "font-face-src", "font-face-uri", "font-face-format", "font-face-name", "missing-glyph"], x2 = {}, w = "http://www.w3.org/1999/xhtml", E = document.createElement.bind(document), S = document.createElementNS.bind(document);
          g2 = Object.__proto__ || A2 ? function(t4, e4) {
            return t4 instanceof e4;
          } : function(t4, e4) {
            if (t4 instanceof e4)
              return true;
            for (var n4 = t4; n4; ) {
              if (n4 === e4.prototype)
                return true;
              n4 = n4.__proto__;
            }
            return false;
          }, f2(Node.prototype, "cloneNode"), f2(document, "importNode"), document.registerElement = e3, document.createElement = d2, document.createElementNS = p2, t3.registry = x2, t3.instanceof = g2, t3.reservedTagList = C2, t3.getRegisteredDefinition = c2, document.register = document.registerElement;
        }), function(t3) {
          function e3() {
            r2(window.wrap(document)), window.CustomElements.ready = true;
            var t4 = window.requestAnimationFrame || function(t5) {
              setTimeout(t5, 16);
            };
            t4(function() {
              setTimeout(function() {
                window.CustomElements.readyTime = Date.now(), window.HTMLImports && (window.CustomElements.elapsed = window.CustomElements.readyTime - window.HTMLImports.readyTime), document.dispatchEvent(new CustomEvent("WebComponentsReady", { bubbles: true }));
              });
            });
          }
          var n3 = t3.useNative, i2 = t3.initializeModules;
          if (t3.isIE, n3) {
            var o2 = function() {
            };
            t3.watchShadow = o2, t3.upgrade = o2, t3.upgradeAll = o2, t3.upgradeDocumentTree = o2, t3.upgradeSubtree = o2, t3.takeRecords = o2, t3.instanceof = function(t4, e4) {
              return t4 instanceof e4;
            };
          } else
            i2();
          var r2 = t3.upgradeDocumentTree, s2 = t3.upgradeDocument;
          if (window.wrap || (window.ShadowDOMPolyfill ? (window.wrap = window.ShadowDOMPolyfill.wrapIfNeeded, window.unwrap = window.ShadowDOMPolyfill.unwrapIfNeeded) : window.wrap = window.unwrap = function(t4) {
            return t4;
          }), window.HTMLImports && (window.HTMLImports.__importsParsingHook = function(t4) {
            t4.import && s2(wrap(t4.import));
          }), document.readyState === "complete" || t3.flags.eager)
            e3();
          else if (document.readyState !== "interactive" || window.attachEvent || window.HTMLImports && !window.HTMLImports.ready) {
            var a2 = window.HTMLImports && !window.HTMLImports.ready ? "HTMLImportsLoaded" : "DOMContentLoaded";
            window.addEventListener(a2, e3);
          } else
            e3();
        }(window.CustomElements));
      }.call(exports), function() {
      }.call(exports), function() {
        var t2 = this;
        (function() {
          (function() {
            this.Trix = { VERSION: "1.3.1", ZERO_WIDTH_SPACE: "\uFEFF", NON_BREAKING_SPACE: "\xA0", OBJECT_REPLACEMENT_CHARACTER: "\uFFFC", browser: { composesExistingText: /Android.*Chrome/.test(navigator.userAgent), forcesObjectResizing: /Trident.*rv:11/.test(navigator.userAgent), supportsInputEvents: function() {
              var t3, e3, n2, i2;
              if (typeof InputEvent == "undefined")
                return false;
              for (i2 = ["data", "getTargetRanges", "inputType"], t3 = 0, e3 = i2.length; e3 > t3; t3++)
                if (n2 = i2[t3], !(n2 in InputEvent.prototype))
                  return false;
              return true;
            }() }, config: {} };
          }).call(this);
        }).call(t2);
        var e2 = t2.Trix;
        (function() {
          (function() {
            e2.BasicObject = function() {
              function t3() {
              }
              var e3, n2, i2;
              return t3.proxyMethod = function(t4) {
                var i3, o2, r2, s2, a2;
                return r2 = n2(t4), i3 = r2.name, s2 = r2.toMethod, a2 = r2.toProperty, o2 = r2.optional, this.prototype[i3] = function() {
                  var t5, n3;
                  return t5 = s2 != null ? o2 ? typeof this[s2] == "function" ? this[s2]() : void 0 : this[s2]() : a2 != null ? this[a2] : void 0, o2 ? (n3 = t5 != null ? t5[i3] : void 0, n3 != null ? e3.call(n3, t5, arguments) : void 0) : (n3 = t5[i3], e3.call(n3, t5, arguments));
                };
              }, n2 = function(t4) {
                var e4, n3;
                if (!(n3 = t4.match(i2)))
                  throw new Error("can't parse @proxyMethod expression: " + t4);
                return e4 = { name: n3[4] }, n3[2] != null ? e4.toMethod = n3[1] : e4.toProperty = n3[1], n3[3] != null && (e4.optional = true), e4;
              }, e3 = Function.prototype.apply, i2 = /^(.+?)(\(\))?(\?)?\.(.+?)$/, t3;
            }();
          }).call(this), function() {
            var t3 = function(t4, e3) {
              function i2() {
                this.constructor = t4;
              }
              for (var o2 in e3)
                n2.call(e3, o2) && (t4[o2] = e3[o2]);
              return i2.prototype = e3.prototype, t4.prototype = new i2(), t4.__super__ = e3.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e2.Object = function(n3) {
              function i2() {
                this.id = ++o2;
              }
              var o2;
              return t3(i2, n3), o2 = 0, i2.fromJSONString = function(t4) {
                return this.fromJSON(JSON.parse(t4));
              }, i2.prototype.hasSameConstructorAs = function(t4) {
                return this.constructor === (t4 != null ? t4.constructor : void 0);
              }, i2.prototype.isEqualTo = function(t4) {
                return this === t4;
              }, i2.prototype.inspect = function() {
                var t4, e3, n4;
                return t4 = function() {
                  var t5, i3, o3;
                  i3 = (t5 = this.contentsForInspection()) != null ? t5 : {}, o3 = [];
                  for (e3 in i3)
                    n4 = i3[e3], o3.push(e3 + "=" + n4);
                  return o3;
                }.call(this), "#<" + this.constructor.name + ":" + this.id + (t4.length ? " " + t4.join(", ") : "") + ">";
              }, i2.prototype.contentsForInspection = function() {
              }, i2.prototype.toJSONString = function() {
                return JSON.stringify(this);
              }, i2.prototype.toUTF16String = function() {
                return e2.UTF16String.box(this);
              }, i2.prototype.getCacheKey = function() {
                return this.id.toString();
              }, i2;
            }(e2.BasicObject);
          }.call(this), function() {
            e2.extend = function(t3) {
              var e3, n2;
              for (e3 in t3)
                n2 = t3[e3], this[e3] = n2;
              return this;
            };
          }.call(this), function() {
            e2.extend({ defer: function(t3) {
              return setTimeout(t3, 1);
            } });
          }.call(this), function() {
            var t3, n2;
            e2.extend({ normalizeSpaces: function(t4) {
              return t4.replace(RegExp("" + e2.ZERO_WIDTH_SPACE, "g"), "").replace(RegExp("" + e2.NON_BREAKING_SPACE, "g"), " ");
            }, normalizeNewlines: function(t4) {
              return t4.replace(/\r\n/g, "\n");
            }, breakableWhitespacePattern: RegExp("[^\\S" + e2.NON_BREAKING_SPACE + "]"), squishBreakableWhitespace: function(t4) {
              return t4.replace(RegExp("" + e2.breakableWhitespacePattern.source, "g"), " ").replace(/\ {2,}/g, " ");
            }, summarizeStringChange: function(t4, i2) {
              var o2, r2, s2, a2;
              return t4 = e2.UTF16String.box(t4), i2 = e2.UTF16String.box(i2), i2.length < t4.length ? (r2 = n2(t4, i2), a2 = r2[0], o2 = r2[1]) : (s2 = n2(i2, t4), o2 = s2[0], a2 = s2[1]), { added: o2, removed: a2 };
            } }), n2 = function(n3, i2) {
              var o2, r2, s2, a2, u2;
              return n3.isEqualTo(i2) ? ["", ""] : (r2 = t3(n3, i2), a2 = r2.utf16String.length, s2 = a2 ? (u2 = r2.offset, r2, o2 = n3.codepoints.slice(0, u2).concat(n3.codepoints.slice(u2 + a2)), t3(i2, e2.UTF16String.fromCodepoints(o2))) : t3(i2, n3), [r2.utf16String.toString(), s2.utf16String.toString()]);
            }, t3 = function(t4, e3) {
              var n3, i2, o2;
              for (n3 = 0, i2 = t4.length, o2 = e3.length; i2 > n3 && t4.charAt(n3).isEqualTo(e3.charAt(n3)); )
                n3++;
              for (; i2 > n3 + 1 && t4.charAt(i2 - 1).isEqualTo(e3.charAt(o2 - 1)); )
                i2--, o2--;
              return { utf16String: t4.slice(n3, i2), offset: n3 };
            };
          }.call(this), function() {
            e2.extend({ copyObject: function(t3) {
              var e3, n2, i2;
              t3 == null && (t3 = {}), n2 = {};
              for (e3 in t3)
                i2 = t3[e3], n2[e3] = i2;
              return n2;
            }, objectsAreEqual: function(t3, e3) {
              var n2, i2;
              if (t3 == null && (t3 = {}), e3 == null && (e3 = {}), Object.keys(t3).length !== Object.keys(e3).length)
                return false;
              for (n2 in t3)
                if (i2 = t3[n2], i2 !== e3[n2])
                  return false;
              return true;
            } });
          }.call(this), function() {
            var t3 = [].slice;
            e2.extend({ arraysAreEqual: function(t4, e3) {
              var n2, i2, o2, r2;
              if (t4 == null && (t4 = []), e3 == null && (e3 = []), t4.length !== e3.length)
                return false;
              for (i2 = n2 = 0, o2 = t4.length; o2 > n2; i2 = ++n2)
                if (r2 = t4[i2], r2 !== e3[i2])
                  return false;
              return true;
            }, arrayStartsWith: function(t4, n2) {
              return t4 == null && (t4 = []), n2 == null && (n2 = []), e2.arraysAreEqual(t4.slice(0, n2.length), n2);
            }, spliceArray: function() {
              var e3, n2, i2;
              return n2 = arguments[0], e3 = 2 <= arguments.length ? t3.call(arguments, 1) : [], i2 = n2.slice(0), i2.splice.apply(i2, e3), i2;
            }, summarizeArrayChange: function(t4, e3) {
              var n2, i2, o2, r2, s2, a2, u2, c2, l2, h, p2;
              for (t4 == null && (t4 = []), e3 == null && (e3 = []), n2 = [], h = [], o2 = /* @__PURE__ */ new Set(), r2 = 0, u2 = t4.length; u2 > r2; r2++)
                p2 = t4[r2], o2.add(p2);
              for (i2 = /* @__PURE__ */ new Set(), s2 = 0, c2 = e3.length; c2 > s2; s2++)
                p2 = e3[s2], i2.add(p2), o2.has(p2) || n2.push(p2);
              for (a2 = 0, l2 = t4.length; l2 > a2; a2++)
                p2 = t4[a2], i2.has(p2) || h.push(p2);
              return { added: n2, removed: h };
            } });
          }.call(this), function() {
            var t3, n2, i2, o2;
            t3 = null, n2 = null, o2 = null, i2 = null, e2.extend({ getAllAttributeNames: function() {
              return t3 != null ? t3 : t3 = e2.getTextAttributeNames().concat(e2.getBlockAttributeNames());
            }, getBlockConfig: function(t4) {
              return e2.config.blockAttributes[t4];
            }, getBlockAttributeNames: function() {
              return n2 != null ? n2 : n2 = Object.keys(e2.config.blockAttributes);
            }, getTextConfig: function(t4) {
              return e2.config.textAttributes[t4];
            }, getTextAttributeNames: function() {
              return o2 != null ? o2 : o2 = Object.keys(e2.config.textAttributes);
            }, getListAttributeNames: function() {
              var t4, n3;
              return i2 != null ? i2 : i2 = function() {
                var i3, o3;
                i3 = e2.config.blockAttributes, o3 = [];
                for (t4 in i3)
                  n3 = i3[t4].listAttribute, n3 != null && o3.push(n3);
                return o3;
              }();
            } });
          }.call(this), function() {
            var t3, n2, i2, o2, r2, s2 = [].indexOf || function(t4) {
              for (var e3 = 0, n3 = this.length; n3 > e3; e3++)
                if (e3 in this && this[e3] === t4)
                  return e3;
              return -1;
            };
            t3 = document.documentElement, n2 = (i2 = (o2 = (r2 = t3.matchesSelector) != null ? r2 : t3.webkitMatchesSelector) != null ? o2 : t3.msMatchesSelector) != null ? i2 : t3.mozMatchesSelector, e2.extend({ handleEvent: function(n3, i3) {
              var o3, r3, s3, a2, u2, c2, l2, h, p2, d2, f2, g2;
              return h = i3 != null ? i3 : {}, c2 = h.onElement, u2 = h.matchingSelector, g2 = h.withCallback, a2 = h.inPhase, l2 = h.preventDefault, d2 = h.times, r3 = c2 != null ? c2 : t3, p2 = u2, o3 = g2, f2 = a2 === "capturing", s3 = function(t4) {
                var n4;
                return d2 != null && --d2 === 0 && s3.destroy(), n4 = e2.findClosestElementFromNode(t4.target, { matchingSelector: p2 }), n4 != null && (g2 != null && g2.call(n4, t4, n4), l2) ? t4.preventDefault() : void 0;
              }, s3.destroy = function() {
                return r3.removeEventListener(n3, s3, f2);
              }, r3.addEventListener(n3, s3, f2), s3;
            }, handleEventOnce: function(t4, n3) {
              return n3 == null && (n3 = {}), n3.times = 1, e2.handleEvent(t4, n3);
            }, triggerEvent: function(n3, i3) {
              var o3, r3, s3, a2, u2, c2, l2;
              return l2 = i3 != null ? i3 : {}, c2 = l2.onElement, r3 = l2.bubbles, s3 = l2.cancelable, o3 = l2.attributes, a2 = c2 != null ? c2 : t3, r3 = r3 !== false, s3 = s3 !== false, u2 = document.createEvent("Events"), u2.initEvent(n3, r3, s3), o3 != null && e2.extend.call(u2, o3), a2.dispatchEvent(u2);
            }, elementMatchesSelector: function(t4, e3) {
              return (t4 != null ? t4.nodeType : void 0) === 1 ? n2.call(t4, e3) : void 0;
            }, findClosestElementFromNode: function(t4, n3) {
              var i3, o3, r3;
              for (o3 = n3 != null ? n3 : {}, i3 = o3.matchingSelector, r3 = o3.untilNode; t4 != null && t4.nodeType !== Node.ELEMENT_NODE; )
                t4 = t4.parentNode;
              if (t4 != null) {
                if (i3 == null)
                  return t4;
                if (t4.closest && r3 == null)
                  return t4.closest(i3);
                for (; t4 && t4 !== r3; ) {
                  if (e2.elementMatchesSelector(t4, i3))
                    return t4;
                  t4 = t4.parentNode;
                }
              }
            }, findInnerElement: function(t4) {
              for (; t4 != null ? t4.firstElementChild : void 0; )
                t4 = t4.firstElementChild;
              return t4;
            }, innerElementIsActive: function(t4) {
              return document.activeElement !== t4 && e2.elementContainsNode(t4, document.activeElement);
            }, elementContainsNode: function(t4, e3) {
              if (t4 && e3)
                for (; e3; ) {
                  if (e3 === t4)
                    return true;
                  e3 = e3.parentNode;
                }
            }, findNodeFromContainerAndOffset: function(t4, e3) {
              var n3;
              if (t4)
                return t4.nodeType === Node.TEXT_NODE ? t4 : e3 === 0 ? (n3 = t4.firstChild) != null ? n3 : t4 : t4.childNodes.item(e3 - 1);
            }, findElementFromContainerAndOffset: function(t4, n3) {
              var i3;
              return i3 = e2.findNodeFromContainerAndOffset(t4, n3), e2.findClosestElementFromNode(i3);
            }, findChildIndexOfNode: function(t4) {
              var e3;
              if (t4 != null ? t4.parentNode : void 0) {
                for (e3 = 0; t4 = t4.previousSibling; )
                  e3++;
                return e3;
              }
            }, removeNode: function(t4) {
              var e3;
              return t4 != null && (e3 = t4.parentNode) != null ? e3.removeChild(t4) : void 0;
            }, walkTree: function(t4, e3) {
              var n3, i3, o3, r3, s3;
              return o3 = e3 != null ? e3 : {}, i3 = o3.onlyNodesOfType, r3 = o3.usingFilter, n3 = o3.expandEntityReferences, s3 = function() {
                switch (i3) {
                  case "element":
                    return NodeFilter.SHOW_ELEMENT;
                  case "text":
                    return NodeFilter.SHOW_TEXT;
                  case "comment":
                    return NodeFilter.SHOW_COMMENT;
                  default:
                    return NodeFilter.SHOW_ALL;
                }
              }(), document.createTreeWalker(t4, s3, r3 != null ? r3 : null, n3 === true);
            }, tagName: function(t4) {
              var e3;
              return t4 != null && (e3 = t4.tagName) != null ? e3.toLowerCase() : void 0;
            }, makeElement: function(t4, e3) {
              var n3, i3, o3, r3, s3, a2, u2, c2, l2, h, p2, d2, f2, g2;
              if (e3 == null && (e3 = {}), typeof t4 == "object" ? (e3 = t4, t4 = e3.tagName) : e3 = { attributes: e3 }, o3 = document.createElement(t4), e3.editable != null && (e3.attributes == null && (e3.attributes = {}), e3.attributes.contenteditable = e3.editable), e3.attributes) {
                l2 = e3.attributes;
                for (a2 in l2)
                  g2 = l2[a2], o3.setAttribute(a2, g2);
              }
              if (e3.style) {
                h = e3.style;
                for (a2 in h)
                  g2 = h[a2], o3.style[a2] = g2;
              }
              if (e3.data) {
                p2 = e3.data;
                for (a2 in p2)
                  g2 = p2[a2], o3.dataset[a2] = g2;
              }
              if (e3.className)
                for (d2 = e3.className.split(" "), r3 = 0, u2 = d2.length; u2 > r3; r3++)
                  i3 = d2[r3], o3.classList.add(i3);
              if (e3.textContent && (o3.textContent = e3.textContent), e3.childNodes)
                for (f2 = [].concat(e3.childNodes), s3 = 0, c2 = f2.length; c2 > s3; s3++)
                  n3 = f2[s3], o3.appendChild(n3);
              return o3;
            }, getBlockTagNames: function() {
              var t4, n3;
              return e2.blockTagNames != null ? e2.blockTagNames : e2.blockTagNames = function() {
                var i3, o3;
                i3 = e2.config.blockAttributes, o3 = [];
                for (t4 in i3)
                  n3 = i3[t4].tagName, n3 && o3.push(n3);
                return o3;
              }();
            }, nodeIsBlockContainer: function(t4) {
              return e2.nodeIsBlockStartComment(t4 != null ? t4.firstChild : void 0);
            }, nodeProbablyIsBlockContainer: function(t4) {
              var n3, i3;
              return n3 = e2.tagName(t4), s2.call(e2.getBlockTagNames(), n3) >= 0 && (i3 = e2.tagName(t4.firstChild), s2.call(e2.getBlockTagNames(), i3) < 0);
            }, nodeIsBlockStart: function(t4, n3) {
              var i3;
              return i3 = (n3 != null ? n3 : { strict: true }).strict, i3 ? e2.nodeIsBlockStartComment(t4) : e2.nodeIsBlockStartComment(t4) || !e2.nodeIsBlockStartComment(t4.firstChild) && e2.nodeProbablyIsBlockContainer(t4);
            }, nodeIsBlockStartComment: function(t4) {
              return e2.nodeIsCommentNode(t4) && (t4 != null ? t4.data : void 0) === "block";
            }, nodeIsCommentNode: function(t4) {
              return (t4 != null ? t4.nodeType : void 0) === Node.COMMENT_NODE;
            }, nodeIsCursorTarget: function(t4, n3) {
              var i3;
              return i3 = (n3 != null ? n3 : {}).name, t4 ? e2.nodeIsTextNode(t4) ? t4.data === e2.ZERO_WIDTH_SPACE ? i3 ? t4.parentNode.dataset.trixCursorTarget === i3 : true : void 0 : e2.nodeIsCursorTarget(t4.firstChild) : void 0;
            }, nodeIsAttachmentElement: function(t4) {
              return e2.elementMatchesSelector(t4, e2.AttachmentView.attachmentSelector);
            }, nodeIsEmptyTextNode: function(t4) {
              return e2.nodeIsTextNode(t4) && (t4 != null ? t4.data : void 0) === "";
            }, nodeIsTextNode: function(t4) {
              return (t4 != null ? t4.nodeType : void 0) === Node.TEXT_NODE;
            } });
          }.call(this), function() {
            var t3, n2, i2, o2, r2;
            t3 = e2.copyObject, o2 = e2.objectsAreEqual, e2.extend({ normalizeRange: i2 = function(t4) {
              var e3;
              if (t4 != null)
                return Array.isArray(t4) || (t4 = [t4, t4]), [n2(t4[0]), n2((e3 = t4[1]) != null ? e3 : t4[0])];
            }, rangeIsCollapsed: function(t4) {
              var e3, n3, o3;
              if (t4 != null)
                return n3 = i2(t4), o3 = n3[0], e3 = n3[1], r2(o3, e3);
            }, rangesAreEqual: function(t4, e3) {
              var n3, o3, s2, a2, u2, c2;
              if (t4 != null && e3 != null)
                return s2 = i2(t4), o3 = s2[0], n3 = s2[1], a2 = i2(e3), c2 = a2[0], u2 = a2[1], r2(o3, c2) && r2(n3, u2);
            } }), n2 = function(e3) {
              return typeof e3 == "number" ? e3 : t3(e3);
            }, r2 = function(t4, e3) {
              return typeof t4 == "number" ? t4 === e3 : o2(t4, e3);
            };
          }.call(this), function() {
            var t3, n2, i2, o2, r2, s2, a2;
            e2.registerElement = function(t4, e3) {
              var n3, i3;
              return e3 == null && (e3 = {}), t4 = t4.toLowerCase(), e3 = a2(e3), i3 = s2(e3), (n3 = i3.defaultCSS) && (delete i3.defaultCSS, o2(n3, t4)), r2(t4, i3);
            }, o2 = function(t4, e3) {
              var n3;
              return n3 = i2(e3), n3.textContent = t4.replace(/%t/g, e3);
            }, i2 = function(e3) {
              var n3, i3;
              return n3 = document.createElement("style"), n3.setAttribute("type", "text/css"), n3.setAttribute("data-tag-name", e3.toLowerCase()), (i3 = t3()) && n3.setAttribute("nonce", i3), document.head.insertBefore(n3, document.head.firstChild), n3;
            }, t3 = function() {
              var t4;
              return (t4 = n2("trix-csp-nonce") || n2("csp-nonce")) ? t4.getAttribute("content") : void 0;
            }, n2 = function(t4) {
              return document.head.querySelector("meta[name=" + t4 + "]");
            }, s2 = function(t4) {
              var e3, n3, i3;
              n3 = {};
              for (e3 in t4)
                i3 = t4[e3], n3[e3] = typeof i3 == "function" ? { value: i3 } : i3;
              return n3;
            }, a2 = function() {
              var t4;
              return t4 = function(t5) {
                var e3, n3, i3, o3, r3;
                for (e3 = {}, r3 = ["initialize", "connect", "disconnect"], n3 = 0, o3 = r3.length; o3 > n3; n3++)
                  i3 = r3[n3], e3[i3] = t5[i3], delete t5[i3];
                return e3;
              }, window.customElements ? function(e3) {
                var n3, i3, o3, r3, s3;
                return s3 = t4(e3), o3 = s3.initialize, n3 = s3.connect, i3 = s3.disconnect, o3 && (r3 = n3, n3 = function() {
                  return this.initialized || (this.initialized = true, o3.call(this)), r3 != null ? r3.call(this) : void 0;
                }), n3 && (e3.connectedCallback = n3), i3 && (e3.disconnectedCallback = i3), e3;
              } : function(e3) {
                var n3, i3, o3, r3;
                return r3 = t4(e3), o3 = r3.initialize, n3 = r3.connect, i3 = r3.disconnect, o3 && (e3.createdCallback = o3), n3 && (e3.attachedCallback = n3), i3 && (e3.detachedCallback = i3), e3;
              };
            }(), r2 = function() {
              return window.customElements ? function(t4, e3) {
                var n3;
                return n3 = function() {
                  return typeof Reflect == "object" ? Reflect.construct(HTMLElement, [], n3) : HTMLElement.apply(this);
                }, Object.setPrototypeOf(n3.prototype, HTMLElement.prototype), Object.setPrototypeOf(n3, HTMLElement), Object.defineProperties(n3.prototype, e3), window.customElements.define(t4, n3), n3;
              } : function(t4, e3) {
                var n3, i3;
                return i3 = Object.create(HTMLElement.prototype, e3), n3 = document.registerElement(t4, { prototype: i3 }), Object.defineProperty(i3, "constructor", { value: n3 }), n3;
              };
            }();
          }.call(this), function() {
            var t3, n2;
            e2.extend({ getDOMSelection: function() {
              var t4;
              return t4 = window.getSelection(), t4.rangeCount > 0 ? t4 : void 0;
            }, getDOMRange: function() {
              var n3, i2;
              return (n3 = (i2 = e2.getDOMSelection()) != null ? i2.getRangeAt(0) : void 0) && !t3(n3) ? n3 : void 0;
            }, setDOMRange: function(t4) {
              var n3;
              return n3 = window.getSelection(), n3.removeAllRanges(), n3.addRange(t4), e2.selectionChangeObserver.update();
            } }), t3 = function(t4) {
              return n2(t4.startContainer) || n2(t4.endContainer);
            }, n2 = function(t4) {
              return !Object.getPrototypeOf(t4);
            };
          }.call(this), function() {
            var t3;
            t3 = { "application/x-trix-feature-detection": "test" }, e2.extend({ dataTransferIsPlainText: function(t4) {
              var e3, n2, i2;
              return i2 = t4.getData("text/plain"), n2 = t4.getData("text/html"), i2 && n2 ? (e3 = new DOMParser().parseFromString(n2, "text/html").body, e3.textContent === i2 ? !e3.querySelector("*") : void 0) : i2 != null ? i2.length : void 0;
            }, dataTransferIsWritable: function(e3) {
              var n2, i2;
              if ((e3 != null ? e3.setData : void 0) != null) {
                for (n2 in t3)
                  if (i2 = t3[n2], !function() {
                    try {
                      return e3.setData(n2, i2), e3.getData(n2) === i2;
                    } catch (t4) {
                    }
                  }())
                    return;
                return true;
              }
            }, keyEventIsKeyboardCommand: function() {
              return /Mac|^iP/.test(navigator.platform) ? function(t4) {
                return t4.metaKey;
              } : function(t4) {
                return t4.ctrlKey;
              };
            }() });
          }.call(this), function() {
            e2.extend({ RTL_PATTERN: /[\u05BE\u05C0\u05C3\u05D0-\u05EA\u05F0-\u05F4\u061B\u061F\u0621-\u063A\u0640-\u064A\u066D\u0671-\u06B7\u06BA-\u06BE\u06C0-\u06CE\u06D0-\u06D5\u06E5\u06E6\u200F\u202B\u202E\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE72\uFE74\uFE76-\uFEFC]/, getDirection: function() {
              var t3, n2, i2, o2;
              return n2 = e2.makeElement("input", { dir: "auto", name: "x", dirName: "x.dir" }), t3 = e2.makeElement("form"), t3.appendChild(n2), i2 = function() {
                try {
                  return new FormData(t3).has(n2.dirName);
                } catch (e3) {
                }
              }(), o2 = function() {
                try {
                  return n2.matches(":dir(ltr),:dir(rtl)");
                } catch (t4) {
                }
              }(), i2 ? function(e3) {
                return n2.value = e3, new FormData(t3).get(n2.dirName);
              } : o2 ? function(t4) {
                return n2.value = t4, n2.matches(":dir(rtl)") ? "rtl" : "ltr";
              } : function(t4) {
                var n3;
                return n3 = t4.trim().charAt(0), e2.RTL_PATTERN.test(n3) ? "rtl" : "ltr";
              };
            }() });
          }.call(this), function() {
          }.call(this), function() {
            var t3, n2 = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var o2 in e3)
                i2.call(e3, o2) && (t4[o2] = e3[o2]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, i2 = {}.hasOwnProperty;
            t3 = e2.arraysAreEqual, e2.Hash = function(i3) {
              function o2(t4) {
                t4 == null && (t4 = {}), this.values = s2(t4), o2.__super__.constructor.apply(this, arguments);
              }
              var r2, s2, a2, u2, c2;
              return n2(o2, i3), o2.fromCommonAttributesOfObjects = function(t4) {
                var e3, n3, i4, o3, s3, a3;
                if (t4 == null && (t4 = []), !t4.length)
                  return new this();
                for (e3 = r2(t4[0]), i4 = e3.getKeys(), a3 = t4.slice(1), n3 = 0, o3 = a3.length; o3 > n3; n3++)
                  s3 = a3[n3], i4 = e3.getKeysCommonToHash(r2(s3)), e3 = e3.slice(i4);
                return e3;
              }, o2.box = function(t4) {
                return r2(t4);
              }, o2.prototype.add = function(t4, e3) {
                return this.merge(u2(t4, e3));
              }, o2.prototype.remove = function(t4) {
                return new e2.Hash(s2(this.values, t4));
              }, o2.prototype.get = function(t4) {
                return this.values[t4];
              }, o2.prototype.has = function(t4) {
                return t4 in this.values;
              }, o2.prototype.merge = function(t4) {
                return new e2.Hash(a2(this.values, c2(t4)));
              }, o2.prototype.slice = function(t4) {
                var n3, i4, o3, r3;
                for (r3 = {}, n3 = 0, o3 = t4.length; o3 > n3; n3++)
                  i4 = t4[n3], this.has(i4) && (r3[i4] = this.values[i4]);
                return new e2.Hash(r3);
              }, o2.prototype.getKeys = function() {
                return Object.keys(this.values);
              }, o2.prototype.getKeysCommonToHash = function(t4) {
                var e3, n3, i4, o3, s3;
                for (t4 = r2(t4), o3 = this.getKeys(), s3 = [], e3 = 0, i4 = o3.length; i4 > e3; e3++)
                  n3 = o3[e3], this.values[n3] === t4.values[n3] && s3.push(n3);
                return s3;
              }, o2.prototype.isEqualTo = function(e3) {
                return t3(this.toArray(), r2(e3).toArray());
              }, o2.prototype.isEmpty = function() {
                return this.getKeys().length === 0;
              }, o2.prototype.toArray = function() {
                var t4, e3, n3;
                return (this.array != null ? this.array : this.array = function() {
                  var i4;
                  e3 = [], i4 = this.values;
                  for (t4 in i4)
                    n3 = i4[t4], e3.push(t4, n3);
                  return e3;
                }.call(this)).slice(0);
              }, o2.prototype.toObject = function() {
                return s2(this.values);
              }, o2.prototype.toJSON = function() {
                return this.toObject();
              }, o2.prototype.contentsForInspection = function() {
                return { values: JSON.stringify(this.values) };
              }, u2 = function(t4, e3) {
                var n3;
                return n3 = {}, n3[t4] = e3, n3;
              }, a2 = function(t4, e3) {
                var n3, i4, o3;
                i4 = s2(t4);
                for (n3 in e3)
                  o3 = e3[n3], i4[n3] = o3;
                return i4;
              }, s2 = function(t4, e3) {
                var n3, i4, o3, r3, s3;
                for (r3 = {}, s3 = Object.keys(t4).sort(), n3 = 0, o3 = s3.length; o3 > n3; n3++)
                  i4 = s3[n3], i4 !== e3 && (r3[i4] = t4[i4]);
                return r3;
              }, r2 = function(t4) {
                return t4 instanceof e2.Hash ? t4 : new e2.Hash(t4);
              }, c2 = function(t4) {
                return t4 instanceof e2.Hash ? t4.values : t4;
              }, o2;
            }(e2.Object);
          }.call(this), function() {
            e2.ObjectGroup = function() {
              function t3(t4, e3) {
                var n2, i2;
                this.objects = t4 != null ? t4 : [], i2 = e3.depth, n2 = e3.asTree, n2 && (this.depth = i2, this.objects = this.constructor.groupObjects(this.objects, { asTree: n2, depth: this.depth + 1 }));
              }
              return t3.groupObjects = function(t4, e3) {
                var n2, i2, o2, r2, s2, a2, u2, c2, l2;
                for (t4 == null && (t4 = []), l2 = e3 != null ? e3 : {}, o2 = l2.depth, n2 = l2.asTree, n2 && o2 == null && (o2 = 0), c2 = [], s2 = 0, a2 = t4.length; a2 > s2; s2++) {
                  if (u2 = t4[s2], r2) {
                    if ((typeof u2.canBeGrouped == "function" ? u2.canBeGrouped(o2) : void 0) && (typeof (i2 = r2[r2.length - 1]).canBeGroupedWith == "function" ? i2.canBeGroupedWith(u2, o2) : void 0)) {
                      r2.push(u2);
                      continue;
                    }
                    c2.push(new this(r2, { depth: o2, asTree: n2 })), r2 = null;
                  }
                  (typeof u2.canBeGrouped == "function" ? u2.canBeGrouped(o2) : void 0) ? r2 = [u2] : c2.push(u2);
                }
                return r2 && c2.push(new this(r2, { depth: o2, asTree: n2 })), c2;
              }, t3.prototype.getObjects = function() {
                return this.objects;
              }, t3.prototype.getDepth = function() {
                return this.depth;
              }, t3.prototype.getCacheKey = function() {
                var t4, e3, n2, i2, o2;
                for (e3 = ["objectGroup"], o2 = this.getObjects(), t4 = 0, n2 = o2.length; n2 > t4; t4++)
                  i2 = o2[t4], e3.push(i2.getCacheKey());
                return e3.join("/");
              }, t3;
            }();
          }.call(this), function() {
            var t3 = function(t4, e3) {
              function i2() {
                this.constructor = t4;
              }
              for (var o2 in e3)
                n2.call(e3, o2) && (t4[o2] = e3[o2]);
              return i2.prototype = e3.prototype, t4.prototype = new i2(), t4.__super__ = e3.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e2.ObjectMap = function(e3) {
              function n3(t4) {
                var e4, n4, i2, o2, r2;
                for (t4 == null && (t4 = []), this.objects = {}, i2 = 0, o2 = t4.length; o2 > i2; i2++)
                  r2 = t4[i2], n4 = JSON.stringify(r2), (e4 = this.objects)[n4] == null && (e4[n4] = r2);
              }
              return t3(n3, e3), n3.prototype.find = function(t4) {
                var e4;
                return e4 = JSON.stringify(t4), this.objects[e4];
              }, n3;
            }(e2.BasicObject);
          }.call(this), function() {
            e2.ElementStore = function() {
              function t3(t4) {
                this.reset(t4);
              }
              var e3;
              return t3.prototype.add = function(t4) {
                var n2;
                return n2 = e3(t4), this.elements[n2] = t4;
              }, t3.prototype.remove = function(t4) {
                var n2, i2;
                return n2 = e3(t4), (i2 = this.elements[n2]) ? (delete this.elements[n2], i2) : void 0;
              }, t3.prototype.reset = function(t4) {
                var e4, n2, i2;
                for (t4 == null && (t4 = []), this.elements = {}, n2 = 0, i2 = t4.length; i2 > n2; n2++)
                  e4 = t4[n2], this.add(e4);
                return t4;
              }, e3 = function(t4) {
                return t4.dataset.trixStoreKey;
              }, t3;
            }();
          }.call(this), function() {
          }.call(this), function() {
            var t3 = function(t4, e3) {
              function i2() {
                this.constructor = t4;
              }
              for (var o2 in e3)
                n2.call(e3, o2) && (t4[o2] = e3[o2]);
              return i2.prototype = e3.prototype, t4.prototype = new i2(), t4.__super__ = e3.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e2.Operation = function(e3) {
              function n3() {
                return n3.__super__.constructor.apply(this, arguments);
              }
              return t3(n3, e3), n3.prototype.isPerforming = function() {
                return this.performing === true;
              }, n3.prototype.hasPerformed = function() {
                return this.performed === true;
              }, n3.prototype.hasSucceeded = function() {
                return this.performed && this.succeeded;
              }, n3.prototype.hasFailed = function() {
                return this.performed && !this.succeeded;
              }, n3.prototype.getPromise = function() {
                return this.promise != null ? this.promise : this.promise = new Promise(function(t4) {
                  return function(e4, n4) {
                    return t4.performing = true, t4.perform(function(i2, o2) {
                      return t4.succeeded = i2, t4.performing = false, t4.performed = true, t4.succeeded ? e4(o2) : n4(o2);
                    });
                  };
                }(this));
              }, n3.prototype.perform = function(t4) {
                return t4(false);
              }, n3.prototype.release = function() {
                var t4;
                return (t4 = this.promise) != null && typeof t4.cancel == "function" && t4.cancel(), this.promise = null, this.performing = null, this.performed = null, this.succeeded = null;
              }, n3.proxyMethod("getPromise().then"), n3.proxyMethod("getPromise().catch"), n3;
            }(e2.BasicObject);
          }.call(this), function() {
            var t3, n2, i2, o2, r2, s2 = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var i3 in e3)
                a2.call(e3, i3) && (t4[i3] = e3[i3]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, a2 = {}.hasOwnProperty;
            e2.UTF16String = function(t4) {
              function e3(t5, e4) {
                this.ucs2String = t5, this.codepoints = e4, this.length = this.codepoints.length, this.ucs2Length = this.ucs2String.length;
              }
              return s2(e3, t4), e3.box = function(t5) {
                return t5 == null && (t5 = ""), t5 instanceof this ? t5 : this.fromUCS2String(t5 != null ? t5.toString() : void 0);
              }, e3.fromUCS2String = function(t5) {
                return new this(t5, o2(t5));
              }, e3.fromCodepoints = function(t5) {
                return new this(r2(t5), t5);
              }, e3.prototype.offsetToUCS2Offset = function(t5) {
                return r2(this.codepoints.slice(0, Math.max(0, t5))).length;
              }, e3.prototype.offsetFromUCS2Offset = function(t5) {
                return o2(this.ucs2String.slice(0, Math.max(0, t5))).length;
              }, e3.prototype.slice = function() {
                var t5;
                return this.constructor.fromCodepoints((t5 = this.codepoints).slice.apply(t5, arguments));
              }, e3.prototype.charAt = function(t5) {
                return this.slice(t5, t5 + 1);
              }, e3.prototype.isEqualTo = function(t5) {
                return this.constructor.box(t5).ucs2String === this.ucs2String;
              }, e3.prototype.toJSON = function() {
                return this.ucs2String;
              }, e3.prototype.getCacheKey = function() {
                return this.ucs2String;
              }, e3.prototype.toString = function() {
                return this.ucs2String;
              }, e3;
            }(e2.BasicObject), t3 = (typeof Array.from == "function" ? Array.from("\u{1F47C}").length : void 0) === 1, n2 = (typeof " ".codePointAt == "function" ? " ".codePointAt(0) : void 0) != null, i2 = (typeof String.fromCodePoint == "function" ? String.fromCodePoint(32, 128124) : void 0) === " \u{1F47C}", o2 = t3 && n2 ? function(t4) {
              return Array.from(t4).map(function(t5) {
                return t5.codePointAt(0);
              });
            } : function(t4) {
              var e3, n3, i3, o3, r3;
              for (o3 = [], e3 = 0, i3 = t4.length; i3 > e3; )
                r3 = t4.charCodeAt(e3++), r3 >= 55296 && 56319 >= r3 && i3 > e3 && (n3 = t4.charCodeAt(e3++), (64512 & n3) === 56320 ? r3 = ((1023 & r3) << 10) + (1023 & n3) + 65536 : e3--), o3.push(r3);
              return o3;
            }, r2 = i2 ? function(t4) {
              return String.fromCodePoint.apply(String, t4);
            } : function(t4) {
              var e3, n3, i3;
              return e3 = function() {
                var e4, o3, r3;
                for (r3 = [], e4 = 0, o3 = t4.length; o3 > e4; e4++)
                  i3 = t4[e4], n3 = "", i3 > 65535 && (i3 -= 65536, n3 += String.fromCharCode(i3 >>> 10 & 1023 | 55296), i3 = 56320 | 1023 & i3), r3.push(n3 + String.fromCharCode(i3));
                return r3;
              }(), e3.join("");
            };
          }.call(this), function() {
          }.call(this), function() {
          }.call(this), function() {
            e2.config.lang = { attachFiles: "Attach Files", bold: "Bold", bullets: "Bullets", "byte": "Byte", bytes: "Bytes", captionPlaceholder: "Add a caption\u2026", code: "Code", heading1: "Heading", indent: "Increase Level", italic: "Italic", link: "Link", numbers: "Numbers", outdent: "Decrease Level", quote: "Quote", redo: "Redo", remove: "Remove", strike: "Strikethrough", undo: "Undo", unlink: "Unlink", url: "URL", urlPlaceholder: "Enter a URL\u2026", GB: "GB", KB: "KB", MB: "MB", PB: "PB", TB: "TB" };
          }.call(this), function() {
            e2.config.css = { attachment: "attachment", attachmentCaption: "attachment__caption", attachmentCaptionEditor: "attachment__caption-editor", attachmentMetadata: "attachment__metadata", attachmentMetadataContainer: "attachment__metadata-container", attachmentName: "attachment__name", attachmentProgress: "attachment__progress", attachmentSize: "attachment__size", attachmentToolbar: "attachment__toolbar", attachmentGallery: "attachment-gallery" };
          }.call(this), function() {
            var t3;
            e2.config.blockAttributes = t3 = { "default": { tagName: "div", parse: false }, quote: { tagName: "blockquote", nestable: true }, heading1: { tagName: "h1", terminal: true, breakOnReturn: true, group: false }, code: { tagName: "pre", terminal: true, text: { plaintext: true } }, bulletList: { tagName: "ul", parse: false }, bullet: { tagName: "li", listAttribute: "bulletList", group: false, nestable: true, test: function(n2) {
              return e2.tagName(n2.parentNode) === t3[this.listAttribute].tagName;
            } }, numberList: { tagName: "ol", parse: false }, number: { tagName: "li", listAttribute: "numberList", group: false, nestable: true, test: function(n2) {
              return e2.tagName(n2.parentNode) === t3[this.listAttribute].tagName;
            } }, attachmentGallery: { tagName: "div", exclusive: true, terminal: true, parse: false, group: false } };
          }.call(this), function() {
            var t3, n2;
            t3 = e2.config.lang, n2 = [t3.bytes, t3.KB, t3.MB, t3.GB, t3.TB, t3.PB], e2.config.fileSize = { prefix: "IEC", precision: 2, formatter: function(e3) {
              var i2, o2, r2, s2, a2;
              switch (e3) {
                case 0:
                  return "0 " + t3.bytes;
                case 1:
                  return "1 " + t3.byte;
                default:
                  return i2 = function() {
                    switch (this.prefix) {
                      case "SI":
                        return 1e3;
                      case "IEC":
                        return 1024;
                    }
                  }.call(this), o2 = Math.floor(Math.log(e3) / Math.log(i2)), r2 = e3 / Math.pow(i2, o2), s2 = r2.toFixed(this.precision), a2 = s2.replace(/0*$/, "").replace(/\.$/, ""), a2 + " " + n2[o2];
              }
            } };
          }.call(this), function() {
            e2.config.textAttributes = { bold: { tagName: "strong", inheritable: true, parser: function(t3) {
              var e3;
              return e3 = window.getComputedStyle(t3), e3.fontWeight === "bold" || e3.fontWeight >= 600;
            } }, italic: { tagName: "em", inheritable: true, parser: function(t3) {
              var e3;
              return e3 = window.getComputedStyle(t3), e3.fontStyle === "italic";
            } }, href: { groupTagName: "a", parser: function(t3) {
              var n2, i2, o2;
              return n2 = e2.AttachmentView.attachmentSelector, o2 = "a:not(" + n2 + ")", (i2 = e2.findClosestElementFromNode(t3, { matchingSelector: o2 })) ? i2.getAttribute("href") : void 0;
            } }, strike: { tagName: "del", inheritable: true }, frozen: { style: { backgroundColor: "highlight" } } };
          }.call(this), function() {
            var t3, n2, i2, o2, r2;
            r2 = "[data-trix-serialize=false]", o2 = ["contenteditable", "data-trix-id", "data-trix-store-key", "data-trix-mutable", "data-trix-placeholder", "tabindex"], n2 = "data-trix-serialized-attributes", i2 = "[" + n2 + "]", t3 = new RegExp("<!--block-->", "g"), e2.extend({ serializers: { "application/json": function(t4) {
              var n3;
              if (t4 instanceof e2.Document)
                n3 = t4;
              else {
                if (!(t4 instanceof HTMLElement))
                  throw new Error("unserializable object");
                n3 = e2.Document.fromHTML(t4.innerHTML);
              }
              return n3.toSerializableDocument().toJSONString();
            }, "text/html": function(s2) {
              var a2, u2, c2, l2, h, p2, d2, f2, g2, m2, v2, y2, b2, A2, C2, x2, w;
              if (s2 instanceof e2.Document)
                l2 = e2.DocumentView.render(s2);
              else {
                if (!(s2 instanceof HTMLElement))
                  throw new Error("unserializable object");
                l2 = s2.cloneNode(true);
              }
              for (A2 = l2.querySelectorAll(r2), h = 0, g2 = A2.length; g2 > h; h++)
                c2 = A2[h], e2.removeNode(c2);
              for (p2 = 0, m2 = o2.length; m2 > p2; p2++)
                for (a2 = o2[p2], C2 = l2.querySelectorAll("[" + a2 + "]"), d2 = 0, v2 = C2.length; v2 > d2; d2++)
                  c2 = C2[d2], c2.removeAttribute(a2);
              for (x2 = l2.querySelectorAll(i2), f2 = 0, y2 = x2.length; y2 > f2; f2++) {
                c2 = x2[f2];
                try {
                  u2 = JSON.parse(c2.getAttribute(n2)), c2.removeAttribute(n2);
                  for (b2 in u2)
                    w = u2[b2], c2.setAttribute(b2, w);
                } catch (E) {
                }
              }
              return l2.innerHTML.replace(t3, "");
            } }, deserializers: { "application/json": function(t4) {
              return e2.Document.fromJSONString(t4);
            }, "text/html": function(t4) {
              return e2.Document.fromHTML(t4);
            } }, serializeToContentType: function(t4, n3) {
              var i3;
              if (i3 = e2.serializers[n3])
                return i3(t4);
              throw new Error("unknown content type: " + n3);
            }, deserializeFromContentType: function(t4, n3) {
              var i3;
              if (i3 = e2.deserializers[n3])
                return i3(t4);
              throw new Error("unknown content type: " + n3);
            } });
          }.call(this), function() {
            var t3;
            t3 = e2.config.lang, e2.config.toolbar = { getDefaultHTML: function() {
              return '<div class="trix-button-row">\n  <span class="trix-button-group trix-button-group--text-tools" data-trix-button-group="text-tools">\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-bold" data-trix-attribute="bold" data-trix-key="b" title="' + t3.bold + '" tabindex="-1">' + t3.bold + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-italic" data-trix-attribute="italic" data-trix-key="i" title="' + t3.italic + '" tabindex="-1">' + t3.italic + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-strike" data-trix-attribute="strike" title="' + t3.strike + '" tabindex="-1">' + t3.strike + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-link" data-trix-attribute="href" data-trix-action="link" data-trix-key="k" title="' + t3.link + '" tabindex="-1">' + t3.link + '</button>\n  </span>\n\n  <span class="trix-button-group trix-button-group--block-tools" data-trix-button-group="block-tools">\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-heading-1" data-trix-attribute="heading1" title="' + t3.heading1 + '" tabindex="-1">' + t3.heading1 + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-quote" data-trix-attribute="quote" title="' + t3.quote + '" tabindex="-1">' + t3.quote + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-code" data-trix-attribute="code" title="' + t3.code + '" tabindex="-1">' + t3.code + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-bullet-list" data-trix-attribute="bullet" title="' + t3.bullets + '" tabindex="-1">' + t3.bullets + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-number-list" data-trix-attribute="number" title="' + t3.numbers + '" tabindex="-1">' + t3.numbers + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-decrease-nesting-level" data-trix-action="decreaseNestingLevel" title="' + t3.outdent + '" tabindex="-1">' + t3.outdent + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-increase-nesting-level" data-trix-action="increaseNestingLevel" title="' + t3.indent + '" tabindex="-1">' + t3.indent + '</button>\n  </span>\n\n  <span class="trix-button-group trix-button-group--file-tools" data-trix-button-group="file-tools">\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-attach" data-trix-action="attachFiles" title="' + t3.attachFiles + '" tabindex="-1">' + t3.attachFiles + '</button>\n  </span>\n\n  <span class="trix-button-group-spacer"></span>\n\n  <span class="trix-button-group trix-button-group--history-tools" data-trix-button-group="history-tools">\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-undo" data-trix-action="undo" data-trix-key="z" title="' + t3.undo + '" tabindex="-1">' + t3.undo + '</button>\n    <button type="button" class="trix-button trix-button--icon trix-button--icon-redo" data-trix-action="redo" data-trix-key="shift+z" title="' + t3.redo + '" tabindex="-1">' + t3.redo + '</button>\n  </span>\n</div>\n\n<div class="trix-dialogs" data-trix-dialogs>\n  <div class="trix-dialog trix-dialog--link" data-trix-dialog="href" data-trix-dialog-attribute="href">\n    <div class="trix-dialog__link-fields">\n      <input type="url" name="href" class="trix-input trix-input--dialog" placeholder="' + t3.urlPlaceholder + '" aria-label="' + t3.url + '" required data-trix-input>\n      <div class="trix-button-group">\n        <input type="button" class="trix-button trix-button--dialog" value="' + t3.link + '" data-trix-method="setAttribute">\n        <input type="button" class="trix-button trix-button--dialog" value="' + t3.unlink + '" data-trix-method="removeAttribute">\n      </div>\n    </div>\n  </div>\n</div>';
            } };
          }.call(this), function() {
            e2.config.undoInterval = 5e3;
          }.call(this), function() {
            e2.config.attachments = { preview: { presentation: "gallery", caption: { name: true, size: true } }, file: { caption: { size: true } } };
          }.call(this), function() {
            e2.config.keyNames = { 8: "backspace", 9: "tab", 13: "return", 27: "escape", 37: "left", 39: "right", 46: "delete", 68: "d", 72: "h", 79: "o" };
          }.call(this), function() {
            e2.config.input = { level2Enabled: true, getLevel: function() {
              return this.level2Enabled && e2.browser.supportsInputEvents ? 2 : 0;
            }, pickFiles: function(t3) {
              var n2;
              return n2 = e2.makeElement("input", { type: "file", multiple: true, hidden: true, id: this.fileInputId }), n2.addEventListener("change", function() {
                return t3(n2.files), e2.removeNode(n2);
              }), e2.removeNode(document.getElementById(this.fileInputId)), document.body.appendChild(n2), n2.click();
            }, fileInputId: "trix-file-input-" + Date.now().toString(16) };
          }.call(this), function() {
          }.call(this), function() {
            e2.registerElement("trix-toolbar", { defaultCSS: "%t {\n  display: block;\n}\n\n%t {\n  white-space: nowrap;\n}\n\n%t [data-trix-dialog] {\n  display: none;\n}\n\n%t [data-trix-dialog][data-trix-active] {\n  display: block;\n}\n\n%t [data-trix-dialog] [data-trix-validate]:invalid {\n  background-color: #ffdddd;\n}", initialize: function() {
              return this.innerHTML === "" ? this.innerHTML = e2.config.toolbar.getDefaultHTML() : void 0;
            } });
          }.call(this), function() {
            var t3 = function(t4, e3) {
              function i3() {
                this.constructor = t4;
              }
              for (var o2 in e3)
                n2.call(e3, o2) && (t4[o2] = e3[o2]);
              return i3.prototype = e3.prototype, t4.prototype = new i3(), t4.__super__ = e3.prototype, t4;
            }, n2 = {}.hasOwnProperty, i2 = [].indexOf || function(t4) {
              for (var e3 = 0, n3 = this.length; n3 > e3; e3++)
                if (e3 in this && this[e3] === t4)
                  return e3;
              return -1;
            };
            e2.ObjectView = function(n3) {
              function o2(t4, e3) {
                this.object = t4, this.options = e3 != null ? e3 : {}, this.childViews = [], this.rootView = this;
              }
              return t3(o2, n3), o2.prototype.getNodes = function() {
                var t4, e3, n4, i3, o3;
                for (this.nodes == null && (this.nodes = this.createNodes()), i3 = this.nodes, o3 = [], t4 = 0, e3 = i3.length; e3 > t4; t4++)
                  n4 = i3[t4], o3.push(n4.cloneNode(true));
                return o3;
              }, o2.prototype.invalidate = function() {
                var t4;
                return this.nodes = null, this.childViews = [], (t4 = this.parentView) != null ? t4.invalidate() : void 0;
              }, o2.prototype.invalidateViewForObject = function(t4) {
                var e3;
                return (e3 = this.findViewForObject(t4)) != null ? e3.invalidate() : void 0;
              }, o2.prototype.findOrCreateCachedChildView = function(t4, e3) {
                var n4;
                return (n4 = this.getCachedViewForObject(e3)) ? this.recordChildView(n4) : (n4 = this.createChildView.apply(this, arguments), this.cacheViewForObject(n4, e3)), n4;
              }, o2.prototype.createChildView = function(t4, n4, i3) {
                var o3;
                return i3 == null && (i3 = {}), n4 instanceof e2.ObjectGroup && (i3.viewClass = t4, t4 = e2.ObjectGroupView), o3 = new t4(n4, i3), this.recordChildView(o3);
              }, o2.prototype.recordChildView = function(t4) {
                return t4.parentView = this, t4.rootView = this.rootView, this.childViews.push(t4), t4;
              }, o2.prototype.getAllChildViews = function() {
                var t4, e3, n4, i3, o3;
                for (o3 = [], i3 = this.childViews, e3 = 0, n4 = i3.length; n4 > e3; e3++)
                  t4 = i3[e3], o3.push(t4), o3 = o3.concat(t4.getAllChildViews());
                return o3;
              }, o2.prototype.findElement = function() {
                return this.findElementForObject(this.object);
              }, o2.prototype.findElementForObject = function(t4) {
                var e3;
                return (e3 = t4 != null ? t4.id : void 0) ? this.rootView.element.querySelector("[data-trix-id='" + e3 + "']") : void 0;
              }, o2.prototype.findViewForObject = function(t4) {
                var e3, n4, i3, o3;
                for (i3 = this.getAllChildViews(), e3 = 0, n4 = i3.length; n4 > e3; e3++)
                  if (o3 = i3[e3], o3.object === t4)
                    return o3;
              }, o2.prototype.getViewCache = function() {
                return this.rootView !== this ? this.rootView.getViewCache() : this.isViewCachingEnabled() ? this.viewCache != null ? this.viewCache : this.viewCache = {} : void 0;
              }, o2.prototype.isViewCachingEnabled = function() {
                return this.shouldCacheViews !== false;
              }, o2.prototype.enableViewCaching = function() {
                return this.shouldCacheViews = true;
              }, o2.prototype.disableViewCaching = function() {
                return this.shouldCacheViews = false;
              }, o2.prototype.getCachedViewForObject = function(t4) {
                var e3;
                return (e3 = this.getViewCache()) != null ? e3[t4.getCacheKey()] : void 0;
              }, o2.prototype.cacheViewForObject = function(t4, e3) {
                var n4;
                return (n4 = this.getViewCache()) != null ? n4[e3.getCacheKey()] = t4 : void 0;
              }, o2.prototype.garbageCollectCachedViews = function() {
                var t4, e3, n4, o3, r2, s2;
                if (t4 = this.getViewCache()) {
                  s2 = this.getAllChildViews().concat(this), n4 = function() {
                    var t5, e4, n5;
                    for (n5 = [], t5 = 0, e4 = s2.length; e4 > t5; t5++)
                      r2 = s2[t5], n5.push(r2.object.getCacheKey());
                    return n5;
                  }(), o3 = [];
                  for (e3 in t4)
                    i2.call(n4, e3) < 0 && o3.push(delete t4[e3]);
                  return o3;
                }
              }, o2;
            }(e2.BasicObject);
          }.call(this), function() {
            var t3 = function(t4, e3) {
              function i2() {
                this.constructor = t4;
              }
              for (var o2 in e3)
                n2.call(e3, o2) && (t4[o2] = e3[o2]);
              return i2.prototype = e3.prototype, t4.prototype = new i2(), t4.__super__ = e3.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e2.ObjectGroupView = function(e3) {
              function n3() {
                n3.__super__.constructor.apply(this, arguments), this.objectGroup = this.object, this.viewClass = this.options.viewClass, delete this.options.viewClass;
              }
              return t3(n3, e3), n3.prototype.getChildViews = function() {
                var t4, e4, n4, i2;
                if (!this.childViews.length)
                  for (i2 = this.objectGroup.getObjects(), t4 = 0, e4 = i2.length; e4 > t4; t4++)
                    n4 = i2[t4], this.findOrCreateCachedChildView(this.viewClass, n4, this.options);
                return this.childViews;
              }, n3.prototype.createNodes = function() {
                var t4, e4, n4, i2, o2, r2, s2, a2, u2;
                for (t4 = this.createContainerElement(), s2 = this.getChildViews(), e4 = 0, i2 = s2.length; i2 > e4; e4++)
                  for (u2 = s2[e4], a2 = u2.getNodes(), n4 = 0, o2 = a2.length; o2 > n4; n4++)
                    r2 = a2[n4], t4.appendChild(r2);
                return [t4];
              }, n3.prototype.createContainerElement = function(t4) {
                return t4 == null && (t4 = this.objectGroup.getDepth()), this.getChildViews()[0].createContainerElement(t4);
              }, n3;
            }(e2.ObjectView);
          }.call(this), function() {
            var t3 = function(t4, e3) {
              function i2() {
                this.constructor = t4;
              }
              for (var o2 in e3)
                n2.call(e3, o2) && (t4[o2] = e3[o2]);
              return i2.prototype = e3.prototype, t4.prototype = new i2(), t4.__super__ = e3.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e2.Controller = function(e3) {
              function n3() {
                return n3.__super__.constructor.apply(this, arguments);
              }
              return t3(n3, e3), n3;
            }(e2.BasicObject);
          }.call(this), function() {
            var t3, n2, i2, o2, r2, s2, a2 = function(t4, e3) {
              return function() {
                return t4.apply(e3, arguments);
              };
            }, u2 = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var i3 in e3)
                c2.call(e3, i3) && (t4[i3] = e3[i3]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, c2 = {}.hasOwnProperty, l2 = [].indexOf || function(t4) {
              for (var e3 = 0, n3 = this.length; n3 > e3; e3++)
                if (e3 in this && this[e3] === t4)
                  return e3;
              return -1;
            };
            t3 = e2.findClosestElementFromNode, i2 = e2.nodeIsEmptyTextNode, n2 = e2.nodeIsBlockStartComment, o2 = e2.normalizeSpaces, r2 = e2.summarizeStringChange, s2 = e2.tagName, e2.MutationObserver = function(e3) {
              function c3(t4) {
                this.element = t4, this.didMutate = a2(this.didMutate, this), this.observer = new window.MutationObserver(this.didMutate), this.start();
              }
              var h, p2, d2, f2;
              return u2(c3, e3), p2 = "data-trix-mutable", d2 = "[" + p2 + "]", f2 = { attributes: true, childList: true, characterData: true, characterDataOldValue: true, subtree: true }, c3.prototype.start = function() {
                return this.reset(), this.observer.observe(this.element, f2);
              }, c3.prototype.stop = function() {
                return this.observer.disconnect();
              }, c3.prototype.didMutate = function(t4) {
                var e4, n3;
                return (e4 = this.mutations).push.apply(e4, this.findSignificantMutations(t4)), this.mutations.length ? ((n3 = this.delegate) != null && typeof n3.elementDidMutate == "function" && n3.elementDidMutate(this.getMutationSummary()), this.reset()) : void 0;
              }, c3.prototype.reset = function() {
                return this.mutations = [];
              }, c3.prototype.findSignificantMutations = function(t4) {
                var e4, n3, i3, o3;
                for (o3 = [], e4 = 0, n3 = t4.length; n3 > e4; e4++)
                  i3 = t4[e4], this.mutationIsSignificant(i3) && o3.push(i3);
                return o3;
              }, c3.prototype.mutationIsSignificant = function(t4) {
                var e4, n3, i3, o3;
                if (this.nodeIsMutable(t4.target))
                  return false;
                for (o3 = this.nodesModifiedByMutation(t4), e4 = 0, n3 = o3.length; n3 > e4; e4++)
                  if (i3 = o3[e4], this.nodeIsSignificant(i3))
                    return true;
                return false;
              }, c3.prototype.nodeIsSignificant = function(t4) {
                return t4 !== this.element && !this.nodeIsMutable(t4) && !i2(t4);
              }, c3.prototype.nodeIsMutable = function(e4) {
                return t3(e4, { matchingSelector: d2 });
              }, c3.prototype.nodesModifiedByMutation = function(t4) {
                var e4;
                switch (e4 = [], t4.type) {
                  case "attributes":
                    t4.attributeName !== p2 && e4.push(t4.target);
                    break;
                  case "characterData":
                    e4.push(t4.target.parentNode), e4.push(t4.target);
                    break;
                  case "childList":
                    e4.push.apply(e4, t4.addedNodes), e4.push.apply(e4, t4.removedNodes);
                }
                return e4;
              }, c3.prototype.getMutationSummary = function() {
                return this.getTextMutationSummary();
              }, c3.prototype.getTextMutationSummary = function() {
                var t4, e4, n3, i3, o3, r3, s3, a3, u3, c4, h2;
                for (a3 = this.getTextChangesFromCharacterData(), n3 = a3.additions, o3 = a3.deletions, h2 = this.getTextChangesFromChildList(), u3 = h2.additions, r3 = 0, s3 = u3.length; s3 > r3; r3++)
                  e4 = u3[r3], l2.call(n3, e4) < 0 && n3.push(e4);
                return o3.push.apply(o3, h2.deletions), c4 = {}, (t4 = n3.join("")) && (c4.textAdded = t4), (i3 = o3.join("")) && (c4.textDeleted = i3), c4;
              }, c3.prototype.getMutationsByType = function(t4) {
                var e4, n3, i3, o3, r3;
                for (o3 = this.mutations, r3 = [], e4 = 0, n3 = o3.length; n3 > e4; e4++)
                  i3 = o3[e4], i3.type === t4 && r3.push(i3);
                return r3;
              }, c3.prototype.getTextChangesFromChildList = function() {
                var t4, e4, i3, r3, s3, a3, u3, c4, l3, p3, d3;
                for (t4 = [], u3 = [], a3 = this.getMutationsByType("childList"), e4 = 0, r3 = a3.length; r3 > e4; e4++)
                  s3 = a3[e4], t4.push.apply(t4, s3.addedNodes), u3.push.apply(u3, s3.removedNodes);
                return c4 = t4.length === 0 && u3.length === 1 && n2(u3[0]), c4 ? (p3 = [], d3 = ["\n"]) : (p3 = h(t4), d3 = h(u3)), { additions: function() {
                  var t5, e5, n3;
                  for (n3 = [], i3 = t5 = 0, e5 = p3.length; e5 > t5; i3 = ++t5)
                    l3 = p3[i3], l3 !== d3[i3] && n3.push(o2(l3));
                  return n3;
                }(), deletions: function() {
                  var t5, e5, n3;
                  for (n3 = [], i3 = t5 = 0, e5 = d3.length; e5 > t5; i3 = ++t5)
                    l3 = d3[i3], l3 !== p3[i3] && n3.push(o2(l3));
                  return n3;
                }() };
              }, c3.prototype.getTextChangesFromCharacterData = function() {
                var t4, e4, n3, i3, s3, a3, u3, c4;
                return e4 = this.getMutationsByType("characterData"), e4.length && (c4 = e4[0], n3 = e4[e4.length - 1], s3 = o2(c4.oldValue), i3 = o2(n3.target.data), a3 = r2(s3, i3), t4 = a3.added, u3 = a3.removed), { additions: t4 ? [t4] : [], deletions: u3 ? [u3] : [] };
              }, h = function(t4) {
                var e4, n3, i3, o3;
                for (t4 == null && (t4 = []), o3 = [], e4 = 0, n3 = t4.length; n3 > e4; e4++)
                  switch (i3 = t4[e4], i3.nodeType) {
                    case Node.TEXT_NODE:
                      o3.push(i3.data);
                      break;
                    case Node.ELEMENT_NODE:
                      s2(i3) === "br" ? o3.push("\n") : o3.push.apply(o3, h(i3.childNodes));
                  }
                return o3;
              }, c3;
            }(e2.BasicObject);
          }.call(this), function() {
            var t3 = function(t4, e3) {
              function i2() {
                this.constructor = t4;
              }
              for (var o2 in e3)
                n2.call(e3, o2) && (t4[o2] = e3[o2]);
              return i2.prototype = e3.prototype, t4.prototype = new i2(), t4.__super__ = e3.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e2.FileVerificationOperation = function(e3) {
              function n3(t4) {
                this.file = t4;
              }
              return t3(n3, e3), n3.prototype.perform = function(t4) {
                var e4;
                return e4 = new FileReader(), e4.onerror = function() {
                  return t4(false);
                }, e4.onload = function(n4) {
                  return function() {
                    e4.onerror = null;
                    try {
                      e4.abort();
                    } catch (i2) {
                    }
                    return t4(true, n4.file);
                  };
                }(this), e4.readAsArrayBuffer(this.file);
              }, n3;
            }(e2.Operation);
          }.call(this), function() {
            var t3, n2, i2 = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var i3 in e3)
                o2.call(e3, i3) && (t4[i3] = e3[i3]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, o2 = {}.hasOwnProperty;
            t3 = e2.handleEvent, n2 = e2.innerElementIsActive, e2.InputController = function(o3) {
              function r2(n3) {
                var i3;
                this.element = n3, this.mutationObserver = new e2.MutationObserver(this.element), this.mutationObserver.delegate = this;
                for (i3 in this.events)
                  t3(i3, { onElement: this.element, withCallback: this.handlerFor(i3) });
              }
              return i2(r2, o3), r2.prototype.events = {}, r2.prototype.elementDidMutate = function() {
              }, r2.prototype.editorWillSyncDocumentView = function() {
                return this.mutationObserver.stop();
              }, r2.prototype.editorDidSyncDocumentView = function() {
                return this.mutationObserver.start();
              }, r2.prototype.requestRender = function() {
                var t4;
                return (t4 = this.delegate) != null && typeof t4.inputControllerDidRequestRender == "function" ? t4.inputControllerDidRequestRender() : void 0;
              }, r2.prototype.requestReparse = function() {
                var t4;
                return (t4 = this.delegate) != null && typeof t4.inputControllerDidRequestReparse == "function" && t4.inputControllerDidRequestReparse(), this.requestRender();
              }, r2.prototype.attachFiles = function(t4) {
                var n3, i3;
                return i3 = function() {
                  var i4, o4, r3;
                  for (r3 = [], i4 = 0, o4 = t4.length; o4 > i4; i4++)
                    n3 = t4[i4], r3.push(new e2.FileVerificationOperation(n3));
                  return r3;
                }(), Promise.all(i3).then(function(t5) {
                  return function(e3) {
                    return t5.handleInput(function() {
                      var t6, n4;
                      return (t6 = this.delegate) != null && t6.inputControllerWillAttachFiles(), (n4 = this.responder) != null && n4.insertFiles(e3), this.requestRender();
                    });
                  };
                }(this));
              }, r2.prototype.handlerFor = function(t4) {
                return function(e3) {
                  return function(i3) {
                    return i3.defaultPrevented ? void 0 : e3.handleInput(function() {
                      return n2(this.element) ? void 0 : (this.eventName = t4, this.events[t4].call(this, i3));
                    });
                  };
                }(this);
              }, r2.prototype.handleInput = function(t4) {
                var e3, n3;
                try {
                  return (e3 = this.delegate) != null && e3.inputControllerWillHandleInput(), t4.call(this);
                } finally {
                  (n3 = this.delegate) != null && n3.inputControllerDidHandleInput();
                }
              }, r2.prototype.createLinkHTML = function(t4, e3) {
                var n3;
                return n3 = document.createElement("a"), n3.href = t4, n3.textContent = e3 != null ? e3 : t4, n3.outerHTML;
              }, r2;
            }(e2.BasicObject);
          }.call(this), function() {
            var t3, n2, i2, o2, r2, s2, a2, u2, c2, l2, h, p2, d2, f2 = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var i3 in e3)
                g2.call(e3, i3) && (t4[i3] = e3[i3]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, g2 = {}.hasOwnProperty, m2 = [].indexOf || function(t4) {
              for (var e3 = 0, n3 = this.length; n3 > e3; e3++)
                if (e3 in this && this[e3] === t4)
                  return e3;
              return -1;
            };
            c2 = e2.makeElement, l2 = e2.objectsAreEqual, d2 = e2.tagName, n2 = e2.browser, a2 = e2.keyEventIsKeyboardCommand, o2 = e2.dataTransferIsWritable, i2 = e2.dataTransferIsPlainText, u2 = e2.config.keyNames, e2.Level0InputController = function(n3) {
              function s3() {
                s3.__super__.constructor.apply(this, arguments), this.resetInputSummary();
              }
              var d3;
              return f2(s3, n3), d3 = 0, s3.prototype.setInputSummary = function(t4) {
                var e3, n4;
                t4 == null && (t4 = {}), this.inputSummary.eventName = this.eventName;
                for (e3 in t4)
                  n4 = t4[e3], this.inputSummary[e3] = n4;
                return this.inputSummary;
              }, s3.prototype.resetInputSummary = function() {
                return this.inputSummary = {};
              }, s3.prototype.reset = function() {
                return this.resetInputSummary(), e2.selectionChangeObserver.reset();
              }, s3.prototype.elementDidMutate = function(t4) {
                var e3;
                return this.isComposing() ? (e3 = this.delegate) != null && typeof e3.inputControllerDidAllowUnhandledInput == "function" ? e3.inputControllerDidAllowUnhandledInput() : void 0 : this.handleInput(function() {
                  return this.mutationIsSignificant(t4) && (this.mutationIsExpected(t4) ? this.requestRender() : this.requestReparse()), this.reset();
                });
              }, s3.prototype.mutationIsExpected = function(t4) {
                var e3, n4, i3, o3, r3, s4, a3, u3, c3, l3;
                return a3 = t4.textAdded, u3 = t4.textDeleted, this.inputSummary.preferDocument ? true : (e3 = a3 != null ? a3 === this.inputSummary.textAdded : !this.inputSummary.textAdded, n4 = u3 != null ? this.inputSummary.didDelete : !this.inputSummary.didDelete, c3 = (a3 === "\n" || a3 === " \n") && !e3, l3 = u3 === "\n" && !n4, s4 = c3 && !l3 || l3 && !c3, s4 && (o3 = this.getSelectedRange()) && (i3 = c3 ? a3.replace(/\n$/, "").length || -1 : (a3 != null ? a3.length : void 0) || 1, (r3 = this.responder) != null ? r3.positionIsBlockBreak(o3[1] + i3) : void 0) ? true : e3 && n4);
              }, s3.prototype.mutationIsSignificant = function(t4) {
                var e3, n4, i3;
                return i3 = Object.keys(t4).length > 0, e3 = ((n4 = this.compositionInput) != null ? n4.getEndData() : void 0) === "", i3 || !e3;
              }, s3.prototype.events = { keydown: function(t4) {
                var n4, i3, o3, r3, s4, c3, l3, h2, p3;
                if (this.isComposing() || this.resetInputSummary(), this.inputSummary.didInput = true, r3 = u2[t4.keyCode]) {
                  for (i3 = this.keys, h2 = ["ctrl", "alt", "shift", "meta"], o3 = 0, c3 = h2.length; c3 > o3; o3++)
                    l3 = h2[o3], t4[l3 + "Key"] && (l3 === "ctrl" && (l3 = "control"), i3 = i3 != null ? i3[l3] : void 0);
                  (i3 != null ? i3[r3] : void 0) != null && (this.setInputSummary({ keyName: r3 }), e2.selectionChangeObserver.reset(), i3[r3].call(this, t4));
                }
                return a2(t4) && (n4 = String.fromCharCode(t4.keyCode).toLowerCase()) && (s4 = function() {
                  var e3, n5, i4, o4;
                  for (i4 = ["alt", "shift"], o4 = [], e3 = 0, n5 = i4.length; n5 > e3; e3++)
                    l3 = i4[e3], t4[l3 + "Key"] && o4.push(l3);
                  return o4;
                }(), s4.push(n4), (p3 = this.delegate) != null ? p3.inputControllerDidReceiveKeyboardCommand(s4) : void 0) ? t4.preventDefault() : void 0;
              }, keypress: function(t4) {
                var e3, n4, i3;
                if (this.inputSummary.eventName == null && !t4.metaKey && (!t4.ctrlKey || t4.altKey))
                  return (i3 = p2(t4)) ? ((e3 = this.delegate) != null && e3.inputControllerWillPerformTyping(), (n4 = this.responder) != null && n4.insertString(i3), this.setInputSummary({ textAdded: i3, didDelete: this.selectionIsExpanded() })) : void 0;
              }, textInput: function(t4) {
                var e3, n4, i3, o3;
                return e3 = t4.data, o3 = this.inputSummary.textAdded, o3 && o3 !== e3 && o3.toUpperCase() === e3 ? (n4 = this.getSelectedRange(), this.setSelectedRange([n4[0], n4[1] + o3.length]), (i3 = this.responder) != null && i3.insertString(e3), this.setInputSummary({ textAdded: e3 }), this.setSelectedRange(n4)) : void 0;
              }, dragenter: function(t4) {
                return t4.preventDefault();
              }, dragstart: function(t4) {
                var e3, n4;
                return n4 = t4.target, this.serializeSelectionToDataTransfer(t4.dataTransfer), this.draggedRange = this.getSelectedRange(), (e3 = this.delegate) != null && typeof e3.inputControllerDidStartDrag == "function" ? e3.inputControllerDidStartDrag() : void 0;
              }, dragover: function(t4) {
                var e3, n4;
                return !this.draggedRange && !this.canAcceptDataTransfer(t4.dataTransfer) || (t4.preventDefault(), e3 = { x: t4.clientX, y: t4.clientY }, l2(e3, this.draggingPoint)) ? void 0 : (this.draggingPoint = e3, (n4 = this.delegate) != null && typeof n4.inputControllerDidReceiveDragOverPoint == "function" ? n4.inputControllerDidReceiveDragOverPoint(this.draggingPoint) : void 0);
              }, dragend: function() {
                var t4;
                return (t4 = this.delegate) != null && typeof t4.inputControllerDidCancelDrag == "function" && t4.inputControllerDidCancelDrag(), this.draggedRange = null, this.draggingPoint = null;
              }, drop: function(t4) {
                var n4, i3, o3, r3, s4, a3, u3, c3, l3;
                return t4.preventDefault(), o3 = (s4 = t4.dataTransfer) != null ? s4.files : void 0, r3 = { x: t4.clientX, y: t4.clientY }, (a3 = this.responder) != null && a3.setLocationRangeFromPointRange(r3), (o3 != null ? o3.length : void 0) ? this.attachFiles(o3) : this.draggedRange ? ((u3 = this.delegate) != null && u3.inputControllerWillMoveText(), (c3 = this.responder) != null && c3.moveTextFromRange(this.draggedRange), this.draggedRange = null, this.requestRender()) : (i3 = t4.dataTransfer.getData("application/x-trix-document")) && (n4 = e2.Document.fromJSONString(i3), (l3 = this.responder) != null && l3.insertDocument(n4), this.requestRender()), this.draggedRange = null, this.draggingPoint = null;
              }, cut: function(t4) {
                var e3, n4;
                return ((e3 = this.responder) != null ? e3.selectionIsExpanded() : void 0) && (this.serializeSelectionToDataTransfer(t4.clipboardData) && t4.preventDefault(), (n4 = this.delegate) != null && n4.inputControllerWillCutText(), this.deleteInDirection("backward"), t4.defaultPrevented) ? this.requestRender() : void 0;
              }, copy: function(t4) {
                var e3;
                return ((e3 = this.responder) != null ? e3.selectionIsExpanded() : void 0) && this.serializeSelectionToDataTransfer(t4.clipboardData) ? t4.preventDefault() : void 0;
              }, paste: function(t4) {
                var n4, o3, s4, a3, u3, c3, l3, p3, f3, g3, v2, y2, b2, A2, C2, x2, w, E, S, R, k2, D, L2;
                return n4 = (p3 = t4.clipboardData) != null ? p3 : t4.testClipboardData, l3 = { clipboard: n4 }, n4 == null || h(t4) ? void this.getPastedHTMLUsingHiddenElement(function(t5) {
                  return function(e3) {
                    var n5, i3, o4;
                    return l3.type = "text/html", l3.html = e3, (n5 = t5.delegate) != null && n5.inputControllerWillPaste(l3), (i3 = t5.responder) != null && i3.insertHTML(l3.html), t5.requestRender(), (o4 = t5.delegate) != null ? o4.inputControllerDidPaste(l3) : void 0;
                  };
                }(this)) : ((a3 = n4.getData("URL")) ? (l3.type = "text/html", L2 = (c3 = n4.getData("public.url-name")) ? e2.squishBreakableWhitespace(c3).trim() : a3, l3.html = this.createLinkHTML(a3, L2), (f3 = this.delegate) != null && f3.inputControllerWillPaste(l3), this.setInputSummary({ textAdded: L2, didDelete: this.selectionIsExpanded() }), (C2 = this.responder) != null && C2.insertHTML(l3.html), this.requestRender(), (x2 = this.delegate) != null && x2.inputControllerDidPaste(l3)) : i2(n4) ? (l3.type = "text/plain", l3.string = n4.getData("text/plain"), (w = this.delegate) != null && w.inputControllerWillPaste(l3), this.setInputSummary({ textAdded: l3.string, didDelete: this.selectionIsExpanded() }), (E = this.responder) != null && E.insertString(l3.string), this.requestRender(), (S = this.delegate) != null && S.inputControllerDidPaste(l3)) : (u3 = n4.getData("text/html")) ? (l3.type = "text/html", l3.html = u3, (R = this.delegate) != null && R.inputControllerWillPaste(l3), (k2 = this.responder) != null && k2.insertHTML(l3.html), this.requestRender(), (D = this.delegate) != null && D.inputControllerDidPaste(l3)) : m2.call(n4.types, "Files") >= 0 && (s4 = (g3 = n4.items) != null && (v2 = g3[0]) != null && typeof v2.getAsFile == "function" ? v2.getAsFile() : void 0) && (!s4.name && (o3 = r2(s4)) && (s4.name = "pasted-file-" + ++d3 + "." + o3), l3.type = "File", l3.file = s4, (y2 = this.delegate) != null && y2.inputControllerWillAttachFiles(), (b2 = this.responder) != null && b2.insertFile(l3.file), this.requestRender(), (A2 = this.delegate) != null && A2.inputControllerDidPaste(l3)), t4.preventDefault());
              }, compositionstart: function(t4) {
                return this.getCompositionInput().start(t4.data);
              }, compositionupdate: function(t4) {
                return this.getCompositionInput().update(t4.data);
              }, compositionend: function(t4) {
                return this.getCompositionInput().end(t4.data);
              }, beforeinput: function() {
                return this.inputSummary.didInput = true;
              }, input: function(t4) {
                return this.inputSummary.didInput = true, t4.stopPropagation();
              } }, s3.prototype.keys = { backspace: function(t4) {
                var e3;
                return (e3 = this.delegate) != null && e3.inputControllerWillPerformTyping(), this.deleteInDirection("backward", t4);
              }, "delete": function(t4) {
                var e3;
                return (e3 = this.delegate) != null && e3.inputControllerWillPerformTyping(), this.deleteInDirection("forward", t4);
              }, "return": function() {
                var t4, e3;
                return this.setInputSummary({ preferDocument: true }), (t4 = this.delegate) != null && t4.inputControllerWillPerformTyping(), (e3 = this.responder) != null ? e3.insertLineBreak() : void 0;
              }, tab: function(t4) {
                var e3, n4;
                return ((e3 = this.responder) != null ? e3.canIncreaseNestingLevel() : void 0) ? ((n4 = this.responder) != null && n4.increaseNestingLevel(), this.requestRender(), t4.preventDefault()) : void 0;
              }, left: function(t4) {
                var e3;
                return this.selectionIsInCursorTarget() ? (t4.preventDefault(), (e3 = this.responder) != null ? e3.moveCursorInDirection("backward") : void 0) : void 0;
              }, right: function(t4) {
                var e3;
                return this.selectionIsInCursorTarget() ? (t4.preventDefault(), (e3 = this.responder) != null ? e3.moveCursorInDirection("forward") : void 0) : void 0;
              }, control: { d: function(t4) {
                var e3;
                return (e3 = this.delegate) != null && e3.inputControllerWillPerformTyping(), this.deleteInDirection("forward", t4);
              }, h: function(t4) {
                var e3;
                return (e3 = this.delegate) != null && e3.inputControllerWillPerformTyping(), this.deleteInDirection("backward", t4);
              }, o: function(t4) {
                var e3, n4;
                return t4.preventDefault(), (e3 = this.delegate) != null && e3.inputControllerWillPerformTyping(), (n4 = this.responder) != null && n4.insertString("\n", { updatePosition: false }), this.requestRender();
              } }, shift: { "return": function(t4) {
                var e3, n4;
                return (e3 = this.delegate) != null && e3.inputControllerWillPerformTyping(), (n4 = this.responder) != null && n4.insertString("\n"), this.requestRender(), t4.preventDefault();
              }, tab: function(t4) {
                var e3, n4;
                return ((e3 = this.responder) != null ? e3.canDecreaseNestingLevel() : void 0) ? ((n4 = this.responder) != null && n4.decreaseNestingLevel(), this.requestRender(), t4.preventDefault()) : void 0;
              }, left: function(t4) {
                return this.selectionIsInCursorTarget() ? (t4.preventDefault(), this.expandSelectionInDirection("backward")) : void 0;
              }, right: function(t4) {
                return this.selectionIsInCursorTarget() ? (t4.preventDefault(), this.expandSelectionInDirection("forward")) : void 0;
              } }, alt: { backspace: function() {
                var t4;
                return this.setInputSummary({ preferDocument: false }), (t4 = this.delegate) != null ? t4.inputControllerWillPerformTyping() : void 0;
              } }, meta: { backspace: function() {
                var t4;
                return this.setInputSummary({ preferDocument: false }), (t4 = this.delegate) != null ? t4.inputControllerWillPerformTyping() : void 0;
              } } }, s3.prototype.getCompositionInput = function() {
                return this.isComposing() ? this.compositionInput : this.compositionInput = new t3(this);
              }, s3.prototype.isComposing = function() {
                return this.compositionInput != null && !this.compositionInput.isEnded();
              }, s3.prototype.deleteInDirection = function(t4, e3) {
                var n4;
                return ((n4 = this.responder) != null ? n4.deleteInDirection(t4) : void 0) !== false ? this.setInputSummary({ didDelete: true }) : e3 ? (e3.preventDefault(), this.requestRender()) : void 0;
              }, s3.prototype.serializeSelectionToDataTransfer = function(t4) {
                var n4, i3;
                if (o2(t4))
                  return n4 = (i3 = this.responder) != null ? i3.getSelectedDocument().toSerializableDocument() : void 0, t4.setData("application/x-trix-document", JSON.stringify(n4)), t4.setData("text/html", e2.DocumentView.render(n4).innerHTML), t4.setData("text/plain", n4.toString().replace(/\n$/, "")), true;
              }, s3.prototype.canAcceptDataTransfer = function(t4) {
                var e3, n4, i3, o3, r3, s4;
                for (s4 = {}, o3 = (i3 = t4 != null ? t4.types : void 0) != null ? i3 : [], e3 = 0, n4 = o3.length; n4 > e3; e3++)
                  r3 = o3[e3], s4[r3] = true;
                return s4.Files || s4["application/x-trix-document"] || s4["text/html"] || s4["text/plain"];
              }, s3.prototype.getPastedHTMLUsingHiddenElement = function(t4) {
                var n4, i3, o3;
                return i3 = this.getSelectedRange(), o3 = { position: "absolute", left: window.pageXOffset + "px", top: window.pageYOffset + "px", opacity: 0 }, n4 = c2({ style: o3, tagName: "div", editable: true }), document.body.appendChild(n4), n4.focus(), requestAnimationFrame(function(o4) {
                  return function() {
                    var r3;
                    return r3 = n4.innerHTML, e2.removeNode(n4), o4.setSelectedRange(i3), t4(r3);
                  };
                }(this));
              }, s3.proxyMethod("responder?.getSelectedRange"), s3.proxyMethod("responder?.setSelectedRange"), s3.proxyMethod("responder?.expandSelectionInDirection"), s3.proxyMethod("responder?.selectionIsInCursorTarget"), s3.proxyMethod("responder?.selectionIsExpanded"), s3;
            }(e2.InputController), r2 = function(t4) {
              var e3, n3;
              return (e3 = t4.type) != null && (n3 = e3.match(/\/(\w+)$/)) != null ? n3[1] : void 0;
            }, s2 = (typeof " ".codePointAt == "function" ? " ".codePointAt(0) : void 0) != null, p2 = function(t4) {
              var n3;
              return t4.key && s2 && t4.key.codePointAt(0) === t4.keyCode ? t4.key : (t4.which === null ? n3 = t4.keyCode : t4.which !== 0 && t4.charCode !== 0 && (n3 = t4.charCode), n3 != null && u2[n3] !== "escape" ? e2.UTF16String.fromCodepoints([n3]).toString() : void 0);
            }, h = function(t4) {
              var e3, n3, i3, o3, r3, s3, a3, u3, c3, l3;
              if (u3 = t4.clipboardData) {
                if (m2.call(u3.types, "text/html") >= 0) {
                  for (c3 = u3.types, i3 = 0, s3 = c3.length; s3 > i3; i3++)
                    if (l3 = c3[i3], e3 = /^CorePasteboardFlavorType/.test(l3), n3 = /^dyn\./.test(l3) && u3.getData(l3), a3 = e3 || n3)
                      return true;
                  return false;
                }
                return o3 = m2.call(u3.types, "com.apple.webarchive") >= 0, r3 = m2.call(u3.types, "com.apple.flat-rtfd") >= 0, o3 || r3;
              }
            }, t3 = function(t4) {
              function e3(t5) {
                var e4;
                this.inputController = t5, e4 = this.inputController, this.responder = e4.responder, this.delegate = e4.delegate, this.inputSummary = e4.inputSummary, this.data = {};
              }
              return f2(e3, t4), e3.prototype.start = function(t5) {
                var e4, n3;
                return this.data.start = t5, this.isSignificant() ? (this.inputSummary.eventName === "keypress" && this.inputSummary.textAdded && (e4 = this.responder) != null && e4.deleteInDirection("left"), this.selectionIsExpanded() || (this.insertPlaceholder(), this.requestRender()), this.range = (n3 = this.responder) != null ? n3.getSelectedRange() : void 0) : void 0;
              }, e3.prototype.update = function(t5) {
                var e4;
                return this.data.update = t5, this.isSignificant() && (e4 = this.selectPlaceholder()) ? (this.forgetPlaceholder(), this.range = e4) : void 0;
              }, e3.prototype.end = function(t5) {
                var e4, n3, i3, o3;
                return this.data.end = t5, this.isSignificant() ? (this.forgetPlaceholder(), this.canApplyToDocument() ? (this.setInputSummary({ preferDocument: true, didInput: false }), (e4 = this.delegate) != null && e4.inputControllerWillPerformTyping(), (n3 = this.responder) != null && n3.setSelectedRange(this.range), (i3 = this.responder) != null && i3.insertString(this.data.end), (o3 = this.responder) != null ? o3.setSelectedRange(this.range[0] + this.data.end.length) : void 0) : this.data.start != null || this.data.update != null ? (this.requestReparse(), this.inputController.reset()) : void 0) : this.inputController.reset();
              }, e3.prototype.getEndData = function() {
                return this.data.end;
              }, e3.prototype.isEnded = function() {
                return this.getEndData() != null;
              }, e3.prototype.isSignificant = function() {
                return n2.composesExistingText ? this.inputSummary.didInput : true;
              }, e3.prototype.canApplyToDocument = function() {
                var t5, e4;
                return ((t5 = this.data.start) != null ? t5.length : void 0) === 0 && ((e4 = this.data.end) != null ? e4.length : void 0) > 0 && this.range != null;
              }, e3.proxyMethod("inputController.setInputSummary"), e3.proxyMethod("inputController.requestRender"), e3.proxyMethod("inputController.requestReparse"), e3.proxyMethod("responder?.selectionIsExpanded"), e3.proxyMethod("responder?.insertPlaceholder"), e3.proxyMethod("responder?.selectPlaceholder"), e3.proxyMethod("responder?.forgetPlaceholder"), e3;
            }(e2.BasicObject);
          }.call(this), function() {
            var t3, n2, i2, o2 = function(t4, e3) {
              return function() {
                return t4.apply(e3, arguments);
              };
            }, r2 = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var i3 in e3)
                s2.call(e3, i3) && (t4[i3] = e3[i3]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, s2 = {}.hasOwnProperty, a2 = [].indexOf || function(t4) {
              for (var e3 = 0, n3 = this.length; n3 > e3; e3++)
                if (e3 in this && this[e3] === t4)
                  return e3;
              return -1;
            };
            t3 = e2.dataTransferIsPlainText, n2 = e2.keyEventIsKeyboardCommand, i2 = e2.objectsAreEqual, e2.Level2InputController = function(s3) {
              function u2() {
                return this.render = o2(this.render, this), u2.__super__.constructor.apply(this, arguments);
              }
              var c2, l2, h, p2, d2, f2;
              return r2(u2, s3), u2.prototype.elementDidMutate = function() {
                var t4;
                return this.scheduledRender ? this.composing && (t4 = this.delegate) != null && typeof t4.inputControllerDidAllowUnhandledInput == "function" ? t4.inputControllerDidAllowUnhandledInput() : void 0 : this.reparse();
              }, u2.prototype.scheduleRender = function() {
                return this.scheduledRender != null ? this.scheduledRender : this.scheduledRender = requestAnimationFrame(this.render);
              }, u2.prototype.render = function() {
                var t4;
                return cancelAnimationFrame(this.scheduledRender), this.scheduledRender = null, this.composing || (t4 = this.delegate) != null && t4.render(), typeof this.afterRender == "function" && this.afterRender(), this.afterRender = null;
              }, u2.prototype.reparse = function() {
                var t4;
                return (t4 = this.delegate) != null ? t4.reparse() : void 0;
              }, u2.prototype.events = { keydown: function(t4) {
                var e3, i3, o3, r3;
                if (n2(t4)) {
                  if (e3 = l2(t4), (r3 = this.delegate) != null ? r3.inputControllerDidReceiveKeyboardCommand(e3) : void 0)
                    return t4.preventDefault();
                } else if (o3 = t4.key, t4.altKey && (o3 += "+Alt"), t4.shiftKey && (o3 += "+Shift"), i3 = this.keys[o3])
                  return this.withEvent(t4, i3);
              }, paste: function(t4) {
                var e3, n3, i3, o3, r3, s4, a3, u3, c3;
                return h(t4) ? (t4.preventDefault(), this.attachFiles(t4.clipboardData.files)) : p2(t4) ? (t4.preventDefault(), n3 = { type: "text/plain", string: t4.clipboardData.getData("text/plain") }, (i3 = this.delegate) != null && i3.inputControllerWillPaste(n3), (o3 = this.responder) != null && o3.insertString(n3.string), this.render(), (r3 = this.delegate) != null ? r3.inputControllerDidPaste(n3) : void 0) : (e3 = (s4 = t4.clipboardData) != null ? s4.getData("URL") : void 0) ? (t4.preventDefault(), n3 = { type: "text/html", html: this.createLinkHTML(e3) }, (a3 = this.delegate) != null && a3.inputControllerWillPaste(n3), (u3 = this.responder) != null && u3.insertHTML(n3.html), this.render(), (c3 = this.delegate) != null ? c3.inputControllerDidPaste(n3) : void 0) : void 0;
              }, beforeinput: function(t4) {
                var e3;
                return (e3 = this.inputTypes[t4.inputType]) ? (this.withEvent(t4, e3), this.scheduleRender()) : void 0;
              }, input: function() {
                return e2.selectionChangeObserver.reset();
              }, dragstart: function(t4) {
                var e3, n3;
                return ((e3 = this.responder) != null ? e3.selectionContainsAttachments() : void 0) ? (t4.dataTransfer.setData("application/x-trix-dragging", true), this.dragging = { range: (n3 = this.responder) != null ? n3.getSelectedRange() : void 0, point: d2(t4) }) : void 0;
              }, dragenter: function(t4) {
                return c2(t4) ? t4.preventDefault() : void 0;
              }, dragover: function(t4) {
                var e3, n3;
                if (this.dragging) {
                  if (t4.preventDefault(), e3 = d2(t4), !i2(e3, this.dragging.point))
                    return this.dragging.point = e3, (n3 = this.responder) != null ? n3.setLocationRangeFromPointRange(e3) : void 0;
                } else if (c2(t4))
                  return t4.preventDefault();
              }, drop: function(t4) {
                var e3, n3, i3, o3;
                return this.dragging ? (t4.preventDefault(), (n3 = this.delegate) != null && n3.inputControllerWillMoveText(), (i3 = this.responder) != null && i3.moveTextFromRange(this.dragging.range), this.dragging = null, this.scheduleRender()) : c2(t4) ? (t4.preventDefault(), e3 = d2(t4), (o3 = this.responder) != null && o3.setLocationRangeFromPointRange(e3), this.attachFiles(t4.dataTransfer.files)) : void 0;
              }, dragend: function() {
                var t4;
                return this.dragging ? ((t4 = this.responder) != null && t4.setSelectedRange(this.dragging.range), this.dragging = null) : void 0;
              }, compositionend: function() {
                return this.composing ? (this.composing = false, this.scheduleRender()) : void 0;
              } }, u2.prototype.keys = { ArrowLeft: function() {
                var t4, e3;
                return ((t4 = this.responder) != null ? t4.shouldManageMovingCursorInDirection("backward") : void 0) ? (this.event.preventDefault(), (e3 = this.responder) != null ? e3.moveCursorInDirection("backward") : void 0) : void 0;
              }, ArrowRight: function() {
                var t4, e3;
                return ((t4 = this.responder) != null ? t4.shouldManageMovingCursorInDirection("forward") : void 0) ? (this.event.preventDefault(), (e3 = this.responder) != null ? e3.moveCursorInDirection("forward") : void 0) : void 0;
              }, Backspace: function() {
                var t4, e3, n3;
                return ((t4 = this.responder) != null ? t4.shouldManageDeletingInDirection("backward") : void 0) ? (this.event.preventDefault(), (e3 = this.delegate) != null && e3.inputControllerWillPerformTyping(), (n3 = this.responder) != null && n3.deleteInDirection("backward"), this.render()) : void 0;
              }, Tab: function() {
                var t4, e3;
                return ((t4 = this.responder) != null ? t4.canIncreaseNestingLevel() : void 0) ? (this.event.preventDefault(), (e3 = this.responder) != null && e3.increaseNestingLevel(), this.render()) : void 0;
              }, "Tab+Shift": function() {
                var t4, e3;
                return ((t4 = this.responder) != null ? t4.canDecreaseNestingLevel() : void 0) ? (this.event.preventDefault(), (e3 = this.responder) != null && e3.decreaseNestingLevel(), this.render()) : void 0;
              } }, u2.prototype.inputTypes = { deleteByComposition: function() {
                return this.deleteInDirection("backward", { recordUndoEntry: false });
              }, deleteByCut: function() {
                return this.deleteInDirection("backward");
              }, deleteByDrag: function() {
                return this.event.preventDefault(), this.withTargetDOMRange(function() {
                  var t4;
                  return this.deleteByDragRange = (t4 = this.responder) != null ? t4.getSelectedRange() : void 0;
                });
              }, deleteCompositionText: function() {
                return this.deleteInDirection("backward", { recordUndoEntry: false });
              }, deleteContent: function() {
                return this.deleteInDirection("backward");
              }, deleteContentBackward: function() {
                return this.deleteInDirection("backward");
              }, deleteContentForward: function() {
                return this.deleteInDirection("forward");
              }, deleteEntireSoftLine: function() {
                return this.deleteInDirection("forward");
              }, deleteHardLineBackward: function() {
                return this.deleteInDirection("backward");
              }, deleteHardLineForward: function() {
                return this.deleteInDirection("forward");
              }, deleteSoftLineBackward: function() {
                return this.deleteInDirection("backward");
              }, deleteSoftLineForward: function() {
                return this.deleteInDirection("forward");
              }, deleteWordBackward: function() {
                return this.deleteInDirection("backward");
              }, deleteWordForward: function() {
                return this.deleteInDirection("forward");
              }, formatBackColor: function() {
                return this.activateAttributeIfSupported("backgroundColor", this.event.data);
              }, formatBold: function() {
                return this.toggleAttributeIfSupported("bold");
              }, formatFontColor: function() {
                return this.activateAttributeIfSupported("color", this.event.data);
              }, formatFontName: function() {
                return this.activateAttributeIfSupported("font", this.event.data);
              }, formatIndent: function() {
                var t4;
                return ((t4 = this.responder) != null ? t4.canIncreaseNestingLevel() : void 0) ? this.withTargetDOMRange(function() {
                  var t5;
                  return (t5 = this.responder) != null ? t5.increaseNestingLevel() : void 0;
                }) : void 0;
              }, formatItalic: function() {
                return this.toggleAttributeIfSupported("italic");
              }, formatJustifyCenter: function() {
                return this.toggleAttributeIfSupported("justifyCenter");
              }, formatJustifyFull: function() {
                return this.toggleAttributeIfSupported("justifyFull");
              }, formatJustifyLeft: function() {
                return this.toggleAttributeIfSupported("justifyLeft");
              }, formatJustifyRight: function() {
                return this.toggleAttributeIfSupported("justifyRight");
              }, formatOutdent: function() {
                var t4;
                return ((t4 = this.responder) != null ? t4.canDecreaseNestingLevel() : void 0) ? this.withTargetDOMRange(function() {
                  var t5;
                  return (t5 = this.responder) != null ? t5.decreaseNestingLevel() : void 0;
                }) : void 0;
              }, formatRemove: function() {
                return this.withTargetDOMRange(function() {
                  var t4, e3, n3, i3;
                  i3 = [];
                  for (t4 in (e3 = this.responder) != null ? e3.getCurrentAttributes() : void 0)
                    i3.push((n3 = this.responder) != null ? n3.removeCurrentAttribute(t4) : void 0);
                  return i3;
                });
              }, formatSetBlockTextDirection: function() {
                return this.activateAttributeIfSupported("blockDir", this.event.data);
              }, formatSetInlineTextDirection: function() {
                return this.activateAttributeIfSupported("textDir", this.event.data);
              }, formatStrikeThrough: function() {
                return this.toggleAttributeIfSupported("strike");
              }, formatSubscript: function() {
                return this.toggleAttributeIfSupported("sub");
              }, formatSuperscript: function() {
                return this.toggleAttributeIfSupported("sup");
              }, formatUnderline: function() {
                return this.toggleAttributeIfSupported("underline");
              }, historyRedo: function() {
                var t4;
                return (t4 = this.delegate) != null ? t4.inputControllerWillPerformRedo() : void 0;
              }, historyUndo: function() {
                var t4;
                return (t4 = this.delegate) != null ? t4.inputControllerWillPerformUndo() : void 0;
              }, insertCompositionText: function() {
                return this.composing = true, this.insertString(this.event.data);
              }, insertFromComposition: function() {
                return this.composing = false, this.insertString(this.event.data);
              }, insertFromDrop: function() {
                var t4, e3;
                return (t4 = this.deleteByDragRange) ? (this.deleteByDragRange = null, (e3 = this.delegate) != null && e3.inputControllerWillMoveText(), this.withTargetDOMRange(function() {
                  var e4;
                  return (e4 = this.responder) != null ? e4.moveTextFromRange(t4) : void 0;
                })) : void 0;
              }, insertFromPaste: function() {
                var n3, i3, o3, r3, s4, a3, u3, c3, l3, h2, p3;
                return n3 = this.event.dataTransfer, s4 = { dataTransfer: n3 }, (i3 = n3.getData("URL")) ? (this.event.preventDefault(), s4.type = "text/html", p3 = (r3 = n3.getData("public.url-name")) ? e2.squishBreakableWhitespace(r3).trim() : i3, s4.html = this.createLinkHTML(i3, p3), (a3 = this.delegate) != null && a3.inputControllerWillPaste(s4), this.withTargetDOMRange(function() {
                  var t4;
                  return (t4 = this.responder) != null ? t4.insertHTML(s4.html) : void 0;
                }), this.afterRender = function(t4) {
                  return function() {
                    var e3;
                    return (e3 = t4.delegate) != null ? e3.inputControllerDidPaste(s4) : void 0;
                  };
                }(this)) : t3(n3) ? (s4.type = "text/plain", s4.string = n3.getData("text/plain"), (u3 = this.delegate) != null && u3.inputControllerWillPaste(s4), this.withTargetDOMRange(function() {
                  var t4;
                  return (t4 = this.responder) != null ? t4.insertString(s4.string) : void 0;
                }), this.afterRender = function(t4) {
                  return function() {
                    var e3;
                    return (e3 = t4.delegate) != null ? e3.inputControllerDidPaste(s4) : void 0;
                  };
                }(this)) : (o3 = n3.getData("text/html")) ? (this.event.preventDefault(), s4.type = "text/html", s4.html = o3, (c3 = this.delegate) != null && c3.inputControllerWillPaste(s4), this.withTargetDOMRange(function() {
                  var t4;
                  return (t4 = this.responder) != null ? t4.insertHTML(s4.html) : void 0;
                }), this.afterRender = function(t4) {
                  return function() {
                    var e3;
                    return (e3 = t4.delegate) != null ? e3.inputControllerDidPaste(s4) : void 0;
                  };
                }(this)) : ((l3 = n3.files) != null ? l3.length : void 0) ? (s4.type = "File", s4.file = n3.files[0], (h2 = this.delegate) != null && h2.inputControllerWillPaste(s4), this.withTargetDOMRange(function() {
                  var t4;
                  return (t4 = this.responder) != null ? t4.insertFile(s4.file) : void 0;
                }), this.afterRender = function(t4) {
                  return function() {
                    var e3;
                    return (e3 = t4.delegate) != null ? e3.inputControllerDidPaste(s4) : void 0;
                  };
                }(this)) : void 0;
              }, insertFromYank: function() {
                return this.insertString(this.event.data);
              }, insertLineBreak: function() {
                return this.insertString("\n");
              }, insertLink: function() {
                return this.activateAttributeIfSupported("href", this.event.data);
              }, insertOrderedList: function() {
                return this.toggleAttributeIfSupported("number");
              }, insertParagraph: function() {
                var t4;
                return (t4 = this.delegate) != null && t4.inputControllerWillPerformTyping(), this.withTargetDOMRange(function() {
                  var t5;
                  return (t5 = this.responder) != null ? t5.insertLineBreak() : void 0;
                });
              }, insertReplacementText: function() {
                return this.insertString(this.event.dataTransfer.getData("text/plain"), { updatePosition: false });
              }, insertText: function() {
                var t4, e3;
                return this.insertString((t4 = this.event.data) != null ? t4 : (e3 = this.event.dataTransfer) != null ? e3.getData("text/plain") : void 0);
              }, insertTranspose: function() {
                return this.insertString(this.event.data);
              }, insertUnorderedList: function() {
                return this.toggleAttributeIfSupported("bullet");
              } }, u2.prototype.insertString = function(t4, e3) {
                var n3;
                return t4 == null && (t4 = ""), (n3 = this.delegate) != null && n3.inputControllerWillPerformTyping(), this.withTargetDOMRange(function() {
                  var n4;
                  return (n4 = this.responder) != null ? n4.insertString(t4, e3) : void 0;
                });
              }, u2.prototype.toggleAttributeIfSupported = function(t4) {
                var n3;
                return a2.call(e2.getAllAttributeNames(), t4) >= 0 ? ((n3 = this.delegate) != null && n3.inputControllerWillPerformFormatting(t4), this.withTargetDOMRange(function() {
                  var e3;
                  return (e3 = this.responder) != null ? e3.toggleCurrentAttribute(t4) : void 0;
                })) : void 0;
              }, u2.prototype.activateAttributeIfSupported = function(t4, n3) {
                var i3;
                return a2.call(e2.getAllAttributeNames(), t4) >= 0 ? ((i3 = this.delegate) != null && i3.inputControllerWillPerformFormatting(t4), this.withTargetDOMRange(function() {
                  var e3;
                  return (e3 = this.responder) != null ? e3.setCurrentAttribute(t4, n3) : void 0;
                })) : void 0;
              }, u2.prototype.deleteInDirection = function(t4, e3) {
                var n3, i3, o3, r3;
                return o3 = (e3 != null ? e3 : { recordUndoEntry: true }).recordUndoEntry, o3 && (r3 = this.delegate) != null && r3.inputControllerWillPerformTyping(), i3 = function(e4) {
                  return function() {
                    var n4;
                    return (n4 = e4.responder) != null ? n4.deleteInDirection(t4) : void 0;
                  };
                }(this), (n3 = this.getTargetDOMRange({ minLength: 2 })) ? this.withTargetDOMRange(n3, i3) : i3();
              }, u2.prototype.withTargetDOMRange = function(t4, n3) {
                var i3;
                return typeof t4 == "function" && (n3 = t4, t4 = this.getTargetDOMRange()), t4 ? (i3 = this.responder) != null ? i3.withTargetDOMRange(t4, n3.bind(this)) : void 0 : (e2.selectionChangeObserver.reset(), n3.call(this));
              }, u2.prototype.getTargetDOMRange = function(t4) {
                var e3, n3, i3, o3;
                return i3 = (t4 != null ? t4 : { minLength: 0 }).minLength, (o3 = typeof (e3 = this.event).getTargetRanges == "function" ? e3.getTargetRanges() : void 0) && o3.length && (n3 = f2(o3[0]), i3 === 0 || n3.toString().length >= i3) ? n3 : void 0;
              }, f2 = function(t4) {
                var e3;
                return e3 = document.createRange(), e3.setStart(t4.startContainer, t4.startOffset), e3.setEnd(t4.endContainer, t4.endOffset), e3;
              }, u2.prototype.withEvent = function(t4, e3) {
                var n3;
                this.event = t4;
                try {
                  n3 = e3.call(this);
                } finally {
                  this.event = null;
                }
                return n3;
              }, c2 = function(t4) {
                var e3, n3;
                return a2.call((e3 = (n3 = t4.dataTransfer) != null ? n3.types : void 0) != null ? e3 : [], "Files") >= 0;
              }, h = function(t4) {
                var e3;
                return (e3 = t4.clipboardData) ? a2.call(e3.types, "Files") >= 0 && e3.types.length === 1 && e3.files.length >= 1 : void 0;
              }, p2 = function(t4) {
                var e3;
                return (e3 = t4.clipboardData) ? a2.call(e3.types, "text/plain") >= 0 && e3.types.length === 1 : void 0;
              }, l2 = function(t4) {
                var e3;
                return e3 = [], t4.altKey && e3.push("alt"), t4.shiftKey && e3.push("shift"), e3.push(t4.key), e3;
              }, d2 = function(t4) {
                return { x: t4.clientX, y: t4.clientY };
              }, u2;
            }(e2.InputController);
          }.call(this), function() {
            var t3, n2, i2, o2, r2, s2, a2, u2, c2 = function(t4, e3) {
              return function() {
                return t4.apply(e3, arguments);
              };
            }, l2 = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var i3 in e3)
                h.call(e3, i3) && (t4[i3] = e3[i3]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, h = {}.hasOwnProperty;
            n2 = e2.defer, i2 = e2.handleEvent, s2 = e2.makeElement, u2 = e2.tagName, a2 = e2.config, r2 = a2.lang, t3 = a2.css, o2 = a2.keyNames, e2.AttachmentEditorController = function(a3) {
              function h2(t4, e3, n3, i3) {
                this.attachmentPiece = t4, this.element = e3, this.container = n3, this.options = i3 != null ? i3 : {}, this.didBlurCaption = c2(this.didBlurCaption, this), this.didChangeCaption = c2(this.didChangeCaption, this), this.didInputCaption = c2(this.didInputCaption, this), this.didKeyDownCaption = c2(this.didKeyDownCaption, this), this.didClickActionButton = c2(this.didClickActionButton, this), this.didClickToolbar = c2(this.didClickToolbar, this), this.attachment = this.attachmentPiece.attachment, u2(this.element) === "a" && (this.element = this.element.firstChild), this.install();
              }
              var p2;
              return l2(h2, a3), p2 = function(t4) {
                return function() {
                  var e3;
                  return e3 = t4.apply(this, arguments), e3["do"](), this.undos == null && (this.undos = []), this.undos.push(e3.undo);
                };
              }, h2.prototype.install = function() {
                return this.makeElementMutable(), this.addToolbar(), this.attachment.isPreviewable() ? this.installCaptionEditor() : void 0;
              }, h2.prototype.uninstall = function() {
                var t4, e3;
                for (this.savePendingCaption(); e3 = this.undos.pop(); )
                  e3();
                return (t4 = this.delegate) != null ? t4.didUninstallAttachmentEditor(this) : void 0;
              }, h2.prototype.savePendingCaption = function() {
                var t4, e3, n3;
                return this.pendingCaption != null ? (t4 = this.pendingCaption, this.pendingCaption = null, t4 ? (e3 = this.delegate) != null && typeof e3.attachmentEditorDidRequestUpdatingAttributesForAttachment == "function" ? e3.attachmentEditorDidRequestUpdatingAttributesForAttachment({ caption: t4 }, this.attachment) : void 0 : (n3 = this.delegate) != null && typeof n3.attachmentEditorDidRequestRemovingAttributeForAttachment == "function" ? n3.attachmentEditorDidRequestRemovingAttributeForAttachment("caption", this.attachment) : void 0) : void 0;
              }, h2.prototype.makeElementMutable = p2(function() {
                return { "do": function(t4) {
                  return function() {
                    return t4.element.dataset.trixMutable = true;
                  };
                }(this), undo: function(t4) {
                  return function() {
                    return delete t4.element.dataset.trixMutable;
                  };
                }(this) };
              }), h2.prototype.addToolbar = p2(function() {
                var n3;
                return n3 = s2({ tagName: "div", className: t3.attachmentToolbar, data: { trixMutable: true }, childNodes: s2({ tagName: "div", className: "trix-button-row", childNodes: s2({ tagName: "span", className: "trix-button-group trix-button-group--actions", childNodes: s2({ tagName: "button", className: "trix-button trix-button--remove", textContent: r2.remove, attributes: { title: r2.remove }, data: { trixAction: "remove" } }) }) }) }), this.attachment.isPreviewable() && n3.appendChild(s2({ tagName: "div", className: t3.attachmentMetadataContainer, childNodes: s2({ tagName: "span", className: t3.attachmentMetadata, childNodes: [s2({ tagName: "span", className: t3.attachmentName, textContent: this.attachment.getFilename(), attributes: { title: this.attachment.getFilename() } }), s2({ tagName: "span", className: t3.attachmentSize, textContent: this.attachment.getFormattedFilesize() })] }) })), i2("click", { onElement: n3, withCallback: this.didClickToolbar }), i2("click", { onElement: n3, matchingSelector: "[data-trix-action]", withCallback: this.didClickActionButton }), { "do": function(t4) {
                  return function() {
                    return t4.element.appendChild(n3);
                  };
                }(this), undo: function() {
                  return function() {
                    return e2.removeNode(n3);
                  };
                }(this) };
              }), h2.prototype.installCaptionEditor = p2(function() {
                var o3, a4, u3, c3, l3;
                return c3 = s2({ tagName: "textarea", className: t3.attachmentCaptionEditor, attributes: { placeholder: r2.captionPlaceholder }, data: { trixMutable: true } }), c3.value = this.attachmentPiece.getCaption(), l3 = c3.cloneNode(), l3.classList.add("trix-autoresize-clone"), l3.tabIndex = -1, o3 = function() {
                  return l3.value = c3.value, c3.style.height = l3.scrollHeight + "px";
                }, i2("input", { onElement: c3, withCallback: o3 }), i2("input", { onElement: c3, withCallback: this.didInputCaption }), i2("keydown", { onElement: c3, withCallback: this.didKeyDownCaption }), i2("change", { onElement: c3, withCallback: this.didChangeCaption }), i2("blur", { onElement: c3, withCallback: this.didBlurCaption }), u3 = this.element.querySelector("figcaption"), a4 = u3.cloneNode(), { "do": function(e3) {
                  return function() {
                    return u3.style.display = "none", a4.appendChild(c3), a4.appendChild(l3), a4.classList.add(t3.attachmentCaption + "--editing"), u3.parentElement.insertBefore(a4, u3), o3(), e3.options.editCaption ? n2(function() {
                      return c3.focus();
                    }) : void 0;
                  };
                }(this), undo: function() {
                  return e2.removeNode(a4), u3.style.display = null;
                } };
              }), h2.prototype.didClickToolbar = function(t4) {
                return t4.preventDefault(), t4.stopPropagation();
              }, h2.prototype.didClickActionButton = function(t4) {
                var e3, n3;
                switch (e3 = t4.target.getAttribute("data-trix-action")) {
                  case "remove":
                    return (n3 = this.delegate) != null ? n3.attachmentEditorDidRequestRemovalOfAttachment(this.attachment) : void 0;
                }
              }, h2.prototype.didKeyDownCaption = function(t4) {
                var e3;
                return o2[t4.keyCode] === "return" ? (t4.preventDefault(), this.savePendingCaption(), (e3 = this.delegate) != null && typeof e3.attachmentEditorDidRequestDeselectingAttachment == "function" ? e3.attachmentEditorDidRequestDeselectingAttachment(this.attachment) : void 0) : void 0;
              }, h2.prototype.didInputCaption = function(t4) {
                return this.pendingCaption = t4.target.value.replace(/\s/g, " ").trim();
              }, h2.prototype.didChangeCaption = function() {
                return this.savePendingCaption();
              }, h2.prototype.didBlurCaption = function() {
                return this.savePendingCaption();
              }, h2;
            }(e2.BasicObject);
          }.call(this), function() {
            var t3, n2, i2, o2 = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var i3 in e3)
                r2.call(e3, i3) && (t4[i3] = e3[i3]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, r2 = {}.hasOwnProperty;
            i2 = e2.makeElement, t3 = e2.config.css, e2.AttachmentView = function(r3) {
              function s2() {
                s2.__super__.constructor.apply(this, arguments), this.attachment = this.object, this.attachment.uploadProgressDelegate = this, this.attachmentPiece = this.options.piece;
              }
              var a2;
              return o2(s2, r3), s2.attachmentSelector = "[data-trix-attachment]", s2.prototype.createContentNodes = function() {
                return [];
              }, s2.prototype.createNodes = function() {
                var e3, n3, o3, r4, s3, u2, c2;
                if (e3 = r4 = i2({ tagName: "figure", className: this.getClassName(), data: this.getData(), editable: false }), (n3 = this.getHref()) && (r4 = i2({ tagName: "a", editable: false, attributes: { href: n3, tabindex: -1 } }), e3.appendChild(r4)), this.attachment.hasContent())
                  r4.innerHTML = this.attachment.getContent();
                else
                  for (c2 = this.createContentNodes(), o3 = 0, s3 = c2.length; s3 > o3; o3++)
                    u2 = c2[o3], r4.appendChild(u2);
                return r4.appendChild(this.createCaptionElement()), this.attachment.isPending() && (this.progressElement = i2({ tagName: "progress", attributes: { "class": t3.attachmentProgress, value: this.attachment.getUploadProgress(), max: 100 }, data: { trixMutable: true, trixStoreKey: ["progressElement", this.attachment.id].join("/") } }), e3.appendChild(this.progressElement)), [a2("left"), e3, a2("right")];
              }, s2.prototype.createCaptionElement = function() {
                var e3, n3, o3, r4, s3, a3, u2;
                return o3 = i2({ tagName: "figcaption", className: t3.attachmentCaption }), (e3 = this.attachmentPiece.getCaption()) ? (o3.classList.add(t3.attachmentCaption + "--edited"), o3.textContent = e3) : (n3 = this.getCaptionConfig(), n3.name && (r4 = this.attachment.getFilename()), n3.size && (a3 = this.attachment.getFormattedFilesize()), r4 && (s3 = i2({ tagName: "span", className: t3.attachmentName, textContent: r4 }), o3.appendChild(s3)), a3 && (r4 && o3.appendChild(document.createTextNode(" ")), u2 = i2({ tagName: "span", className: t3.attachmentSize, textContent: a3 }), o3.appendChild(u2))), o3;
              }, s2.prototype.getClassName = function() {
                var e3, n3;
                return n3 = [t3.attachment, t3.attachment + "--" + this.attachment.getType()], (e3 = this.attachment.getExtension()) && n3.push(t3.attachment + "--" + e3), n3.join(" ");
              }, s2.prototype.getData = function() {
                var t4, e3;
                return e3 = { trixAttachment: JSON.stringify(this.attachment), trixContentType: this.attachment.getContentType(), trixId: this.attachment.id }, t4 = this.attachmentPiece.attributes, t4.isEmpty() || (e3.trixAttributes = JSON.stringify(t4)), this.attachment.isPending() && (e3.trixSerialize = false), e3;
              }, s2.prototype.getHref = function() {
                return n2(this.attachment.getContent(), "a") ? void 0 : this.attachment.getHref();
              }, s2.prototype.getCaptionConfig = function() {
                var t4, n3, i3;
                return i3 = this.attachment.getType(), t4 = e2.copyObject((n3 = e2.config.attachments[i3]) != null ? n3.caption : void 0), i3 === "file" && (t4.name = true), t4;
              }, s2.prototype.findProgressElement = function() {
                var t4;
                return (t4 = this.findElement()) != null ? t4.querySelector("progress") : void 0;
              }, a2 = function(t4) {
                return i2({ tagName: "span", textContent: e2.ZERO_WIDTH_SPACE, data: { trixCursorTarget: t4, trixSerialize: false } });
              }, s2.prototype.attachmentDidChangeUploadProgress = function() {
                var t4, e3;
                return e3 = this.attachment.getUploadProgress(), (t4 = this.findProgressElement()) != null ? t4.value = e3 : void 0;
              }, s2;
            }(e2.ObjectView), n2 = function(t4, e3) {
              var n3;
              return n3 = i2("div"), n3.innerHTML = t4 != null ? t4 : "", n3.querySelector(e3);
            };
          }.call(this), function() {
            var t3, n2 = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var o2 in e3)
                i2.call(e3, o2) && (t4[o2] = e3[o2]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, i2 = {}.hasOwnProperty;
            t3 = e2.makeElement, e2.PreviewableAttachmentView = function(i3) {
              function o2() {
                o2.__super__.constructor.apply(this, arguments), this.attachment.previewDelegate = this;
              }
              return n2(o2, i3), o2.prototype.createContentNodes = function() {
                return this.image = t3({ tagName: "img", attributes: { src: "" }, data: { trixMutable: true } }), this.refresh(this.image), [this.image];
              }, o2.prototype.createCaptionElement = function() {
                var t4;
                return t4 = o2.__super__.createCaptionElement.apply(this, arguments), t4.textContent || t4.setAttribute("data-trix-placeholder", e2.config.lang.captionPlaceholder), t4;
              }, o2.prototype.refresh = function(t4) {
                var e3;
                return t4 == null && (t4 = (e3 = this.findElement()) != null ? e3.querySelector("img") : void 0), t4 ? this.updateAttributesForImage(t4) : void 0;
              }, o2.prototype.updateAttributesForImage = function(t4) {
                var e3, n3, i4, o3, r2, s2;
                return r2 = this.attachment.getURL(), n3 = this.attachment.getPreviewURL(), t4.src = n3 || r2, n3 === r2 ? t4.removeAttribute("data-trix-serialized-attributes") : (i4 = JSON.stringify({ src: r2 }), t4.setAttribute("data-trix-serialized-attributes", i4)), s2 = this.attachment.getWidth(), e3 = this.attachment.getHeight(), s2 != null && (t4.width = s2), e3 != null && (t4.height = e3), o3 = ["imageElement", this.attachment.id, t4.src, t4.width, t4.height].join("/"), t4.dataset.trixStoreKey = o3;
              }, o2.prototype.attachmentDidChangeAttributes = function() {
                return this.refresh(this.image), this.refresh();
              }, o2;
            }(e2.AttachmentView);
          }.call(this), function() {
            var t3, n2, i2, o2 = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var i3 in e3)
                r2.call(e3, i3) && (t4[i3] = e3[i3]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, r2 = {}.hasOwnProperty;
            i2 = e2.makeElement, t3 = e2.findInnerElement, n2 = e2.getTextConfig, e2.PieceView = function(r3) {
              function s2() {
                var t4;
                s2.__super__.constructor.apply(this, arguments), this.piece = this.object, this.attributes = this.piece.getAttributes(), t4 = this.options, this.textConfig = t4.textConfig, this.context = t4.context, this.piece.attachment ? this.attachment = this.piece.attachment : this.string = this.piece.toString();
              }
              var a2;
              return o2(s2, r3), s2.prototype.createNodes = function() {
                var e3, n3, i3, o3, r4, s3;
                if (s3 = this.attachment ? this.createAttachmentNodes() : this.createStringNodes(), e3 = this.createElement()) {
                  for (i3 = t3(e3), n3 = 0, o3 = s3.length; o3 > n3; n3++)
                    r4 = s3[n3], i3.appendChild(r4);
                  s3 = [e3];
                }
                return s3;
              }, s2.prototype.createAttachmentNodes = function() {
                var t4, n3;
                return t4 = this.attachment.isPreviewable() ? e2.PreviewableAttachmentView : e2.AttachmentView, n3 = this.createChildView(t4, this.piece.attachment, { piece: this.piece }), n3.getNodes();
              }, s2.prototype.createStringNodes = function() {
                var t4, e3, n3, o3, r4, s3, a3, u2, c2, l2;
                if ((u2 = this.textConfig) != null ? u2.plaintext : void 0)
                  return [document.createTextNode(this.string)];
                for (a3 = [], c2 = this.string.split("\n"), n3 = e3 = 0, o3 = c2.length; o3 > e3; n3 = ++e3)
                  l2 = c2[n3], n3 > 0 && (t4 = i2("br"), a3.push(t4)), (r4 = l2.length) && (s3 = document.createTextNode(this.preserveSpaces(l2)), a3.push(s3));
                return a3;
              }, s2.prototype.createElement = function() {
                var t4, e3, o3, r4, s3, a3, u2, c2, l2;
                c2 = {}, a3 = this.attributes;
                for (r4 in a3)
                  if (l2 = a3[r4], (t4 = n2(r4)) && (t4.tagName && (s3 = i2(t4.tagName), o3 ? (o3.appendChild(s3), o3 = s3) : e3 = o3 = s3), t4.styleProperty && (c2[t4.styleProperty] = l2), t4.style)) {
                    u2 = t4.style;
                    for (r4 in u2)
                      l2 = u2[r4], c2[r4] = l2;
                  }
                if (Object.keys(c2).length) {
                  e3 == null && (e3 = i2("span"));
                  for (r4 in c2)
                    l2 = c2[r4], e3.style[r4] = l2;
                }
                return e3;
              }, s2.prototype.createContainerElement = function() {
                var t4, e3, o3, r4, s3;
                r4 = this.attributes;
                for (o3 in r4)
                  if (s3 = r4[o3], (e3 = n2(o3)) && e3.groupTagName)
                    return t4 = {}, t4[o3] = s3, i2(e3.groupTagName, t4);
              }, a2 = e2.NON_BREAKING_SPACE, s2.prototype.preserveSpaces = function(t4) {
                return this.context.isLast && (t4 = t4.replace(/\ $/, a2)), t4 = t4.replace(/(\S)\ {3}(\S)/g, "$1 " + a2 + " $2").replace(/\ {2}/g, a2 + " ").replace(/\ {2}/g, " " + a2), (this.context.isFirst || this.context.followsWhitespace) && (t4 = t4.replace(/^\ /, a2)), t4;
              }, s2;
            }(e2.ObjectView);
          }.call(this), function() {
            var t3 = function(t4, e3) {
              function i2() {
                this.constructor = t4;
              }
              for (var o2 in e3)
                n2.call(e3, o2) && (t4[o2] = e3[o2]);
              return i2.prototype = e3.prototype, t4.prototype = new i2(), t4.__super__ = e3.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e2.TextView = function(n3) {
              function i2() {
                i2.__super__.constructor.apply(this, arguments), this.text = this.object, this.textConfig = this.options.textConfig;
              }
              var o2;
              return t3(i2, n3), i2.prototype.createNodes = function() {
                var t4, n4, i3, r2, s2, a2, u2, c2, l2, h;
                for (a2 = [], c2 = e2.ObjectGroup.groupObjects(this.getPieces()), r2 = c2.length - 1, i3 = n4 = 0, s2 = c2.length; s2 > n4; i3 = ++n4)
                  u2 = c2[i3], t4 = {}, i3 === 0 && (t4.isFirst = true), i3 === r2 && (t4.isLast = true), o2(l2) && (t4.followsWhitespace = true), h = this.findOrCreateCachedChildView(e2.PieceView, u2, { textConfig: this.textConfig, context: t4 }), a2.push.apply(a2, h.getNodes()), l2 = u2;
                return a2;
              }, i2.prototype.getPieces = function() {
                var t4, e3, n4, i3, o3;
                for (i3 = this.text.getPieces(), o3 = [], t4 = 0, e3 = i3.length; e3 > t4; t4++)
                  n4 = i3[t4], n4.hasAttribute("blockBreak") || o3.push(n4);
                return o3;
              }, o2 = function(t4) {
                return /\s$/.test(t4 != null ? t4.toString() : void 0);
              }, i2;
            }(e2.ObjectView);
          }.call(this), function() {
            var t3, n2, i2, o2 = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var i3 in e3)
                r2.call(e3, i3) && (t4[i3] = e3[i3]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, r2 = {}.hasOwnProperty;
            i2 = e2.makeElement, n2 = e2.getBlockConfig, t3 = e2.config.css, e2.BlockView = function(r3) {
              function s2() {
                s2.__super__.constructor.apply(this, arguments), this.block = this.object, this.attributes = this.block.getAttributes();
              }
              return o2(s2, r3), s2.prototype.createNodes = function() {
                var t4, o3, r4, s3, a2, u2, c2, l2, h, p2, d2;
                if (o3 = document.createComment("block"), c2 = [o3], this.block.isEmpty() ? c2.push(i2("br")) : (p2 = (l2 = n2(this.block.getLastAttribute())) != null ? l2.text : void 0, d2 = this.findOrCreateCachedChildView(e2.TextView, this.block.text, { textConfig: p2 }), c2.push.apply(c2, d2.getNodes()), this.shouldAddExtraNewlineElement() && c2.push(i2("br"))), this.attributes.length)
                  return c2;
                for (h = e2.config.blockAttributes["default"].tagName, this.block.isRTL() && (t4 = { dir: "rtl" }), r4 = i2({ tagName: h, attributes: t4 }), s3 = 0, a2 = c2.length; a2 > s3; s3++)
                  u2 = c2[s3], r4.appendChild(u2);
                return [r4];
              }, s2.prototype.createContainerElement = function(e3) {
                var o3, r4, s3, a2, u2;
                return o3 = this.attributes[e3], u2 = n2(o3).tagName, e3 === 0 && this.block.isRTL() && (r4 = { dir: "rtl" }), o3 === "attachmentGallery" && (a2 = this.block.getBlockBreakPosition(), s3 = t3.attachmentGallery + " " + t3.attachmentGallery + "--" + a2), i2({ tagName: u2, className: s3, attributes: r4 });
              }, s2.prototype.shouldAddExtraNewlineElement = function() {
                return /\n\n$/.test(this.block.toString());
              }, s2;
            }(e2.ObjectView);
          }.call(this), function() {
            var t3, n2, i2 = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var i3 in e3)
                o2.call(e3, i3) && (t4[i3] = e3[i3]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, o2 = {}.hasOwnProperty;
            t3 = e2.defer, n2 = e2.makeElement, e2.DocumentView = function(o3) {
              function r2() {
                r2.__super__.constructor.apply(this, arguments), this.element = this.options.element, this.elementStore = new e2.ElementStore(), this.setDocument(this.object);
              }
              var s2, a2, u2;
              return i2(r2, o3), r2.render = function(t4) {
                var e3, i3;
                return e3 = n2("div"), i3 = new this(t4, { element: e3 }), i3.render(), i3.sync(), e3;
              }, r2.prototype.setDocument = function(t4) {
                return t4.isEqualTo(this.document) ? void 0 : this.document = this.object = t4;
              }, r2.prototype.render = function() {
                var t4, i3, o4, r3, s3, a3, u3;
                if (this.childViews = [], this.shadowElement = n2("div"), !this.document.isEmpty()) {
                  for (s3 = e2.ObjectGroup.groupObjects(this.document.getBlocks(), { asTree: true }), a3 = [], t4 = 0, i3 = s3.length; i3 > t4; t4++)
                    r3 = s3[t4], u3 = this.findOrCreateCachedChildView(e2.BlockView, r3), a3.push(function() {
                      var t5, e3, n3, i4;
                      for (n3 = u3.getNodes(), i4 = [], t5 = 0, e3 = n3.length; e3 > t5; t5++)
                        o4 = n3[t5], i4.push(this.shadowElement.appendChild(o4));
                      return i4;
                    }.call(this));
                  return a3;
                }
              }, r2.prototype.isSynced = function() {
                return s2(this.shadowElement, this.element);
              }, r2.prototype.sync = function() {
                var t4;
                for (t4 = this.createDocumentFragmentForSync(); this.element.lastChild; )
                  this.element.removeChild(this.element.lastChild);
                return this.element.appendChild(t4), this.didSync();
              }, r2.prototype.didSync = function() {
                return this.elementStore.reset(a2(this.element)), t3(function(t4) {
                  return function() {
                    return t4.garbageCollectCachedViews();
                  };
                }(this));
              }, r2.prototype.createDocumentFragmentForSync = function() {
                var t4, e3, n3, i3, o4, r3, s3, u3, c2, l2;
                for (e3 = document.createDocumentFragment(), u3 = this.shadowElement.childNodes, n3 = 0, o4 = u3.length; o4 > n3; n3++)
                  s3 = u3[n3], e3.appendChild(s3.cloneNode(true));
                for (c2 = a2(e3), i3 = 0, r3 = c2.length; r3 > i3; i3++)
                  t4 = c2[i3], (l2 = this.elementStore.remove(t4)) && t4.parentNode.replaceChild(l2, t4);
                return e3;
              }, a2 = function(t4) {
                return t4.querySelectorAll("[data-trix-store-key]");
              }, s2 = function(t4, e3) {
                return u2(t4.innerHTML) === u2(e3.innerHTML);
              }, u2 = function(t4) {
                return t4.replace(/&nbsp;/g, " ");
              }, r2;
            }(e2.ObjectView);
          }.call(this), function() {
            var t3, n2, i2, o2, r2, s2 = function(t4, e3) {
              return function() {
                return t4.apply(e3, arguments);
              };
            }, a2 = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var i3 in e3)
                u2.call(e3, i3) && (t4[i3] = e3[i3]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, u2 = {}.hasOwnProperty;
            i2 = e2.findClosestElementFromNode, o2 = e2.handleEvent, r2 = e2.innerElementIsActive, n2 = e2.defer, t3 = e2.AttachmentView.attachmentSelector, e2.CompositionController = function(u3) {
              function c2(n3, i3) {
                this.element = n3, this.composition = i3, this.didClickAttachment = s2(this.didClickAttachment, this), this.didBlur = s2(this.didBlur, this), this.didFocus = s2(this.didFocus, this), this.documentView = new e2.DocumentView(this.composition.document, { element: this.element }), o2("focus", { onElement: this.element, withCallback: this.didFocus }), o2("blur", { onElement: this.element, withCallback: this.didBlur }), o2("click", { onElement: this.element, matchingSelector: "a[contenteditable=false]", preventDefault: true }), o2("mousedown", { onElement: this.element, matchingSelector: t3, withCallback: this.didClickAttachment }), o2("click", { onElement: this.element, matchingSelector: "a" + t3, preventDefault: true });
              }
              return a2(c2, u3), c2.prototype.didFocus = function() {
                var t4, e3, n3;
                return t4 = function(t5) {
                  return function() {
                    var e4;
                    return t5.focused ? void 0 : (t5.focused = true, (e4 = t5.delegate) != null && typeof e4.compositionControllerDidFocus == "function" ? e4.compositionControllerDidFocus() : void 0);
                  };
                }(this), (e3 = (n3 = this.blurPromise) != null ? n3.then(t4) : void 0) != null ? e3 : t4();
              }, c2.prototype.didBlur = function() {
                return this.blurPromise = new Promise(function(t4) {
                  return function(e3) {
                    return n2(function() {
                      var n3;
                      return r2(t4.element) || (t4.focused = null, (n3 = t4.delegate) != null && typeof n3.compositionControllerDidBlur == "function" && n3.compositionControllerDidBlur()), t4.blurPromise = null, e3();
                    });
                  };
                }(this));
              }, c2.prototype.didClickAttachment = function(t4, e3) {
                var n3, o3, r3;
                return n3 = this.findAttachmentForElement(e3), o3 = i2(t4.target, { matchingSelector: "figcaption" }) != null, (r3 = this.delegate) != null && typeof r3.compositionControllerDidSelectAttachment == "function" ? r3.compositionControllerDidSelectAttachment(n3, { editCaption: o3 }) : void 0;
              }, c2.prototype.getSerializableElement = function() {
                return this.isEditingAttachment() ? this.documentView.shadowElement : this.element;
              }, c2.prototype.render = function() {
                var t4, e3, n3;
                return this.revision !== this.composition.revision && (this.documentView.setDocument(this.composition.document), this.documentView.render(), this.revision = this.composition.revision), this.canSyncDocumentView() && !this.documentView.isSynced() && ((t4 = this.delegate) != null && typeof t4.compositionControllerWillSyncDocumentView == "function" && t4.compositionControllerWillSyncDocumentView(), this.documentView.sync(), (e3 = this.delegate) != null && typeof e3.compositionControllerDidSyncDocumentView == "function" && e3.compositionControllerDidSyncDocumentView()), (n3 = this.delegate) != null && typeof n3.compositionControllerDidRender == "function" ? n3.compositionControllerDidRender() : void 0;
              }, c2.prototype.rerenderViewForObject = function(t4) {
                return this.invalidateViewForObject(t4), this.render();
              }, c2.prototype.invalidateViewForObject = function(t4) {
                return this.documentView.invalidateViewForObject(t4);
              }, c2.prototype.isViewCachingEnabled = function() {
                return this.documentView.isViewCachingEnabled();
              }, c2.prototype.enableViewCaching = function() {
                return this.documentView.enableViewCaching();
              }, c2.prototype.disableViewCaching = function() {
                return this.documentView.disableViewCaching();
              }, c2.prototype.refreshViewCache = function() {
                return this.documentView.garbageCollectCachedViews();
              }, c2.prototype.isEditingAttachment = function() {
                return this.attachmentEditor != null;
              }, c2.prototype.installAttachmentEditorForAttachment = function(t4, n3) {
                var i3, o3, r3;
                if (((r3 = this.attachmentEditor) != null ? r3.attachment : void 0) !== t4 && (o3 = this.documentView.findElementForObject(t4)))
                  return this.uninstallAttachmentEditor(), i3 = this.composition.document.getAttachmentPieceForAttachment(t4), this.attachmentEditor = new e2.AttachmentEditorController(i3, o3, this.element, n3), this.attachmentEditor.delegate = this;
              }, c2.prototype.uninstallAttachmentEditor = function() {
                var t4;
                return (t4 = this.attachmentEditor) != null ? t4.uninstall() : void 0;
              }, c2.prototype.didUninstallAttachmentEditor = function() {
                return this.attachmentEditor = null, this.render();
              }, c2.prototype.attachmentEditorDidRequestUpdatingAttributesForAttachment = function(t4, e3) {
                var n3;
                return (n3 = this.delegate) != null && typeof n3.compositionControllerWillUpdateAttachment == "function" && n3.compositionControllerWillUpdateAttachment(e3), this.composition.updateAttributesForAttachment(t4, e3);
              }, c2.prototype.attachmentEditorDidRequestRemovingAttributeForAttachment = function(t4, e3) {
                var n3;
                return (n3 = this.delegate) != null && typeof n3.compositionControllerWillUpdateAttachment == "function" && n3.compositionControllerWillUpdateAttachment(e3), this.composition.removeAttributeForAttachment(t4, e3);
              }, c2.prototype.attachmentEditorDidRequestRemovalOfAttachment = function(t4) {
                var e3;
                return (e3 = this.delegate) != null && typeof e3.compositionControllerDidRequestRemovalOfAttachment == "function" ? e3.compositionControllerDidRequestRemovalOfAttachment(t4) : void 0;
              }, c2.prototype.attachmentEditorDidRequestDeselectingAttachment = function(t4) {
                var e3;
                return (e3 = this.delegate) != null && typeof e3.compositionControllerDidRequestDeselectingAttachment == "function" ? e3.compositionControllerDidRequestDeselectingAttachment(t4) : void 0;
              }, c2.prototype.canSyncDocumentView = function() {
                return !this.isEditingAttachment();
              }, c2.prototype.findAttachmentForElement = function(t4) {
                return this.composition.document.getAttachmentById(parseInt(t4.dataset.trixId, 10));
              }, c2;
            }(e2.BasicObject);
          }.call(this), function() {
            var t3, n2, i2, o2 = function(t4, e3) {
              return function() {
                return t4.apply(e3, arguments);
              };
            }, r2 = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var i3 in e3)
                s2.call(e3, i3) && (t4[i3] = e3[i3]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, s2 = {}.hasOwnProperty;
            n2 = e2.handleEvent, i2 = e2.triggerEvent, t3 = e2.findClosestElementFromNode, e2.ToolbarController = function(e3) {
              function s3(t4) {
                this.element = t4, this.didKeyDownDialogInput = o2(this.didKeyDownDialogInput, this), this.didClickDialogButton = o2(this.didClickDialogButton, this), this.didClickAttributeButton = o2(this.didClickAttributeButton, this), this.didClickActionButton = o2(this.didClickActionButton, this), this.attributes = {}, this.actions = {}, this.resetDialogInputs(), n2("mousedown", { onElement: this.element, matchingSelector: a2, withCallback: this.didClickActionButton }), n2("mousedown", { onElement: this.element, matchingSelector: c2, withCallback: this.didClickAttributeButton }), n2("click", { onElement: this.element, matchingSelector: v2, preventDefault: true }), n2("click", { onElement: this.element, matchingSelector: l2, withCallback: this.didClickDialogButton }), n2("keydown", { onElement: this.element, matchingSelector: h, withCallback: this.didKeyDownDialogInput });
              }
              var a2, u2, c2, l2, h, p2, d2, f2, g2, m2, v2;
              return r2(s3, e3), c2 = "[data-trix-attribute]", a2 = "[data-trix-action]", v2 = c2 + ", " + a2, p2 = "[data-trix-dialog]", u2 = p2 + "[data-trix-active]", l2 = p2 + " [data-trix-method]", h = p2 + " [data-trix-input]", s3.prototype.didClickActionButton = function(t4, e4) {
                var n3, i3, o3;
                return (i3 = this.delegate) != null && i3.toolbarDidClickButton(), t4.preventDefault(), n3 = d2(e4), this.getDialog(n3) ? this.toggleDialog(n3) : (o3 = this.delegate) != null ? o3.toolbarDidInvokeAction(n3) : void 0;
              }, s3.prototype.didClickAttributeButton = function(t4, e4) {
                var n3, i3, o3;
                return (i3 = this.delegate) != null && i3.toolbarDidClickButton(), t4.preventDefault(), n3 = f2(e4), this.getDialog(n3) ? this.toggleDialog(n3) : (o3 = this.delegate) != null && o3.toolbarDidToggleAttribute(n3), this.refreshAttributeButtons();
              }, s3.prototype.didClickDialogButton = function(e4, n3) {
                var i3, o3;
                return i3 = t3(n3, { matchingSelector: p2 }), o3 = n3.getAttribute("data-trix-method"), this[o3].call(this, i3);
              }, s3.prototype.didKeyDownDialogInput = function(t4, e4) {
                var n3, i3;
                return t4.keyCode === 13 && (t4.preventDefault(), n3 = e4.getAttribute("name"), i3 = this.getDialog(n3), this.setAttribute(i3)), t4.keyCode === 27 ? (t4.preventDefault(), this.hideDialog()) : void 0;
              }, s3.prototype.updateActions = function(t4) {
                return this.actions = t4, this.refreshActionButtons();
              }, s3.prototype.refreshActionButtons = function() {
                return this.eachActionButton(function(t4) {
                  return function(e4, n3) {
                    return e4.disabled = t4.actions[n3] === false;
                  };
                }(this));
              }, s3.prototype.eachActionButton = function(t4) {
                var e4, n3, i3, o3, r3;
                for (o3 = this.element.querySelectorAll(a2), r3 = [], n3 = 0, i3 = o3.length; i3 > n3; n3++)
                  e4 = o3[n3], r3.push(t4(e4, d2(e4)));
                return r3;
              }, s3.prototype.updateAttributes = function(t4) {
                return this.attributes = t4, this.refreshAttributeButtons();
              }, s3.prototype.refreshAttributeButtons = function() {
                return this.eachAttributeButton(function(t4) {
                  return function(e4, n3) {
                    return e4.disabled = t4.attributes[n3] === false, t4.attributes[n3] || t4.dialogIsVisible(n3) ? (e4.setAttribute("data-trix-active", ""), e4.classList.add("trix-active")) : (e4.removeAttribute("data-trix-active"), e4.classList.remove("trix-active"));
                  };
                }(this));
              }, s3.prototype.eachAttributeButton = function(t4) {
                var e4, n3, i3, o3, r3;
                for (o3 = this.element.querySelectorAll(c2), r3 = [], n3 = 0, i3 = o3.length; i3 > n3; n3++)
                  e4 = o3[n3], r3.push(t4(e4, f2(e4)));
                return r3;
              }, s3.prototype.applyKeyboardCommand = function(t4) {
                var e4, n3, o3, r3, s4, a3, u3;
                for (s4 = JSON.stringify(t4.sort()), u3 = this.element.querySelectorAll("[data-trix-key]"), r3 = 0, a3 = u3.length; a3 > r3; r3++)
                  if (e4 = u3[r3], o3 = e4.getAttribute("data-trix-key").split("+"), n3 = JSON.stringify(o3.sort()), n3 === s4)
                    return i2("mousedown", { onElement: e4 }), true;
                return false;
              }, s3.prototype.dialogIsVisible = function(t4) {
                var e4;
                return (e4 = this.getDialog(t4)) ? e4.hasAttribute("data-trix-active") : void 0;
              }, s3.prototype.toggleDialog = function(t4) {
                return this.dialogIsVisible(t4) ? this.hideDialog() : this.showDialog(t4);
              }, s3.prototype.showDialog = function(t4) {
                var e4, n3, i3, o3, r3, s4, a3, u3, c3, l3;
                for (this.hideDialog(), (a3 = this.delegate) != null && a3.toolbarWillShowDialog(), i3 = this.getDialog(t4), i3.setAttribute("data-trix-active", ""), i3.classList.add("trix-active"), u3 = i3.querySelectorAll("input[disabled]"), o3 = 0, s4 = u3.length; s4 > o3; o3++)
                  n3 = u3[o3], n3.removeAttribute("disabled");
                return (e4 = f2(i3)) && (r3 = m2(i3, t4)) && (r3.value = (c3 = this.attributes[e4]) != null ? c3 : "", r3.select()), (l3 = this.delegate) != null ? l3.toolbarDidShowDialog(t4) : void 0;
              }, s3.prototype.setAttribute = function(t4) {
                var e4, n3, i3;
                return e4 = f2(t4), n3 = m2(t4, e4), n3.willValidate && !n3.checkValidity() ? (n3.setAttribute("data-trix-validate", ""), n3.classList.add("trix-validate"), n3.focus()) : ((i3 = this.delegate) != null && i3.toolbarDidUpdateAttribute(e4, n3.value), this.hideDialog());
              }, s3.prototype.removeAttribute = function(t4) {
                var e4, n3;
                return e4 = f2(t4), (n3 = this.delegate) != null && n3.toolbarDidRemoveAttribute(e4), this.hideDialog();
              }, s3.prototype.hideDialog = function() {
                var t4, e4;
                return (t4 = this.element.querySelector(u2)) ? (t4.removeAttribute("data-trix-active"), t4.classList.remove("trix-active"), this.resetDialogInputs(), (e4 = this.delegate) != null ? e4.toolbarDidHideDialog(g2(t4)) : void 0) : void 0;
              }, s3.prototype.resetDialogInputs = function() {
                var t4, e4, n3, i3, o3;
                for (i3 = this.element.querySelectorAll(h), o3 = [], t4 = 0, n3 = i3.length; n3 > t4; t4++)
                  e4 = i3[t4], e4.setAttribute("disabled", "disabled"), e4.removeAttribute("data-trix-validate"), o3.push(e4.classList.remove("trix-validate"));
                return o3;
              }, s3.prototype.getDialog = function(t4) {
                return this.element.querySelector("[data-trix-dialog=" + t4 + "]");
              }, m2 = function(t4, e4) {
                return e4 == null && (e4 = f2(t4)), t4.querySelector("[data-trix-input][name='" + e4 + "']");
              }, d2 = function(t4) {
                return t4.getAttribute("data-trix-action");
              }, f2 = function(t4) {
                var e4;
                return (e4 = t4.getAttribute("data-trix-attribute")) != null ? e4 : t4.getAttribute("data-trix-dialog-attribute");
              }, g2 = function(t4) {
                return t4.getAttribute("data-trix-dialog");
              }, s3;
            }(e2.BasicObject);
          }.call(this), function() {
            var t3 = function(t4, e3) {
              function i2() {
                this.constructor = t4;
              }
              for (var o2 in e3)
                n2.call(e3, o2) && (t4[o2] = e3[o2]);
              return i2.prototype = e3.prototype, t4.prototype = new i2(), t4.__super__ = e3.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e2.ImagePreloadOperation = function(e3) {
              function n3(t4) {
                this.url = t4;
              }
              return t3(n3, e3), n3.prototype.perform = function(t4) {
                var e4;
                return e4 = new Image(), e4.onload = function(n4) {
                  return function() {
                    return e4.width = n4.width = e4.naturalWidth, e4.height = n4.height = e4.naturalHeight, t4(true, e4);
                  };
                }(this), e4.onerror = function() {
                  return t4(false);
                }, e4.src = this.url;
              }, n3;
            }(e2.Operation);
          }.call(this), function() {
            var t3 = function(t4, e3) {
              return function() {
                return t4.apply(e3, arguments);
              };
            }, n2 = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var o2 in e3)
                i2.call(e3, o2) && (t4[o2] = e3[o2]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, i2 = {}.hasOwnProperty;
            e2.Attachment = function(i3) {
              function o2(n3) {
                n3 == null && (n3 = {}), this.releaseFile = t3(this.releaseFile, this), o2.__super__.constructor.apply(this, arguments), this.attributes = e2.Hash.box(n3), this.didChangeAttributes();
              }
              return n2(o2, i3), o2.previewablePattern = /^image(\/(gif|png|jpe?g)|$)/, o2.attachmentForFile = function(t4) {
                var e3, n3;
                return n3 = this.attributesForFile(t4), e3 = new this(n3), e3.setFile(t4), e3;
              }, o2.attributesForFile = function(t4) {
                return new e2.Hash({ filename: t4.name, filesize: t4.size, contentType: t4.type });
              }, o2.fromJSON = function(t4) {
                return new this(t4);
              }, o2.prototype.getAttribute = function(t4) {
                return this.attributes.get(t4);
              }, o2.prototype.hasAttribute = function(t4) {
                return this.attributes.has(t4);
              }, o2.prototype.getAttributes = function() {
                return this.attributes.toObject();
              }, o2.prototype.setAttributes = function(t4) {
                var e3, n3, i4;
                return t4 == null && (t4 = {}), e3 = this.attributes.merge(t4), this.attributes.isEqualTo(e3) ? void 0 : (this.attributes = e3, this.didChangeAttributes(), (n3 = this.previewDelegate) != null && typeof n3.attachmentDidChangeAttributes == "function" && n3.attachmentDidChangeAttributes(this), (i4 = this.delegate) != null && typeof i4.attachmentDidChangeAttributes == "function" ? i4.attachmentDidChangeAttributes(this) : void 0);
              }, o2.prototype.didChangeAttributes = function() {
                return this.isPreviewable() ? this.preloadURL() : void 0;
              }, o2.prototype.isPending = function() {
                return this.file != null && !(this.getURL() || this.getHref());
              }, o2.prototype.isPreviewable = function() {
                return this.attributes.has("previewable") ? this.attributes.get("previewable") : this.constructor.previewablePattern.test(this.getContentType());
              }, o2.prototype.getType = function() {
                return this.hasContent() ? "content" : this.isPreviewable() ? "preview" : "file";
              }, o2.prototype.getURL = function() {
                return this.attributes.get("url");
              }, o2.prototype.getHref = function() {
                return this.attributes.get("href");
              }, o2.prototype.getFilename = function() {
                var t4;
                return (t4 = this.attributes.get("filename")) != null ? t4 : "";
              }, o2.prototype.getFilesize = function() {
                return this.attributes.get("filesize");
              }, o2.prototype.getFormattedFilesize = function() {
                var t4;
                return t4 = this.attributes.get("filesize"), typeof t4 == "number" ? e2.config.fileSize.formatter(t4) : "";
              }, o2.prototype.getExtension = function() {
                var t4;
                return (t4 = this.getFilename().match(/\.(\w+)$/)) != null ? t4[1].toLowerCase() : void 0;
              }, o2.prototype.getContentType = function() {
                return this.attributes.get("contentType");
              }, o2.prototype.hasContent = function() {
                return this.attributes.has("content");
              }, o2.prototype.getContent = function() {
                return this.attributes.get("content");
              }, o2.prototype.getWidth = function() {
                return this.attributes.get("width");
              }, o2.prototype.getHeight = function() {
                return this.attributes.get("height");
              }, o2.prototype.getFile = function() {
                return this.file;
              }, o2.prototype.setFile = function(t4) {
                return this.file = t4, this.isPreviewable() ? this.preloadFile() : void 0;
              }, o2.prototype.releaseFile = function() {
                return this.releasePreloadedFile(), this.file = null;
              }, o2.prototype.getUploadProgress = function() {
                var t4;
                return (t4 = this.uploadProgress) != null ? t4 : 0;
              }, o2.prototype.setUploadProgress = function(t4) {
                var e3;
                return this.uploadProgress !== t4 ? (this.uploadProgress = t4, (e3 = this.uploadProgressDelegate) != null && typeof e3.attachmentDidChangeUploadProgress == "function" ? e3.attachmentDidChangeUploadProgress(this) : void 0) : void 0;
              }, o2.prototype.toJSON = function() {
                return this.getAttributes();
              }, o2.prototype.getCacheKey = function() {
                return [o2.__super__.getCacheKey.apply(this, arguments), this.attributes.getCacheKey(), this.getPreviewURL()].join("/");
              }, o2.prototype.getPreviewURL = function() {
                return this.previewURL || this.preloadingURL;
              }, o2.prototype.setPreviewURL = function(t4) {
                var e3, n3;
                return t4 !== this.getPreviewURL() ? (this.previewURL = t4, (e3 = this.previewDelegate) != null && typeof e3.attachmentDidChangeAttributes == "function" && e3.attachmentDidChangeAttributes(this), (n3 = this.delegate) != null && typeof n3.attachmentDidChangePreviewURL == "function" ? n3.attachmentDidChangePreviewURL(this) : void 0) : void 0;
              }, o2.prototype.preloadURL = function() {
                return this.preload(this.getURL(), this.releaseFile);
              }, o2.prototype.preloadFile = function() {
                return this.file ? (this.fileObjectURL = URL.createObjectURL(this.file), this.preload(this.fileObjectURL)) : void 0;
              }, o2.prototype.releasePreloadedFile = function() {
                return this.fileObjectURL ? (URL.revokeObjectURL(this.fileObjectURL), this.fileObjectURL = null) : void 0;
              }, o2.prototype.preload = function(t4, n3) {
                var i4;
                return t4 && t4 !== this.getPreviewURL() ? (this.preloadingURL = t4, i4 = new e2.ImagePreloadOperation(t4), i4.then(function(e3) {
                  return function(i5) {
                    var o3, r2;
                    return r2 = i5.width, o3 = i5.height, e3.getWidth() && e3.getHeight() || e3.setAttributes({ width: r2, height: o3 }), e3.preloadingURL = null, e3.setPreviewURL(t4), typeof n3 == "function" ? n3() : void 0;
                  };
                }(this))["catch"](function(t5) {
                  return function() {
                    return t5.preloadingURL = null, typeof n3 == "function" ? n3() : void 0;
                  };
                }(this))) : void 0;
              }, o2;
            }(e2.Object);
          }.call(this), function() {
            var t3 = function(t4, e3) {
              function i2() {
                this.constructor = t4;
              }
              for (var o2 in e3)
                n2.call(e3, o2) && (t4[o2] = e3[o2]);
              return i2.prototype = e3.prototype, t4.prototype = new i2(), t4.__super__ = e3.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e2.Piece = function(n3) {
              function i2(t4, n4) {
                n4 == null && (n4 = {}), i2.__super__.constructor.apply(this, arguments), this.attributes = e2.Hash.box(n4);
              }
              return t3(i2, n3), i2.types = {}, i2.registerType = function(t4, e3) {
                return e3.type = t4, this.types[t4] = e3;
              }, i2.fromJSON = function(t4) {
                var e3;
                return (e3 = this.types[t4.type]) ? e3.fromJSON(t4) : void 0;
              }, i2.prototype.copyWithAttributes = function(t4) {
                return new this.constructor(this.getValue(), t4);
              }, i2.prototype.copyWithAdditionalAttributes = function(t4) {
                return this.copyWithAttributes(this.attributes.merge(t4));
              }, i2.prototype.copyWithoutAttribute = function(t4) {
                return this.copyWithAttributes(this.attributes.remove(t4));
              }, i2.prototype.copy = function() {
                return this.copyWithAttributes(this.attributes);
              }, i2.prototype.getAttribute = function(t4) {
                return this.attributes.get(t4);
              }, i2.prototype.getAttributesHash = function() {
                return this.attributes;
              }, i2.prototype.getAttributes = function() {
                return this.attributes.toObject();
              }, i2.prototype.getCommonAttributes = function() {
                var t4, e3, n4;
                return (n4 = pieceList.getPieceAtIndex(0)) ? (t4 = n4.attributes, e3 = t4.getKeys(), pieceList.eachPiece(function(n5) {
                  return e3 = t4.getKeysCommonToHash(n5.attributes), t4 = t4.slice(e3);
                }), t4.toObject()) : {};
              }, i2.prototype.hasAttribute = function(t4) {
                return this.attributes.has(t4);
              }, i2.prototype.hasSameStringValueAsPiece = function(t4) {
                return t4 != null && this.toString() === t4.toString();
              }, i2.prototype.hasSameAttributesAsPiece = function(t4) {
                return t4 != null && (this.attributes === t4.attributes || this.attributes.isEqualTo(t4.attributes));
              }, i2.prototype.isBlockBreak = function() {
                return false;
              }, i2.prototype.isEqualTo = function(t4) {
                return i2.__super__.isEqualTo.apply(this, arguments) || this.hasSameConstructorAs(t4) && this.hasSameStringValueAsPiece(t4) && this.hasSameAttributesAsPiece(t4);
              }, i2.prototype.isEmpty = function() {
                return this.length === 0;
              }, i2.prototype.isSerializable = function() {
                return true;
              }, i2.prototype.toJSON = function() {
                return { type: this.constructor.type, attributes: this.getAttributes() };
              }, i2.prototype.contentsForInspection = function() {
                return { type: this.constructor.type, attributes: this.attributes.inspect() };
              }, i2.prototype.canBeGrouped = function() {
                return this.hasAttribute("href");
              }, i2.prototype.canBeGroupedWith = function(t4) {
                return this.getAttribute("href") === t4.getAttribute("href");
              }, i2.prototype.getLength = function() {
                return this.length;
              }, i2.prototype.canBeConsolidatedWith = function() {
                return false;
              }, i2;
            }(e2.Object);
          }.call(this), function() {
            var t3 = function(t4, e3) {
              function i2() {
                this.constructor = t4;
              }
              for (var o2 in e3)
                n2.call(e3, o2) && (t4[o2] = e3[o2]);
              return i2.prototype = e3.prototype, t4.prototype = new i2(), t4.__super__ = e3.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e2.Piece.registerType("attachment", e2.AttachmentPiece = function(n3) {
              function i2(t4) {
                this.attachment = t4, i2.__super__.constructor.apply(this, arguments), this.length = 1, this.ensureAttachmentExclusivelyHasAttribute("href"), this.attachment.hasContent() || this.removeProhibitedAttributes();
              }
              return t3(i2, n3), i2.fromJSON = function(t4) {
                return new this(e2.Attachment.fromJSON(t4.attachment), t4.attributes);
              }, i2.permittedAttributes = ["caption", "presentation"], i2.prototype.ensureAttachmentExclusivelyHasAttribute = function(t4) {
                return this.hasAttribute(t4) ? (this.attachment.hasAttribute(t4) || this.attachment.setAttributes(this.attributes.slice(t4)), this.attributes = this.attributes.remove(t4)) : void 0;
              }, i2.prototype.removeProhibitedAttributes = function() {
                var t4;
                return t4 = this.attributes.slice(this.constructor.permittedAttributes), t4.isEqualTo(this.attributes) ? void 0 : this.attributes = t4;
              }, i2.prototype.getValue = function() {
                return this.attachment;
              }, i2.prototype.isSerializable = function() {
                return !this.attachment.isPending();
              }, i2.prototype.getCaption = function() {
                var t4;
                return (t4 = this.attributes.get("caption")) != null ? t4 : "";
              }, i2.prototype.isEqualTo = function(t4) {
                var e3;
                return i2.__super__.isEqualTo.apply(this, arguments) && this.attachment.id === (t4 != null && (e3 = t4.attachment) != null ? e3.id : void 0);
              }, i2.prototype.toString = function() {
                return e2.OBJECT_REPLACEMENT_CHARACTER;
              }, i2.prototype.toJSON = function() {
                var t4;
                return t4 = i2.__super__.toJSON.apply(this, arguments), t4.attachment = this.attachment, t4;
              }, i2.prototype.getCacheKey = function() {
                return [i2.__super__.getCacheKey.apply(this, arguments), this.attachment.getCacheKey()].join("/");
              }, i2.prototype.toConsole = function() {
                return JSON.stringify(this.toString());
              }, i2;
            }(e2.Piece));
          }.call(this), function() {
            var t3, n2 = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var o2 in e3)
                i2.call(e3, o2) && (t4[o2] = e3[o2]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, i2 = {}.hasOwnProperty;
            t3 = e2.normalizeNewlines, e2.Piece.registerType("string", e2.StringPiece = function(e3) {
              function i3(e4) {
                i3.__super__.constructor.apply(this, arguments), this.string = t3(e4), this.length = this.string.length;
              }
              return n2(i3, e3), i3.fromJSON = function(t4) {
                return new this(t4.string, t4.attributes);
              }, i3.prototype.getValue = function() {
                return this.string;
              }, i3.prototype.toString = function() {
                return this.string.toString();
              }, i3.prototype.isBlockBreak = function() {
                return this.toString() === "\n" && this.getAttribute("blockBreak") === true;
              }, i3.prototype.toJSON = function() {
                var t4;
                return t4 = i3.__super__.toJSON.apply(this, arguments), t4.string = this.string, t4;
              }, i3.prototype.canBeConsolidatedWith = function(t4) {
                return t4 != null && this.hasSameConstructorAs(t4) && this.hasSameAttributesAsPiece(t4);
              }, i3.prototype.consolidateWith = function(t4) {
                return new this.constructor(this.toString() + t4.toString(), this.attributes);
              }, i3.prototype.splitAtOffset = function(t4) {
                var e4, n3;
                return t4 === 0 ? (e4 = null, n3 = this) : t4 === this.length ? (e4 = this, n3 = null) : (e4 = new this.constructor(this.string.slice(0, t4), this.attributes), n3 = new this.constructor(this.string.slice(t4), this.attributes)), [e4, n3];
              }, i3.prototype.toConsole = function() {
                var t4;
                return t4 = this.string, t4.length > 15 && (t4 = t4.slice(0, 14) + "\u2026"), JSON.stringify(t4.toString());
              }, i3;
            }(e2.Piece));
          }.call(this), function() {
            var t3, n2 = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var o3 in e3)
                i2.call(e3, o3) && (t4[o3] = e3[o3]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, i2 = {}.hasOwnProperty, o2 = [].slice;
            t3 = e2.spliceArray, e2.SplittableList = function(e3) {
              function i3(t4) {
                t4 == null && (t4 = []), i3.__super__.constructor.apply(this, arguments), this.objects = t4.slice(0), this.length = this.objects.length;
              }
              var r2, s2, a2;
              return n2(i3, e3), i3.box = function(t4) {
                return t4 instanceof this ? t4 : new this(t4);
              }, i3.prototype.indexOf = function(t4) {
                return this.objects.indexOf(t4);
              }, i3.prototype.splice = function() {
                var e4;
                return e4 = 1 <= arguments.length ? o2.call(arguments, 0) : [], new this.constructor(t3.apply(null, [this.objects].concat(o2.call(e4))));
              }, i3.prototype.eachObject = function(t4) {
                var e4, n3, i4, o3, r3, s3;
                for (r3 = this.objects, s3 = [], n3 = e4 = 0, i4 = r3.length; i4 > e4; n3 = ++e4)
                  o3 = r3[n3], s3.push(t4(o3, n3));
                return s3;
              }, i3.prototype.insertObjectAtIndex = function(t4, e4) {
                return this.splice(e4, 0, t4);
              }, i3.prototype.insertSplittableListAtIndex = function(t4, e4) {
                return this.splice.apply(this, [e4, 0].concat(o2.call(t4.objects)));
              }, i3.prototype.insertSplittableListAtPosition = function(t4, e4) {
                var n3, i4, o3;
                return o3 = this.splitObjectAtPosition(e4), i4 = o3[0], n3 = o3[1], new this.constructor(i4).insertSplittableListAtIndex(t4, n3);
              }, i3.prototype.editObjectAtIndex = function(t4, e4) {
                return this.replaceObjectAtIndex(e4(this.objects[t4]), t4);
              }, i3.prototype.replaceObjectAtIndex = function(t4, e4) {
                return this.splice(e4, 1, t4);
              }, i3.prototype.removeObjectAtIndex = function(t4) {
                return this.splice(t4, 1);
              }, i3.prototype.getObjectAtIndex = function(t4) {
                return this.objects[t4];
              }, i3.prototype.getSplittableListInRange = function(t4) {
                var e4, n3, i4, o3;
                return i4 = this.splitObjectsAtRange(t4), n3 = i4[0], e4 = i4[1], o3 = i4[2], new this.constructor(n3.slice(e4, o3 + 1));
              }, i3.prototype.selectSplittableList = function(t4) {
                var e4, n3;
                return n3 = function() {
                  var n4, i4, o3, r3;
                  for (o3 = this.objects, r3 = [], n4 = 0, i4 = o3.length; i4 > n4; n4++)
                    e4 = o3[n4], t4(e4) && r3.push(e4);
                  return r3;
                }.call(this), new this.constructor(n3);
              }, i3.prototype.removeObjectsInRange = function(t4) {
                var e4, n3, i4, o3;
                return i4 = this.splitObjectsAtRange(t4), n3 = i4[0], e4 = i4[1], o3 = i4[2], new this.constructor(n3).splice(e4, o3 - e4 + 1);
              }, i3.prototype.transformObjectsInRange = function(t4, e4) {
                var n3, i4, o3, r3, s3, a3, u2;
                return s3 = this.splitObjectsAtRange(t4), r3 = s3[0], i4 = s3[1], a3 = s3[2], u2 = function() {
                  var t5, s4, u3;
                  for (u3 = [], n3 = t5 = 0, s4 = r3.length; s4 > t5; n3 = ++t5)
                    o3 = r3[n3], u3.push(n3 >= i4 && a3 >= n3 ? e4(o3) : o3);
                  return u3;
                }(), new this.constructor(u2);
              }, i3.prototype.splitObjectsAtRange = function(t4) {
                var e4, n3, i4, o3, s3, u2;
                return o3 = this.splitObjectAtPosition(a2(t4)), n3 = o3[0], e4 = o3[1], i4 = o3[2], s3 = new this.constructor(n3).splitObjectAtPosition(r2(t4) + i4), n3 = s3[0], u2 = s3[1], [n3, e4, u2 - 1];
              }, i3.prototype.getObjectAtPosition = function(t4) {
                var e4, n3, i4;
                return i4 = this.findIndexAndOffsetAtPosition(t4), e4 = i4.index, n3 = i4.offset, this.objects[e4];
              }, i3.prototype.splitObjectAtPosition = function(t4) {
                var e4, n3, i4, o3, r3, s3, a3, u2, c2, l2;
                return s3 = this.findIndexAndOffsetAtPosition(t4), e4 = s3.index, r3 = s3.offset, o3 = this.objects.slice(0), e4 != null ? r3 === 0 ? (c2 = e4, l2 = 0) : (i4 = this.getObjectAtIndex(e4), a3 = i4.splitAtOffset(r3), n3 = a3[0], u2 = a3[1], o3.splice(e4, 1, n3, u2), c2 = e4 + 1, l2 = n3.getLength() - r3) : (c2 = o3.length, l2 = 0), [o3, c2, l2];
              }, i3.prototype.consolidate = function() {
                var t4, e4, n3, i4, o3, r3;
                for (i4 = [], o3 = this.objects[0], r3 = this.objects.slice(1), t4 = 0, e4 = r3.length; e4 > t4; t4++)
                  n3 = r3[t4], (typeof o3.canBeConsolidatedWith == "function" ? o3.canBeConsolidatedWith(n3) : void 0) ? o3 = o3.consolidateWith(n3) : (i4.push(o3), o3 = n3);
                return o3 != null && i4.push(o3), new this.constructor(i4);
              }, i3.prototype.consolidateFromIndexToIndex = function(t4, e4) {
                var n3, i4, r3;
                return i4 = this.objects.slice(0), r3 = i4.slice(t4, e4 + 1), n3 = new this.constructor(r3).consolidate().toArray(), this.splice.apply(this, [t4, r3.length].concat(o2.call(n3)));
              }, i3.prototype.findIndexAndOffsetAtPosition = function(t4) {
                var e4, n3, i4, o3, r3, s3, a3;
                for (e4 = 0, a3 = this.objects, i4 = n3 = 0, o3 = a3.length; o3 > n3; i4 = ++n3) {
                  if (s3 = a3[i4], r3 = e4 + s3.getLength(), t4 >= e4 && r3 > t4)
                    return { index: i4, offset: t4 - e4 };
                  e4 = r3;
                }
                return { index: null, offset: null };
              }, i3.prototype.findPositionAtIndexAndOffset = function(t4, e4) {
                var n3, i4, o3, r3, s3, a3;
                for (s3 = 0, a3 = this.objects, n3 = i4 = 0, o3 = a3.length; o3 > i4; n3 = ++i4)
                  if (r3 = a3[n3], t4 > n3)
                    s3 += r3.getLength();
                  else if (n3 === t4) {
                    s3 += e4;
                    break;
                  }
                return s3;
              }, i3.prototype.getEndPosition = function() {
                var t4, e4;
                return this.endPosition != null ? this.endPosition : this.endPosition = function() {
                  var n3, i4, o3;
                  for (e4 = 0, o3 = this.objects, n3 = 0, i4 = o3.length; i4 > n3; n3++)
                    t4 = o3[n3], e4 += t4.getLength();
                  return e4;
                }.call(this);
              }, i3.prototype.toString = function() {
                return this.objects.join("");
              }, i3.prototype.toArray = function() {
                return this.objects.slice(0);
              }, i3.prototype.toJSON = function() {
                return this.toArray();
              }, i3.prototype.isEqualTo = function(t4) {
                return i3.__super__.isEqualTo.apply(this, arguments) || s2(this.objects, t4 != null ? t4.objects : void 0);
              }, s2 = function(t4, e4) {
                var n3, i4, o3, r3, s3;
                if (e4 == null && (e4 = []), t4.length !== e4.length)
                  return false;
                for (s3 = true, i4 = n3 = 0, o3 = t4.length; o3 > n3; i4 = ++n3)
                  r3 = t4[i4], s3 && !r3.isEqualTo(e4[i4]) && (s3 = false);
                return s3;
              }, i3.prototype.contentsForInspection = function() {
                var t4;
                return { objects: "[" + function() {
                  var e4, n3, i4, o3;
                  for (i4 = this.objects, o3 = [], e4 = 0, n3 = i4.length; n3 > e4; e4++)
                    t4 = i4[e4], o3.push(t4.inspect());
                  return o3;
                }.call(this).join(", ") + "]" };
              }, a2 = function(t4) {
                return t4[0];
              }, r2 = function(t4) {
                return t4[1];
              }, i3;
            }(e2.Object);
          }.call(this), function() {
            var t3 = function(t4, e3) {
              function i2() {
                this.constructor = t4;
              }
              for (var o2 in e3)
                n2.call(e3, o2) && (t4[o2] = e3[o2]);
              return i2.prototype = e3.prototype, t4.prototype = new i2(), t4.__super__ = e3.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e2.Text = function(n3) {
              function i2(t4) {
                var n4;
                t4 == null && (t4 = []), i2.__super__.constructor.apply(this, arguments), this.pieceList = new e2.SplittableList(function() {
                  var e3, i3, o2;
                  for (o2 = [], e3 = 0, i3 = t4.length; i3 > e3; e3++)
                    n4 = t4[e3], n4.isEmpty() || o2.push(n4);
                  return o2;
                }());
              }
              return t3(i2, n3), i2.textForAttachmentWithAttributes = function(t4, n4) {
                var i3;
                return i3 = new e2.AttachmentPiece(t4, n4), new this([i3]);
              }, i2.textForStringWithAttributes = function(t4, n4) {
                var i3;
                return i3 = new e2.StringPiece(t4, n4), new this([i3]);
              }, i2.fromJSON = function(t4) {
                var n4, i3;
                return i3 = function() {
                  var i4, o2, r2;
                  for (r2 = [], i4 = 0, o2 = t4.length; o2 > i4; i4++)
                    n4 = t4[i4], r2.push(e2.Piece.fromJSON(n4));
                  return r2;
                }(), new this(i3);
              }, i2.prototype.copy = function() {
                return this.copyWithPieceList(this.pieceList);
              }, i2.prototype.copyWithPieceList = function(t4) {
                return new this.constructor(t4.consolidate().toArray());
              }, i2.prototype.copyUsingObjectMap = function(t4) {
                var e3, n4;
                return n4 = function() {
                  var n5, i3, o2, r2, s2;
                  for (o2 = this.getPieces(), s2 = [], n5 = 0, i3 = o2.length; i3 > n5; n5++)
                    e3 = o2[n5], s2.push((r2 = t4.find(e3)) != null ? r2 : e3);
                  return s2;
                }.call(this), new this.constructor(n4);
              }, i2.prototype.appendText = function(t4) {
                return this.insertTextAtPosition(t4, this.getLength());
              }, i2.prototype.insertTextAtPosition = function(t4, e3) {
                return this.copyWithPieceList(this.pieceList.insertSplittableListAtPosition(t4.pieceList, e3));
              }, i2.prototype.removeTextAtRange = function(t4) {
                return this.copyWithPieceList(this.pieceList.removeObjectsInRange(t4));
              }, i2.prototype.replaceTextAtRange = function(t4, e3) {
                return this.removeTextAtRange(e3).insertTextAtPosition(t4, e3[0]);
              }, i2.prototype.moveTextFromRangeToPosition = function(t4, e3) {
                var n4, i3;
                if (!(t4[0] <= e3 && e3 <= t4[1]))
                  return i3 = this.getTextAtRange(t4), n4 = i3.getLength(), t4[0] < e3 && (e3 -= n4), this.removeTextAtRange(t4).insertTextAtPosition(i3, e3);
              }, i2.prototype.addAttributeAtRange = function(t4, e3, n4) {
                var i3;
                return i3 = {}, i3[t4] = e3, this.addAttributesAtRange(i3, n4);
              }, i2.prototype.addAttributesAtRange = function(t4, e3) {
                return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e3, function(e4) {
                  return e4.copyWithAdditionalAttributes(t4);
                }));
              }, i2.prototype.removeAttributeAtRange = function(t4, e3) {
                return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e3, function(e4) {
                  return e4.copyWithoutAttribute(t4);
                }));
              }, i2.prototype.setAttributesAtRange = function(t4, e3) {
                return this.copyWithPieceList(this.pieceList.transformObjectsInRange(e3, function(e4) {
                  return e4.copyWithAttributes(t4);
                }));
              }, i2.prototype.getAttributesAtPosition = function(t4) {
                var e3, n4;
                return (e3 = (n4 = this.pieceList.getObjectAtPosition(t4)) != null ? n4.getAttributes() : void 0) != null ? e3 : {};
              }, i2.prototype.getCommonAttributes = function() {
                var t4, n4;
                return t4 = function() {
                  var t5, e3, i3, o2;
                  for (i3 = this.pieceList.toArray(), o2 = [], t5 = 0, e3 = i3.length; e3 > t5; t5++)
                    n4 = i3[t5], o2.push(n4.getAttributes());
                  return o2;
                }.call(this), e2.Hash.fromCommonAttributesOfObjects(t4).toObject();
              }, i2.prototype.getCommonAttributesAtRange = function(t4) {
                var e3;
                return (e3 = this.getTextAtRange(t4).getCommonAttributes()) != null ? e3 : {};
              }, i2.prototype.getExpandedRangeForAttributeAtOffset = function(t4, e3) {
                var n4, i3, o2;
                for (n4 = o2 = e3, i3 = this.getLength(); n4 > 0 && this.getCommonAttributesAtRange([n4 - 1, o2])[t4]; )
                  n4--;
                for (; i3 > o2 && this.getCommonAttributesAtRange([e3, o2 + 1])[t4]; )
                  o2++;
                return [n4, o2];
              }, i2.prototype.getTextAtRange = function(t4) {
                return this.copyWithPieceList(this.pieceList.getSplittableListInRange(t4));
              }, i2.prototype.getStringAtRange = function(t4) {
                return this.pieceList.getSplittableListInRange(t4).toString();
              }, i2.prototype.getStringAtPosition = function(t4) {
                return this.getStringAtRange([t4, t4 + 1]);
              }, i2.prototype.startsWithString = function(t4) {
                return this.getStringAtRange([0, t4.length]) === t4;
              }, i2.prototype.endsWithString = function(t4) {
                var e3;
                return e3 = this.getLength(), this.getStringAtRange([e3 - t4.length, e3]) === t4;
              }, i2.prototype.getAttachmentPieces = function() {
                var t4, e3, n4, i3, o2;
                for (i3 = this.pieceList.toArray(), o2 = [], t4 = 0, e3 = i3.length; e3 > t4; t4++)
                  n4 = i3[t4], n4.attachment != null && o2.push(n4);
                return o2;
              }, i2.prototype.getAttachments = function() {
                var t4, e3, n4, i3, o2;
                for (i3 = this.getAttachmentPieces(), o2 = [], t4 = 0, e3 = i3.length; e3 > t4; t4++)
                  n4 = i3[t4], o2.push(n4.attachment);
                return o2;
              }, i2.prototype.getAttachmentAndPositionById = function(t4) {
                var e3, n4, i3, o2, r2, s2;
                for (o2 = 0, r2 = this.pieceList.toArray(), e3 = 0, n4 = r2.length; n4 > e3; e3++) {
                  if (i3 = r2[e3], ((s2 = i3.attachment) != null ? s2.id : void 0) === t4)
                    return { attachment: i3.attachment, position: o2 };
                  o2 += i3.length;
                }
                return { attachment: null, position: null };
              }, i2.prototype.getAttachmentById = function(t4) {
                var e3, n4, i3;
                return i3 = this.getAttachmentAndPositionById(t4), e3 = i3.attachment, n4 = i3.position, e3;
              }, i2.prototype.getRangeOfAttachment = function(t4) {
                var e3, n4;
                return n4 = this.getAttachmentAndPositionById(t4.id), t4 = n4.attachment, e3 = n4.position, t4 != null ? [e3, e3 + 1] : void 0;
              }, i2.prototype.updateAttributesForAttachment = function(t4, e3) {
                var n4;
                return (n4 = this.getRangeOfAttachment(e3)) ? this.addAttributesAtRange(t4, n4) : this;
              }, i2.prototype.getLength = function() {
                return this.pieceList.getEndPosition();
              }, i2.prototype.isEmpty = function() {
                return this.getLength() === 0;
              }, i2.prototype.isEqualTo = function(t4) {
                var e3;
                return i2.__super__.isEqualTo.apply(this, arguments) || (t4 != null && (e3 = t4.pieceList) != null ? e3.isEqualTo(this.pieceList) : void 0);
              }, i2.prototype.isBlockBreak = function() {
                return this.getLength() === 1 && this.pieceList.getObjectAtIndex(0).isBlockBreak();
              }, i2.prototype.eachPiece = function(t4) {
                return this.pieceList.eachObject(t4);
              }, i2.prototype.getPieces = function() {
                return this.pieceList.toArray();
              }, i2.prototype.getPieceAtPosition = function(t4) {
                return this.pieceList.getObjectAtPosition(t4);
              }, i2.prototype.contentsForInspection = function() {
                return { pieceList: this.pieceList.inspect() };
              }, i2.prototype.toSerializableText = function() {
                var t4;
                return t4 = this.pieceList.selectSplittableList(function(t5) {
                  return t5.isSerializable();
                }), this.copyWithPieceList(t4);
              }, i2.prototype.toString = function() {
                return this.pieceList.toString();
              }, i2.prototype.toJSON = function() {
                return this.pieceList.toJSON();
              }, i2.prototype.toConsole = function() {
                var t4;
                return JSON.stringify(function() {
                  var e3, n4, i3, o2;
                  for (i3 = this.pieceList.toArray(), o2 = [], e3 = 0, n4 = i3.length; n4 > e3; e3++)
                    t4 = i3[e3], o2.push(JSON.parse(t4.toConsole()));
                  return o2;
                }.call(this));
              }, i2.prototype.getDirection = function() {
                return e2.getDirection(this.toString());
              }, i2.prototype.isRTL = function() {
                return this.getDirection() === "rtl";
              }, i2;
            }(e2.Object);
          }.call(this), function() {
            var t3, n2, i2, o2, r2, s2 = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var i3 in e3)
                a2.call(e3, i3) && (t4[i3] = e3[i3]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, a2 = {}.hasOwnProperty, u2 = [].indexOf || function(t4) {
              for (var e3 = 0, n3 = this.length; n3 > e3; e3++)
                if (e3 in this && this[e3] === t4)
                  return e3;
              return -1;
            }, c2 = [].slice;
            t3 = e2.arraysAreEqual, r2 = e2.spliceArray, i2 = e2.getBlockConfig, n2 = e2.getBlockAttributeNames, o2 = e2.getListAttributeNames, e2.Block = function(n3) {
              function a3(t4, n4) {
                t4 == null && (t4 = new e2.Text()), n4 == null && (n4 = []), a3.__super__.constructor.apply(this, arguments), this.text = h(t4), this.attributes = n4;
              }
              var l2, h, p2, d2, f2, g2, m2, v2, y2;
              return s2(a3, n3), a3.fromJSON = function(t4) {
                var n4;
                return n4 = e2.Text.fromJSON(t4.text), new this(n4, t4.attributes);
              }, a3.prototype.isEmpty = function() {
                return this.text.isBlockBreak();
              }, a3.prototype.isEqualTo = function(e3) {
                return a3.__super__.isEqualTo.apply(this, arguments) || this.text.isEqualTo(e3 != null ? e3.text : void 0) && t3(this.attributes, e3 != null ? e3.attributes : void 0);
              }, a3.prototype.copyWithText = function(t4) {
                return new this.constructor(t4, this.attributes);
              }, a3.prototype.copyWithoutText = function() {
                return this.copyWithText(null);
              }, a3.prototype.copyWithAttributes = function(t4) {
                return new this.constructor(this.text, t4);
              }, a3.prototype.copyWithoutAttributes = function() {
                return this.copyWithAttributes(null);
              }, a3.prototype.copyUsingObjectMap = function(t4) {
                var e3;
                return this.copyWithText((e3 = t4.find(this.text)) ? e3 : this.text.copyUsingObjectMap(t4));
              }, a3.prototype.addAttribute = function(t4) {
                var e3;
                return e3 = this.attributes.concat(d2(t4)), this.copyWithAttributes(e3);
              }, a3.prototype.removeAttribute = function(t4) {
                var e3, n4;
                return n4 = i2(t4).listAttribute, e3 = g2(g2(this.attributes, t4), n4), this.copyWithAttributes(e3);
              }, a3.prototype.removeLastAttribute = function() {
                return this.removeAttribute(this.getLastAttribute());
              }, a3.prototype.getLastAttribute = function() {
                return f2(this.attributes);
              }, a3.prototype.getAttributes = function() {
                return this.attributes.slice(0);
              }, a3.prototype.getAttributeLevel = function() {
                return this.attributes.length;
              }, a3.prototype.getAttributeAtLevel = function(t4) {
                return this.attributes[t4 - 1];
              }, a3.prototype.hasAttribute = function(t4) {
                return u2.call(this.attributes, t4) >= 0;
              }, a3.prototype.hasAttributes = function() {
                return this.getAttributeLevel() > 0;
              }, a3.prototype.getLastNestableAttribute = function() {
                return f2(this.getNestableAttributes());
              }, a3.prototype.getNestableAttributes = function() {
                var t4, e3, n4, o3, r3;
                for (o3 = this.attributes, r3 = [], e3 = 0, n4 = o3.length; n4 > e3; e3++)
                  t4 = o3[e3], i2(t4).nestable && r3.push(t4);
                return r3;
              }, a3.prototype.getNestingLevel = function() {
                return this.getNestableAttributes().length;
              }, a3.prototype.decreaseNestingLevel = function() {
                var t4;
                return (t4 = this.getLastNestableAttribute()) ? this.removeAttribute(t4) : this;
              }, a3.prototype.increaseNestingLevel = function() {
                var t4, e3, n4;
                return (t4 = this.getLastNestableAttribute()) ? (n4 = this.attributes.lastIndexOf(t4), e3 = r2.apply(null, [this.attributes, n4 + 1, 0].concat(c2.call(d2(t4)))), this.copyWithAttributes(e3)) : this;
              }, a3.prototype.getListItemAttributes = function() {
                var t4, e3, n4, o3, r3;
                for (o3 = this.attributes, r3 = [], e3 = 0, n4 = o3.length; n4 > e3; e3++)
                  t4 = o3[e3], i2(t4).listAttribute && r3.push(t4);
                return r3;
              }, a3.prototype.isListItem = function() {
                var t4;
                return (t4 = i2(this.getLastAttribute())) != null ? t4.listAttribute : void 0;
              }, a3.prototype.isTerminalBlock = function() {
                var t4;
                return (t4 = i2(this.getLastAttribute())) != null ? t4.terminal : void 0;
              }, a3.prototype.breaksOnReturn = function() {
                var t4;
                return (t4 = i2(this.getLastAttribute())) != null ? t4.breakOnReturn : void 0;
              }, a3.prototype.findLineBreakInDirectionFromPosition = function(t4, e3) {
                var n4, i3;
                return i3 = this.toString(), n4 = function() {
                  switch (t4) {
                    case "forward":
                      return i3.indexOf("\n", e3);
                    case "backward":
                      return i3.slice(0, e3).lastIndexOf("\n");
                  }
                }(), n4 !== -1 ? n4 : void 0;
              }, a3.prototype.contentsForInspection = function() {
                return { text: this.text.inspect(), attributes: this.attributes };
              }, a3.prototype.toString = function() {
                return this.text.toString();
              }, a3.prototype.toJSON = function() {
                return { text: this.text, attributes: this.attributes };
              }, a3.prototype.getDirection = function() {
                return this.text.getDirection();
              }, a3.prototype.isRTL = function() {
                return this.text.isRTL();
              }, a3.prototype.getLength = function() {
                return this.text.getLength();
              }, a3.prototype.canBeConsolidatedWith = function(t4) {
                return !this.hasAttributes() && !t4.hasAttributes() && this.getDirection() === t4.getDirection();
              }, a3.prototype.consolidateWith = function(t4) {
                var n4, i3;
                return n4 = e2.Text.textForStringWithAttributes("\n"), i3 = this.getTextWithoutBlockBreak().appendText(n4), this.copyWithText(i3.appendText(t4.text));
              }, a3.prototype.splitAtOffset = function(t4) {
                var e3, n4;
                return t4 === 0 ? (e3 = null, n4 = this) : t4 === this.getLength() ? (e3 = this, n4 = null) : (e3 = this.copyWithText(this.text.getTextAtRange([0, t4])), n4 = this.copyWithText(this.text.getTextAtRange([t4, this.getLength()]))), [e3, n4];
              }, a3.prototype.getBlockBreakPosition = function() {
                return this.text.getLength() - 1;
              }, a3.prototype.getTextWithoutBlockBreak = function() {
                return m2(this.text) ? this.text.getTextAtRange([0, this.getBlockBreakPosition()]) : this.text.copy();
              }, a3.prototype.canBeGrouped = function(t4) {
                return this.attributes[t4];
              }, a3.prototype.canBeGroupedWith = function(t4, e3) {
                var n4, r3, s3, a4;
                return s3 = t4.getAttributes(), r3 = s3[e3], n4 = this.attributes[e3], !(n4 !== r3 || i2(n4).group === false && (a4 = s3[e3 + 1], u2.call(o2(), a4) < 0) || this.getDirection() !== t4.getDirection() && !t4.isEmpty());
              }, h = function(t4) {
                return t4 = y2(t4), t4 = l2(t4);
              }, y2 = function(t4) {
                var n4, i3, o3, r3, s3, a4;
                return r3 = false, a4 = t4.getPieces(), i3 = 2 <= a4.length ? c2.call(a4, 0, n4 = a4.length - 1) : (n4 = 0, []), o3 = a4[n4++], o3 == null ? t4 : (i3 = function() {
                  var t5, e3, n5;
                  for (n5 = [], t5 = 0, e3 = i3.length; e3 > t5; t5++)
                    s3 = i3[t5], s3.isBlockBreak() ? (r3 = true, n5.push(v2(s3))) : n5.push(s3);
                  return n5;
                }(), r3 ? new e2.Text(c2.call(i3).concat([o3])) : t4);
              }, p2 = e2.Text.textForStringWithAttributes("\n", { blockBreak: true }), l2 = function(t4) {
                return m2(t4) ? t4 : t4.appendText(p2);
              }, m2 = function(t4) {
                var e3, n4;
                return n4 = t4.getLength(), n4 === 0 ? false : (e3 = t4.getTextAtRange([n4 - 1, n4]), e3.isBlockBreak());
              }, v2 = function(t4) {
                return t4.copyWithoutAttribute("blockBreak");
              }, d2 = function(t4) {
                var e3;
                return e3 = i2(t4).listAttribute, e3 != null ? [e3, t4] : [t4];
              }, f2 = function(t4) {
                return t4.slice(-1)[0];
              }, g2 = function(t4, e3) {
                var n4;
                return n4 = t4.lastIndexOf(e3), n4 === -1 ? t4 : r2(t4, n4, 1);
              }, a3;
            }(e2.Object);
          }.call(this), function() {
            var t3, n2, i2, o2 = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var i3 in e3)
                r2.call(e3, i3) && (t4[i3] = e3[i3]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, r2 = {}.hasOwnProperty, s2 = [].indexOf || function(t4) {
              for (var e3 = 0, n3 = this.length; n3 > e3; e3++)
                if (e3 in this && this[e3] === t4)
                  return e3;
              return -1;
            }, a2 = [].slice;
            n2 = e2.tagName, i2 = e2.walkTree, t3 = e2.nodeIsAttachmentElement, e2.HTMLSanitizer = function(r3) {
              function u2(t4, e3) {
                var n3;
                n3 = e3 != null ? e3 : {}, this.allowedAttributes = n3.allowedAttributes, this.forbiddenProtocols = n3.forbiddenProtocols, this.forbiddenElements = n3.forbiddenElements, this.allowedAttributes == null && (this.allowedAttributes = c2), this.forbiddenProtocols == null && (this.forbiddenProtocols = h), this.forbiddenElements == null && (this.forbiddenElements = l2), this.body = p2(t4);
              }
              var c2, l2, h, p2;
              return o2(u2, r3), c2 = "style href src width height class".split(" "), h = "javascript:".split(" "), l2 = "script iframe".split(" "), u2.sanitize = function(t4, e3) {
                var n3;
                return n3 = new this(t4, e3), n3.sanitize(), n3;
              }, u2.prototype.sanitize = function() {
                return this.sanitizeElements(), this.normalizeListElementNesting();
              }, u2.prototype.getHTML = function() {
                return this.body.innerHTML;
              }, u2.prototype.getBody = function() {
                return this.body;
              }, u2.prototype.sanitizeElements = function() {
                var t4, n3, o3, r4, s3;
                for (s3 = i2(this.body), r4 = []; s3.nextNode(); )
                  switch (o3 = s3.currentNode, o3.nodeType) {
                    case Node.ELEMENT_NODE:
                      this.elementIsRemovable(o3) ? r4.push(o3) : this.sanitizeElement(o3);
                      break;
                    case Node.COMMENT_NODE:
                      r4.push(o3);
                  }
                for (t4 = 0, n3 = r4.length; n3 > t4; t4++)
                  o3 = r4[t4], e2.removeNode(o3);
                return this.body;
              }, u2.prototype.sanitizeElement = function(t4) {
                var e3, n3, i3, o3, r4;
                for (t4.hasAttribute("href") && (o3 = t4.protocol, s2.call(this.forbiddenProtocols, o3) >= 0 && t4.removeAttribute("href")), r4 = a2.call(t4.attributes), e3 = 0, n3 = r4.length; n3 > e3; e3++)
                  i3 = r4[e3].name, s2.call(this.allowedAttributes, i3) >= 0 || i3.indexOf("data-trix") === 0 || t4.removeAttribute(i3);
                return t4;
              }, u2.prototype.normalizeListElementNesting = function() {
                var t4, e3, i3, o3, r4;
                for (r4 = a2.call(this.body.querySelectorAll("ul,ol")), t4 = 0, e3 = r4.length; e3 > t4; t4++)
                  i3 = r4[t4], (o3 = i3.previousElementSibling) && n2(o3) === "li" && o3.appendChild(i3);
                return this.body;
              }, u2.prototype.elementIsRemovable = function(t4) {
                return (t4 != null ? t4.nodeType : void 0) === Node.ELEMENT_NODE ? this.elementIsForbidden(t4) || this.elementIsntSerializable(t4) : void 0;
              }, u2.prototype.elementIsForbidden = function(t4) {
                var e3;
                return e3 = n2(t4), s2.call(this.forbiddenElements, e3) >= 0;
              }, u2.prototype.elementIsntSerializable = function(e3) {
                return e3.getAttribute("data-trix-serialize") === "false" && !t3(e3);
              }, p2 = function(t4) {
                var e3, n3, i3, o3, r4;
                for (t4 == null && (t4 = ""), t4 = t4.replace(/<\/html[^>]*>[^]*$/i, "</html>"), e3 = document.implementation.createHTMLDocument(""), e3.documentElement.innerHTML = t4, r4 = e3.head.querySelectorAll("style"), i3 = 0, o3 = r4.length; o3 > i3; i3++)
                  n3 = r4[i3], e3.body.appendChild(n3);
                return e3.body;
              }, u2;
            }(e2.BasicObject);
          }.call(this), function() {
            var t3, n2, i2, o2, r2, s2, a2, u2, c2, l2, h, p2 = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var i3 in e3)
                d2.call(e3, i3) && (t4[i3] = e3[i3]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, d2 = {}.hasOwnProperty, f2 = [].indexOf || function(t4) {
              for (var e3 = 0, n3 = this.length; n3 > e3; e3++)
                if (e3 in this && this[e3] === t4)
                  return e3;
              return -1;
            };
            t3 = e2.arraysAreEqual, s2 = e2.makeElement, l2 = e2.tagName, r2 = e2.getBlockTagNames, h = e2.walkTree, o2 = e2.findClosestElementFromNode, i2 = e2.elementContainsNode, a2 = e2.nodeIsAttachmentElement, u2 = e2.normalizeSpaces, n2 = e2.breakableWhitespacePattern, c2 = e2.squishBreakableWhitespace, e2.HTMLParser = function(d3) {
              function g2(t4, e3) {
                this.html = t4, this.referenceElement = (e3 != null ? e3 : {}).referenceElement, this.blocks = [], this.blockElements = [], this.processedElements = [];
              }
              var m2, v2, y2, b2, A2, C2, x2, w, E, S, R, k2;
              return p2(g2, d3), g2.parse = function(t4, e3) {
                var n3;
                return n3 = new this(t4, e3), n3.parse(), n3;
              }, g2.prototype.getDocument = function() {
                return e2.Document.fromJSON(this.blocks);
              }, g2.prototype.parse = function() {
                var t4, n3;
                try {
                  for (this.createHiddenContainer(), t4 = e2.HTMLSanitizer.sanitize(this.html).getHTML(), this.containerElement.innerHTML = t4, n3 = h(this.containerElement, { usingFilter: x2 }); n3.nextNode(); )
                    this.processNode(n3.currentNode);
                  return this.translateBlockElementMarginsToNewlines();
                } finally {
                  this.removeHiddenContainer();
                }
              }, g2.prototype.createHiddenContainer = function() {
                return this.referenceElement ? (this.containerElement = this.referenceElement.cloneNode(false), this.containerElement.removeAttribute("id"), this.containerElement.setAttribute("data-trix-internal", ""), this.containerElement.style.display = "none", this.referenceElement.parentNode.insertBefore(this.containerElement, this.referenceElement.nextSibling)) : (this.containerElement = s2({ tagName: "div", style: { display: "none" } }), document.body.appendChild(this.containerElement));
              }, g2.prototype.removeHiddenContainer = function() {
                return e2.removeNode(this.containerElement);
              }, x2 = function(t4) {
                return l2(t4) === "style" ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
              }, g2.prototype.processNode = function(t4) {
                switch (t4.nodeType) {
                  case Node.TEXT_NODE:
                    if (!this.isInsignificantTextNode(t4))
                      return this.appendBlockForTextNode(t4), this.processTextNode(t4);
                    break;
                  case Node.ELEMENT_NODE:
                    return this.appendBlockForElement(t4), this.processElement(t4);
                }
              }, g2.prototype.appendBlockForTextNode = function(e3) {
                var n3, i3, o3;
                return i3 = e3.parentNode, i3 === this.currentBlockElement && this.isBlockElement(e3.previousSibling) ? this.appendStringWithAttributes("\n") : i3 !== this.containerElement && !this.isBlockElement(i3) || (n3 = this.getBlockAttributes(i3), t3(n3, (o3 = this.currentBlock) != null ? o3.attributes : void 0)) ? void 0 : (this.currentBlock = this.appendBlockForAttributesWithElement(n3, i3), this.currentBlockElement = i3);
              }, g2.prototype.appendBlockForElement = function(e3) {
                var n3, o3, r3, s3;
                if (r3 = this.isBlockElement(e3), o3 = i2(this.currentBlockElement, e3), r3 && !this.isBlockElement(e3.firstChild)) {
                  if ((!this.isInsignificantTextNode(e3.firstChild) || !this.isBlockElement(e3.firstElementChild)) && (n3 = this.getBlockAttributes(e3), e3.firstChild))
                    return o3 && t3(n3, this.currentBlock.attributes) ? this.appendStringWithAttributes("\n") : (this.currentBlock = this.appendBlockForAttributesWithElement(n3, e3), this.currentBlockElement = e3);
                } else if (this.currentBlockElement && !o3 && !r3)
                  return (s3 = this.findParentBlockElement(e3)) ? this.appendBlockForElement(s3) : (this.currentBlock = this.appendEmptyBlock(), this.currentBlockElement = null);
              }, g2.prototype.findParentBlockElement = function(t4) {
                var e3;
                for (e3 = t4.parentElement; e3 && e3 !== this.containerElement; ) {
                  if (this.isBlockElement(e3) && f2.call(this.blockElements, e3) >= 0)
                    return e3;
                  e3 = e3.parentElement;
                }
                return null;
              }, g2.prototype.processTextNode = function(t4) {
                var e3, n3;
                return n3 = t4.data, v2(t4.parentNode) || (n3 = c2(n3), R((e3 = t4.previousSibling) != null ? e3.textContent : void 0) && (n3 = A2(n3))), this.appendStringWithAttributes(n3, this.getTextAttributes(t4.parentNode));
              }, g2.prototype.processElement = function(t4) {
                var e3, n3, i3, o3, r3;
                if (a2(t4))
                  return e3 = w(t4, "attachment"), Object.keys(e3).length && (o3 = this.getTextAttributes(t4), this.appendAttachmentWithAttributes(e3, o3), t4.innerHTML = ""), this.processedElements.push(t4);
                switch (l2(t4)) {
                  case "br":
                    return this.isExtraBR(t4) || this.isBlockElement(t4.nextSibling) || this.appendStringWithAttributes("\n", this.getTextAttributes(t4)), this.processedElements.push(t4);
                  case "img":
                    e3 = { url: t4.getAttribute("src"), contentType: "image" }, i3 = b2(t4);
                    for (n3 in i3)
                      r3 = i3[n3], e3[n3] = r3;
                    return this.appendAttachmentWithAttributes(e3, this.getTextAttributes(t4)), this.processedElements.push(t4);
                  case "tr":
                    if (t4.parentNode.firstChild !== t4)
                      return this.appendStringWithAttributes("\n");
                    break;
                  case "td":
                    if (t4.parentNode.firstChild !== t4)
                      return this.appendStringWithAttributes(" | ");
                }
              }, g2.prototype.appendBlockForAttributesWithElement = function(t4, e3) {
                var n3;
                return this.blockElements.push(e3), n3 = m2(t4), this.blocks.push(n3), n3;
              }, g2.prototype.appendEmptyBlock = function() {
                return this.appendBlockForAttributesWithElement([], null);
              }, g2.prototype.appendStringWithAttributes = function(t4, e3) {
                return this.appendPiece(S(t4, e3));
              }, g2.prototype.appendAttachmentWithAttributes = function(t4, e3) {
                return this.appendPiece(E(t4, e3));
              }, g2.prototype.appendPiece = function(t4) {
                return this.blocks.length === 0 && this.appendEmptyBlock(), this.blocks[this.blocks.length - 1].text.push(t4);
              }, g2.prototype.appendStringToTextAtIndex = function(t4, e3) {
                var n3, i3;
                return i3 = this.blocks[e3].text, n3 = i3[i3.length - 1], (n3 != null ? n3.type : void 0) === "string" ? n3.string += t4 : i3.push(S(t4));
              }, g2.prototype.prependStringToTextAtIndex = function(t4, e3) {
                var n3, i3;
                return i3 = this.blocks[e3].text, n3 = i3[0], (n3 != null ? n3.type : void 0) === "string" ? n3.string = t4 + n3.string : i3.unshift(S(t4));
              }, S = function(t4, e3) {
                var n3;
                return e3 == null && (e3 = {}), n3 = "string", t4 = u2(t4), { string: t4, attributes: e3, type: n3 };
              }, E = function(t4, e3) {
                var n3;
                return e3 == null && (e3 = {}), n3 = "attachment", { attachment: t4, attributes: e3, type: n3 };
              }, m2 = function(t4) {
                var e3;
                return t4 == null && (t4 = {}), e3 = [], { text: e3, attributes: t4 };
              }, g2.prototype.getTextAttributes = function(t4) {
                var n3, i3, r3, s3, u3, c3, l3, h2, p3, d4, f3, g3;
                r3 = {}, p3 = e2.config.textAttributes;
                for (n3 in p3)
                  if (u3 = p3[n3], u3.tagName && o2(t4, { matchingSelector: u3.tagName, untilNode: this.containerElement }))
                    r3[n3] = true;
                  else if (u3.parser) {
                    if (g3 = u3.parser(t4)) {
                      for (i3 = false, d4 = this.findBlockElementAncestors(t4), c3 = 0, h2 = d4.length; h2 > c3; c3++)
                        if (s3 = d4[c3], u3.parser(s3) === g3) {
                          i3 = true;
                          break;
                        }
                      i3 || (r3[n3] = g3);
                    }
                  } else
                    u3.styleProperty && (g3 = t4.style[u3.styleProperty]) && (r3[n3] = g3);
                if (a2(t4)) {
                  f3 = w(t4, "attributes");
                  for (l3 in f3)
                    g3 = f3[l3], r3[l3] = g3;
                }
                return r3;
              }, g2.prototype.getBlockAttributes = function(t4) {
                var n3, i3, o3, r3;
                for (i3 = []; t4 && t4 !== this.containerElement; ) {
                  r3 = e2.config.blockAttributes;
                  for (n3 in r3)
                    o3 = r3[n3], o3.parse !== false && l2(t4) === o3.tagName && ((typeof o3.test == "function" ? o3.test(t4) : void 0) || !o3.test) && (i3.push(n3), o3.listAttribute && i3.push(o3.listAttribute));
                  t4 = t4.parentNode;
                }
                return i3.reverse();
              }, g2.prototype.findBlockElementAncestors = function(t4) {
                var e3, n3;
                for (e3 = []; t4 && t4 !== this.containerElement; )
                  n3 = l2(t4), f2.call(r2(), n3) >= 0 && e3.push(t4), t4 = t4.parentNode;
                return e3;
              }, w = function(t4, e3) {
                try {
                  return JSON.parse(t4.getAttribute("data-trix-" + e3));
                } catch (n3) {
                  return {};
                }
              }, b2 = function(t4) {
                var e3, n3, i3;
                return i3 = t4.getAttribute("width"), n3 = t4.getAttribute("height"), e3 = {}, i3 && (e3.width = parseInt(i3, 10)), n3 && (e3.height = parseInt(n3, 10)), e3;
              }, g2.prototype.isBlockElement = function(t4) {
                var e3;
                if ((t4 != null ? t4.nodeType : void 0) === Node.ELEMENT_NODE && !a2(t4) && !o2(t4, { matchingSelector: "td", untilNode: this.containerElement }))
                  return e3 = l2(t4), f2.call(r2(), e3) >= 0 || window.getComputedStyle(t4).display === "block";
              }, g2.prototype.isInsignificantTextNode = function(t4) {
                var e3, n3, i3;
                if ((t4 != null ? t4.nodeType : void 0) === Node.TEXT_NODE && k2(t4.data) && (n3 = t4.parentNode, i3 = t4.previousSibling, e3 = t4.nextSibling, (!C2(n3.previousSibling) || this.isBlockElement(n3.previousSibling)) && !v2(n3)))
                  return !i3 || this.isBlockElement(i3) || !e3 || this.isBlockElement(e3);
              }, g2.prototype.isExtraBR = function(t4) {
                return l2(t4) === "br" && this.isBlockElement(t4.parentNode) && t4.parentNode.lastChild === t4;
              }, v2 = function(t4) {
                var e3;
                return e3 = window.getComputedStyle(t4).whiteSpace, e3 === "pre" || e3 === "pre-wrap" || e3 === "pre-line";
              }, C2 = function(t4) {
                return t4 && !R(t4.textContent);
              }, g2.prototype.translateBlockElementMarginsToNewlines = function() {
                var t4, e3, n3, i3, o3, r3, s3, a3;
                for (e3 = this.getMarginOfDefaultBlockElement(), s3 = this.blocks, a3 = [], i3 = n3 = 0, o3 = s3.length; o3 > n3; i3 = ++n3)
                  t4 = s3[i3], (r3 = this.getMarginOfBlockElementAtIndex(i3)) && (r3.top > 2 * e3.top && this.prependStringToTextAtIndex("\n", i3), a3.push(r3.bottom > 2 * e3.bottom ? this.appendStringToTextAtIndex("\n", i3) : void 0));
                return a3;
              }, g2.prototype.getMarginOfBlockElementAtIndex = function(t4) {
                var e3, n3;
                return !(e3 = this.blockElements[t4]) || !e3.textContent || (n3 = l2(e3), f2.call(r2(), n3) >= 0 || f2.call(this.processedElements, e3) >= 0) ? void 0 : y2(e3);
              }, g2.prototype.getMarginOfDefaultBlockElement = function() {
                var t4;
                return t4 = s2(e2.config.blockAttributes["default"].tagName), this.containerElement.appendChild(t4), y2(t4);
              }, y2 = function(t4) {
                var e3;
                return e3 = window.getComputedStyle(t4), e3.display === "block" ? { top: parseInt(e3.marginTop), bottom: parseInt(e3.marginBottom) } : void 0;
              }, A2 = function(t4) {
                return t4.replace(RegExp("^" + n2.source + "+"), "");
              }, k2 = function(t4) {
                return RegExp("^" + n2.source + "*$").test(t4);
              }, R = function(t4) {
                return /\s$/.test(t4);
              }, g2;
            }(e2.BasicObject);
          }.call(this), function() {
            var t3, n2, i2, o2, r2 = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var i3 in e3)
                s2.call(e3, i3) && (t4[i3] = e3[i3]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, s2 = {}.hasOwnProperty, a2 = [].slice, u2 = [].indexOf || function(t4) {
              for (var e3 = 0, n3 = this.length; n3 > e3; e3++)
                if (e3 in this && this[e3] === t4)
                  return e3;
              return -1;
            };
            t3 = e2.arraysAreEqual, i2 = e2.normalizeRange, o2 = e2.rangeIsCollapsed, n2 = e2.getBlockConfig, e2.Document = function(s3) {
              function c2(t4) {
                t4 == null && (t4 = []), c2.__super__.constructor.apply(this, arguments), t4.length === 0 && (t4 = [new e2.Block()]), this.blockList = e2.SplittableList.box(t4);
              }
              var l2;
              return r2(c2, s3), c2.fromJSON = function(t4) {
                var n3, i3;
                return i3 = function() {
                  var i4, o3, r3;
                  for (r3 = [], i4 = 0, o3 = t4.length; o3 > i4; i4++)
                    n3 = t4[i4], r3.push(e2.Block.fromJSON(n3));
                  return r3;
                }(), new this(i3);
              }, c2.fromHTML = function(t4, n3) {
                return e2.HTMLParser.parse(t4, n3).getDocument();
              }, c2.fromString = function(t4, n3) {
                var i3;
                return i3 = e2.Text.textForStringWithAttributes(t4, n3), new this([new e2.Block(i3)]);
              }, c2.prototype.isEmpty = function() {
                var t4;
                return this.blockList.length === 1 && (t4 = this.getBlockAtIndex(0), t4.isEmpty() && !t4.hasAttributes());
              }, c2.prototype.copy = function(t4) {
                var e3;
                return t4 == null && (t4 = {}), e3 = t4.consolidateBlocks ? this.blockList.consolidate().toArray() : this.blockList.toArray(), new this.constructor(e3);
              }, c2.prototype.copyUsingObjectsFromDocument = function(t4) {
                var n3;
                return n3 = new e2.ObjectMap(t4.getObjects()), this.copyUsingObjectMap(n3);
              }, c2.prototype.copyUsingObjectMap = function(t4) {
                var e3, n3, i3;
                return n3 = function() {
                  var n4, o3, r3, s4;
                  for (r3 = this.getBlocks(), s4 = [], n4 = 0, o3 = r3.length; o3 > n4; n4++)
                    e3 = r3[n4], s4.push((i3 = t4.find(e3)) ? i3 : e3.copyUsingObjectMap(t4));
                  return s4;
                }.call(this), new this.constructor(n3);
              }, c2.prototype.copyWithBaseBlockAttributes = function(t4) {
                var e3, n3, i3;
                return t4 == null && (t4 = []), i3 = function() {
                  var i4, o3, r3, s4;
                  for (r3 = this.getBlocks(), s4 = [], i4 = 0, o3 = r3.length; o3 > i4; i4++)
                    n3 = r3[i4], e3 = t4.concat(n3.getAttributes()), s4.push(n3.copyWithAttributes(e3));
                  return s4;
                }.call(this), new this.constructor(i3);
              }, c2.prototype.replaceBlock = function(t4, e3) {
                var n3;
                return n3 = this.blockList.indexOf(t4), n3 === -1 ? this : new this.constructor(this.blockList.replaceObjectAtIndex(e3, n3));
              }, c2.prototype.insertDocumentAtRange = function(t4, e3) {
                var n3, r3, s4, a3, u3, c3, l3;
                return r3 = t4.blockList, u3 = (e3 = i2(e3))[0], c3 = this.locationFromPosition(u3), s4 = c3.index, a3 = c3.offset, l3 = this, n3 = this.getBlockAtPosition(u3), o2(e3) && n3.isEmpty() && !n3.hasAttributes() ? l3 = new this.constructor(l3.blockList.removeObjectAtIndex(s4)) : n3.getBlockBreakPosition() === a3 && u3++, l3 = l3.removeTextAtRange(e3), new this.constructor(l3.blockList.insertSplittableListAtPosition(r3, u3));
              }, c2.prototype.mergeDocumentAtRange = function(e3, n3) {
                var o3, r3, s4, a3, u3, c3, l3, h, p2, d2, f2, g2;
                return f2 = (n3 = i2(n3))[0], d2 = this.locationFromPosition(f2), r3 = this.getBlockAtIndex(d2.index).getAttributes(), o3 = e3.getBaseBlockAttributes(), g2 = r3.slice(-o3.length), t3(o3, g2) ? (l3 = r3.slice(0, -o3.length), c3 = e3.copyWithBaseBlockAttributes(l3)) : c3 = e3.copy({ consolidateBlocks: true }).copyWithBaseBlockAttributes(r3), s4 = c3.getBlockCount(), a3 = c3.getBlockAtIndex(0), t3(r3, a3.getAttributes()) ? (u3 = a3.getTextWithoutBlockBreak(), p2 = this.insertTextAtRange(u3, n3), s4 > 1 && (c3 = new this.constructor(c3.getBlocks().slice(1)), h = f2 + u3.getLength(), p2 = p2.insertDocumentAtRange(c3, h))) : p2 = this.insertDocumentAtRange(c3, n3), p2;
              }, c2.prototype.insertTextAtRange = function(t4, e3) {
                var n3, o3, r3, s4, a3;
                return a3 = (e3 = i2(e3))[0], s4 = this.locationFromPosition(a3), o3 = s4.index, r3 = s4.offset, n3 = this.removeTextAtRange(e3), new this.constructor(n3.blockList.editObjectAtIndex(o3, function(e4) {
                  return e4.copyWithText(e4.text.insertTextAtPosition(t4, r3));
                }));
              }, c2.prototype.removeTextAtRange = function(t4) {
                var e3, n3, r3, s4, a3, u3, c3, l3, h, p2, d2, f2, g2, m2, v2, y2, b2, A2, C2, x2, w;
                return p2 = t4 = i2(t4), l3 = p2[0], A2 = p2[1], o2(t4) ? this : (d2 = this.locationRangeFromRange(t4), u3 = d2[0], y2 = d2[1], a3 = u3.index, c3 = u3.offset, s4 = this.getBlockAtIndex(a3), v2 = y2.index, b2 = y2.offset, m2 = this.getBlockAtIndex(v2), f2 = A2 - l3 === 1 && s4.getBlockBreakPosition() === c3 && m2.getBlockBreakPosition() !== b2 && m2.text.getStringAtPosition(b2) === "\n", f2 ? r3 = this.blockList.editObjectAtIndex(v2, function(t5) {
                  return t5.copyWithText(t5.text.removeTextAtRange([b2, b2 + 1]));
                }) : (h = s4.text.getTextAtRange([0, c3]), C2 = m2.text.getTextAtRange([b2, m2.getLength()]), x2 = h.appendText(C2), g2 = a3 !== v2 && c3 === 0, w = g2 && s4.getAttributeLevel() >= m2.getAttributeLevel(), n3 = w ? m2.copyWithText(x2) : s4.copyWithText(x2), e3 = v2 + 1 - a3, r3 = this.blockList.splice(a3, e3, n3)), new this.constructor(r3));
              }, c2.prototype.moveTextFromRangeToPosition = function(t4, e3) {
                var n3, o3, r3, s4, u3, c3, l3, h, p2, d2;
                return c3 = t4 = i2(t4), p2 = c3[0], r3 = c3[1], e3 >= p2 && r3 >= e3 ? this : (o3 = this.getDocumentAtRange(t4), h = this.removeTextAtRange(t4), u3 = e3 > p2, u3 && (e3 -= o3.getLength()), l3 = o3.getBlocks(), s4 = l3[0], n3 = 2 <= l3.length ? a2.call(l3, 1) : [], n3.length === 0 ? (d2 = s4.getTextWithoutBlockBreak(), u3 && (e3 += 1)) : d2 = s4.text, h = h.insertTextAtRange(d2, e3), n3.length === 0 ? h : (o3 = new this.constructor(n3), e3 += d2.getLength(), h.insertDocumentAtRange(o3, e3)));
              }, c2.prototype.addAttributeAtRange = function(t4, e3, i3) {
                var o3;
                return o3 = this.blockList, this.eachBlockAtRange(i3, function(i4, r3, s4) {
                  return o3 = o3.editObjectAtIndex(s4, function() {
                    return n2(t4) ? i4.addAttribute(t4, e3) : r3[0] === r3[1] ? i4 : i4.copyWithText(i4.text.addAttributeAtRange(t4, e3, r3));
                  });
                }), new this.constructor(o3);
              }, c2.prototype.addAttribute = function(t4, e3) {
                var n3;
                return n3 = this.blockList, this.eachBlock(function(i3, o3) {
                  return n3 = n3.editObjectAtIndex(o3, function() {
                    return i3.addAttribute(t4, e3);
                  });
                }), new this.constructor(n3);
              }, c2.prototype.removeAttributeAtRange = function(t4, e3) {
                var i3;
                return i3 = this.blockList, this.eachBlockAtRange(e3, function(e4, o3, r3) {
                  return n2(t4) ? i3 = i3.editObjectAtIndex(r3, function() {
                    return e4.removeAttribute(t4);
                  }) : o3[0] !== o3[1] ? i3 = i3.editObjectAtIndex(r3, function() {
                    return e4.copyWithText(e4.text.removeAttributeAtRange(t4, o3));
                  }) : void 0;
                }), new this.constructor(i3);
              }, c2.prototype.updateAttributesForAttachment = function(t4, e3) {
                var n3, i3, o3, r3;
                return o3 = (i3 = this.getRangeOfAttachment(e3))[0], n3 = this.locationFromPosition(o3).index, r3 = this.getTextAtIndex(n3), new this.constructor(this.blockList.editObjectAtIndex(n3, function(n4) {
                  return n4.copyWithText(r3.updateAttributesForAttachment(t4, e3));
                }));
              }, c2.prototype.removeAttributeForAttachment = function(t4, e3) {
                var n3;
                return n3 = this.getRangeOfAttachment(e3), this.removeAttributeAtRange(t4, n3);
              }, c2.prototype.insertBlockBreakAtRange = function(t4) {
                var n3, o3, r3, s4;
                return s4 = (t4 = i2(t4))[0], r3 = this.locationFromPosition(s4).offset, o3 = this.removeTextAtRange(t4), r3 === 0 && (n3 = [new e2.Block()]), new this.constructor(o3.blockList.insertSplittableListAtPosition(new e2.SplittableList(n3), s4));
              }, c2.prototype.applyBlockAttributeAtRange = function(t4, e3, i3) {
                var o3, r3, s4, a3;
                return s4 = this.expandRangeToLineBreaksAndSplitBlocks(i3), r3 = s4.document, i3 = s4.range, o3 = n2(t4), o3.listAttribute ? (r3 = r3.removeLastListAttributeAtRange(i3, { exceptAttributeName: t4 }), a3 = r3.convertLineBreaksToBlockBreaksInRange(i3), r3 = a3.document, i3 = a3.range) : r3 = o3.exclusive ? r3.removeBlockAttributesAtRange(i3) : o3.terminal ? r3.removeLastTerminalAttributeAtRange(i3) : r3.consolidateBlocksAtRange(i3), r3.addAttributeAtRange(t4, e3, i3);
              }, c2.prototype.removeLastListAttributeAtRange = function(t4, e3) {
                var i3;
                return e3 == null && (e3 = {}), i3 = this.blockList, this.eachBlockAtRange(t4, function(t5, o3, r3) {
                  var s4;
                  if ((s4 = t5.getLastAttribute()) && n2(s4).listAttribute && s4 !== e3.exceptAttributeName)
                    return i3 = i3.editObjectAtIndex(r3, function() {
                      return t5.removeAttribute(s4);
                    });
                }), new this.constructor(i3);
              }, c2.prototype.removeLastTerminalAttributeAtRange = function(t4) {
                var e3;
                return e3 = this.blockList, this.eachBlockAtRange(t4, function(t5, i3, o3) {
                  var r3;
                  if ((r3 = t5.getLastAttribute()) && n2(r3).terminal)
                    return e3 = e3.editObjectAtIndex(o3, function() {
                      return t5.removeAttribute(r3);
                    });
                }), new this.constructor(e3);
              }, c2.prototype.removeBlockAttributesAtRange = function(t4) {
                var e3;
                return e3 = this.blockList, this.eachBlockAtRange(t4, function(t5, n3, i3) {
                  return t5.hasAttributes() ? e3 = e3.editObjectAtIndex(i3, function() {
                    return t5.copyWithoutAttributes();
                  }) : void 0;
                }), new this.constructor(e3);
              }, c2.prototype.expandRangeToLineBreaksAndSplitBlocks = function(t4) {
                var e3, n3, o3, r3, s4, a3, u3, c3, l3;
                return a3 = t4 = i2(t4), l3 = a3[0], r3 = a3[1], c3 = this.locationFromPosition(l3), o3 = this.locationFromPosition(r3), e3 = this, u3 = e3.getBlockAtIndex(c3.index), (c3.offset = u3.findLineBreakInDirectionFromPosition("backward", c3.offset)) != null && (s4 = e3.positionFromLocation(c3), e3 = e3.insertBlockBreakAtRange([s4, s4 + 1]), o3.index += 1, o3.offset -= e3.getBlockAtIndex(c3.index).getLength(), c3.index += 1), c3.offset = 0, o3.offset === 0 && o3.index > c3.index ? (o3.index -= 1, o3.offset = e3.getBlockAtIndex(o3.index).getBlockBreakPosition()) : (n3 = e3.getBlockAtIndex(o3.index), n3.text.getStringAtRange([o3.offset - 1, o3.offset]) === "\n" ? o3.offset -= 1 : o3.offset = n3.findLineBreakInDirectionFromPosition("forward", o3.offset), o3.offset !== n3.getBlockBreakPosition() && (s4 = e3.positionFromLocation(o3), e3 = e3.insertBlockBreakAtRange([s4, s4 + 1]))), l3 = e3.positionFromLocation(c3), r3 = e3.positionFromLocation(o3), t4 = i2([l3, r3]), { document: e3, range: t4 };
              }, c2.prototype.convertLineBreaksToBlockBreaksInRange = function(t4) {
                var e3, n3, o3;
                return n3 = (t4 = i2(t4))[0], o3 = this.getStringAtRange(t4).slice(0, -1), e3 = this, o3.replace(/.*?\n/g, function(t5) {
                  return n3 += t5.length, e3 = e3.insertBlockBreakAtRange([n3 - 1, n3]);
                }), { document: e3, range: t4 };
              }, c2.prototype.consolidateBlocksAtRange = function(t4) {
                var e3, n3, o3, r3, s4;
                return o3 = t4 = i2(t4), s4 = o3[0], n3 = o3[1], r3 = this.locationFromPosition(s4).index, e3 = this.locationFromPosition(n3).index, new this.constructor(this.blockList.consolidateFromIndexToIndex(r3, e3));
              }, c2.prototype.getDocumentAtRange = function(t4) {
                var e3;
                return t4 = i2(t4), e3 = this.blockList.getSplittableListInRange(t4).toArray(), new this.constructor(e3);
              }, c2.prototype.getStringAtRange = function(t4) {
                var e3, n3, o3;
                return o3 = t4 = i2(t4), n3 = o3[o3.length - 1], n3 !== this.getLength() && (e3 = -1), this.getDocumentAtRange(t4).toString().slice(0, e3);
              }, c2.prototype.getBlockAtIndex = function(t4) {
                return this.blockList.getObjectAtIndex(t4);
              }, c2.prototype.getBlockAtPosition = function(t4) {
                var e3;
                return e3 = this.locationFromPosition(t4).index, this.getBlockAtIndex(e3);
              }, c2.prototype.getTextAtIndex = function(t4) {
                var e3;
                return (e3 = this.getBlockAtIndex(t4)) != null ? e3.text : void 0;
              }, c2.prototype.getTextAtPosition = function(t4) {
                var e3;
                return e3 = this.locationFromPosition(t4).index, this.getTextAtIndex(e3);
              }, c2.prototype.getPieceAtPosition = function(t4) {
                var e3, n3, i3;
                return i3 = this.locationFromPosition(t4), e3 = i3.index, n3 = i3.offset, this.getTextAtIndex(e3).getPieceAtPosition(n3);
              }, c2.prototype.getCharacterAtPosition = function(t4) {
                var e3, n3, i3;
                return i3 = this.locationFromPosition(t4), e3 = i3.index, n3 = i3.offset, this.getTextAtIndex(e3).getStringAtRange([n3, n3 + 1]);
              }, c2.prototype.getLength = function() {
                return this.blockList.getEndPosition();
              }, c2.prototype.getBlocks = function() {
                return this.blockList.toArray();
              }, c2.prototype.getBlockCount = function() {
                return this.blockList.length;
              }, c2.prototype.getEditCount = function() {
                return this.editCount;
              }, c2.prototype.eachBlock = function(t4) {
                return this.blockList.eachObject(t4);
              }, c2.prototype.eachBlockAtRange = function(t4, e3) {
                var n3, o3, r3, s4, a3, u3, c3, l3, h, p2, d2, f2;
                if (u3 = t4 = i2(t4), d2 = u3[0], r3 = u3[1], p2 = this.locationFromPosition(d2), o3 = this.locationFromPosition(r3), p2.index === o3.index)
                  return n3 = this.getBlockAtIndex(p2.index), f2 = [p2.offset, o3.offset], e3(n3, f2, p2.index);
                for (h = [], a3 = s4 = c3 = p2.index, l3 = o3.index; l3 >= c3 ? l3 >= s4 : s4 >= l3; a3 = l3 >= c3 ? ++s4 : --s4)
                  (n3 = this.getBlockAtIndex(a3)) ? (f2 = function() {
                    switch (a3) {
                      case p2.index:
                        return [p2.offset, n3.text.getLength()];
                      case o3.index:
                        return [0, o3.offset];
                      default:
                        return [0, n3.text.getLength()];
                    }
                  }(), h.push(e3(n3, f2, a3))) : h.push(void 0);
                return h;
              }, c2.prototype.getCommonAttributesAtRange = function(t4) {
                var n3, r3, s4;
                return r3 = (t4 = i2(t4))[0], o2(t4) ? this.getCommonAttributesAtPosition(r3) : (s4 = [], n3 = [], this.eachBlockAtRange(t4, function(t5, e3) {
                  return e3[0] !== e3[1] ? (s4.push(t5.text.getCommonAttributesAtRange(e3)), n3.push(l2(t5))) : void 0;
                }), e2.Hash.fromCommonAttributesOfObjects(s4).merge(e2.Hash.fromCommonAttributesOfObjects(n3)).toObject());
              }, c2.prototype.getCommonAttributesAtPosition = function(t4) {
                var n3, i3, o3, r3, s4, a3, c3, h, p2, d2;
                if (p2 = this.locationFromPosition(t4), s4 = p2.index, h = p2.offset, o3 = this.getBlockAtIndex(s4), !o3)
                  return {};
                r3 = l2(o3), n3 = o3.text.getAttributesAtPosition(h), i3 = o3.text.getAttributesAtPosition(h - 1), a3 = function() {
                  var t5, n4;
                  t5 = e2.config.textAttributes, n4 = [];
                  for (c3 in t5)
                    d2 = t5[c3], d2.inheritable && n4.push(c3);
                  return n4;
                }();
                for (c3 in i3)
                  d2 = i3[c3], (d2 === n3[c3] || u2.call(a3, c3) >= 0) && (r3[c3] = d2);
                return r3;
              }, c2.prototype.getRangeOfCommonAttributeAtPosition = function(t4, e3) {
                var n3, o3, r3, s4, a3, u3, c3, l3, h;
                return a3 = this.locationFromPosition(e3), r3 = a3.index, s4 = a3.offset, h = this.getTextAtIndex(r3), u3 = h.getExpandedRangeForAttributeAtOffset(t4, s4), l3 = u3[0], o3 = u3[1], c3 = this.positionFromLocation({ index: r3, offset: l3 }), n3 = this.positionFromLocation({ index: r3, offset: o3 }), i2([c3, n3]);
              }, c2.prototype.getBaseBlockAttributes = function() {
                var t4, e3, n3, i3, o3, r3, s4;
                for (t4 = this.getBlockAtIndex(0).getAttributes(), n3 = i3 = 1, s4 = this.getBlockCount(); s4 >= 1 ? s4 > i3 : i3 > s4; n3 = s4 >= 1 ? ++i3 : --i3)
                  e3 = this.getBlockAtIndex(n3).getAttributes(), r3 = Math.min(t4.length, e3.length), t4 = function() {
                    var n4, i4, s5;
                    for (s5 = [], o3 = n4 = 0, i4 = r3; (i4 >= 0 ? i4 > n4 : n4 > i4) && e3[o3] === t4[o3]; o3 = i4 >= 0 ? ++n4 : --n4)
                      s5.push(e3[o3]);
                    return s5;
                  }();
                return t4;
              }, l2 = function(t4) {
                var e3, n3;
                return n3 = {}, (e3 = t4.getLastAttribute()) && (n3[e3] = true), n3;
              }, c2.prototype.getAttachmentById = function(t4) {
                var e3, n3, i3, o3;
                for (o3 = this.getAttachments(), n3 = 0, i3 = o3.length; i3 > n3; n3++)
                  if (e3 = o3[n3], e3.id === t4)
                    return e3;
              }, c2.prototype.getAttachmentPieces = function() {
                var t4;
                return t4 = [], this.blockList.eachObject(function(e3) {
                  var n3;
                  return n3 = e3.text, t4 = t4.concat(n3.getAttachmentPieces());
                }), t4;
              }, c2.prototype.getAttachments = function() {
                var t4, e3, n3, i3, o3;
                for (i3 = this.getAttachmentPieces(), o3 = [], t4 = 0, e3 = i3.length; e3 > t4; t4++)
                  n3 = i3[t4], o3.push(n3.attachment);
                return o3;
              }, c2.prototype.getRangeOfAttachment = function(t4) {
                var e3, n3, o3, r3, s4, a3, u3;
                for (r3 = 0, s4 = this.blockList.toArray(), n3 = e3 = 0, o3 = s4.length; o3 > e3; n3 = ++e3) {
                  if (a3 = s4[n3].text, u3 = a3.getRangeOfAttachment(t4))
                    return i2([r3 + u3[0], r3 + u3[1]]);
                  r3 += a3.getLength();
                }
              }, c2.prototype.getLocationRangeOfAttachment = function(t4) {
                var e3;
                return e3 = this.getRangeOfAttachment(t4), this.locationRangeFromRange(e3);
              }, c2.prototype.getAttachmentPieceForAttachment = function(t4) {
                var e3, n3, i3, o3;
                for (o3 = this.getAttachmentPieces(), e3 = 0, n3 = o3.length; n3 > e3; e3++)
                  if (i3 = o3[e3], i3.attachment === t4)
                    return i3;
              }, c2.prototype.findRangesForBlockAttribute = function(t4) {
                var e3, n3, i3, o3, r3, s4, a3;
                for (r3 = 0, s4 = [], a3 = this.getBlocks(), n3 = 0, i3 = a3.length; i3 > n3; n3++)
                  e3 = a3[n3], o3 = e3.getLength(), e3.hasAttribute(t4) && s4.push([r3, r3 + o3]), r3 += o3;
                return s4;
              }, c2.prototype.findRangesForTextAttribute = function(t4, e3) {
                var n3, i3, o3, r3, s4, a3, u3, c3, l3, h;
                for (h = (e3 != null ? e3 : {}).withValue, a3 = 0, u3 = [], c3 = [], r3 = function(e4) {
                  return h != null ? e4.getAttribute(t4) === h : e4.hasAttribute(t4);
                }, l3 = this.getPieces(), n3 = 0, i3 = l3.length; i3 > n3; n3++)
                  s4 = l3[n3], o3 = s4.getLength(), r3(s4) && (u3[1] === a3 ? u3[1] = a3 + o3 : c3.push(u3 = [a3, a3 + o3])), a3 += o3;
                return c3;
              }, c2.prototype.locationFromPosition = function(t4) {
                var e3, n3;
                return n3 = this.blockList.findIndexAndOffsetAtPosition(Math.max(0, t4)), n3.index != null ? n3 : (e3 = this.getBlocks(), { index: e3.length - 1, offset: e3[e3.length - 1].getLength() });
              }, c2.prototype.positionFromLocation = function(t4) {
                return this.blockList.findPositionAtIndexAndOffset(t4.index, t4.offset);
              }, c2.prototype.locationRangeFromPosition = function(t4) {
                return i2(this.locationFromPosition(t4));
              }, c2.prototype.locationRangeFromRange = function(t4) {
                var e3, n3, o3, r3;
                if (t4 = i2(t4))
                  return r3 = t4[0], n3 = t4[1], o3 = this.locationFromPosition(r3), e3 = this.locationFromPosition(n3), i2([o3, e3]);
              }, c2.prototype.rangeFromLocationRange = function(t4) {
                var e3, n3;
                return t4 = i2(t4), e3 = this.positionFromLocation(t4[0]), o2(t4) || (n3 = this.positionFromLocation(t4[1])), i2([e3, n3]);
              }, c2.prototype.isEqualTo = function(t4) {
                return this.blockList.isEqualTo(t4 != null ? t4.blockList : void 0);
              }, c2.prototype.getTexts = function() {
                var t4, e3, n3, i3, o3;
                for (i3 = this.getBlocks(), o3 = [], e3 = 0, n3 = i3.length; n3 > e3; e3++)
                  t4 = i3[e3], o3.push(t4.text);
                return o3;
              }, c2.prototype.getPieces = function() {
                var t4, e3, n3, i3, o3;
                for (n3 = [], i3 = this.getTexts(), t4 = 0, e3 = i3.length; e3 > t4; t4++)
                  o3 = i3[t4], n3.push.apply(n3, o3.getPieces());
                return n3;
              }, c2.prototype.getObjects = function() {
                return this.getBlocks().concat(this.getTexts()).concat(this.getPieces());
              }, c2.prototype.toSerializableDocument = function() {
                var t4;
                return t4 = [], this.blockList.eachObject(function(e3) {
                  return t4.push(e3.copyWithText(e3.text.toSerializableText()));
                }), new this.constructor(t4);
              }, c2.prototype.toString = function() {
                return this.blockList.toString();
              }, c2.prototype.toJSON = function() {
                return this.blockList.toJSON();
              }, c2.prototype.toConsole = function() {
                var t4;
                return JSON.stringify(function() {
                  var e3, n3, i3, o3;
                  for (i3 = this.blockList.toArray(), o3 = [], e3 = 0, n3 = i3.length; n3 > e3; e3++)
                    t4 = i3[e3], o3.push(JSON.parse(t4.text.toConsole()));
                  return o3;
                }.call(this));
              }, c2;
            }(e2.Object);
          }.call(this), function() {
            e2.LineBreakInsertion = function() {
              function t3(t4) {
                var e3;
                this.composition = t4, this.document = this.composition.document, e3 = this.composition.getSelectedRange(), this.startPosition = e3[0], this.endPosition = e3[1], this.startLocation = this.document.locationFromPosition(this.startPosition), this.endLocation = this.document.locationFromPosition(this.endPosition), this.block = this.document.getBlockAtIndex(this.endLocation.index), this.breaksOnReturn = this.block.breaksOnReturn(), this.previousCharacter = this.block.text.getStringAtPosition(this.endLocation.offset - 1), this.nextCharacter = this.block.text.getStringAtPosition(this.endLocation.offset);
              }
              return t3.prototype.shouldInsertBlockBreak = function() {
                return this.block.hasAttributes() && this.block.isListItem() && !this.block.isEmpty() ? this.startLocation.offset !== 0 : this.breaksOnReturn && this.nextCharacter !== "\n";
              }, t3.prototype.shouldBreakFormattedBlock = function() {
                return this.block.hasAttributes() && !this.block.isListItem() && (this.breaksOnReturn && this.nextCharacter === "\n" || this.previousCharacter === "\n");
              }, t3.prototype.shouldDecreaseListLevel = function() {
                return this.block.hasAttributes() && this.block.isListItem() && this.block.isEmpty();
              }, t3.prototype.shouldPrependListItem = function() {
                return this.block.isListItem() && this.startLocation.offset === 0 && !this.block.isEmpty();
              }, t3.prototype.shouldRemoveLastBlockAttribute = function() {
                return this.block.hasAttributes() && !this.block.isListItem() && this.block.isEmpty();
              }, t3;
            }();
          }.call(this), function() {
            var t3, n2, i2, o2, r2, s2, a2, u2, c2, l2, h = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var i3 in e3)
                p2.call(e3, i3) && (t4[i3] = e3[i3]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, p2 = {}.hasOwnProperty;
            s2 = e2.normalizeRange, c2 = e2.rangesAreEqual, u2 = e2.rangeIsCollapsed, a2 = e2.objectsAreEqual, t3 = e2.arrayStartsWith, l2 = e2.summarizeArrayChange, i2 = e2.getAllAttributeNames, o2 = e2.getBlockConfig, r2 = e2.getTextConfig, n2 = e2.extend, e2.Composition = function(p3) {
              function d2() {
                this.document = new e2.Document(), this.attachments = [], this.currentAttributes = {}, this.revision = 0;
              }
              var f2;
              return h(d2, p3), d2.prototype.setDocument = function(t4) {
                var e3;
                return t4.isEqualTo(this.document) ? void 0 : (this.document = t4, this.refreshAttachments(), this.revision++, (e3 = this.delegate) != null && typeof e3.compositionDidChangeDocument == "function" ? e3.compositionDidChangeDocument(t4) : void 0);
              }, d2.prototype.getSnapshot = function() {
                return { document: this.document, selectedRange: this.getSelectedRange() };
              }, d2.prototype.loadSnapshot = function(t4) {
                var n3, i3, o3, r3;
                return n3 = t4.document, r3 = t4.selectedRange, (i3 = this.delegate) != null && typeof i3.compositionWillLoadSnapshot == "function" && i3.compositionWillLoadSnapshot(), this.setDocument(n3 != null ? n3 : new e2.Document()), this.setSelection(r3 != null ? r3 : [0, 0]), (o3 = this.delegate) != null && typeof o3.compositionDidLoadSnapshot == "function" ? o3.compositionDidLoadSnapshot() : void 0;
              }, d2.prototype.insertText = function(t4, e3) {
                var n3, i3, o3, r3;
                return r3 = (e3 != null ? e3 : { updatePosition: true }).updatePosition, i3 = this.getSelectedRange(), this.setDocument(this.document.insertTextAtRange(t4, i3)), o3 = i3[0], n3 = o3 + t4.getLength(), r3 && this.setSelection(n3), this.notifyDelegateOfInsertionAtRange([o3, n3]);
              }, d2.prototype.insertBlock = function(t4) {
                var n3;
                return t4 == null && (t4 = new e2.Block()), n3 = new e2.Document([t4]), this.insertDocument(n3);
              }, d2.prototype.insertDocument = function(t4) {
                var n3, i3, o3;
                return t4 == null && (t4 = new e2.Document()), i3 = this.getSelectedRange(), this.setDocument(this.document.insertDocumentAtRange(t4, i3)), o3 = i3[0], n3 = o3 + t4.getLength(), this.setSelection(n3), this.notifyDelegateOfInsertionAtRange([o3, n3]);
              }, d2.prototype.insertString = function(t4, n3) {
                var i3, o3;
                return i3 = this.getCurrentTextAttributes(), o3 = e2.Text.textForStringWithAttributes(t4, i3), this.insertText(o3, n3);
              }, d2.prototype.insertBlockBreak = function() {
                var t4, e3, n3;
                return e3 = this.getSelectedRange(), this.setDocument(this.document.insertBlockBreakAtRange(e3)), n3 = e3[0], t4 = n3 + 1, this.setSelection(t4), this.notifyDelegateOfInsertionAtRange([n3, t4]);
              }, d2.prototype.insertLineBreak = function() {
                var t4, n3;
                return n3 = new e2.LineBreakInsertion(this), n3.shouldDecreaseListLevel() ? (this.decreaseListLevel(), this.setSelection(n3.startPosition)) : n3.shouldPrependListItem() ? (t4 = new e2.Document([n3.block.copyWithoutText()]), this.insertDocument(t4)) : n3.shouldInsertBlockBreak() ? this.insertBlockBreak() : n3.shouldRemoveLastBlockAttribute() ? this.removeLastBlockAttribute() : n3.shouldBreakFormattedBlock() ? this.breakFormattedBlock(n3) : this.insertString("\n");
              }, d2.prototype.insertHTML = function(t4) {
                var n3, i3, o3, r3;
                return n3 = e2.Document.fromHTML(t4), o3 = this.getSelectedRange(), this.setDocument(this.document.mergeDocumentAtRange(n3, o3)), r3 = o3[0], i3 = r3 + n3.getLength() - 1, this.setSelection(i3), this.notifyDelegateOfInsertionAtRange([r3, i3]);
              }, d2.prototype.replaceHTML = function(t4) {
                var n3, i3, o3;
                return n3 = e2.Document.fromHTML(t4).copyUsingObjectsFromDocument(this.document), i3 = this.getLocationRange({ strict: false }), o3 = this.document.rangeFromLocationRange(i3), this.setDocument(n3), this.setSelection(o3);
              }, d2.prototype.insertFile = function(t4) {
                return this.insertFiles([t4]);
              }, d2.prototype.insertFiles = function(t4) {
                var n3, i3, o3, r3, s3, a3;
                for (i3 = [], r3 = 0, s3 = t4.length; s3 > r3; r3++)
                  o3 = t4[r3], ((a3 = this.delegate) != null ? a3.compositionShouldAcceptFile(o3) : void 0) && (n3 = e2.Attachment.attachmentForFile(o3), i3.push(n3));
                return this.insertAttachments(i3);
              }, d2.prototype.insertAttachment = function(t4) {
                return this.insertAttachments([t4]);
              }, d2.prototype.insertAttachments = function(t4) {
                var n3, i3, o3, r3, s3, a3, u3, c3, l3;
                for (c3 = new e2.Text(), r3 = 0, s3 = t4.length; s3 > r3; r3++)
                  n3 = t4[r3], l3 = n3.getType(), a3 = (u3 = e2.config.attachments[l3]) != null ? u3.presentation : void 0, o3 = this.getCurrentTextAttributes(), a3 && (o3.presentation = a3), i3 = e2.Text.textForAttachmentWithAttributes(n3, o3), c3 = c3.appendText(i3);
                return this.insertText(c3);
              }, d2.prototype.shouldManageDeletingInDirection = function(t4) {
                var e3;
                if (e3 = this.getLocationRange(), u2(e3)) {
                  if (t4 === "backward" && e3[0].offset === 0)
                    return true;
                  if (this.shouldManageMovingCursorInDirection(t4))
                    return true;
                } else if (e3[0].index !== e3[1].index)
                  return true;
                return false;
              }, d2.prototype.deleteInDirection = function(t4, e3) {
                var n3, i3, o3, r3, s3, a3, c3, l3;
                return r3 = (e3 != null ? e3 : {}).length, s3 = this.getLocationRange(), a3 = this.getSelectedRange(), c3 = u2(a3), c3 ? o3 = t4 === "backward" && s3[0].offset === 0 : l3 = s3[0].index !== s3[1].index, o3 && this.canDecreaseBlockAttributeLevel() && (i3 = this.getBlock(), i3.isListItem() ? this.decreaseListLevel() : this.decreaseBlockAttributeLevel(), this.setSelection(a3[0]), i3.isEmpty()) ? false : (c3 && (a3 = this.getExpandedRangeInDirection(t4, { length: r3 }), t4 === "backward" && (n3 = this.getAttachmentAtRange(a3))), n3 ? (this.editAttachment(n3), false) : (this.setDocument(this.document.removeTextAtRange(a3)), this.setSelection(a3[0]), o3 || l3 ? false : void 0));
              }, d2.prototype.moveTextFromRange = function(t4) {
                var e3;
                return e3 = this.getSelectedRange()[0], this.setDocument(this.document.moveTextFromRangeToPosition(t4, e3)), this.setSelection(e3);
              }, d2.prototype.removeAttachment = function(t4) {
                var e3;
                return (e3 = this.document.getRangeOfAttachment(t4)) ? (this.stopEditingAttachment(), this.setDocument(this.document.removeTextAtRange(e3)), this.setSelection(e3[0])) : void 0;
              }, d2.prototype.removeLastBlockAttribute = function() {
                var t4, e3, n3, i3;
                return n3 = this.getSelectedRange(), i3 = n3[0], e3 = n3[1], t4 = this.document.getBlockAtPosition(e3), this.removeCurrentAttribute(t4.getLastAttribute()), this.setSelection(i3);
              }, f2 = " ", d2.prototype.insertPlaceholder = function() {
                return this.placeholderPosition = this.getPosition(), this.insertString(f2);
              }, d2.prototype.selectPlaceholder = function() {
                return this.placeholderPosition != null ? (this.setSelectedRange([this.placeholderPosition, this.placeholderPosition + f2.length]), this.getSelectedRange()) : void 0;
              }, d2.prototype.forgetPlaceholder = function() {
                return this.placeholderPosition = null;
              }, d2.prototype.hasCurrentAttribute = function(t4) {
                var e3;
                return e3 = this.currentAttributes[t4], e3 != null && e3 !== false;
              }, d2.prototype.toggleCurrentAttribute = function(t4) {
                var e3;
                return (e3 = !this.currentAttributes[t4]) ? this.setCurrentAttribute(t4, e3) : this.removeCurrentAttribute(t4);
              }, d2.prototype.canSetCurrentAttribute = function(t4) {
                return o2(t4) ? this.canSetCurrentBlockAttribute(t4) : this.canSetCurrentTextAttribute(t4);
              }, d2.prototype.canSetCurrentTextAttribute = function() {
                var t4, e3, n3, i3, o3;
                if (e3 = this.getSelectedDocument()) {
                  for (o3 = e3.getAttachments(), n3 = 0, i3 = o3.length; i3 > n3; n3++)
                    if (t4 = o3[n3], !t4.hasContent())
                      return false;
                  return true;
                }
              }, d2.prototype.canSetCurrentBlockAttribute = function() {
                var t4;
                if (t4 = this.getBlock())
                  return !t4.isTerminalBlock();
              }, d2.prototype.setCurrentAttribute = function(t4, e3) {
                return o2(t4) ? this.setBlockAttribute(t4, e3) : (this.setTextAttribute(t4, e3), this.currentAttributes[t4] = e3, this.notifyDelegateOfCurrentAttributesChange());
              }, d2.prototype.setTextAttribute = function(t4, n3) {
                var i3, o3, r3, s3;
                if (o3 = this.getSelectedRange())
                  return r3 = o3[0], i3 = o3[1], r3 !== i3 ? this.setDocument(this.document.addAttributeAtRange(t4, n3, o3)) : t4 === "href" ? (s3 = e2.Text.textForStringWithAttributes(n3, { href: n3 }), this.insertText(s3)) : void 0;
              }, d2.prototype.setBlockAttribute = function(t4, e3) {
                var n3, i3;
                if (i3 = this.getSelectedRange())
                  return this.canSetCurrentAttribute(t4) ? (n3 = this.getBlock(), this.setDocument(this.document.applyBlockAttributeAtRange(t4, e3, i3)), this.setSelection(i3)) : void 0;
              }, d2.prototype.removeCurrentAttribute = function(t4) {
                return o2(t4) ? (this.removeBlockAttribute(t4), this.updateCurrentAttributes()) : (this.removeTextAttribute(t4), delete this.currentAttributes[t4], this.notifyDelegateOfCurrentAttributesChange());
              }, d2.prototype.removeTextAttribute = function(t4) {
                var e3;
                if (e3 = this.getSelectedRange())
                  return this.setDocument(this.document.removeAttributeAtRange(t4, e3));
              }, d2.prototype.removeBlockAttribute = function(t4) {
                var e3;
                if (e3 = this.getSelectedRange())
                  return this.setDocument(this.document.removeAttributeAtRange(t4, e3));
              }, d2.prototype.canDecreaseNestingLevel = function() {
                var t4;
                return ((t4 = this.getBlock()) != null ? t4.getNestingLevel() : void 0) > 0;
              }, d2.prototype.canIncreaseNestingLevel = function() {
                var e3, n3, i3;
                if (e3 = this.getBlock())
                  return ((i3 = o2(e3.getLastNestableAttribute())) != null ? i3.listAttribute : 0) ? (n3 = this.getPreviousBlock()) ? t3(n3.getListItemAttributes(), e3.getListItemAttributes()) : void 0 : e3.getNestingLevel() > 0;
              }, d2.prototype.decreaseNestingLevel = function() {
                var t4;
                if (t4 = this.getBlock())
                  return this.setDocument(this.document.replaceBlock(t4, t4.decreaseNestingLevel()));
              }, d2.prototype.increaseNestingLevel = function() {
                var t4;
                if (t4 = this.getBlock())
                  return this.setDocument(this.document.replaceBlock(t4, t4.increaseNestingLevel()));
              }, d2.prototype.canDecreaseBlockAttributeLevel = function() {
                var t4;
                return ((t4 = this.getBlock()) != null ? t4.getAttributeLevel() : void 0) > 0;
              }, d2.prototype.decreaseBlockAttributeLevel = function() {
                var t4, e3;
                return (t4 = (e3 = this.getBlock()) != null ? e3.getLastAttribute() : void 0) ? this.removeCurrentAttribute(t4) : void 0;
              }, d2.prototype.decreaseListLevel = function() {
                var t4, e3, n3, i3, o3, r3;
                for (r3 = this.getSelectedRange()[0], o3 = this.document.locationFromPosition(r3).index, n3 = o3, t4 = this.getBlock().getAttributeLevel(); (e3 = this.document.getBlockAtIndex(n3 + 1)) && e3.isListItem() && e3.getAttributeLevel() > t4; )
                  n3++;
                return r3 = this.document.positionFromLocation({ index: o3, offset: 0 }), i3 = this.document.positionFromLocation({ index: n3, offset: 0 }), this.setDocument(this.document.removeLastListAttributeAtRange([r3, i3]));
              }, d2.prototype.updateCurrentAttributes = function() {
                var t4, e3, n3, o3, r3, s3;
                if (s3 = this.getSelectedRange({ ignoreLock: true })) {
                  for (e3 = this.document.getCommonAttributesAtRange(s3), r3 = i2(), n3 = 0, o3 = r3.length; o3 > n3; n3++)
                    t4 = r3[n3], e3[t4] || this.canSetCurrentAttribute(t4) || (e3[t4] = false);
                  if (!a2(e3, this.currentAttributes))
                    return this.currentAttributes = e3, this.notifyDelegateOfCurrentAttributesChange();
                }
              }, d2.prototype.getCurrentAttributes = function() {
                return n2.call({}, this.currentAttributes);
              }, d2.prototype.getCurrentTextAttributes = function() {
                var t4, e3, n3, i3;
                t4 = {}, n3 = this.currentAttributes;
                for (e3 in n3)
                  i3 = n3[e3], i3 !== false && r2(e3) && (t4[e3] = i3);
                return t4;
              }, d2.prototype.freezeSelection = function() {
                return this.setCurrentAttribute("frozen", true);
              }, d2.prototype.thawSelection = function() {
                return this.removeCurrentAttribute("frozen");
              }, d2.prototype.hasFrozenSelection = function() {
                return this.hasCurrentAttribute("frozen");
              }, d2.proxyMethod("getSelectionManager().getPointRange"), d2.proxyMethod("getSelectionManager().setLocationRangeFromPointRange"), d2.proxyMethod("getSelectionManager().createLocationRangeFromDOMRange"), d2.proxyMethod("getSelectionManager().locationIsCursorTarget"), d2.proxyMethod("getSelectionManager().selectionIsExpanded"), d2.proxyMethod("delegate?.getSelectionManager"), d2.prototype.setSelection = function(t4) {
                var e3, n3;
                return e3 = this.document.locationRangeFromRange(t4), (n3 = this.delegate) != null ? n3.compositionDidRequestChangingSelectionToLocationRange(e3) : void 0;
              }, d2.prototype.getSelectedRange = function() {
                var t4;
                return (t4 = this.getLocationRange()) ? this.document.rangeFromLocationRange(t4) : void 0;
              }, d2.prototype.setSelectedRange = function(t4) {
                var e3;
                return e3 = this.document.locationRangeFromRange(t4), this.getSelectionManager().setLocationRange(e3);
              }, d2.prototype.getPosition = function() {
                var t4;
                return (t4 = this.getLocationRange()) ? this.document.positionFromLocation(t4[0]) : void 0;
              }, d2.prototype.getLocationRange = function(t4) {
                var e3, n3;
                return (e3 = (n3 = this.targetLocationRange) != null ? n3 : this.getSelectionManager().getLocationRange(t4)) != null ? e3 : s2({ index: 0, offset: 0 });
              }, d2.prototype.withTargetLocationRange = function(t4, e3) {
                var n3;
                this.targetLocationRange = t4;
                try {
                  n3 = e3();
                } finally {
                  this.targetLocationRange = null;
                }
                return n3;
              }, d2.prototype.withTargetRange = function(t4, e3) {
                var n3;
                return n3 = this.document.locationRangeFromRange(t4), this.withTargetLocationRange(n3, e3);
              }, d2.prototype.withTargetDOMRange = function(t4, e3) {
                var n3;
                return n3 = this.createLocationRangeFromDOMRange(t4, { strict: false }), this.withTargetLocationRange(n3, e3);
              }, d2.prototype.getExpandedRangeInDirection = function(t4, e3) {
                var n3, i3, o3, r3;
                return i3 = (e3 != null ? e3 : {}).length, o3 = this.getSelectedRange(), r3 = o3[0], n3 = o3[1], t4 === "backward" ? i3 ? r3 -= i3 : r3 = this.translateUTF16PositionFromOffset(r3, -1) : i3 ? n3 += i3 : n3 = this.translateUTF16PositionFromOffset(n3, 1), s2([r3, n3]);
              }, d2.prototype.shouldManageMovingCursorInDirection = function(t4) {
                var e3;
                return this.editingAttachment ? true : (e3 = this.getExpandedRangeInDirection(t4), this.getAttachmentAtRange(e3) != null);
              }, d2.prototype.moveCursorInDirection = function(t4) {
                var e3, n3, i3, o3;
                return this.editingAttachment ? i3 = this.document.getRangeOfAttachment(this.editingAttachment) : (o3 = this.getSelectedRange(), i3 = this.getExpandedRangeInDirection(t4), n3 = !c2(o3, i3)), this.setSelectedRange(t4 === "backward" ? i3[0] : i3[1]), n3 && (e3 = this.getAttachmentAtRange(i3)) ? this.editAttachment(e3) : void 0;
              }, d2.prototype.expandSelectionInDirection = function(t4, e3) {
                var n3, i3;
                return n3 = (e3 != null ? e3 : {}).length, i3 = this.getExpandedRangeInDirection(t4, { length: n3 }), this.setSelectedRange(i3);
              }, d2.prototype.expandSelectionForEditing = function() {
                return this.hasCurrentAttribute("href") ? this.expandSelectionAroundCommonAttribute("href") : void 0;
              }, d2.prototype.expandSelectionAroundCommonAttribute = function(t4) {
                var e3, n3;
                return e3 = this.getPosition(), n3 = this.document.getRangeOfCommonAttributeAtPosition(t4, e3), this.setSelectedRange(n3);
              }, d2.prototype.selectionContainsAttachments = function() {
                var t4;
                return ((t4 = this.getSelectedAttachments()) != null ? t4.length : void 0) > 0;
              }, d2.prototype.selectionIsInCursorTarget = function() {
                return this.editingAttachment || this.positionIsCursorTarget(this.getPosition());
              }, d2.prototype.positionIsCursorTarget = function(t4) {
                var e3;
                return (e3 = this.document.locationFromPosition(t4)) ? this.locationIsCursorTarget(e3) : void 0;
              }, d2.prototype.positionIsBlockBreak = function(t4) {
                var e3;
                return (e3 = this.document.getPieceAtPosition(t4)) != null ? e3.isBlockBreak() : void 0;
              }, d2.prototype.getSelectedDocument = function() {
                var t4;
                return (t4 = this.getSelectedRange()) ? this.document.getDocumentAtRange(t4) : void 0;
              }, d2.prototype.getSelectedAttachments = function() {
                var t4;
                return (t4 = this.getSelectedDocument()) != null ? t4.getAttachments() : void 0;
              }, d2.prototype.getAttachments = function() {
                return this.attachments.slice(0);
              }, d2.prototype.refreshAttachments = function() {
                var t4, e3, n3, i3, o3, r3, s3, a3, u3, c3, h2, p4;
                for (n3 = this.document.getAttachments(), a3 = l2(this.attachments, n3), t4 = a3.added, h2 = a3.removed, this.attachments = n3, i3 = 0, r3 = h2.length; r3 > i3; i3++)
                  e3 = h2[i3], e3.delegate = null, (u3 = this.delegate) != null && typeof u3.compositionDidRemoveAttachment == "function" && u3.compositionDidRemoveAttachment(e3);
                for (p4 = [], o3 = 0, s3 = t4.length; s3 > o3; o3++)
                  e3 = t4[o3], e3.delegate = this, p4.push((c3 = this.delegate) != null && typeof c3.compositionDidAddAttachment == "function" ? c3.compositionDidAddAttachment(e3) : void 0);
                return p4;
              }, d2.prototype.attachmentDidChangeAttributes = function(t4) {
                var e3;
                return this.revision++, (e3 = this.delegate) != null && typeof e3.compositionDidEditAttachment == "function" ? e3.compositionDidEditAttachment(t4) : void 0;
              }, d2.prototype.attachmentDidChangePreviewURL = function(t4) {
                var e3;
                return this.revision++, (e3 = this.delegate) != null && typeof e3.compositionDidChangeAttachmentPreviewURL == "function" ? e3.compositionDidChangeAttachmentPreviewURL(t4) : void 0;
              }, d2.prototype.editAttachment = function(t4, e3) {
                var n3;
                if (t4 !== this.editingAttachment)
                  return this.stopEditingAttachment(), this.editingAttachment = t4, (n3 = this.delegate) != null && typeof n3.compositionDidStartEditingAttachment == "function" ? n3.compositionDidStartEditingAttachment(this.editingAttachment, e3) : void 0;
              }, d2.prototype.stopEditingAttachment = function() {
                var t4;
                if (this.editingAttachment)
                  return (t4 = this.delegate) != null && typeof t4.compositionDidStopEditingAttachment == "function" && t4.compositionDidStopEditingAttachment(this.editingAttachment), this.editingAttachment = null;
              }, d2.prototype.updateAttributesForAttachment = function(t4, e3) {
                return this.setDocument(this.document.updateAttributesForAttachment(t4, e3));
              }, d2.prototype.removeAttributeForAttachment = function(t4, e3) {
                return this.setDocument(this.document.removeAttributeForAttachment(t4, e3));
              }, d2.prototype.breakFormattedBlock = function(t4) {
                var n3, i3, o3, r3, s3;
                return i3 = t4.document, n3 = t4.block, r3 = t4.startPosition, s3 = [r3 - 1, r3], n3.getBlockBreakPosition() === t4.startLocation.offset ? (n3.breaksOnReturn() && t4.nextCharacter === "\n" ? r3 += 1 : i3 = i3.removeTextAtRange(s3), s3 = [r3, r3]) : t4.nextCharacter === "\n" ? t4.previousCharacter === "\n" ? s3 = [r3 - 1, r3 + 1] : (s3 = [r3, r3 + 1], r3 += 1) : t4.startLocation.offset - 1 !== 0 && (r3 += 1), o3 = new e2.Document([n3.removeLastAttribute().copyWithoutText()]), this.setDocument(i3.insertDocumentAtRange(o3, s3)), this.setSelection(r3);
              }, d2.prototype.getPreviousBlock = function() {
                var t4, e3;
                return (e3 = this.getLocationRange()) && (t4 = e3[0].index, t4 > 0) ? this.document.getBlockAtIndex(t4 - 1) : void 0;
              }, d2.prototype.getBlock = function() {
                var t4;
                return (t4 = this.getLocationRange()) ? this.document.getBlockAtIndex(t4[0].index) : void 0;
              }, d2.prototype.getAttachmentAtRange = function(t4) {
                var n3;
                return n3 = this.document.getDocumentAtRange(t4), n3.toString() === e2.OBJECT_REPLACEMENT_CHARACTER + "\n" ? n3.getAttachments()[0] : void 0;
              }, d2.prototype.notifyDelegateOfCurrentAttributesChange = function() {
                var t4;
                return (t4 = this.delegate) != null && typeof t4.compositionDidChangeCurrentAttributes == "function" ? t4.compositionDidChangeCurrentAttributes(this.currentAttributes) : void 0;
              }, d2.prototype.notifyDelegateOfInsertionAtRange = function(t4) {
                var e3;
                return (e3 = this.delegate) != null && typeof e3.compositionDidPerformInsertionAtRange == "function" ? e3.compositionDidPerformInsertionAtRange(t4) : void 0;
              }, d2.prototype.translateUTF16PositionFromOffset = function(t4, e3) {
                var n3, i3;
                return i3 = this.document.toUTF16String(), n3 = i3.offsetFromUCS2Offset(t4), i3.offsetToUCS2Offset(n3 + e3);
              }, d2;
            }(e2.BasicObject);
          }.call(this), function() {
            var t3 = function(t4, e3) {
              function i2() {
                this.constructor = t4;
              }
              for (var o2 in e3)
                n2.call(e3, o2) && (t4[o2] = e3[o2]);
              return i2.prototype = e3.prototype, t4.prototype = new i2(), t4.__super__ = e3.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e2.UndoManager = function(e3) {
              function n3(t4) {
                this.composition = t4, this.undoEntries = [], this.redoEntries = [];
              }
              var i2;
              return t3(n3, e3), n3.prototype.recordUndoEntry = function(t4, e4) {
                var n4, o2, r2, s2, a2;
                return s2 = e4 != null ? e4 : {}, o2 = s2.context, n4 = s2.consolidatable, r2 = this.undoEntries.slice(-1)[0], n4 && i2(r2, t4, o2) ? void 0 : (a2 = this.createEntry({ description: t4, context: o2 }), this.undoEntries.push(a2), this.redoEntries = []);
              }, n3.prototype.undo = function() {
                var t4, e4;
                return (e4 = this.undoEntries.pop()) ? (t4 = this.createEntry(e4), this.redoEntries.push(t4), this.composition.loadSnapshot(e4.snapshot)) : void 0;
              }, n3.prototype.redo = function() {
                var t4, e4;
                return (t4 = this.redoEntries.pop()) ? (e4 = this.createEntry(t4), this.undoEntries.push(e4), this.composition.loadSnapshot(t4.snapshot)) : void 0;
              }, n3.prototype.canUndo = function() {
                return this.undoEntries.length > 0;
              }, n3.prototype.canRedo = function() {
                return this.redoEntries.length > 0;
              }, n3.prototype.createEntry = function(t4) {
                var e4, n4, i3;
                return i3 = t4 != null ? t4 : {}, n4 = i3.description, e4 = i3.context, { description: n4 != null ? n4.toString() : void 0, context: JSON.stringify(e4), snapshot: this.composition.getSnapshot() };
              }, i2 = function(t4, e4, n4) {
                return (t4 != null ? t4.description : void 0) === (e4 != null ? e4.toString() : void 0) && (t4 != null ? t4.context : void 0) === JSON.stringify(n4);
              }, n3;
            }(e2.BasicObject);
          }.call(this), function() {
            var t3;
            e2.attachmentGalleryFilter = function(e3) {
              var n2;
              return n2 = new t3(e3), n2.perform(), n2.getSnapshot();
            }, t3 = function() {
              function t4(t5) {
                this.document = t5.document, this.selectedRange = t5.selectedRange;
              }
              var e3, n2, i2;
              return e3 = "attachmentGallery", n2 = "presentation", i2 = "gallery", t4.prototype.perform = function() {
                return this.removeBlockAttribute(), this.applyBlockAttribute();
              }, t4.prototype.getSnapshot = function() {
                return { document: this.document, selectedRange: this.selectedRange };
              }, t4.prototype.removeBlockAttribute = function() {
                var t5, n3, i3, o2, r2;
                for (o2 = this.findRangesOfBlocks(), r2 = [], t5 = 0, n3 = o2.length; n3 > t5; t5++)
                  i3 = o2[t5], r2.push(this.document = this.document.removeAttributeAtRange(e3, i3));
                return r2;
              }, t4.prototype.applyBlockAttribute = function() {
                var t5, n3, i3, o2, r2, s2;
                for (i3 = 0, r2 = this.findRangesOfPieces(), s2 = [], t5 = 0, n3 = r2.length; n3 > t5; t5++)
                  o2 = r2[t5], o2[1] - o2[0] > 1 && (o2[0] += i3, o2[1] += i3, this.document.getCharacterAtPosition(o2[1]) !== "\n" && (this.document = this.document.insertBlockBreakAtRange(o2[1]), o2[1] < this.selectedRange[1] && this.moveSelectedRangeForward(), o2[1]++, i3++), o2[0] !== 0 && this.document.getCharacterAtPosition(o2[0] - 1) !== "\n" && (this.document = this.document.insertBlockBreakAtRange(o2[0]), o2[0] < this.selectedRange[0] && this.moveSelectedRangeForward(), o2[0]++, i3++), s2.push(this.document = this.document.applyBlockAttributeAtRange(e3, true, o2)));
                return s2;
              }, t4.prototype.findRangesOfBlocks = function() {
                return this.document.findRangesForBlockAttribute(e3);
              }, t4.prototype.findRangesOfPieces = function() {
                return this.document.findRangesForTextAttribute(n2, { withValue: i2 });
              }, t4.prototype.moveSelectedRangeForward = function() {
                return this.selectedRange[0] += 1, this.selectedRange[1] += 1;
              }, t4;
            }();
          }.call(this), function() {
            var t3 = function(t4, e3) {
              return function() {
                return t4.apply(e3, arguments);
              };
            };
            e2.Editor = function() {
              function n2(n3, o2, r2) {
                this.composition = n3, this.selectionManager = o2, this.element = r2, this.insertFiles = t3(this.insertFiles, this), this.undoManager = new e2.UndoManager(this.composition), this.filters = i2.slice(0);
              }
              var i2;
              return i2 = [e2.attachmentGalleryFilter], n2.prototype.loadDocument = function(t4) {
                return this.loadSnapshot({ document: t4, selectedRange: [0, 0] });
              }, n2.prototype.loadHTML = function(t4) {
                return t4 == null && (t4 = ""), this.loadDocument(e2.Document.fromHTML(t4, { referenceElement: this.element }));
              }, n2.prototype.loadJSON = function(t4) {
                var n3, i3;
                return n3 = t4.document, i3 = t4.selectedRange, n3 = e2.Document.fromJSON(n3), this.loadSnapshot({ document: n3, selectedRange: i3 });
              }, n2.prototype.loadSnapshot = function(t4) {
                return this.undoManager = new e2.UndoManager(this.composition), this.composition.loadSnapshot(t4);
              }, n2.prototype.getDocument = function() {
                return this.composition.document;
              }, n2.prototype.getSelectedDocument = function() {
                return this.composition.getSelectedDocument();
              }, n2.prototype.getSnapshot = function() {
                return this.composition.getSnapshot();
              }, n2.prototype.toJSON = function() {
                return this.getSnapshot();
              }, n2.prototype.deleteInDirection = function(t4) {
                return this.composition.deleteInDirection(t4);
              }, n2.prototype.insertAttachment = function(t4) {
                return this.composition.insertAttachment(t4);
              }, n2.prototype.insertAttachments = function(t4) {
                return this.composition.insertAttachments(t4);
              }, n2.prototype.insertDocument = function(t4) {
                return this.composition.insertDocument(t4);
              }, n2.prototype.insertFile = function(t4) {
                return this.composition.insertFile(t4);
              }, n2.prototype.insertFiles = function(t4) {
                return this.composition.insertFiles(t4);
              }, n2.prototype.insertHTML = function(t4) {
                return this.composition.insertHTML(t4);
              }, n2.prototype.insertString = function(t4) {
                return this.composition.insertString(t4);
              }, n2.prototype.insertText = function(t4) {
                return this.composition.insertText(t4);
              }, n2.prototype.insertLineBreak = function() {
                return this.composition.insertLineBreak();
              }, n2.prototype.getSelectedRange = function() {
                return this.composition.getSelectedRange();
              }, n2.prototype.getPosition = function() {
                return this.composition.getPosition();
              }, n2.prototype.getClientRectAtPosition = function(t4) {
                var e3;
                return e3 = this.getDocument().locationRangeFromRange([t4, t4 + 1]), this.selectionManager.getClientRectAtLocationRange(e3);
              }, n2.prototype.expandSelectionInDirection = function(t4) {
                return this.composition.expandSelectionInDirection(t4);
              }, n2.prototype.moveCursorInDirection = function(t4) {
                return this.composition.moveCursorInDirection(t4);
              }, n2.prototype.setSelectedRange = function(t4) {
                return this.composition.setSelectedRange(t4);
              }, n2.prototype.activateAttribute = function(t4, e3) {
                return e3 == null && (e3 = true), this.composition.setCurrentAttribute(t4, e3);
              }, n2.prototype.attributeIsActive = function(t4) {
                return this.composition.hasCurrentAttribute(t4);
              }, n2.prototype.canActivateAttribute = function(t4) {
                return this.composition.canSetCurrentAttribute(t4);
              }, n2.prototype.deactivateAttribute = function(t4) {
                return this.composition.removeCurrentAttribute(t4);
              }, n2.prototype.canDecreaseNestingLevel = function() {
                return this.composition.canDecreaseNestingLevel();
              }, n2.prototype.canIncreaseNestingLevel = function() {
                return this.composition.canIncreaseNestingLevel();
              }, n2.prototype.decreaseNestingLevel = function() {
                return this.canDecreaseNestingLevel() ? this.composition.decreaseNestingLevel() : void 0;
              }, n2.prototype.increaseNestingLevel = function() {
                return this.canIncreaseNestingLevel() ? this.composition.increaseNestingLevel() : void 0;
              }, n2.prototype.canRedo = function() {
                return this.undoManager.canRedo();
              }, n2.prototype.canUndo = function() {
                return this.undoManager.canUndo();
              }, n2.prototype.recordUndoEntry = function(t4, e3) {
                var n3, i3, o2;
                return o2 = e3 != null ? e3 : {}, i3 = o2.context, n3 = o2.consolidatable, this.undoManager.recordUndoEntry(t4, { context: i3, consolidatable: n3 });
              }, n2.prototype.redo = function() {
                return this.canRedo() ? this.undoManager.redo() : void 0;
              }, n2.prototype.undo = function() {
                return this.canUndo() ? this.undoManager.undo() : void 0;
              }, n2;
            }();
          }.call(this), function() {
            var t3 = function(t4, e3) {
              function i2() {
                this.constructor = t4;
              }
              for (var o2 in e3)
                n2.call(e3, o2) && (t4[o2] = e3[o2]);
              return i2.prototype = e3.prototype, t4.prototype = new i2(), t4.__super__ = e3.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e2.ManagedAttachment = function(e3) {
              function n3(t4, e4) {
                var n4;
                this.attachmentManager = t4, this.attachment = e4, n4 = this.attachment, this.id = n4.id, this.file = n4.file;
              }
              return t3(n3, e3), n3.prototype.remove = function() {
                return this.attachmentManager.requestRemovalOfAttachment(this.attachment);
              }, n3.proxyMethod("attachment.getAttribute"), n3.proxyMethod("attachment.hasAttribute"), n3.proxyMethod("attachment.setAttribute"), n3.proxyMethod("attachment.getAttributes"), n3.proxyMethod("attachment.setAttributes"), n3.proxyMethod("attachment.isPending"), n3.proxyMethod("attachment.isPreviewable"), n3.proxyMethod("attachment.getURL"), n3.proxyMethod("attachment.getHref"), n3.proxyMethod("attachment.getFilename"), n3.proxyMethod("attachment.getFilesize"), n3.proxyMethod("attachment.getFormattedFilesize"), n3.proxyMethod("attachment.getExtension"), n3.proxyMethod("attachment.getContentType"), n3.proxyMethod("attachment.getFile"), n3.proxyMethod("attachment.setFile"), n3.proxyMethod("attachment.releaseFile"), n3.proxyMethod("attachment.getUploadProgress"), n3.proxyMethod("attachment.setUploadProgress"), n3;
            }(e2.BasicObject);
          }.call(this), function() {
            var t3 = function(t4, e3) {
              function i2() {
                this.constructor = t4;
              }
              for (var o2 in e3)
                n2.call(e3, o2) && (t4[o2] = e3[o2]);
              return i2.prototype = e3.prototype, t4.prototype = new i2(), t4.__super__ = e3.prototype, t4;
            }, n2 = {}.hasOwnProperty;
            e2.AttachmentManager = function(n3) {
              function i2(t4) {
                var e3, n4, i3;
                for (t4 == null && (t4 = []), this.managedAttachments = {}, n4 = 0, i3 = t4.length; i3 > n4; n4++)
                  e3 = t4[n4], this.manageAttachment(e3);
              }
              return t3(i2, n3), i2.prototype.getAttachments = function() {
                var t4, e3, n4, i3;
                n4 = this.managedAttachments, i3 = [];
                for (e3 in n4)
                  t4 = n4[e3], i3.push(t4);
                return i3;
              }, i2.prototype.manageAttachment = function(t4) {
                var n4, i3;
                return (n4 = this.managedAttachments)[i3 = t4.id] != null ? n4[i3] : n4[i3] = new e2.ManagedAttachment(this, t4);
              }, i2.prototype.attachmentIsManaged = function(t4) {
                return t4.id in this.managedAttachments;
              }, i2.prototype.requestRemovalOfAttachment = function(t4) {
                var e3;
                return this.attachmentIsManaged(t4) && (e3 = this.delegate) != null && typeof e3.attachmentManagerDidRequestRemovalOfAttachment == "function" ? e3.attachmentManagerDidRequestRemovalOfAttachment(t4) : void 0;
              }, i2.prototype.unmanageAttachment = function(t4) {
                var e3;
                return e3 = this.managedAttachments[t4.id], delete this.managedAttachments[t4.id], e3;
              }, i2;
            }(e2.BasicObject);
          }.call(this), function() {
            var t3, n2, i2, o2, r2, s2, a2, u2, c2, l2, h;
            t3 = e2.elementContainsNode, n2 = e2.findChildIndexOfNode, r2 = e2.nodeIsBlockStart, s2 = e2.nodeIsBlockStartComment, o2 = e2.nodeIsBlockContainer, a2 = e2.nodeIsCursorTarget, u2 = e2.nodeIsEmptyTextNode, c2 = e2.nodeIsTextNode, i2 = e2.nodeIsAttachmentElement, l2 = e2.tagName, h = e2.walkTree, e2.LocationMapper = function() {
              function e3(t4) {
                this.element = t4;
              }
              var p2, d2, f2, g2;
              return e3.prototype.findLocationFromContainerAndOffset = function(e4, i3, o3) {
                var s3, u3, l3, p3, g3, m2, v2;
                for (m2 = (o3 != null ? o3 : { strict: true }).strict, u3 = 0, l3 = false, p3 = { index: 0, offset: 0 }, (s3 = this.findAttachmentElementParentForNode(e4)) && (e4 = s3.parentNode, i3 = n2(s3)), v2 = h(this.element, { usingFilter: f2 }); v2.nextNode(); ) {
                  if (g3 = v2.currentNode, g3 === e4 && c2(e4)) {
                    a2(g3) || (p3.offset += i3);
                    break;
                  }
                  if (g3.parentNode === e4) {
                    if (u3++ === i3)
                      break;
                  } else if (!t3(e4, g3) && u3 > 0)
                    break;
                  r2(g3, { strict: m2 }) ? (l3 && p3.index++, p3.offset = 0, l3 = true) : p3.offset += d2(g3);
                }
                return p3;
              }, e3.prototype.findContainerAndOffsetFromLocation = function(t4) {
                var e4, i3, s3, u3, l3;
                if (t4.index === 0 && t4.offset === 0) {
                  for (e4 = this.element, u3 = 0; e4.firstChild; )
                    if (e4 = e4.firstChild, o2(e4)) {
                      u3 = 1;
                      break;
                    }
                  return [e4, u3];
                }
                if (l3 = this.findNodeAndOffsetFromLocation(t4), i3 = l3[0], s3 = l3[1], i3) {
                  if (c2(i3))
                    d2(i3) === 0 ? (e4 = i3.parentNode.parentNode, u3 = n2(i3.parentNode), a2(i3, { name: "right" }) && u3++) : (e4 = i3, u3 = t4.offset - s3);
                  else {
                    if (e4 = i3.parentNode, !r2(i3.previousSibling) && !o2(e4))
                      for (; i3 === e4.lastChild && (i3 = e4, e4 = e4.parentNode, !o2(e4)); )
                        ;
                    u3 = n2(i3), t4.offset !== 0 && u3++;
                  }
                  return [e4, u3];
                }
              }, e3.prototype.findNodeAndOffsetFromLocation = function(t4) {
                var e4, n3, i3, o3, r3, s3, u3, l3;
                for (u3 = 0, l3 = this.getSignificantNodesForIndex(t4.index), n3 = 0, i3 = l3.length; i3 > n3; n3++) {
                  if (e4 = l3[n3], o3 = d2(e4), t4.offset <= u3 + o3)
                    if (c2(e4)) {
                      if (r3 = e4, s3 = u3, t4.offset === s3 && a2(r3))
                        break;
                    } else
                      r3 || (r3 = e4, s3 = u3);
                  if (u3 += o3, u3 > t4.offset)
                    break;
                }
                return [r3, s3];
              }, e3.prototype.findAttachmentElementParentForNode = function(t4) {
                for (; t4 && t4 !== this.element; ) {
                  if (i2(t4))
                    return t4;
                  t4 = t4.parentNode;
                }
              }, e3.prototype.getSignificantNodesForIndex = function(t4) {
                var e4, n3, i3, o3, r3;
                for (i3 = [], r3 = h(this.element, { usingFilter: p2 }), o3 = false; r3.nextNode(); )
                  if (n3 = r3.currentNode, s2(n3)) {
                    if (typeof e4 != "undefined" && e4 !== null ? e4++ : e4 = 0, e4 === t4)
                      o3 = true;
                    else if (o3)
                      break;
                  } else
                    o3 && i3.push(n3);
                return i3;
              }, d2 = function(t4) {
                var e4;
                return t4.nodeType === Node.TEXT_NODE ? a2(t4) ? 0 : (e4 = t4.textContent, e4.length) : l2(t4) === "br" || i2(t4) ? 1 : 0;
              }, p2 = function(t4) {
                return g2(t4) === NodeFilter.FILTER_ACCEPT ? f2(t4) : NodeFilter.FILTER_REJECT;
              }, g2 = function(t4) {
                return u2(t4) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
              }, f2 = function(t4) {
                return i2(t4.parentNode) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
              }, e3;
            }();
          }.call(this), function() {
            var t3, n2, i2 = [].slice;
            t3 = e2.getDOMRange, n2 = e2.setDOMRange, e2.PointMapper = function() {
              function e3() {
              }
              return e3.prototype.createDOMRangeFromPoint = function(e4) {
                var i3, o2, r2, s2, a2, u2, c2, l2;
                if (c2 = e4.x, l2 = e4.y, document.caretPositionFromPoint)
                  return a2 = document.caretPositionFromPoint(c2, l2), r2 = a2.offsetNode, o2 = a2.offset, i3 = document.createRange(), i3.setStart(r2, o2), i3;
                if (document.caretRangeFromPoint)
                  return document.caretRangeFromPoint(c2, l2);
                if (document.body.createTextRange) {
                  s2 = t3();
                  try {
                    u2 = document.body.createTextRange(), u2.moveToPoint(c2, l2), u2.select();
                  } catch (h) {
                  }
                  return i3 = t3(), n2(s2), i3;
                }
              }, e3.prototype.getClientRectsForDOMRange = function(t4) {
                var e4, n3, o2;
                return n3 = i2.call(t4.getClientRects()), o2 = n3[0], e4 = n3[n3.length - 1], [o2, e4];
              }, e3;
            }();
          }.call(this), function() {
            var t3, n2 = function(t4, e3) {
              return function() {
                return t4.apply(e3, arguments);
              };
            }, i2 = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var i3 in e3)
                o2.call(e3, i3) && (t4[i3] = e3[i3]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, o2 = {}.hasOwnProperty, r2 = [].indexOf || function(t4) {
              for (var e3 = 0, n3 = this.length; n3 > e3; e3++)
                if (e3 in this && this[e3] === t4)
                  return e3;
              return -1;
            };
            t3 = e2.getDOMRange, e2.SelectionChangeObserver = function(e3) {
              function o3() {
                this.run = n2(this.run, this), this.update = n2(this.update, this), this.selectionManagers = [];
              }
              var s2;
              return i2(o3, e3), o3.prototype.start = function() {
                return this.started ? void 0 : (this.started = true, "onselectionchange" in document ? document.addEventListener("selectionchange", this.update, true) : this.run());
              }, o3.prototype.stop = function() {
                return this.started ? (this.started = false, document.removeEventListener("selectionchange", this.update, true)) : void 0;
              }, o3.prototype.registerSelectionManager = function(t4) {
                return r2.call(this.selectionManagers, t4) < 0 ? (this.selectionManagers.push(t4), this.start()) : void 0;
              }, o3.prototype.unregisterSelectionManager = function(t4) {
                var e4;
                return this.selectionManagers = function() {
                  var n3, i3, o4, r3;
                  for (o4 = this.selectionManagers, r3 = [], n3 = 0, i3 = o4.length; i3 > n3; n3++)
                    e4 = o4[n3], e4 !== t4 && r3.push(e4);
                  return r3;
                }.call(this), this.selectionManagers.length === 0 ? this.stop() : void 0;
              }, o3.prototype.notifySelectionManagersOfSelectionChange = function() {
                var t4, e4, n3, i3, o4;
                for (n3 = this.selectionManagers, i3 = [], t4 = 0, e4 = n3.length; e4 > t4; t4++)
                  o4 = n3[t4], i3.push(o4.selectionDidChange());
                return i3;
              }, o3.prototype.update = function() {
                var e4;
                return e4 = t3(), s2(e4, this.domRange) ? void 0 : (this.domRange = e4, this.notifySelectionManagersOfSelectionChange());
              }, o3.prototype.reset = function() {
                return this.domRange = null, this.update();
              }, o3.prototype.run = function() {
                return this.started ? (this.update(), requestAnimationFrame(this.run)) : void 0;
              }, s2 = function(t4, e4) {
                return (t4 != null ? t4.startContainer : void 0) === (e4 != null ? e4.startContainer : void 0) && (t4 != null ? t4.startOffset : void 0) === (e4 != null ? e4.startOffset : void 0) && (t4 != null ? t4.endContainer : void 0) === (e4 != null ? e4.endContainer : void 0) && (t4 != null ? t4.endOffset : void 0) === (e4 != null ? e4.endOffset : void 0);
              }, o3;
            }(e2.BasicObject), e2.selectionChangeObserver == null && (e2.selectionChangeObserver = new e2.SelectionChangeObserver());
          }.call(this), function() {
            var t3, n2, i2, o2, r2, s2, a2, u2, c2, l2, h = function(t4, e3) {
              return function() {
                return t4.apply(e3, arguments);
              };
            }, p2 = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var i3 in e3)
                d2.call(e3, i3) && (t4[i3] = e3[i3]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, d2 = {}.hasOwnProperty;
            i2 = e2.getDOMSelection, n2 = e2.getDOMRange, l2 = e2.setDOMRange, t3 = e2.elementContainsNode, s2 = e2.nodeIsCursorTarget, r2 = e2.innerElementIsActive, o2 = e2.handleEvent, a2 = e2.normalizeRange, u2 = e2.rangeIsCollapsed, c2 = e2.rangesAreEqual, e2.SelectionManager = function(d3) {
              function f2(t4) {
                this.element = t4, this.selectionDidChange = h(this.selectionDidChange, this), this.didMouseDown = h(this.didMouseDown, this), this.locationMapper = new e2.LocationMapper(this.element), this.pointMapper = new e2.PointMapper(), this.lockCount = 0, o2("mousedown", { onElement: this.element, withCallback: this.didMouseDown });
              }
              return p2(f2, d3), f2.prototype.getLocationRange = function(t4) {
                var e3, i3;
                return t4 == null && (t4 = {}), e3 = t4.strict === false ? this.createLocationRangeFromDOMRange(n2(), { strict: false }) : t4.ignoreLock ? this.currentLocationRange : (i3 = this.lockedLocationRange) != null ? i3 : this.currentLocationRange;
              }, f2.prototype.setLocationRange = function(t4) {
                var e3;
                if (!this.lockedLocationRange)
                  return t4 = a2(t4), (e3 = this.createDOMRangeFromLocationRange(t4)) ? (l2(e3), this.updateCurrentLocationRange(t4)) : void 0;
              }, f2.prototype.setLocationRangeFromPointRange = function(t4) {
                var e3, n3;
                return t4 = a2(t4), n3 = this.getLocationAtPoint(t4[0]), e3 = this.getLocationAtPoint(t4[1]), this.setLocationRange([n3, e3]);
              }, f2.prototype.getClientRectAtLocationRange = function(t4) {
                var e3;
                return (e3 = this.createDOMRangeFromLocationRange(t4)) ? this.getClientRectsForDOMRange(e3)[1] : void 0;
              }, f2.prototype.locationIsCursorTarget = function(t4) {
                var e3, n3, i3;
                return i3 = this.findNodeAndOffsetFromLocation(t4), e3 = i3[0], n3 = i3[1], s2(e3);
              }, f2.prototype.lock = function() {
                return this.lockCount++ === 0 ? (this.updateCurrentLocationRange(), this.lockedLocationRange = this.getLocationRange()) : void 0;
              }, f2.prototype.unlock = function() {
                var t4;
                return --this.lockCount === 0 && (t4 = this.lockedLocationRange, this.lockedLocationRange = null, t4 != null) ? this.setLocationRange(t4) : void 0;
              }, f2.prototype.clearSelection = function() {
                var t4;
                return (t4 = i2()) != null ? t4.removeAllRanges() : void 0;
              }, f2.prototype.selectionIsCollapsed = function() {
                var t4;
                return ((t4 = n2()) != null ? t4.collapsed : void 0) === true;
              }, f2.prototype.selectionIsExpanded = function() {
                return !this.selectionIsCollapsed();
              }, f2.prototype.createLocationRangeFromDOMRange = function(t4, e3) {
                var n3, i3;
                if (t4 != null && this.domRangeWithinElement(t4) && (i3 = this.findLocationFromContainerAndOffset(t4.startContainer, t4.startOffset, e3)))
                  return t4.collapsed || (n3 = this.findLocationFromContainerAndOffset(t4.endContainer, t4.endOffset, e3)), a2([i3, n3]);
              }, f2.proxyMethod("locationMapper.findLocationFromContainerAndOffset"), f2.proxyMethod("locationMapper.findContainerAndOffsetFromLocation"), f2.proxyMethod("locationMapper.findNodeAndOffsetFromLocation"), f2.proxyMethod("pointMapper.createDOMRangeFromPoint"), f2.proxyMethod("pointMapper.getClientRectsForDOMRange"), f2.prototype.didMouseDown = function() {
                return this.pauseTemporarily();
              }, f2.prototype.pauseTemporarily = function() {
                var e3, n3, i3, r3;
                return this.paused = true, n3 = function(e4) {
                  return function() {
                    var n4, o3, s3;
                    for (e4.paused = false, clearTimeout(r3), o3 = 0, s3 = i3.length; s3 > o3; o3++)
                      n4 = i3[o3], n4.destroy();
                    return t3(document, e4.element) ? e4.selectionDidChange() : void 0;
                  };
                }(this), r3 = setTimeout(n3, 200), i3 = function() {
                  var t4, i4, r4, s3;
                  for (r4 = ["mousemove", "keydown"], s3 = [], t4 = 0, i4 = r4.length; i4 > t4; t4++)
                    e3 = r4[t4], s3.push(o2(e3, { onElement: document, withCallback: n3 }));
                  return s3;
                }();
              }, f2.prototype.selectionDidChange = function() {
                return this.paused || r2(this.element) ? void 0 : this.updateCurrentLocationRange();
              }, f2.prototype.updateCurrentLocationRange = function(t4) {
                var e3;
                return (t4 != null ? t4 : t4 = this.createLocationRangeFromDOMRange(n2())) && !c2(t4, this.currentLocationRange) ? (this.currentLocationRange = t4, (e3 = this.delegate) != null && typeof e3.locationRangeDidChange == "function" ? e3.locationRangeDidChange(this.currentLocationRange.slice(0)) : void 0) : void 0;
              }, f2.prototype.createDOMRangeFromLocationRange = function(t4) {
                var e3, n3, i3, o3;
                return i3 = this.findContainerAndOffsetFromLocation(t4[0]), n3 = u2(t4) ? i3 : (o3 = this.findContainerAndOffsetFromLocation(t4[1])) != null ? o3 : i3, i3 != null && n3 != null ? (e3 = document.createRange(), e3.setStart.apply(e3, i3), e3.setEnd.apply(e3, n3), e3) : void 0;
              }, f2.prototype.getLocationAtPoint = function(t4) {
                var e3, n3;
                return (e3 = this.createDOMRangeFromPoint(t4)) && (n3 = this.createLocationRangeFromDOMRange(e3)) != null ? n3[0] : void 0;
              }, f2.prototype.domRangeWithinElement = function(e3) {
                return e3.collapsed ? t3(this.element, e3.startContainer) : t3(this.element, e3.startContainer) && t3(this.element, e3.endContainer);
              }, f2;
            }(e2.BasicObject);
          }.call(this), function() {
            var t3, n2, i2, o2, r2 = function(t4, e3) {
              function n3() {
                this.constructor = t4;
              }
              for (var i3 in e3)
                s2.call(e3, i3) && (t4[i3] = e3[i3]);
              return n3.prototype = e3.prototype, t4.prototype = new n3(), t4.__super__ = e3.prototype, t4;
            }, s2 = {}.hasOwnProperty, a2 = [].slice;
            i2 = e2.rangeIsCollapsed, o2 = e2.rangesAreEqual, n2 = e2.objectsAreEqual, t3 = e2.getBlockConfig, e2.EditorController = function(s3) {
              function u2(t4) {
                var n3, i3;
                this.editorElement = t4.editorElement, n3 = t4.document, i3 = t4.html, this.selectionManager = new e2.SelectionManager(this.editorElement), this.selectionManager.delegate = this, this.composition = new e2.Composition(), this.composition.delegate = this, this.attachmentManager = new e2.AttachmentManager(this.composition.getAttachments()), this.attachmentManager.delegate = this, this.inputController = new e2["Level" + e2.config.input.getLevel() + "InputController"](this.editorElement), this.inputController.delegate = this, this.inputController.responder = this.composition, this.compositionController = new e2.CompositionController(this.editorElement, this.composition), this.compositionController.delegate = this, this.toolbarController = new e2.ToolbarController(this.editorElement.toolbarElement), this.toolbarController.delegate = this, this.editor = new e2.Editor(this.composition, this.selectionManager, this.editorElement), n3 != null ? this.editor.loadDocument(n3) : this.editor.loadHTML(i3);
              }
              var c2;
              return r2(u2, s3), u2.prototype.registerSelectionManager = function() {
                return e2.selectionChangeObserver.registerSelectionManager(this.selectionManager);
              }, u2.prototype.unregisterSelectionManager = function() {
                return e2.selectionChangeObserver.unregisterSelectionManager(this.selectionManager);
              }, u2.prototype.render = function() {
                return this.compositionController.render();
              }, u2.prototype.reparse = function() {
                return this.composition.replaceHTML(this.editorElement.innerHTML);
              }, u2.prototype.compositionDidChangeDocument = function() {
                return this.notifyEditorElement("document-change"), this.handlingInput ? void 0 : this.render();
              }, u2.prototype.compositionDidChangeCurrentAttributes = function(t4) {
                return this.currentAttributes = t4, this.toolbarController.updateAttributes(this.currentAttributes), this.updateCurrentActions(), this.notifyEditorElement("attributes-change", { attributes: this.currentAttributes });
              }, u2.prototype.compositionDidPerformInsertionAtRange = function(t4) {
                return this.pasting ? this.pastedRange = t4 : void 0;
              }, u2.prototype.compositionShouldAcceptFile = function(t4) {
                return this.notifyEditorElement("file-accept", { file: t4 });
              }, u2.prototype.compositionDidAddAttachment = function(t4) {
                var e3;
                return e3 = this.attachmentManager.manageAttachment(t4), this.notifyEditorElement("attachment-add", { attachment: e3 });
              }, u2.prototype.compositionDidEditAttachment = function(t4) {
                var e3;
                return this.compositionController.rerenderViewForObject(t4), e3 = this.attachmentManager.manageAttachment(t4), this.notifyEditorElement("attachment-edit", { attachment: e3 }), this.notifyEditorElement("change");
              }, u2.prototype.compositionDidChangeAttachmentPreviewURL = function(t4) {
                return this.compositionController.invalidateViewForObject(t4), this.notifyEditorElement("change");
              }, u2.prototype.compositionDidRemoveAttachment = function(t4) {
                var e3;
                return e3 = this.attachmentManager.unmanageAttachment(t4), this.notifyEditorElement("attachment-remove", { attachment: e3 });
              }, u2.prototype.compositionDidStartEditingAttachment = function(t4, e3) {
                return this.attachmentLocationRange = this.composition.document.getLocationRangeOfAttachment(t4), this.compositionController.installAttachmentEditorForAttachment(t4, e3), this.selectionManager.setLocationRange(this.attachmentLocationRange);
              }, u2.prototype.compositionDidStopEditingAttachment = function() {
                return this.compositionController.uninstallAttachmentEditor(), this.attachmentLocationRange = null;
              }, u2.prototype.compositionDidRequestChangingSelectionToLocationRange = function(t4) {
                return !this.loadingSnapshot || this.isFocused() ? (this.requestedLocationRange = t4, this.compositionRevisionWhenLocationRangeRequested = this.composition.revision, this.handlingInput ? void 0 : this.render()) : void 0;
              }, u2.prototype.compositionWillLoadSnapshot = function() {
                return this.loadingSnapshot = true;
              }, u2.prototype.compositionDidLoadSnapshot = function() {
                return this.compositionController.refreshViewCache(), this.render(), this.loadingSnapshot = false;
              }, u2.prototype.getSelectionManager = function() {
                return this.selectionManager;
              }, u2.proxyMethod("getSelectionManager().setLocationRange"), u2.proxyMethod("getSelectionManager().getLocationRange"), u2.prototype.attachmentManagerDidRequestRemovalOfAttachment = function(t4) {
                return this.removeAttachment(t4);
              }, u2.prototype.compositionControllerWillSyncDocumentView = function() {
                return this.inputController.editorWillSyncDocumentView(), this.selectionManager.lock(), this.selectionManager.clearSelection();
              }, u2.prototype.compositionControllerDidSyncDocumentView = function() {
                return this.inputController.editorDidSyncDocumentView(), this.selectionManager.unlock(), this.updateCurrentActions(), this.notifyEditorElement("sync");
              }, u2.prototype.compositionControllerDidRender = function() {
                return this.requestedLocationRange != null && (this.compositionRevisionWhenLocationRangeRequested === this.composition.revision && this.selectionManager.setLocationRange(this.requestedLocationRange), this.requestedLocationRange = null, this.compositionRevisionWhenLocationRangeRequested = null), this.renderedCompositionRevision !== this.composition.revision && (this.runEditorFilters(), this.composition.updateCurrentAttributes(), this.notifyEditorElement("render")), this.renderedCompositionRevision = this.composition.revision;
              }, u2.prototype.compositionControllerDidFocus = function() {
                return this.isFocusedInvisibly() && this.setLocationRange({ index: 0, offset: 0 }), this.toolbarController.hideDialog(), this.notifyEditorElement("focus");
              }, u2.prototype.compositionControllerDidBlur = function() {
                return this.notifyEditorElement("blur");
              }, u2.prototype.compositionControllerDidSelectAttachment = function(t4, e3) {
                return this.toolbarController.hideDialog(), this.composition.editAttachment(t4, e3);
              }, u2.prototype.compositionControllerDidRequestDeselectingAttachment = function(t4) {
                var e3, n3;
                return e3 = (n3 = this.attachmentLocationRange) != null ? n3 : this.composition.document.getLocationRangeOfAttachment(t4), this.selectionManager.setLocationRange(e3[1]);
              }, u2.prototype.compositionControllerWillUpdateAttachment = function(t4) {
                return this.editor.recordUndoEntry("Edit Attachment", { context: t4.id, consolidatable: true });
              }, u2.prototype.compositionControllerDidRequestRemovalOfAttachment = function(t4) {
                return this.removeAttachment(t4);
              }, u2.prototype.inputControllerWillHandleInput = function() {
                return this.handlingInput = true, this.requestedRender = false;
              }, u2.prototype.inputControllerDidRequestRender = function() {
                return this.requestedRender = true;
              }, u2.prototype.inputControllerDidHandleInput = function() {
                return this.handlingInput = false, this.requestedRender ? (this.requestedRender = false, this.render()) : void 0;
              }, u2.prototype.inputControllerDidAllowUnhandledInput = function() {
                return this.notifyEditorElement("change");
              }, u2.prototype.inputControllerDidRequestReparse = function() {
                return this.reparse();
              }, u2.prototype.inputControllerWillPerformTyping = function() {
                return this.recordTypingUndoEntry();
              }, u2.prototype.inputControllerWillPerformFormatting = function(t4) {
                return this.recordFormattingUndoEntry(t4);
              }, u2.prototype.inputControllerWillCutText = function() {
                return this.editor.recordUndoEntry("Cut");
              }, u2.prototype.inputControllerWillPaste = function(t4) {
                return this.editor.recordUndoEntry("Paste"), this.pasting = true, this.notifyEditorElement("before-paste", { paste: t4 });
              }, u2.prototype.inputControllerDidPaste = function(t4) {
                return t4.range = this.pastedRange, this.pastedRange = null, this.pasting = null, this.notifyEditorElement("paste", { paste: t4 });
              }, u2.prototype.inputControllerWillMoveText = function() {
                return this.editor.recordUndoEntry("Move");
              }, u2.prototype.inputControllerWillAttachFiles = function() {
                return this.editor.recordUndoEntry("Drop Files");
              }, u2.prototype.inputControllerWillPerformUndo = function() {
                return this.editor.undo();
              }, u2.prototype.inputControllerWillPerformRedo = function() {
                return this.editor.redo();
              }, u2.prototype.inputControllerDidReceiveKeyboardCommand = function(t4) {
                return this.toolbarController.applyKeyboardCommand(t4);
              }, u2.prototype.inputControllerDidStartDrag = function() {
                return this.locationRangeBeforeDrag = this.selectionManager.getLocationRange();
              }, u2.prototype.inputControllerDidReceiveDragOverPoint = function(t4) {
                return this.selectionManager.setLocationRangeFromPointRange(t4);
              }, u2.prototype.inputControllerDidCancelDrag = function() {
                return this.selectionManager.setLocationRange(this.locationRangeBeforeDrag), this.locationRangeBeforeDrag = null;
              }, u2.prototype.locationRangeDidChange = function(t4) {
                return this.composition.updateCurrentAttributes(), this.updateCurrentActions(), this.attachmentLocationRange && !o2(this.attachmentLocationRange, t4) && this.composition.stopEditingAttachment(), this.notifyEditorElement("selection-change");
              }, u2.prototype.toolbarDidClickButton = function() {
                return this.getLocationRange() ? void 0 : this.setLocationRange({ index: 0, offset: 0 });
              }, u2.prototype.toolbarDidInvokeAction = function(t4) {
                return this.invokeAction(t4);
              }, u2.prototype.toolbarDidToggleAttribute = function(t4) {
                return this.recordFormattingUndoEntry(t4), this.composition.toggleCurrentAttribute(t4), this.render(), this.selectionFrozen ? void 0 : this.editorElement.focus();
              }, u2.prototype.toolbarDidUpdateAttribute = function(t4, e3) {
                return this.recordFormattingUndoEntry(t4), this.composition.setCurrentAttribute(t4, e3), this.render(), this.selectionFrozen ? void 0 : this.editorElement.focus();
              }, u2.prototype.toolbarDidRemoveAttribute = function(t4) {
                return this.recordFormattingUndoEntry(t4), this.composition.removeCurrentAttribute(t4), this.render(), this.selectionFrozen ? void 0 : this.editorElement.focus();
              }, u2.prototype.toolbarWillShowDialog = function() {
                return this.composition.expandSelectionForEditing(), this.freezeSelection();
              }, u2.prototype.toolbarDidShowDialog = function(t4) {
                return this.notifyEditorElement("toolbar-dialog-show", { dialogName: t4 });
              }, u2.prototype.toolbarDidHideDialog = function(t4) {
                return this.thawSelection(), this.editorElement.focus(), this.notifyEditorElement("toolbar-dialog-hide", { dialogName: t4 });
              }, u2.prototype.freezeSelection = function() {
                return this.selectionFrozen ? void 0 : (this.selectionManager.lock(), this.composition.freezeSelection(), this.selectionFrozen = true, this.render());
              }, u2.prototype.thawSelection = function() {
                return this.selectionFrozen ? (this.composition.thawSelection(), this.selectionManager.unlock(), this.selectionFrozen = false, this.render()) : void 0;
              }, u2.prototype.actions = { undo: { test: function() {
                return this.editor.canUndo();
              }, perform: function() {
                return this.editor.undo();
              } }, redo: { test: function() {
                return this.editor.canRedo();
              }, perform: function() {
                return this.editor.redo();
              } }, link: { test: function() {
                return this.editor.canActivateAttribute("href");
              } }, increaseNestingLevel: { test: function() {
                return this.editor.canIncreaseNestingLevel();
              }, perform: function() {
                return this.editor.increaseNestingLevel() && this.render();
              } }, decreaseNestingLevel: { test: function() {
                return this.editor.canDecreaseNestingLevel();
              }, perform: function() {
                return this.editor.decreaseNestingLevel() && this.render();
              } }, attachFiles: { test: function() {
                return true;
              }, perform: function() {
                return e2.config.input.pickFiles(this.editor.insertFiles);
              } } }, u2.prototype.canInvokeAction = function(t4) {
                var e3, n3;
                return this.actionIsExternal(t4) ? true : !!((e3 = this.actions[t4]) != null && (n3 = e3.test) != null ? n3.call(this) : void 0);
              }, u2.prototype.invokeAction = function(t4) {
                var e3, n3;
                return this.actionIsExternal(t4) ? this.notifyEditorElement("action-invoke", { actionName: t4 }) : (e3 = this.actions[t4]) != null && (n3 = e3.perform) != null ? n3.call(this) : void 0;
              }, u2.prototype.actionIsExternal = function(t4) {
                return /^x-./.test(t4);
              }, u2.prototype.getCurrentActions = function() {
                var t4, e3;
                e3 = {};
                for (t4 in this.actions)
                  e3[t4] = this.canInvokeAction(t4);
                return e3;
              }, u2.prototype.updateCurrentActions = function() {
                var t4;
                return t4 = this.getCurrentActions(), n2(t4, this.currentActions) ? void 0 : (this.currentActions = t4, this.toolbarController.updateActions(this.currentActions), this.notifyEditorElement("actions-change", { actions: this.currentActions }));
              }, u2.prototype.runEditorFilters = function() {
                var t4, e3, n3, i3, o3, r3, s4, a3;
                for (a3 = this.composition.getSnapshot(), o3 = this.editor.filters, n3 = 0, i3 = o3.length; i3 > n3; n3++)
                  e3 = o3[n3], t4 = a3.document, s4 = a3.selectedRange, a3 = (r3 = e3.call(this.editor, a3)) != null ? r3 : {}, a3.document == null && (a3.document = t4), a3.selectedRange == null && (a3.selectedRange = s4);
                return c2(a3, this.composition.getSnapshot()) ? void 0 : this.composition.loadSnapshot(a3);
              }, c2 = function(t4, e3) {
                return o2(t4.selectedRange, e3.selectedRange) && t4.document.isEqualTo(e3.document);
              }, u2.prototype.updateInputElement = function() {
                var t4, n3;
                return t4 = this.compositionController.getSerializableElement(), n3 = e2.serializeToContentType(t4, "text/html"), this.editorElement.setInputElementValue(n3);
              }, u2.prototype.notifyEditorElement = function(t4, e3) {
                switch (t4) {
                  case "document-change":
                    this.documentChangedSinceLastRender = true;
                    break;
                  case "render":
                    this.documentChangedSinceLastRender && (this.documentChangedSinceLastRender = false, this.notifyEditorElement("change"));
                    break;
                  case "change":
                  case "attachment-add":
                  case "attachment-edit":
                  case "attachment-remove":
                    this.updateInputElement();
                }
                return this.editorElement.notify(t4, e3);
              }, u2.prototype.removeAttachment = function(t4) {
                return this.editor.recordUndoEntry("Delete Attachment"), this.composition.removeAttachment(t4), this.render();
              }, u2.prototype.recordFormattingUndoEntry = function(e3) {
                var n3, o3;
                return n3 = t3(e3), o3 = this.selectionManager.getLocationRange(), n3 || !i2(o3) ? this.editor.recordUndoEntry("Formatting", { context: this.getUndoContext(), consolidatable: true }) : void 0;
              }, u2.prototype.recordTypingUndoEntry = function() {
                return this.editor.recordUndoEntry("Typing", { context: this.getUndoContext(this.currentAttributes), consolidatable: true });
              }, u2.prototype.getUndoContext = function() {
                var t4;
                return t4 = 1 <= arguments.length ? a2.call(arguments, 0) : [], [this.getLocationContext(), this.getTimeContext()].concat(a2.call(t4));
              }, u2.prototype.getLocationContext = function() {
                var t4;
                return t4 = this.selectionManager.getLocationRange(), i2(t4) ? t4[0].index : t4;
              }, u2.prototype.getTimeContext = function() {
                return e2.config.undoInterval > 0 ? Math.floor(new Date().getTime() / e2.config.undoInterval) : 0;
              }, u2.prototype.isFocused = function() {
                var t4;
                return this.editorElement === ((t4 = this.editorElement.ownerDocument) != null ? t4.activeElement : void 0);
              }, u2.prototype.isFocusedInvisibly = function() {
                return this.isFocused() && !this.getLocationRange();
              }, u2;
            }(e2.Controller);
          }.call(this), function() {
            var t3, n2, i2, o2, r2, s2, a2, u2 = [].indexOf || function(t4) {
              for (var e3 = 0, n3 = this.length; n3 > e3; e3++)
                if (e3 in this && this[e3] === t4)
                  return e3;
              return -1;
            };
            n2 = e2.browser, s2 = e2.makeElement, a2 = e2.triggerEvent, o2 = e2.handleEvent, r2 = e2.handleEventOnce, i2 = e2.findClosestElementFromNode, t3 = e2.AttachmentView.attachmentSelector, e2.registerElement("trix-editor", function() {
              var c2, l2, h, p2, d2, f2, g2, m2, v2;
              return g2 = 0, l2 = function(t4) {
                return !document.querySelector(":focus") && t4.hasAttribute("autofocus") && document.querySelector("[autofocus]") === t4 ? t4.focus() : void 0;
              }, m2 = function(t4) {
                return t4.hasAttribute("contenteditable") ? void 0 : (t4.setAttribute("contenteditable", ""), r2("focus", { onElement: t4, withCallback: function() {
                  return h(t4);
                } }));
              }, h = function(t4) {
                return d2(t4), v2(t4);
              }, d2 = function(t4) {
                return (typeof document.queryCommandSupported == "function" ? document.queryCommandSupported("enableObjectResizing") : void 0) ? (document.execCommand("enableObjectResizing", false, false), o2("mscontrolselect", { onElement: t4, preventDefault: true })) : void 0;
              }, v2 = function() {
                var t4;
                return (typeof document.queryCommandSupported == "function" ? document.queryCommandSupported("DefaultParagraphSeparator") : void 0) && (t4 = e2.config.blockAttributes["default"].tagName, t4 === "div" || t4 === "p") ? document.execCommand("DefaultParagraphSeparator", false, t4) : void 0;
              }, c2 = function(t4) {
                return t4.hasAttribute("role") ? void 0 : t4.setAttribute("role", "textbox");
              }, f2 = function(t4) {
                var e3;
                if (!t4.hasAttribute("aria-label") && !t4.hasAttribute("aria-labelledby"))
                  return (e3 = function() {
                    var e4, n3, i3;
                    return i3 = function() {
                      var n4, i4, o3, r3;
                      for (o3 = t4.labels, r3 = [], n4 = 0, i4 = o3.length; i4 > n4; n4++)
                        e4 = o3[n4], e4.contains(t4) || r3.push(e4.textContent);
                      return r3;
                    }(), (n3 = i3.join(" ")) ? t4.setAttribute("aria-label", n3) : t4.removeAttribute("aria-label");
                  })(), o2("focus", { onElement: t4, withCallback: e3 });
              }, p2 = function() {
                return n2.forcesObjectResizing ? { display: "inline", width: "auto" } : { display: "inline-block", width: "1px" };
              }(), { defaultCSS: "%t {\n  display: block;\n}\n\n%t:empty:not(:focus)::before {\n  content: attr(placeholder);\n  color: graytext;\n  cursor: text;\n  pointer-events: none;\n}\n\n%t a[contenteditable=false] {\n  cursor: text;\n}\n\n%t img {\n  max-width: 100%;\n  height: auto;\n}\n\n%t " + t3 + " figcaption textarea {\n  resize: none;\n}\n\n%t " + t3 + " figcaption textarea.trix-autoresize-clone {\n  position: absolute;\n  left: -9999px;\n  max-height: 0px;\n}\n\n%t " + t3 + " figcaption[data-trix-placeholder]:empty::before {\n  content: attr(data-trix-placeholder);\n  color: graytext;\n}\n\n%t [data-trix-cursor-target] {\n  display: " + p2.display + " !important;\n  width: " + p2.width + " !important;\n  padding: 0 !important;\n  margin: 0 !important;\n  border: none !important;\n}\n\n%t [data-trix-cursor-target=left] {\n  vertical-align: top !important;\n  margin-left: -1px !important;\n}\n\n%t [data-trix-cursor-target=right] {\n  vertical-align: bottom !important;\n  margin-right: -1px !important;\n}", trixId: { get: function() {
                return this.hasAttribute("trix-id") ? this.getAttribute("trix-id") : (this.setAttribute("trix-id", ++g2), this.trixId);
              } }, labels: { get: function() {
                var t4, e3, n3;
                return e3 = [], this.id && this.ownerDocument && e3.push.apply(e3, this.ownerDocument.querySelectorAll("label[for='" + this.id + "']")), (t4 = i2(this, { matchingSelector: "label" })) && ((n3 = t4.control) === this || n3 === null) && e3.push(t4), e3;
              } }, toolbarElement: { get: function() {
                var t4, e3, n3;
                return this.hasAttribute("toolbar") ? (e3 = this.ownerDocument) != null ? e3.getElementById(this.getAttribute("toolbar")) : void 0 : this.parentNode ? (n3 = "trix-toolbar-" + this.trixId, this.setAttribute("toolbar", n3), t4 = s2("trix-toolbar", { id: n3 }), this.parentNode.insertBefore(t4, this), t4) : void 0;
              } }, inputElement: { get: function() {
                var t4, e3, n3;
                return this.hasAttribute("input") ? (n3 = this.ownerDocument) != null ? n3.getElementById(this.getAttribute("input")) : void 0 : this.parentNode ? (e3 = "trix-input-" + this.trixId, this.setAttribute("input", e3), t4 = s2("input", { type: "hidden", id: e3 }), this.parentNode.insertBefore(t4, this.nextElementSibling), t4) : void 0;
              } }, editor: { get: function() {
                var t4;
                return (t4 = this.editorController) != null ? t4.editor : void 0;
              } }, name: { get: function() {
                var t4;
                return (t4 = this.inputElement) != null ? t4.name : void 0;
              } }, value: { get: function() {
                var t4;
                return (t4 = this.inputElement) != null ? t4.value : void 0;
              }, set: function(t4) {
                var e3;
                return this.defaultValue = t4, (e3 = this.editor) != null ? e3.loadHTML(this.defaultValue) : void 0;
              } }, notify: function(t4, e3) {
                return this.editorController ? a2("trix-" + t4, { onElement: this, attributes: e3 }) : void 0;
              }, setInputElementValue: function(t4) {
                var e3;
                return (e3 = this.inputElement) != null ? e3.value = t4 : void 0;
              }, initialize: function() {
                return this.hasAttribute("data-trix-internal") ? void 0 : (m2(this), c2(this), f2(this));
              }, connect: function() {
                return this.hasAttribute("data-trix-internal") ? void 0 : (this.editorController || (a2("trix-before-initialize", { onElement: this }), this.editorController = new e2.EditorController({ editorElement: this, html: this.defaultValue = this.value }), requestAnimationFrame(function(t4) {
                  return function() {
                    return a2("trix-initialize", { onElement: t4 });
                  };
                }(this))), this.editorController.registerSelectionManager(), this.registerResetListener(), this.registerClickListener(), l2(this));
              }, disconnect: function() {
                var t4;
                return (t4 = this.editorController) != null && t4.unregisterSelectionManager(), this.unregisterResetListener(), this.unregisterClickListener();
              }, registerResetListener: function() {
                return this.resetListener = this.resetBubbled.bind(this), window.addEventListener("reset", this.resetListener, false);
              }, unregisterResetListener: function() {
                return window.removeEventListener("reset", this.resetListener, false);
              }, registerClickListener: function() {
                return this.clickListener = this.clickBubbled.bind(this), window.addEventListener("click", this.clickListener, false);
              }, unregisterClickListener: function() {
                return window.removeEventListener("click", this.clickListener, false);
              }, resetBubbled: function(t4) {
                var e3;
                if (!t4.defaultPrevented && t4.target === ((e3 = this.inputElement) != null ? e3.form : void 0))
                  return this.reset();
              }, clickBubbled: function(t4) {
                var e3;
                if (!(t4.defaultPrevented || this.contains(t4.target) || !(e3 = i2(t4.target, { matchingSelector: "label" })) || u2.call(this.labels, e3) < 0))
                  return this.focus();
              }, reset: function() {
                return this.value = this.defaultValue;
              } };
            }());
          }.call(this), function() {
          }.call(this);
        }).call(this), typeof module == "object" && module.exports ? module.exports = e2 : typeof define == "function" && define.amd && define(e2);
      }.call(exports);
    }
  });

  // node_modules/jquery/dist/jquery.js
  var require_jquery = __commonJS({
    "node_modules/jquery/dist/jquery.js"(exports, module) {
      (function(global2, factory) {
        "use strict";
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = global2.document ? factory(global2, true) : function(w) {
            if (!w.document) {
              throw new Error("jQuery requires a window with a document");
            }
            return factory(w);
          };
        } else {
          factory(global2);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
        "use strict";
        var arr = [];
        var getProto = Object.getPrototypeOf;
        var slice = arr.slice;
        var flat = arr.flat ? function(array) {
          return arr.flat.call(array);
        } : function(array) {
          return arr.concat.apply([], array);
        };
        var push = arr.push;
        var indexOf2 = arr.indexOf;
        var class2type = {};
        var toString = class2type.toString;
        var hasOwn = class2type.hasOwnProperty;
        var fnToString = hasOwn.toString;
        var ObjectFunctionString = fnToString.call(Object);
        var support = {};
        var isFunction = function isFunction2(obj) {
          return typeof obj === "function" && typeof obj.nodeType !== "number";
        };
        var isWindow = function isWindow2(obj) {
          return obj != null && obj === obj.window;
        };
        var document2 = window2.document;
        var preservedScriptAttributes = {
          type: true,
          src: true,
          nonce: true,
          noModule: true
        };
        function DOMEval(code3, node, doc) {
          doc = doc || document2;
          var i2, val, script = doc.createElement("script");
          script.text = code3;
          if (node) {
            for (i2 in preservedScriptAttributes) {
              val = node[i2] || node.getAttribute && node.getAttribute(i2);
              if (val) {
                script.setAttribute(i2, val);
              }
            }
          }
          doc.head.appendChild(script).parentNode.removeChild(script);
        }
        function toType(obj) {
          if (obj == null) {
            return obj + "";
          }
          return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
        }
        var version = "3.5.1", jQuery2 = function(selector, context) {
          return new jQuery2.fn.init(selector, context);
        };
        jQuery2.fn = jQuery2.prototype = {
          jquery: version,
          constructor: jQuery2,
          length: 0,
          toArray: function() {
            return slice.call(this);
          },
          get: function(num) {
            if (num == null) {
              return slice.call(this);
            }
            return num < 0 ? this[num + this.length] : this[num];
          },
          pushStack: function(elems) {
            var ret = jQuery2.merge(this.constructor(), elems);
            ret.prevObject = this;
            return ret;
          },
          each: function(callback) {
            return jQuery2.each(this, callback);
          },
          map: function(callback) {
            return this.pushStack(jQuery2.map(this, function(elem, i2) {
              return callback.call(elem, i2, elem);
            }));
          },
          slice: function() {
            return this.pushStack(slice.apply(this, arguments));
          },
          first: function() {
            return this.eq(0);
          },
          last: function() {
            return this.eq(-1);
          },
          even: function() {
            return this.pushStack(jQuery2.grep(this, function(_elem, i2) {
              return (i2 + 1) % 2;
            }));
          },
          odd: function() {
            return this.pushStack(jQuery2.grep(this, function(_elem, i2) {
              return i2 % 2;
            }));
          },
          eq: function(i2) {
            var len = this.length, j2 = +i2 + (i2 < 0 ? len : 0);
            return this.pushStack(j2 >= 0 && j2 < len ? [this[j2]] : []);
          },
          end: function() {
            return this.prevObject || this.constructor();
          },
          push,
          sort: arr.sort,
          splice: arr.splice
        };
        jQuery2.extend = jQuery2.fn.extend = function() {
          var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i2 = 1, length = arguments.length, deep = false;
          if (typeof target === "boolean") {
            deep = target;
            target = arguments[i2] || {};
            i2++;
          }
          if (typeof target !== "object" && !isFunction(target)) {
            target = {};
          }
          if (i2 === length) {
            target = this;
            i2--;
          }
          for (; i2 < length; i2++) {
            if ((options = arguments[i2]) != null) {
              for (name in options) {
                copy = options[name];
                if (name === "__proto__" || target === copy) {
                  continue;
                }
                if (deep && copy && (jQuery2.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                  src = target[name];
                  if (copyIsArray && !Array.isArray(src)) {
                    clone = [];
                  } else if (!copyIsArray && !jQuery2.isPlainObject(src)) {
                    clone = {};
                  } else {
                    clone = src;
                  }
                  copyIsArray = false;
                  target[name] = jQuery2.extend(deep, clone, copy);
                } else if (copy !== void 0) {
                  target[name] = copy;
                }
              }
            }
          }
          return target;
        };
        jQuery2.extend({
          expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
          isReady: true,
          error: function(msg) {
            throw new Error(msg);
          },
          noop: function() {
          },
          isPlainObject: function(obj) {
            var proto, Ctor;
            if (!obj || toString.call(obj) !== "[object Object]") {
              return false;
            }
            proto = getProto(obj);
            if (!proto) {
              return true;
            }
            Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
            return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
          },
          isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
              return false;
            }
            return true;
          },
          globalEval: function(code3, options, doc) {
            DOMEval(code3, { nonce: options && options.nonce }, doc);
          },
          each: function(obj, callback) {
            var length, i2 = 0;
            if (isArrayLike(obj)) {
              length = obj.length;
              for (; i2 < length; i2++) {
                if (callback.call(obj[i2], i2, obj[i2]) === false) {
                  break;
                }
              }
            } else {
              for (i2 in obj) {
                if (callback.call(obj[i2], i2, obj[i2]) === false) {
                  break;
                }
              }
            }
            return obj;
          },
          makeArray: function(arr2, results) {
            var ret = results || [];
            if (arr2 != null) {
              if (isArrayLike(Object(arr2))) {
                jQuery2.merge(ret, typeof arr2 === "string" ? [arr2] : arr2);
              } else {
                push.call(ret, arr2);
              }
            }
            return ret;
          },
          inArray: function(elem, arr2, i2) {
            return arr2 == null ? -1 : indexOf2.call(arr2, elem, i2);
          },
          merge: function(first, second) {
            var len = +second.length, j2 = 0, i2 = first.length;
            for (; j2 < len; j2++) {
              first[i2++] = second[j2];
            }
            first.length = i2;
            return first;
          },
          grep: function(elems, callback, invert) {
            var callbackInverse, matches = [], i2 = 0, length = elems.length, callbackExpect = !invert;
            for (; i2 < length; i2++) {
              callbackInverse = !callback(elems[i2], i2);
              if (callbackInverse !== callbackExpect) {
                matches.push(elems[i2]);
              }
            }
            return matches;
          },
          map: function(elems, callback, arg) {
            var length, value, i2 = 0, ret = [];
            if (isArrayLike(elems)) {
              length = elems.length;
              for (; i2 < length; i2++) {
                value = callback(elems[i2], i2, arg);
                if (value != null) {
                  ret.push(value);
                }
              }
            } else {
              for (i2 in elems) {
                value = callback(elems[i2], i2, arg);
                if (value != null) {
                  ret.push(value);
                }
              }
            }
            return flat(ret);
          },
          guid: 1,
          support
        });
        if (typeof Symbol === "function") {
          jQuery2.fn[Symbol.iterator] = arr[Symbol.iterator];
        }
        jQuery2.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(_i, name) {
          class2type["[object " + name + "]"] = name.toLowerCase();
        });
        function isArrayLike(obj) {
          var length = !!obj && "length" in obj && obj.length, type = toType(obj);
          if (isFunction(obj) || isWindow(obj)) {
            return false;
          }
          return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
        }
        var Sizzle = function(window3) {
          var i2, support2, Expr, getText, isXML, tokenize2, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document3, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains2, expando = "sizzle" + 1 * new Date(), preferredDoc = window3.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a2, b2) {
            if (a2 === b2) {
              hasDuplicate = true;
            }
            return 0;
          }, hasOwn2 = {}.hasOwnProperty, arr2 = [], pop = arr2.pop, pushNative = arr2.push, push2 = arr2.push, slice2 = arr2.slice, indexOf3 = function(list, elem) {
            var i3 = 0, len = list.length;
            for (; i3 < len; i3++) {
              if (list[i3] === elem) {
                return i3;
              }
            }
            return -1;
          }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rtrim2 = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            "ID": new RegExp("^#(" + identifier + ")"),
            "CLASS": new RegExp("^\\.(" + identifier + ")"),
            "TAG": new RegExp("^(" + identifier + "|[*])"),
            "ATTR": new RegExp("^" + attributes),
            "PSEUDO": new RegExp("^" + pseudos),
            "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
            "bool": new RegExp("^(?:" + booleans + ")$", "i"),
            "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
          }, rhtml2 = /HTML$/i, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape2, nonHex) {
            var high = "0x" + escape2.slice(1) - 65536;
            return nonHex ? nonHex : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
          }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
            if (asCodePoint) {
              if (ch === "\0") {
                return "\uFFFD";
              }
              return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
            }
            return "\\" + ch;
          }, unloadHandler = function() {
            setDocument();
          }, inDisabledFieldset = addCombinator(function(elem) {
            return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
          }, { dir: "parentNode", next: "legend" });
          try {
            push2.apply(arr2 = slice2.call(preferredDoc.childNodes), preferredDoc.childNodes);
            arr2[preferredDoc.childNodes.length].nodeType;
          } catch (e2) {
            push2 = {
              apply: arr2.length ? function(target, els) {
                pushNative.apply(target, slice2.call(els));
              } : function(target, els) {
                var j2 = target.length, i3 = 0;
                while (target[j2++] = els[i3++]) {
                }
                target.length = j2 - 1;
              }
            };
          }
          function Sizzle2(selector, context, results, seed) {
            var m2, i3, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
            results = results || [];
            if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
              return results;
            }
            if (!seed) {
              setDocument(context);
              context = context || document3;
              if (documentIsHTML) {
                if (nodeType !== 11 && (match = rquickExpr2.exec(selector))) {
                  if (m2 = match[1]) {
                    if (nodeType === 9) {
                      if (elem = context.getElementById(m2)) {
                        if (elem.id === m2) {
                          results.push(elem);
                          return results;
                        }
                      } else {
                        return results;
                      }
                    } else {
                      if (newContext && (elem = newContext.getElementById(m2)) && contains2(context, elem) && elem.id === m2) {
                        results.push(elem);
                        return results;
                      }
                    }
                  } else if (match[2]) {
                    push2.apply(results, context.getElementsByTagName(selector));
                    return results;
                  } else if ((m2 = match[3]) && support2.getElementsByClassName && context.getElementsByClassName) {
                    push2.apply(results, context.getElementsByClassName(m2));
                    return results;
                  }
                }
                if (support2.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && (nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
                  newSelector = selector;
                  newContext = context;
                  if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {
                    newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                    if (newContext !== context || !support2.scope) {
                      if (nid = context.getAttribute("id")) {
                        nid = nid.replace(rcssescape, fcssescape);
                      } else {
                        context.setAttribute("id", nid = expando);
                      }
                    }
                    groups = tokenize2(selector);
                    i3 = groups.length;
                    while (i3--) {
                      groups[i3] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i3]);
                    }
                    newSelector = groups.join(",");
                  }
                  try {
                    push2.apply(results, newContext.querySelectorAll(newSelector));
                    return results;
                  } catch (qsaError) {
                    nonnativeSelectorCache(selector, true);
                  } finally {
                    if (nid === expando) {
                      context.removeAttribute("id");
                    }
                  }
                }
              }
            }
            return select(selector.replace(rtrim2, "$1"), context, results, seed);
          }
          function createCache() {
            var keys = [];
            function cache(key, value) {
              if (keys.push(key + " ") > Expr.cacheLength) {
                delete cache[keys.shift()];
              }
              return cache[key + " "] = value;
            }
            return cache;
          }
          function markFunction(fn2) {
            fn2[expando] = true;
            return fn2;
          }
          function assert(fn2) {
            var el = document3.createElement("fieldset");
            try {
              return !!fn2(el);
            } catch (e2) {
              return false;
            } finally {
              if (el.parentNode) {
                el.parentNode.removeChild(el);
              }
              el = null;
            }
          }
          function addHandle(attrs, handler) {
            var arr3 = attrs.split("|"), i3 = arr3.length;
            while (i3--) {
              Expr.attrHandle[arr3[i3]] = handler;
            }
          }
          function siblingCheck(a2, b2) {
            var cur = b2 && a2, diff = cur && a2.nodeType === 1 && b2.nodeType === 1 && a2.sourceIndex - b2.sourceIndex;
            if (diff) {
              return diff;
            }
            if (cur) {
              while (cur = cur.nextSibling) {
                if (cur === b2) {
                  return -1;
                }
              }
            }
            return a2 ? 1 : -1;
          }
          function createInputPseudo(type) {
            return function(elem) {
              var name = elem.nodeName.toLowerCase();
              return name === "input" && elem.type === type;
            };
          }
          function createButtonPseudo(type) {
            return function(elem) {
              var name = elem.nodeName.toLowerCase();
              return (name === "input" || name === "button") && elem.type === type;
            };
          }
          function createDisabledPseudo(disabled) {
            return function(elem) {
              if ("form" in elem) {
                if (elem.parentNode && elem.disabled === false) {
                  if ("label" in elem) {
                    if ("label" in elem.parentNode) {
                      return elem.parentNode.disabled === disabled;
                    } else {
                      return elem.disabled === disabled;
                    }
                  }
                  return elem.isDisabled === disabled || elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
                }
                return elem.disabled === disabled;
              } else if ("label" in elem) {
                return elem.disabled === disabled;
              }
              return false;
            };
          }
          function createPositionalPseudo(fn2) {
            return markFunction(function(argument) {
              argument = +argument;
              return markFunction(function(seed, matches2) {
                var j2, matchIndexes = fn2([], seed.length, argument), i3 = matchIndexes.length;
                while (i3--) {
                  if (seed[j2 = matchIndexes[i3]]) {
                    seed[j2] = !(matches2[j2] = seed[j2]);
                  }
                }
              });
            });
          }
          function testContext(context) {
            return context && typeof context.getElementsByTagName !== "undefined" && context;
          }
          support2 = Sizzle2.support = {};
          isXML = Sizzle2.isXML = function(elem) {
            var namespace = elem.namespaceURI, docElem2 = (elem.ownerDocument || elem).documentElement;
            return !rhtml2.test(namespace || docElem2 && docElem2.nodeName || "HTML");
          };
          setDocument = Sizzle2.setDocument = function(node) {
            var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
            if (doc == document3 || doc.nodeType !== 9 || !doc.documentElement) {
              return document3;
            }
            document3 = doc;
            docElem = document3.documentElement;
            documentIsHTML = !isXML(document3);
            if (preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
              if (subWindow.addEventListener) {
                subWindow.addEventListener("unload", unloadHandler, false);
              } else if (subWindow.attachEvent) {
                subWindow.attachEvent("onunload", unloadHandler);
              }
            }
            support2.scope = assert(function(el) {
              docElem.appendChild(el).appendChild(document3.createElement("div"));
              return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
            });
            support2.attributes = assert(function(el) {
              el.className = "i";
              return !el.getAttribute("className");
            });
            support2.getElementsByTagName = assert(function(el) {
              el.appendChild(document3.createComment(""));
              return !el.getElementsByTagName("*").length;
            });
            support2.getElementsByClassName = rnative.test(document3.getElementsByClassName);
            support2.getById = assert(function(el) {
              docElem.appendChild(el).id = expando;
              return !document3.getElementsByName || !document3.getElementsByName(expando).length;
            });
            if (support2.getById) {
              Expr.filter["ID"] = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                  return elem.getAttribute("id") === attrId;
                };
              };
              Expr.find["ID"] = function(id, context) {
                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                  var elem = context.getElementById(id);
                  return elem ? [elem] : [];
                }
              };
            } else {
              Expr.filter["ID"] = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                  var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                  return node2 && node2.value === attrId;
                };
              };
              Expr.find["ID"] = function(id, context) {
                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                  var node2, i3, elems, elem = context.getElementById(id);
                  if (elem) {
                    node2 = elem.getAttributeNode("id");
                    if (node2 && node2.value === id) {
                      return [elem];
                    }
                    elems = context.getElementsByName(id);
                    i3 = 0;
                    while (elem = elems[i3++]) {
                      node2 = elem.getAttributeNode("id");
                      if (node2 && node2.value === id) {
                        return [elem];
                      }
                    }
                  }
                  return [];
                }
              };
            }
            Expr.find["TAG"] = support2.getElementsByTagName ? function(tag, context) {
              if (typeof context.getElementsByTagName !== "undefined") {
                return context.getElementsByTagName(tag);
              } else if (support2.qsa) {
                return context.querySelectorAll(tag);
              }
            } : function(tag, context) {
              var elem, tmp = [], i3 = 0, results = context.getElementsByTagName(tag);
              if (tag === "*") {
                while (elem = results[i3++]) {
                  if (elem.nodeType === 1) {
                    tmp.push(elem);
                  }
                }
                return tmp;
              }
              return results;
            };
            Expr.find["CLASS"] = support2.getElementsByClassName && function(className, context) {
              if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                return context.getElementsByClassName(className);
              }
            };
            rbuggyMatches = [];
            rbuggyQSA = [];
            if (support2.qsa = rnative.test(document3.querySelectorAll)) {
              assert(function(el) {
                var input;
                docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\r\\' msallowcapture=''><option selected=''></option></select>";
                if (el.querySelectorAll("[msallowcapture^='']").length) {
                  rbuggyQSA.push("[*^$]=" + whitespace + `*(?:''|"")`);
                }
                if (!el.querySelectorAll("[selected]").length) {
                  rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                }
                if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
                  rbuggyQSA.push("~=");
                }
                input = document3.createElement("input");
                input.setAttribute("name", "");
                el.appendChild(input);
                if (!el.querySelectorAll("[name='']").length) {
                  rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + `*(?:''|"")`);
                }
                if (!el.querySelectorAll(":checked").length) {
                  rbuggyQSA.push(":checked");
                }
                if (!el.querySelectorAll("a#" + expando + "+*").length) {
                  rbuggyQSA.push(".#.+[+~]");
                }
                el.querySelectorAll("\\\f");
                rbuggyQSA.push("[\\r\\n\\f]");
              });
              assert(function(el) {
                el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                var input = document3.createElement("input");
                input.setAttribute("type", "hidden");
                el.appendChild(input).setAttribute("name", "D");
                if (el.querySelectorAll("[name=d]").length) {
                  rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                }
                if (el.querySelectorAll(":enabled").length !== 2) {
                  rbuggyQSA.push(":enabled", ":disabled");
                }
                docElem.appendChild(el).disabled = true;
                if (el.querySelectorAll(":disabled").length !== 2) {
                  rbuggyQSA.push(":enabled", ":disabled");
                }
                el.querySelectorAll("*,:x");
                rbuggyQSA.push(",.*:");
              });
            }
            if (support2.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
              assert(function(el) {
                support2.disconnectedMatch = matches.call(el, "*");
                matches.call(el, "[s!='']:x");
                rbuggyMatches.push("!=", pseudos);
              });
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
            hasCompare = rnative.test(docElem.compareDocumentPosition);
            contains2 = hasCompare || rnative.test(docElem.contains) ? function(a2, b2) {
              var adown = a2.nodeType === 9 ? a2.documentElement : a2, bup = b2 && b2.parentNode;
              return a2 === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a2.compareDocumentPosition && a2.compareDocumentPosition(bup) & 16));
            } : function(a2, b2) {
              if (b2) {
                while (b2 = b2.parentNode) {
                  if (b2 === a2) {
                    return true;
                  }
                }
              }
              return false;
            };
            sortOrder = hasCompare ? function(a2, b2) {
              if (a2 === b2) {
                hasDuplicate = true;
                return 0;
              }
              var compare = !a2.compareDocumentPosition - !b2.compareDocumentPosition;
              if (compare) {
                return compare;
              }
              compare = (a2.ownerDocument || a2) == (b2.ownerDocument || b2) ? a2.compareDocumentPosition(b2) : 1;
              if (compare & 1 || !support2.sortDetached && b2.compareDocumentPosition(a2) === compare) {
                if (a2 == document3 || a2.ownerDocument == preferredDoc && contains2(preferredDoc, a2)) {
                  return -1;
                }
                if (b2 == document3 || b2.ownerDocument == preferredDoc && contains2(preferredDoc, b2)) {
                  return 1;
                }
                return sortInput ? indexOf3(sortInput, a2) - indexOf3(sortInput, b2) : 0;
              }
              return compare & 4 ? -1 : 1;
            } : function(a2, b2) {
              if (a2 === b2) {
                hasDuplicate = true;
                return 0;
              }
              var cur, i3 = 0, aup = a2.parentNode, bup = b2.parentNode, ap = [a2], bp = [b2];
              if (!aup || !bup) {
                return a2 == document3 ? -1 : b2 == document3 ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf3(sortInput, a2) - indexOf3(sortInput, b2) : 0;
              } else if (aup === bup) {
                return siblingCheck(a2, b2);
              }
              cur = a2;
              while (cur = cur.parentNode) {
                ap.unshift(cur);
              }
              cur = b2;
              while (cur = cur.parentNode) {
                bp.unshift(cur);
              }
              while (ap[i3] === bp[i3]) {
                i3++;
              }
              return i3 ? siblingCheck(ap[i3], bp[i3]) : ap[i3] == preferredDoc ? -1 : bp[i3] == preferredDoc ? 1 : 0;
            };
            return document3;
          };
          Sizzle2.matches = function(expr, elements) {
            return Sizzle2(expr, null, null, elements);
          };
          Sizzle2.matchesSelector = function(elem, expr) {
            setDocument(elem);
            if (support2.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
              try {
                var ret = matches.call(elem, expr);
                if (ret || support2.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                  return ret;
                }
              } catch (e2) {
                nonnativeSelectorCache(expr, true);
              }
            }
            return Sizzle2(expr, document3, null, [elem]).length > 0;
          };
          Sizzle2.contains = function(context, elem) {
            if ((context.ownerDocument || context) != document3) {
              setDocument(context);
            }
            return contains2(context, elem);
          };
          Sizzle2.attr = function(elem, name) {
            if ((elem.ownerDocument || elem) != document3) {
              setDocument(elem);
            }
            var fn2 = Expr.attrHandle[name.toLowerCase()], val = fn2 && hasOwn2.call(Expr.attrHandle, name.toLowerCase()) ? fn2(elem, name, !documentIsHTML) : void 0;
            return val !== void 0 ? val : support2.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
          };
          Sizzle2.escape = function(sel) {
            return (sel + "").replace(rcssescape, fcssescape);
          };
          Sizzle2.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
          };
          Sizzle2.uniqueSort = function(results) {
            var elem, duplicates = [], j2 = 0, i3 = 0;
            hasDuplicate = !support2.detectDuplicates;
            sortInput = !support2.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
              while (elem = results[i3++]) {
                if (elem === results[i3]) {
                  j2 = duplicates.push(i3);
                }
              }
              while (j2--) {
                results.splice(duplicates[j2], 1);
              }
            }
            sortInput = null;
            return results;
          };
          getText = Sizzle2.getText = function(elem) {
            var node, ret = "", i3 = 0, nodeType = elem.nodeType;
            if (!nodeType) {
              while (node = elem[i3++]) {
                ret += getText(node);
              }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
              if (typeof elem.textContent === "string") {
                return elem.textContent;
              } else {
                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                  ret += getText(elem);
                }
              }
            } else if (nodeType === 3 || nodeType === 4) {
              return elem.nodeValue;
            }
            return ret;
          };
          Expr = Sizzle2.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
              ">": { dir: "parentNode", first: true },
              " ": { dir: "parentNode" },
              "+": { dir: "previousSibling", first: true },
              "~": { dir: "previousSibling" }
            },
            preFilter: {
              "ATTR": function(match) {
                match[1] = match[1].replace(runescape, funescape);
                match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                if (match[2] === "~=") {
                  match[3] = " " + match[3] + " ";
                }
                return match.slice(0, 4);
              },
              "CHILD": function(match) {
                match[1] = match[1].toLowerCase();
                if (match[1].slice(0, 3) === "nth") {
                  if (!match[3]) {
                    Sizzle2.error(match[0]);
                  }
                  match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                  match[5] = +(match[7] + match[8] || match[3] === "odd");
                } else if (match[3]) {
                  Sizzle2.error(match[0]);
                }
                return match;
              },
              "PSEUDO": function(match) {
                var excess, unquoted = !match[6] && match[2];
                if (matchExpr["CHILD"].test(match[0])) {
                  return null;
                }
                if (match[3]) {
                  match[2] = match[4] || match[5] || "";
                } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize2(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                  match[0] = match[0].slice(0, excess);
                  match[2] = unquoted.slice(0, excess);
                }
                return match.slice(0, 3);
              }
            },
            filter: {
              "TAG": function(nodeNameSelector) {
                var nodeName2 = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                return nodeNameSelector === "*" ? function() {
                  return true;
                } : function(elem) {
                  return elem.nodeName && elem.nodeName.toLowerCase() === nodeName2;
                };
              },
              "CLASS": function(className) {
                var pattern = classCache[className + " "];
                return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                  return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                });
              },
              "ATTR": function(name, operator, check) {
                return function(elem) {
                  var result = Sizzle2.attr(elem, name);
                  if (result == null) {
                    return operator === "!=";
                  }
                  if (!operator) {
                    return true;
                  }
                  result += "";
                  return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
                };
              },
              "CHILD": function(type, what, _argument, first, last) {
                var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                return first === 1 && last === 0 ? function(elem) {
                  return !!elem.parentNode;
                } : function(elem, _context, xml) {
                  var cache, uniqueCache, outerCache, node, nodeIndex, start4, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                  if (parent) {
                    if (simple) {
                      while (dir2) {
                        node = elem;
                        while (node = node[dir2]) {
                          if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                            return false;
                          }
                        }
                        start4 = dir2 = type === "only" && !start4 && "nextSibling";
                      }
                      return true;
                    }
                    start4 = [forward ? parent.firstChild : parent.lastChild];
                    if (forward && useCache) {
                      node = parent;
                      outerCache = node[expando] || (node[expando] = {});
                      uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                      cache = uniqueCache[type] || [];
                      nodeIndex = cache[0] === dirruns && cache[1];
                      diff = nodeIndex && cache[2];
                      node = nodeIndex && parent.childNodes[nodeIndex];
                      while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start4.pop()) {
                        if (node.nodeType === 1 && ++diff && node === elem) {
                          uniqueCache[type] = [dirruns, nodeIndex, diff];
                          break;
                        }
                      }
                    } else {
                      if (useCache) {
                        node = elem;
                        outerCache = node[expando] || (node[expando] = {});
                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                        cache = uniqueCache[type] || [];
                        nodeIndex = cache[0] === dirruns && cache[1];
                        diff = nodeIndex;
                      }
                      if (diff === false) {
                        while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start4.pop()) {
                          if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                            if (useCache) {
                              outerCache = node[expando] || (node[expando] = {});
                              uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                              uniqueCache[type] = [dirruns, diff];
                            }
                            if (node === elem) {
                              break;
                            }
                          }
                        }
                      }
                    }
                    diff -= last;
                    return diff === first || diff % first === 0 && diff / first >= 0;
                  }
                };
              },
              "PSEUDO": function(pseudo, argument) {
                var args, fn2 = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle2.error("unsupported pseudo: " + pseudo);
                if (fn2[expando]) {
                  return fn2(argument);
                }
                if (fn2.length > 1) {
                  args = [pseudo, pseudo, "", argument];
                  return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
                    var idx, matched = fn2(seed, argument), i3 = matched.length;
                    while (i3--) {
                      idx = indexOf3(seed, matched[i3]);
                      seed[idx] = !(matches2[idx] = matched[i3]);
                    }
                  }) : function(elem) {
                    return fn2(elem, 0, args);
                  };
                }
                return fn2;
              }
            },
            pseudos: {
              "not": markFunction(function(selector) {
                var input = [], results = [], matcher = compile(selector.replace(rtrim2, "$1"));
                return matcher[expando] ? markFunction(function(seed, matches2, _context, xml) {
                  var elem, unmatched = matcher(seed, null, xml, []), i3 = seed.length;
                  while (i3--) {
                    if (elem = unmatched[i3]) {
                      seed[i3] = !(matches2[i3] = elem);
                    }
                  }
                }) : function(elem, _context, xml) {
                  input[0] = elem;
                  matcher(input, null, xml, results);
                  input[0] = null;
                  return !results.pop();
                };
              }),
              "has": markFunction(function(selector) {
                return function(elem) {
                  return Sizzle2(selector, elem).length > 0;
                };
              }),
              "contains": markFunction(function(text) {
                text = text.replace(runescape, funescape);
                return function(elem) {
                  return (elem.textContent || getText(elem)).indexOf(text) > -1;
                };
              }),
              "lang": markFunction(function(lang) {
                if (!ridentifier.test(lang || "")) {
                  Sizzle2.error("unsupported lang: " + lang);
                }
                lang = lang.replace(runescape, funescape).toLowerCase();
                return function(elem) {
                  var elemLang;
                  do {
                    if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                      elemLang = elemLang.toLowerCase();
                      return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                    }
                  } while ((elem = elem.parentNode) && elem.nodeType === 1);
                  return false;
                };
              }),
              "target": function(elem) {
                var hash3 = window3.location && window3.location.hash;
                return hash3 && hash3.slice(1) === elem.id;
              },
              "root": function(elem) {
                return elem === docElem;
              },
              "focus": function(elem) {
                return elem === document3.activeElement && (!document3.hasFocus || document3.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
              },
              "enabled": createDisabledPseudo(false),
              "disabled": createDisabledPseudo(true),
              "checked": function(elem) {
                var nodeName2 = elem.nodeName.toLowerCase();
                return nodeName2 === "input" && !!elem.checked || nodeName2 === "option" && !!elem.selected;
              },
              "selected": function(elem) {
                if (elem.parentNode) {
                  elem.parentNode.selectedIndex;
                }
                return elem.selected === true;
              },
              "empty": function(elem) {
                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                  if (elem.nodeType < 6) {
                    return false;
                  }
                }
                return true;
              },
              "parent": function(elem) {
                return !Expr.pseudos["empty"](elem);
              },
              "header": function(elem) {
                return rheader.test(elem.nodeName);
              },
              "input": function(elem) {
                return rinputs.test(elem.nodeName);
              },
              "button": function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === "button" || name === "button";
              },
              "text": function(elem) {
                var attr;
                return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
              },
              "first": createPositionalPseudo(function() {
                return [0];
              }),
              "last": createPositionalPseudo(function(_matchIndexes, length) {
                return [length - 1];
              }),
              "eq": createPositionalPseudo(function(_matchIndexes, length, argument) {
                return [argument < 0 ? argument + length : argument];
              }),
              "even": createPositionalPseudo(function(matchIndexes, length) {
                var i3 = 0;
                for (; i3 < length; i3 += 2) {
                  matchIndexes.push(i3);
                }
                return matchIndexes;
              }),
              "odd": createPositionalPseudo(function(matchIndexes, length) {
                var i3 = 1;
                for (; i3 < length; i3 += 2) {
                  matchIndexes.push(i3);
                }
                return matchIndexes;
              }),
              "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
                var i3 = argument < 0 ? argument + length : argument > length ? length : argument;
                for (; --i3 >= 0; ) {
                  matchIndexes.push(i3);
                }
                return matchIndexes;
              }),
              "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
                var i3 = argument < 0 ? argument + length : argument;
                for (; ++i3 < length; ) {
                  matchIndexes.push(i3);
                }
                return matchIndexes;
              })
            }
          };
          Expr.pseudos["nth"] = Expr.pseudos["eq"];
          for (i2 in { radio: true, checkbox: true, file: true, password: true, image: true }) {
            Expr.pseudos[i2] = createInputPseudo(i2);
          }
          for (i2 in { submit: true, reset: true }) {
            Expr.pseudos[i2] = createButtonPseudo(i2);
          }
          function setFilters() {
          }
          setFilters.prototype = Expr.filters = Expr.pseudos;
          Expr.setFilters = new setFilters();
          tokenize2 = Sizzle2.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) {
              return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
              if (!matched || (match = rcomma.exec(soFar))) {
                if (match) {
                  soFar = soFar.slice(match[0].length) || soFar;
                }
                groups.push(tokens = []);
              }
              matched = false;
              if (match = rcombinators.exec(soFar)) {
                matched = match.shift();
                tokens.push({
                  value: matched,
                  type: match[0].replace(rtrim2, " ")
                });
                soFar = soFar.slice(matched.length);
              }
              for (type in Expr.filter) {
                if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                  matched = match.shift();
                  tokens.push({
                    value: matched,
                    type,
                    matches: match
                  });
                  soFar = soFar.slice(matched.length);
                }
              }
              if (!matched) {
                break;
              }
            }
            return parseOnly ? soFar.length : soFar ? Sizzle2.error(selector) : tokenCache(selector, groups).slice(0);
          };
          function toSelector(tokens) {
            var i3 = 0, len = tokens.length, selector = "";
            for (; i3 < len; i3++) {
              selector += tokens[i3].value;
            }
            return selector;
          }
          function addCombinator(matcher, combinator, base) {
            var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
            return combinator.first ? function(elem, context, xml) {
              while (elem = elem[dir2]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  return matcher(elem, context, xml);
                }
              }
              return false;
            } : function(elem, context, xml) {
              var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];
              if (xml) {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    if (matcher(elem, context, xml)) {
                      return true;
                    }
                  }
                }
              } else {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    outerCache = elem[expando] || (elem[expando] = {});
                    uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                    if (skip && skip === elem.nodeName.toLowerCase()) {
                      elem = elem[dir2] || elem;
                    } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                      return newCache[2] = oldCache[2];
                    } else {
                      uniqueCache[key] = newCache;
                      if (newCache[2] = matcher(elem, context, xml)) {
                        return true;
                      }
                    }
                  }
                }
              }
              return false;
            };
          }
          function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
              var i3 = matchers.length;
              while (i3--) {
                if (!matchers[i3](elem, context, xml)) {
                  return false;
                }
              }
              return true;
            } : matchers[0];
          }
          function multipleContexts(selector, contexts, results) {
            var i3 = 0, len = contexts.length;
            for (; i3 < len; i3++) {
              Sizzle2(selector, contexts[i3], results);
            }
            return results;
          }
          function condense(unmatched, map, filter2, context, xml) {
            var elem, newUnmatched = [], i3 = 0, len = unmatched.length, mapped = map != null;
            for (; i3 < len; i3++) {
              if (elem = unmatched[i3]) {
                if (!filter2 || filter2(elem, context, xml)) {
                  newUnmatched.push(elem);
                  if (mapped) {
                    map.push(i3);
                  }
                }
              }
            }
            return newUnmatched;
          }
          function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
              postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
              postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function(seed, results, context, xml) {
              var temp, i3, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
              if (matcher) {
                matcher(matcherIn, matcherOut, context, xml);
              }
              if (postFilter) {
                temp = condense(matcherOut, postMap);
                postFilter(temp, [], context, xml);
                i3 = temp.length;
                while (i3--) {
                  if (elem = temp[i3]) {
                    matcherOut[postMap[i3]] = !(matcherIn[postMap[i3]] = elem);
                  }
                }
              }
              if (seed) {
                if (postFinder || preFilter) {
                  if (postFinder) {
                    temp = [];
                    i3 = matcherOut.length;
                    while (i3--) {
                      if (elem = matcherOut[i3]) {
                        temp.push(matcherIn[i3] = elem);
                      }
                    }
                    postFinder(null, matcherOut = [], temp, xml);
                  }
                  i3 = matcherOut.length;
                  while (i3--) {
                    if ((elem = matcherOut[i3]) && (temp = postFinder ? indexOf3(seed, elem) : preMap[i3]) > -1) {
                      seed[temp] = !(results[temp] = elem);
                    }
                  }
                }
              } else {
                matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                if (postFinder) {
                  postFinder(null, results, matcherOut, xml);
                } else {
                  push2.apply(results, matcherOut);
                }
              }
            });
          }
          function matcherFromTokens(tokens) {
            var checkContext, matcher, j2, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i3 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
              return elem === checkContext;
            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
              return indexOf3(checkContext, elem) > -1;
            }, implicitRelative, true), matchers = [function(elem, context, xml) {
              var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
              checkContext = null;
              return ret;
            }];
            for (; i3 < len; i3++) {
              if (matcher = Expr.relative[tokens[i3].type]) {
                matchers = [addCombinator(elementMatcher(matchers), matcher)];
              } else {
                matcher = Expr.filter[tokens[i3].type].apply(null, tokens[i3].matches);
                if (matcher[expando]) {
                  j2 = ++i3;
                  for (; j2 < len; j2++) {
                    if (Expr.relative[tokens[j2].type]) {
                      break;
                    }
                  }
                  return setMatcher(i3 > 1 && elementMatcher(matchers), i3 > 1 && toSelector(tokens.slice(0, i3 - 1).concat({ value: tokens[i3 - 2].type === " " ? "*" : "" })).replace(rtrim2, "$1"), matcher, i3 < j2 && matcherFromTokens(tokens.slice(i3, j2)), j2 < len && matcherFromTokens(tokens = tokens.slice(j2)), j2 < len && toSelector(tokens));
                }
                matchers.push(matcher);
              }
            }
            return elementMatcher(matchers);
          }
          function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
              var elem, j2, matcher, matchedCount = 0, i3 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
              if (outermost) {
                outermostContext = context == document3 || context || outermost;
              }
              for (; i3 !== len && (elem = elems[i3]) != null; i3++) {
                if (byElement && elem) {
                  j2 = 0;
                  if (!context && elem.ownerDocument != document3) {
                    setDocument(elem);
                    xml = !documentIsHTML;
                  }
                  while (matcher = elementMatchers[j2++]) {
                    if (matcher(elem, context || document3, xml)) {
                      results.push(elem);
                      break;
                    }
                  }
                  if (outermost) {
                    dirruns = dirrunsUnique;
                  }
                }
                if (bySet) {
                  if (elem = !matcher && elem) {
                    matchedCount--;
                  }
                  if (seed) {
                    unmatched.push(elem);
                  }
                }
              }
              matchedCount += i3;
              if (bySet && i3 !== matchedCount) {
                j2 = 0;
                while (matcher = setMatchers[j2++]) {
                  matcher(unmatched, setMatched, context, xml);
                }
                if (seed) {
                  if (matchedCount > 0) {
                    while (i3--) {
                      if (!(unmatched[i3] || setMatched[i3])) {
                        setMatched[i3] = pop.call(results);
                      }
                    }
                  }
                  setMatched = condense(setMatched);
                }
                push2.apply(results, setMatched);
                if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                  Sizzle2.uniqueSort(results);
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
                outermostContext = contextBackup;
              }
              return unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
          }
          compile = Sizzle2.compile = function(selector, match) {
            var i3, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
              if (!match) {
                match = tokenize2(selector);
              }
              i3 = match.length;
              while (i3--) {
                cached = matcherFromTokens(match[i3]);
                if (cached[expando]) {
                  setMatchers.push(cached);
                } else {
                  elementMatchers.push(cached);
                }
              }
              cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
              cached.selector = selector;
            }
            return cached;
          };
          select = Sizzle2.select = function(selector, context, results, seed) {
            var i3, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize2(selector = compiled.selector || selector);
            results = results || [];
            if (match.length === 1) {
              tokens = match[0] = match[0].slice(0);
              if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                if (!context) {
                  return results;
                } else if (compiled) {
                  context = context.parentNode;
                }
                selector = selector.slice(tokens.shift().value.length);
              }
              i3 = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
              while (i3--) {
                token = tokens[i3];
                if (Expr.relative[type = token.type]) {
                  break;
                }
                if (find = Expr.find[type]) {
                  if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                    tokens.splice(i3, 1);
                    selector = seed.length && toSelector(tokens);
                    if (!selector) {
                      push2.apply(results, seed);
                      return results;
                    }
                    break;
                  }
                }
              }
            }
            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
          };
          support2.sortStable = expando.split("").sort(sortOrder).join("") === expando;
          support2.detectDuplicates = !!hasDuplicate;
          setDocument();
          support2.sortDetached = assert(function(el) {
            return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
          });
          if (!assert(function(el) {
            el.innerHTML = "<a href='#'></a>";
            return el.firstChild.getAttribute("href") === "#";
          })) {
            addHandle("type|href|height|width", function(elem, name, isXML2) {
              if (!isXML2) {
                return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
              }
            });
          }
          if (!support2.attributes || !assert(function(el) {
            el.innerHTML = "<input/>";
            el.firstChild.setAttribute("value", "");
            return el.firstChild.getAttribute("value") === "";
          })) {
            addHandle("value", function(elem, _name, isXML2) {
              if (!isXML2 && elem.nodeName.toLowerCase() === "input") {
                return elem.defaultValue;
              }
            });
          }
          if (!assert(function(el) {
            return el.getAttribute("disabled") == null;
          })) {
            addHandle(booleans, function(elem, name, isXML2) {
              var val;
              if (!isXML2) {
                return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
              }
            });
          }
          return Sizzle2;
        }(window2);
        jQuery2.find = Sizzle;
        jQuery2.expr = Sizzle.selectors;
        jQuery2.expr[":"] = jQuery2.expr.pseudos;
        jQuery2.uniqueSort = jQuery2.unique = Sizzle.uniqueSort;
        jQuery2.text = Sizzle.getText;
        jQuery2.isXMLDoc = Sizzle.isXML;
        jQuery2.contains = Sizzle.contains;
        jQuery2.escapeSelector = Sizzle.escape;
        var dir = function(elem, dir2, until) {
          var matched = [], truncate = until !== void 0;
          while ((elem = elem[dir2]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
              if (truncate && jQuery2(elem).is(until)) {
                break;
              }
              matched.push(elem);
            }
          }
          return matched;
        };
        var siblings = function(n2, elem) {
          var matched = [];
          for (; n2; n2 = n2.nextSibling) {
            if (n2.nodeType === 1 && n2 !== elem) {
              matched.push(n2);
            }
          }
          return matched;
        };
        var rneedsContext = jQuery2.expr.match.needsContext;
        function nodeName(elem, name) {
          return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        }
        ;
        var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
        function winnow(elements, qualifier, not) {
          if (isFunction(qualifier)) {
            return jQuery2.grep(elements, function(elem, i2) {
              return !!qualifier.call(elem, i2, elem) !== not;
            });
          }
          if (qualifier.nodeType) {
            return jQuery2.grep(elements, function(elem) {
              return elem === qualifier !== not;
            });
          }
          if (typeof qualifier !== "string") {
            return jQuery2.grep(elements, function(elem) {
              return indexOf2.call(qualifier, elem) > -1 !== not;
            });
          }
          return jQuery2.filter(qualifier, elements, not);
        }
        jQuery2.filter = function(expr, elems, not) {
          var elem = elems[0];
          if (not) {
            expr = ":not(" + expr + ")";
          }
          if (elems.length === 1 && elem.nodeType === 1) {
            return jQuery2.find.matchesSelector(elem, expr) ? [elem] : [];
          }
          return jQuery2.find.matches(expr, jQuery2.grep(elems, function(elem2) {
            return elem2.nodeType === 1;
          }));
        };
        jQuery2.fn.extend({
          find: function(selector) {
            var i2, ret, len = this.length, self2 = this;
            if (typeof selector !== "string") {
              return this.pushStack(jQuery2(selector).filter(function() {
                for (i2 = 0; i2 < len; i2++) {
                  if (jQuery2.contains(self2[i2], this)) {
                    return true;
                  }
                }
              }));
            }
            ret = this.pushStack([]);
            for (i2 = 0; i2 < len; i2++) {
              jQuery2.find(selector, self2[i2], ret);
            }
            return len > 1 ? jQuery2.uniqueSort(ret) : ret;
          },
          filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
          },
          not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
          },
          is: function(selector) {
            return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery2(selector) : selector || [], false).length;
          }
        });
        var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery2.fn.init = function(selector, context, root) {
          var match, elem;
          if (!selector) {
            return this;
          }
          root = root || rootjQuery;
          if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
              match = [null, selector, null];
            } else {
              match = rquickExpr.exec(selector);
            }
            if (match && (match[1] || !context)) {
              if (match[1]) {
                context = context instanceof jQuery2 ? context[0] : context;
                jQuery2.merge(this, jQuery2.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document2, true));
                if (rsingleTag.test(match[1]) && jQuery2.isPlainObject(context)) {
                  for (match in context) {
                    if (isFunction(this[match])) {
                      this[match](context[match]);
                    } else {
                      this.attr(match, context[match]);
                    }
                  }
                }
                return this;
              } else {
                elem = document2.getElementById(match[2]);
                if (elem) {
                  this[0] = elem;
                  this.length = 1;
                }
                return this;
              }
            } else if (!context || context.jquery) {
              return (context || root).find(selector);
            } else {
              return this.constructor(context).find(selector);
            }
          } else if (selector.nodeType) {
            this[0] = selector;
            this.length = 1;
            return this;
          } else if (isFunction(selector)) {
            return root.ready !== void 0 ? root.ready(selector) : selector(jQuery2);
          }
          return jQuery2.makeArray(selector, this);
        };
        init.prototype = jQuery2.fn;
        rootjQuery = jQuery2(document2);
        var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
          children: true,
          contents: true,
          next: true,
          prev: true
        };
        jQuery2.fn.extend({
          has: function(target) {
            var targets = jQuery2(target, this), l2 = targets.length;
            return this.filter(function() {
              var i2 = 0;
              for (; i2 < l2; i2++) {
                if (jQuery2.contains(this, targets[i2])) {
                  return true;
                }
              }
            });
          },
          closest: function(selectors, context) {
            var cur, i2 = 0, l2 = this.length, matched = [], targets = typeof selectors !== "string" && jQuery2(selectors);
            if (!rneedsContext.test(selectors)) {
              for (; i2 < l2; i2++) {
                for (cur = this[i2]; cur && cur !== context; cur = cur.parentNode) {
                  if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : cur.nodeType === 1 && jQuery2.find.matchesSelector(cur, selectors))) {
                    matched.push(cur);
                    break;
                  }
                }
              }
            }
            return this.pushStack(matched.length > 1 ? jQuery2.uniqueSort(matched) : matched);
          },
          index: function(elem) {
            if (!elem) {
              return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === "string") {
              return indexOf2.call(jQuery2(elem), this[0]);
            }
            return indexOf2.call(this, elem.jquery ? elem[0] : elem);
          },
          add: function(selector, context) {
            return this.pushStack(jQuery2.uniqueSort(jQuery2.merge(this.get(), jQuery2(selector, context))));
          },
          addBack: function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
          }
        });
        function sibling(cur, dir2) {
          while ((cur = cur[dir2]) && cur.nodeType !== 1) {
          }
          return cur;
        }
        jQuery2.each({
          parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
          },
          parents: function(elem) {
            return dir(elem, "parentNode");
          },
          parentsUntil: function(elem, _i, until) {
            return dir(elem, "parentNode", until);
          },
          next: function(elem) {
            return sibling(elem, "nextSibling");
          },
          prev: function(elem) {
            return sibling(elem, "previousSibling");
          },
          nextAll: function(elem) {
            return dir(elem, "nextSibling");
          },
          prevAll: function(elem) {
            return dir(elem, "previousSibling");
          },
          nextUntil: function(elem, _i, until) {
            return dir(elem, "nextSibling", until);
          },
          prevUntil: function(elem, _i, until) {
            return dir(elem, "previousSibling", until);
          },
          siblings: function(elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
          },
          children: function(elem) {
            return siblings(elem.firstChild);
          },
          contents: function(elem) {
            if (elem.contentDocument != null && getProto(elem.contentDocument)) {
              return elem.contentDocument;
            }
            if (nodeName(elem, "template")) {
              elem = elem.content || elem;
            }
            return jQuery2.merge([], elem.childNodes);
          }
        }, function(name, fn2) {
          jQuery2.fn[name] = function(until, selector) {
            var matched = jQuery2.map(this, fn2, until);
            if (name.slice(-5) !== "Until") {
              selector = until;
            }
            if (selector && typeof selector === "string") {
              matched = jQuery2.filter(selector, matched);
            }
            if (this.length > 1) {
              if (!guaranteedUnique[name]) {
                jQuery2.uniqueSort(matched);
              }
              if (rparentsprev.test(name)) {
                matched.reverse();
              }
            }
            return this.pushStack(matched);
          };
        });
        var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
        function createOptions(options) {
          var object = {};
          jQuery2.each(options.match(rnothtmlwhite) || [], function(_2, flag) {
            object[flag] = true;
          });
          return object;
        }
        jQuery2.Callbacks = function(options) {
          options = typeof options === "string" ? createOptions(options) : jQuery2.extend({}, options);
          var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
            locked = locked || options.once;
            fired = firing = true;
            for (; queue.length; firingIndex = -1) {
              memory = queue.shift();
              while (++firingIndex < list.length) {
                if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                  firingIndex = list.length;
                  memory = false;
                }
              }
            }
            if (!options.memory) {
              memory = false;
            }
            firing = false;
            if (locked) {
              if (memory) {
                list = [];
              } else {
                list = "";
              }
            }
          }, self2 = {
            add: function() {
              if (list) {
                if (memory && !firing) {
                  firingIndex = list.length - 1;
                  queue.push(memory);
                }
                (function add3(args) {
                  jQuery2.each(args, function(_2, arg) {
                    if (isFunction(arg)) {
                      if (!options.unique || !self2.has(arg)) {
                        list.push(arg);
                      }
                    } else if (arg && arg.length && toType(arg) !== "string") {
                      add3(arg);
                    }
                  });
                })(arguments);
                if (memory && !firing) {
                  fire();
                }
              }
              return this;
            },
            remove: function() {
              jQuery2.each(arguments, function(_2, arg) {
                var index;
                while ((index = jQuery2.inArray(arg, list, index)) > -1) {
                  list.splice(index, 1);
                  if (index <= firingIndex) {
                    firingIndex--;
                  }
                }
              });
              return this;
            },
            has: function(fn2) {
              return fn2 ? jQuery2.inArray(fn2, list) > -1 : list.length > 0;
            },
            empty: function() {
              if (list) {
                list = [];
              }
              return this;
            },
            disable: function() {
              locked = queue = [];
              list = memory = "";
              return this;
            },
            disabled: function() {
              return !list;
            },
            lock: function() {
              locked = queue = [];
              if (!memory && !firing) {
                list = memory = "";
              }
              return this;
            },
            locked: function() {
              return !!locked;
            },
            fireWith: function(context, args) {
              if (!locked) {
                args = args || [];
                args = [context, args.slice ? args.slice() : args];
                queue.push(args);
                if (!firing) {
                  fire();
                }
              }
              return this;
            },
            fire: function() {
              self2.fireWith(this, arguments);
              return this;
            },
            fired: function() {
              return !!fired;
            }
          };
          return self2;
        };
        function Identity(v2) {
          return v2;
        }
        function Thrower(ex) {
          throw ex;
        }
        function adoptValue(value, resolve2, reject, noValue) {
          var method;
          try {
            if (value && isFunction(method = value.promise)) {
              method.call(value).done(resolve2).fail(reject);
            } else if (value && isFunction(method = value.then)) {
              method.call(value, resolve2, reject);
            } else {
              resolve2.apply(void 0, [value].slice(noValue));
            }
          } catch (value2) {
            reject.apply(void 0, [value2]);
          }
        }
        jQuery2.extend({
          Deferred: function(func) {
            var tuples = [
              [
                "notify",
                "progress",
                jQuery2.Callbacks("memory"),
                jQuery2.Callbacks("memory"),
                2
              ],
              [
                "resolve",
                "done",
                jQuery2.Callbacks("once memory"),
                jQuery2.Callbacks("once memory"),
                0,
                "resolved"
              ],
              [
                "reject",
                "fail",
                jQuery2.Callbacks("once memory"),
                jQuery2.Callbacks("once memory"),
                1,
                "rejected"
              ]
            ], state = "pending", promise = {
              state: function() {
                return state;
              },
              always: function() {
                deferred.done(arguments).fail(arguments);
                return this;
              },
              "catch": function(fn2) {
                return promise.then(null, fn2);
              },
              pipe: function() {
                var fns = arguments;
                return jQuery2.Deferred(function(newDefer) {
                  jQuery2.each(tuples, function(_i, tuple) {
                    var fn2 = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                    deferred[tuple[1]](function() {
                      var returned = fn2 && fn2.apply(this, arguments);
                      if (returned && isFunction(returned.promise)) {
                        returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                      } else {
                        newDefer[tuple[0] + "With"](this, fn2 ? [returned] : arguments);
                      }
                    });
                  });
                  fns = null;
                }).promise();
              },
              then: function(onFulfilled, onRejected, onProgress) {
                var maxDepth = 0;
                function resolve2(depth, deferred2, handler, special) {
                  return function() {
                    var that = this, args = arguments, mightThrow = function() {
                      var returned, then;
                      if (depth < maxDepth) {
                        return;
                      }
                      returned = handler.apply(that, args);
                      if (returned === deferred2.promise()) {
                        throw new TypeError("Thenable self-resolution");
                      }
                      then = returned && (typeof returned === "object" || typeof returned === "function") && returned.then;
                      if (isFunction(then)) {
                        if (special) {
                          then.call(returned, resolve2(maxDepth, deferred2, Identity, special), resolve2(maxDepth, deferred2, Thrower, special));
                        } else {
                          maxDepth++;
                          then.call(returned, resolve2(maxDepth, deferred2, Identity, special), resolve2(maxDepth, deferred2, Thrower, special), resolve2(maxDepth, deferred2, Identity, deferred2.notifyWith));
                        }
                      } else {
                        if (handler !== Identity) {
                          that = void 0;
                          args = [returned];
                        }
                        (special || deferred2.resolveWith)(that, args);
                      }
                    }, process2 = special ? mightThrow : function() {
                      try {
                        mightThrow();
                      } catch (e2) {
                        if (jQuery2.Deferred.exceptionHook) {
                          jQuery2.Deferred.exceptionHook(e2, process2.stackTrace);
                        }
                        if (depth + 1 >= maxDepth) {
                          if (handler !== Thrower) {
                            that = void 0;
                            args = [e2];
                          }
                          deferred2.rejectWith(that, args);
                        }
                      }
                    };
                    if (depth) {
                      process2();
                    } else {
                      if (jQuery2.Deferred.getStackHook) {
                        process2.stackTrace = jQuery2.Deferred.getStackHook();
                      }
                      window2.setTimeout(process2);
                    }
                  };
                }
                return jQuery2.Deferred(function(newDefer) {
                  tuples[0][3].add(resolve2(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));
                  tuples[1][3].add(resolve2(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity));
                  tuples[2][3].add(resolve2(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
                }).promise();
              },
              promise: function(obj) {
                return obj != null ? jQuery2.extend(obj, promise) : promise;
              }
            }, deferred = {};
            jQuery2.each(tuples, function(i2, tuple) {
              var list = tuple[2], stateString = tuple[5];
              promise[tuple[1]] = list.add;
              if (stateString) {
                list.add(function() {
                  state = stateString;
                }, tuples[3 - i2][2].disable, tuples[3 - i2][3].disable, tuples[0][2].lock, tuples[0][3].lock);
              }
              list.add(tuple[3].fire);
              deferred[tuple[0]] = function() {
                deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
                return this;
              };
              deferred[tuple[0] + "With"] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
              func.call(deferred, deferred);
            }
            return deferred;
          },
          when: function(singleValue) {
            var remaining = arguments.length, i2 = remaining, resolveContexts = Array(i2), resolveValues = slice.call(arguments), master = jQuery2.Deferred(), updateFunc = function(i3) {
              return function(value) {
                resolveContexts[i3] = this;
                resolveValues[i3] = arguments.length > 1 ? slice.call(arguments) : value;
                if (!--remaining) {
                  master.resolveWith(resolveContexts, resolveValues);
                }
              };
            };
            if (remaining <= 1) {
              adoptValue(singleValue, master.done(updateFunc(i2)).resolve, master.reject, !remaining);
              if (master.state() === "pending" || isFunction(resolveValues[i2] && resolveValues[i2].then)) {
                return master.then();
              }
            }
            while (i2--) {
              adoptValue(resolveValues[i2], updateFunc(i2), master.reject);
            }
            return master.promise();
          }
        });
        var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
        jQuery2.Deferred.exceptionHook = function(error2, stack) {
          if (window2.console && window2.console.warn && error2 && rerrorNames.test(error2.name)) {
            window2.console.warn("jQuery.Deferred exception: " + error2.message, error2.stack, stack);
          }
        };
        jQuery2.readyException = function(error2) {
          window2.setTimeout(function() {
            throw error2;
          });
        };
        var readyList = jQuery2.Deferred();
        jQuery2.fn.ready = function(fn2) {
          readyList.then(fn2).catch(function(error2) {
            jQuery2.readyException(error2);
          });
          return this;
        };
        jQuery2.extend({
          isReady: false,
          readyWait: 1,
          ready: function(wait) {
            if (wait === true ? --jQuery2.readyWait : jQuery2.isReady) {
              return;
            }
            jQuery2.isReady = true;
            if (wait !== true && --jQuery2.readyWait > 0) {
              return;
            }
            readyList.resolveWith(document2, [jQuery2]);
          }
        });
        jQuery2.ready.then = readyList.then;
        function completed() {
          document2.removeEventListener("DOMContentLoaded", completed);
          window2.removeEventListener("load", completed);
          jQuery2.ready();
        }
        if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
          window2.setTimeout(jQuery2.ready);
        } else {
          document2.addEventListener("DOMContentLoaded", completed);
          window2.addEventListener("load", completed);
        }
        var access = function(elems, fn2, key, value, chainable, emptyGet, raw) {
          var i2 = 0, len = elems.length, bulk = key == null;
          if (toType(key) === "object") {
            chainable = true;
            for (i2 in key) {
              access(elems, fn2, i2, key[i2], true, emptyGet, raw);
            }
          } else if (value !== void 0) {
            chainable = true;
            if (!isFunction(value)) {
              raw = true;
            }
            if (bulk) {
              if (raw) {
                fn2.call(elems, value);
                fn2 = null;
              } else {
                bulk = fn2;
                fn2 = function(elem, _key, value2) {
                  return bulk.call(jQuery2(elem), value2);
                };
              }
            }
            if (fn2) {
              for (; i2 < len; i2++) {
                fn2(elems[i2], key, raw ? value : value.call(elems[i2], i2, fn2(elems[i2], key)));
              }
            }
          }
          if (chainable) {
            return elems;
          }
          if (bulk) {
            return fn2.call(elems);
          }
          return len ? fn2(elems[0], key) : emptyGet;
        };
        var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
        function fcamelCase(_all, letter) {
          return letter.toUpperCase();
        }
        function camelCase(string) {
          return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        }
        var acceptData = function(owner) {
          return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
        };
        function Data() {
          this.expando = jQuery2.expando + Data.uid++;
        }
        Data.uid = 1;
        Data.prototype = {
          cache: function(owner) {
            var value = owner[this.expando];
            if (!value) {
              value = {};
              if (acceptData(owner)) {
                if (owner.nodeType) {
                  owner[this.expando] = value;
                } else {
                  Object.defineProperty(owner, this.expando, {
                    value,
                    configurable: true
                  });
                }
              }
            }
            return value;
          },
          set: function(owner, data, value) {
            var prop, cache = this.cache(owner);
            if (typeof data === "string") {
              cache[camelCase(data)] = value;
            } else {
              for (prop in data) {
                cache[camelCase(prop)] = data[prop];
              }
            }
            return cache;
          },
          get: function(owner, key) {
            return key === void 0 ? this.cache(owner) : owner[this.expando] && owner[this.expando][camelCase(key)];
          },
          access: function(owner, key, value) {
            if (key === void 0 || key && typeof key === "string" && value === void 0) {
              return this.get(owner, key);
            }
            this.set(owner, key, value);
            return value !== void 0 ? value : key;
          },
          remove: function(owner, key) {
            var i2, cache = owner[this.expando];
            if (cache === void 0) {
              return;
            }
            if (key !== void 0) {
              if (Array.isArray(key)) {
                key = key.map(camelCase);
              } else {
                key = camelCase(key);
                key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
              }
              i2 = key.length;
              while (i2--) {
                delete cache[key[i2]];
              }
            }
            if (key === void 0 || jQuery2.isEmptyObject(cache)) {
              if (owner.nodeType) {
                owner[this.expando] = void 0;
              } else {
                delete owner[this.expando];
              }
            }
          },
          hasData: function(owner) {
            var cache = owner[this.expando];
            return cache !== void 0 && !jQuery2.isEmptyObject(cache);
          }
        };
        var dataPriv = new Data();
        var dataUser = new Data();
        var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
        function getData(data) {
          if (data === "true") {
            return true;
          }
          if (data === "false") {
            return false;
          }
          if (data === "null") {
            return null;
          }
          if (data === +data + "") {
            return +data;
          }
          if (rbrace.test(data)) {
            return JSON.parse(data);
          }
          return data;
        }
        function dataAttr(elem, key, data) {
          var name;
          if (data === void 0 && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
              try {
                data = getData(data);
              } catch (e2) {
              }
              dataUser.set(elem, key, data);
            } else {
              data = void 0;
            }
          }
          return data;
        }
        jQuery2.extend({
          hasData: function(elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
          },
          data: function(elem, name, data) {
            return dataUser.access(elem, name, data);
          },
          removeData: function(elem, name) {
            dataUser.remove(elem, name);
          },
          _data: function(elem, name, data) {
            return dataPriv.access(elem, name, data);
          },
          _removeData: function(elem, name) {
            dataPriv.remove(elem, name);
          }
        });
        jQuery2.fn.extend({
          data: function(key, value) {
            var i2, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === void 0) {
              if (this.length) {
                data = dataUser.get(elem);
                if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                  i2 = attrs.length;
                  while (i2--) {
                    if (attrs[i2]) {
                      name = attrs[i2].name;
                      if (name.indexOf("data-") === 0) {
                        name = camelCase(name.slice(5));
                        dataAttr(elem, name, data[name]);
                      }
                    }
                  }
                  dataPriv.set(elem, "hasDataAttrs", true);
                }
              }
              return data;
            }
            if (typeof key === "object") {
              return this.each(function() {
                dataUser.set(this, key);
              });
            }
            return access(this, function(value2) {
              var data2;
              if (elem && value2 === void 0) {
                data2 = dataUser.get(elem, key);
                if (data2 !== void 0) {
                  return data2;
                }
                data2 = dataAttr(elem, key);
                if (data2 !== void 0) {
                  return data2;
                }
                return;
              }
              this.each(function() {
                dataUser.set(this, key, value2);
              });
            }, null, value, arguments.length > 1, null, true);
          },
          removeData: function(key) {
            return this.each(function() {
              dataUser.remove(this, key);
            });
          }
        });
        jQuery2.extend({
          queue: function(elem, type, data) {
            var queue;
            if (elem) {
              type = (type || "fx") + "queue";
              queue = dataPriv.get(elem, type);
              if (data) {
                if (!queue || Array.isArray(data)) {
                  queue = dataPriv.access(elem, type, jQuery2.makeArray(data));
                } else {
                  queue.push(data);
                }
              }
              return queue || [];
            }
          },
          dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery2.queue(elem, type), startLength = queue.length, fn2 = queue.shift(), hooks = jQuery2._queueHooks(elem, type), next = function() {
              jQuery2.dequeue(elem, type);
            };
            if (fn2 === "inprogress") {
              fn2 = queue.shift();
              startLength--;
            }
            if (fn2) {
              if (type === "fx") {
                queue.unshift("inprogress");
              }
              delete hooks.stop;
              fn2.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
              hooks.empty.fire();
            }
          },
          _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
              empty: jQuery2.Callbacks("once memory").add(function() {
                dataPriv.remove(elem, [type + "queue", key]);
              })
            });
          }
        });
        jQuery2.fn.extend({
          queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
              data = type;
              type = "fx";
              setter--;
            }
            if (arguments.length < setter) {
              return jQuery2.queue(this[0], type);
            }
            return data === void 0 ? this : this.each(function() {
              var queue = jQuery2.queue(this, type, data);
              jQuery2._queueHooks(this, type);
              if (type === "fx" && queue[0] !== "inprogress") {
                jQuery2.dequeue(this, type);
              }
            });
          },
          dequeue: function(type) {
            return this.each(function() {
              jQuery2.dequeue(this, type);
            });
          },
          clearQueue: function(type) {
            return this.queue(type || "fx", []);
          },
          promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery2.Deferred(), elements = this, i2 = this.length, resolve2 = function() {
              if (!--count) {
                defer.resolveWith(elements, [elements]);
              }
            };
            if (typeof type !== "string") {
              obj = type;
              type = void 0;
            }
            type = type || "fx";
            while (i2--) {
              tmp = dataPriv.get(elements[i2], type + "queueHooks");
              if (tmp && tmp.empty) {
                count++;
                tmp.empty.add(resolve2);
              }
            }
            resolve2();
            return defer.promise(obj);
          }
        });
        var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
        var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
        var cssExpand = ["Top", "Right", "Bottom", "Left"];
        var documentElement = document2.documentElement;
        var isAttached = function(elem) {
          return jQuery2.contains(elem.ownerDocument, elem);
        }, composed = { composed: true };
        if (documentElement.getRootNode) {
          isAttached = function(elem) {
            return jQuery2.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
          };
        }
        var isHiddenWithinTree = function(elem, el) {
          elem = el || elem;
          return elem.style.display === "none" || elem.style.display === "" && isAttached(elem) && jQuery2.css(elem, "display") === "none";
        };
        function adjustCSS(elem, prop, valueParts, tween) {
          var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
            return tween.cur();
          } : function() {
            return jQuery2.css(elem, prop, "");
          }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery2.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery2.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery2.css(elem, prop));
          if (initialInUnit && initialInUnit[3] !== unit) {
            initial = initial / 2;
            unit = unit || initialInUnit[3];
            initialInUnit = +initial || 1;
            while (maxIterations--) {
              jQuery2.style(elem, prop, initialInUnit + unit);
              if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
                maxIterations = 0;
              }
              initialInUnit = initialInUnit / scale;
            }
            initialInUnit = initialInUnit * 2;
            jQuery2.style(elem, prop, initialInUnit + unit);
            valueParts = valueParts || [];
          }
          if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
              tween.unit = unit;
              tween.start = initialInUnit;
              tween.end = adjusted;
            }
          }
          return adjusted;
        }
        var defaultDisplayMap = {};
        function getDefaultDisplay(elem) {
          var temp, doc = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
          if (display) {
            return display;
          }
          temp = doc.body.appendChild(doc.createElement(nodeName2));
          display = jQuery2.css(temp, "display");
          temp.parentNode.removeChild(temp);
          if (display === "none") {
            display = "block";
          }
          defaultDisplayMap[nodeName2] = display;
          return display;
        }
        function showHide(elements, show) {
          var display, elem, values = [], index = 0, length = elements.length;
          for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
              continue;
            }
            display = elem.style.display;
            if (show) {
              if (display === "none") {
                values[index] = dataPriv.get(elem, "display") || null;
                if (!values[index]) {
                  elem.style.display = "";
                }
              }
              if (elem.style.display === "" && isHiddenWithinTree(elem)) {
                values[index] = getDefaultDisplay(elem);
              }
            } else {
              if (display !== "none") {
                values[index] = "none";
                dataPriv.set(elem, "display", display);
              }
            }
          }
          for (index = 0; index < length; index++) {
            if (values[index] != null) {
              elements[index].style.display = values[index];
            }
          }
          return elements;
        }
        jQuery2.fn.extend({
          show: function() {
            return showHide(this, true);
          },
          hide: function() {
            return showHide(this);
          },
          toggle: function(state) {
            if (typeof state === "boolean") {
              return state ? this.show() : this.hide();
            }
            return this.each(function() {
              if (isHiddenWithinTree(this)) {
                jQuery2(this).show();
              } else {
                jQuery2(this).hide();
              }
            });
          }
        });
        var rcheckableType = /^(?:checkbox|radio)$/i;
        var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
        var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
        (function() {
          var fragment = document2.createDocumentFragment(), div2 = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
          input.setAttribute("type", "radio");
          input.setAttribute("checked", "checked");
          input.setAttribute("name", "t");
          div2.appendChild(input);
          support.checkClone = div2.cloneNode(true).cloneNode(true).lastChild.checked;
          div2.innerHTML = "<textarea>x</textarea>";
          support.noCloneChecked = !!div2.cloneNode(true).lastChild.defaultValue;
          div2.innerHTML = "<option></option>";
          support.option = !!div2.lastChild;
        })();
        var wrapMap = {
          thead: [1, "<table>", "</table>"],
          col: [2, "<table><colgroup>", "</colgroup></table>"],
          tr: [2, "<table><tbody>", "</tbody></table>"],
          td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
          _default: [0, "", ""]
        };
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
        wrapMap.th = wrapMap.td;
        if (!support.option) {
          wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
        }
        function getAll(context, tag) {
          var ret;
          if (typeof context.getElementsByTagName !== "undefined") {
            ret = context.getElementsByTagName(tag || "*");
          } else if (typeof context.querySelectorAll !== "undefined") {
            ret = context.querySelectorAll(tag || "*");
          } else {
            ret = [];
          }
          if (tag === void 0 || tag && nodeName(context, tag)) {
            return jQuery2.merge([context], ret);
          }
          return ret;
        }
        function setGlobalEval(elems, refElements) {
          var i2 = 0, l2 = elems.length;
          for (; i2 < l2; i2++) {
            dataPriv.set(elems[i2], "globalEval", !refElements || dataPriv.get(refElements[i2], "globalEval"));
          }
        }
        var rhtml = /<|&#?\w+;/;
        function buildFragment(elems, context, scripts, selection, ignored) {
          var elem, tmp, tag, wrap2, attached, j2, fragment = context.createDocumentFragment(), nodes = [], i2 = 0, l2 = elems.length;
          for (; i2 < l2; i2++) {
            elem = elems[i2];
            if (elem || elem === 0) {
              if (toType(elem) === "object") {
                jQuery2.merge(nodes, elem.nodeType ? [elem] : elem);
              } else if (!rhtml.test(elem)) {
                nodes.push(context.createTextNode(elem));
              } else {
                tmp = tmp || fragment.appendChild(context.createElement("div"));
                tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                wrap2 = wrapMap[tag] || wrapMap._default;
                tmp.innerHTML = wrap2[1] + jQuery2.htmlPrefilter(elem) + wrap2[2];
                j2 = wrap2[0];
                while (j2--) {
                  tmp = tmp.lastChild;
                }
                jQuery2.merge(nodes, tmp.childNodes);
                tmp = fragment.firstChild;
                tmp.textContent = "";
              }
            }
          }
          fragment.textContent = "";
          i2 = 0;
          while (elem = nodes[i2++]) {
            if (selection && jQuery2.inArray(elem, selection) > -1) {
              if (ignored) {
                ignored.push(elem);
              }
              continue;
            }
            attached = isAttached(elem);
            tmp = getAll(fragment.appendChild(elem), "script");
            if (attached) {
              setGlobalEval(tmp);
            }
            if (scripts) {
              j2 = 0;
              while (elem = tmp[j2++]) {
                if (rscriptType.test(elem.type || "")) {
                  scripts.push(elem);
                }
              }
            }
          }
          return fragment;
        }
        var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
        function returnTrue() {
          return true;
        }
        function returnFalse() {
          return false;
        }
        function expectSync(elem, type) {
          return elem === safeActiveElement() === (type === "focus");
        }
        function safeActiveElement() {
          try {
            return document2.activeElement;
          } catch (err) {
          }
        }
        function on(elem, types, selector, data, fn2, one) {
          var origFn, type;
          if (typeof types === "object") {
            if (typeof selector !== "string") {
              data = data || selector;
              selector = void 0;
            }
            for (type in types) {
              on(elem, type, selector, data, types[type], one);
            }
            return elem;
          }
          if (data == null && fn2 == null) {
            fn2 = selector;
            data = selector = void 0;
          } else if (fn2 == null) {
            if (typeof selector === "string") {
              fn2 = data;
              data = void 0;
            } else {
              fn2 = data;
              data = selector;
              selector = void 0;
            }
          }
          if (fn2 === false) {
            fn2 = returnFalse;
          } else if (!fn2) {
            return elem;
          }
          if (one === 1) {
            origFn = fn2;
            fn2 = function(event) {
              jQuery2().off(event);
              return origFn.apply(this, arguments);
            };
            fn2.guid = origFn.guid || (origFn.guid = jQuery2.guid++);
          }
          return elem.each(function() {
            jQuery2.event.add(this, types, fn2, data, selector);
          });
        }
        jQuery2.event = {
          global: {},
          add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t2, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            if (!acceptData(elem)) {
              return;
            }
            if (handler.handler) {
              handleObjIn = handler;
              handler = handleObjIn.handler;
              selector = handleObjIn.selector;
            }
            if (selector) {
              jQuery2.find.matchesSelector(documentElement, selector);
            }
            if (!handler.guid) {
              handler.guid = jQuery2.guid++;
            }
            if (!(events = elemData.events)) {
              events = elemData.events = /* @__PURE__ */ Object.create(null);
            }
            if (!(eventHandle = elemData.handle)) {
              eventHandle = elemData.handle = function(e2) {
                return typeof jQuery2 !== "undefined" && jQuery2.event.triggered !== e2.type ? jQuery2.event.dispatch.apply(elem, arguments) : void 0;
              };
            }
            types = (types || "").match(rnothtmlwhite) || [""];
            t2 = types.length;
            while (t2--) {
              tmp = rtypenamespace.exec(types[t2]) || [];
              type = origType = tmp[1];
              namespaces = (tmp[2] || "").split(".").sort();
              if (!type) {
                continue;
              }
              special = jQuery2.event.special[type] || {};
              type = (selector ? special.delegateType : special.bindType) || type;
              special = jQuery2.event.special[type] || {};
              handleObj = jQuery2.extend({
                type,
                origType,
                data,
                handler,
                guid: handler.guid,
                selector,
                needsContext: selector && jQuery2.expr.match.needsContext.test(selector),
                namespace: namespaces.join(".")
              }, handleObjIn);
              if (!(handlers = events[type])) {
                handlers = events[type] = [];
                handlers.delegateCount = 0;
                if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                  if (elem.addEventListener) {
                    elem.addEventListener(type, eventHandle);
                  }
                }
              }
              if (special.add) {
                special.add.call(elem, handleObj);
                if (!handleObj.handler.guid) {
                  handleObj.handler.guid = handler.guid;
                }
              }
              if (selector) {
                handlers.splice(handlers.delegateCount++, 0, handleObj);
              } else {
                handlers.push(handleObj);
              }
              jQuery2.event.global[type] = true;
            }
          },
          remove: function(elem, types, handler, selector, mappedTypes) {
            var j2, origCount, tmp, events, t2, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (!elemData || !(events = elemData.events)) {
              return;
            }
            types = (types || "").match(rnothtmlwhite) || [""];
            t2 = types.length;
            while (t2--) {
              tmp = rtypenamespace.exec(types[t2]) || [];
              type = origType = tmp[1];
              namespaces = (tmp[2] || "").split(".").sort();
              if (!type) {
                for (type in events) {
                  jQuery2.event.remove(elem, type + types[t2], handler, selector, true);
                }
                continue;
              }
              special = jQuery2.event.special[type] || {};
              type = (selector ? special.delegateType : special.bindType) || type;
              handlers = events[type] || [];
              tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
              origCount = j2 = handlers.length;
              while (j2--) {
                handleObj = handlers[j2];
                if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                  handlers.splice(j2, 1);
                  if (handleObj.selector) {
                    handlers.delegateCount--;
                  }
                  if (special.remove) {
                    special.remove.call(elem, handleObj);
                  }
                }
              }
              if (origCount && !handlers.length) {
                if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                  jQuery2.removeEvent(elem, type, elemData.handle);
                }
                delete events[type];
              }
            }
            if (jQuery2.isEmptyObject(events)) {
              dataPriv.remove(elem, "handle events");
            }
          },
          dispatch: function(nativeEvent) {
            var i2, j2, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery2.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special = jQuery2.event.special[event.type] || {};
            args[0] = event;
            for (i2 = 1; i2 < arguments.length; i2++) {
              args[i2] = arguments[i2];
            }
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
              return;
            }
            handlerQueue = jQuery2.event.handlers.call(this, event, handlers);
            i2 = 0;
            while ((matched = handlerQueue[i2++]) && !event.isPropagationStopped()) {
              event.currentTarget = matched.elem;
              j2 = 0;
              while ((handleObj = matched.handlers[j2++]) && !event.isImmediatePropagationStopped()) {
                if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                  event.handleObj = handleObj;
                  event.data = handleObj.data;
                  ret = ((jQuery2.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                  if (ret !== void 0) {
                    if ((event.result = ret) === false) {
                      event.preventDefault();
                      event.stopPropagation();
                    }
                  }
                }
              }
            }
            if (special.postDispatch) {
              special.postDispatch.call(this, event);
            }
            return event.result;
          },
          handlers: function(event, handlers) {
            var i2, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && !(event.type === "click" && event.button >= 1)) {
              for (; cur !== this; cur = cur.parentNode || this) {
                if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                  matchedHandlers = [];
                  matchedSelectors = {};
                  for (i2 = 0; i2 < delegateCount; i2++) {
                    handleObj = handlers[i2];
                    sel = handleObj.selector + " ";
                    if (matchedSelectors[sel] === void 0) {
                      matchedSelectors[sel] = handleObj.needsContext ? jQuery2(sel, this).index(cur) > -1 : jQuery2.find(sel, this, null, [cur]).length;
                    }
                    if (matchedSelectors[sel]) {
                      matchedHandlers.push(handleObj);
                    }
                  }
                  if (matchedHandlers.length) {
                    handlerQueue.push({ elem: cur, handlers: matchedHandlers });
                  }
                }
              }
            }
            cur = this;
            if (delegateCount < handlers.length) {
              handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
            }
            return handlerQueue;
          },
          addProp: function(name, hook) {
            Object.defineProperty(jQuery2.Event.prototype, name, {
              enumerable: true,
              configurable: true,
              get: isFunction(hook) ? function() {
                if (this.originalEvent) {
                  return hook(this.originalEvent);
                }
              } : function() {
                if (this.originalEvent) {
                  return this.originalEvent[name];
                }
              },
              set: function(value) {
                Object.defineProperty(this, name, {
                  enumerable: true,
                  configurable: true,
                  writable: true,
                  value
                });
              }
            });
          },
          fix: function(originalEvent) {
            return originalEvent[jQuery2.expando] ? originalEvent : new jQuery2.Event(originalEvent);
          },
          special: {
            load: {
              noBubble: true
            },
            click: {
              setup: function(data) {
                var el = this || data;
                if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                  leverageNative(el, "click", returnTrue);
                }
                return false;
              },
              trigger: function(data) {
                var el = this || data;
                if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                  leverageNative(el, "click");
                }
                return true;
              },
              _default: function(event) {
                var target = event.target;
                return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
              }
            },
            beforeunload: {
              postDispatch: function(event) {
                if (event.result !== void 0 && event.originalEvent) {
                  event.originalEvent.returnValue = event.result;
                }
              }
            }
          }
        };
        function leverageNative(el, type, expectSync2) {
          if (!expectSync2) {
            if (dataPriv.get(el, type) === void 0) {
              jQuery2.event.add(el, type, returnTrue);
            }
            return;
          }
          dataPriv.set(el, type, false);
          jQuery2.event.add(el, type, {
            namespace: false,
            handler: function(event) {
              var notAsync, result, saved = dataPriv.get(this, type);
              if (event.isTrigger & 1 && this[type]) {
                if (!saved.length) {
                  saved = slice.call(arguments);
                  dataPriv.set(this, type, saved);
                  notAsync = expectSync2(this, type);
                  this[type]();
                  result = dataPriv.get(this, type);
                  if (saved !== result || notAsync) {
                    dataPriv.set(this, type, false);
                  } else {
                    result = {};
                  }
                  if (saved !== result) {
                    event.stopImmediatePropagation();
                    event.preventDefault();
                    return result.value;
                  }
                } else if ((jQuery2.event.special[type] || {}).delegateType) {
                  event.stopPropagation();
                }
              } else if (saved.length) {
                dataPriv.set(this, type, {
                  value: jQuery2.event.trigger(jQuery2.extend(saved[0], jQuery2.Event.prototype), saved.slice(1), this)
                });
                event.stopImmediatePropagation();
              }
            }
          });
        }
        jQuery2.removeEvent = function(elem, type, handle) {
          if (elem.removeEventListener) {
            elem.removeEventListener(type, handle);
          }
        };
        jQuery2.Event = function(src, props) {
          if (!(this instanceof jQuery2.Event)) {
            return new jQuery2.Event(src, props);
          }
          if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && src.returnValue === false ? returnTrue : returnFalse;
            this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
            this.currentTarget = src.currentTarget;
            this.relatedTarget = src.relatedTarget;
          } else {
            this.type = src;
          }
          if (props) {
            jQuery2.extend(this, props);
          }
          this.timeStamp = src && src.timeStamp || Date.now();
          this[jQuery2.expando] = true;
        };
        jQuery2.Event.prototype = {
          constructor: jQuery2.Event,
          isDefaultPrevented: returnFalse,
          isPropagationStopped: returnFalse,
          isImmediatePropagationStopped: returnFalse,
          isSimulated: false,
          preventDefault: function() {
            var e2 = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e2 && !this.isSimulated) {
              e2.preventDefault();
            }
          },
          stopPropagation: function() {
            var e2 = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e2 && !this.isSimulated) {
              e2.stopPropagation();
            }
          },
          stopImmediatePropagation: function() {
            var e2 = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e2 && !this.isSimulated) {
              e2.stopImmediatePropagation();
            }
            this.stopPropagation();
          }
        };
        jQuery2.each({
          altKey: true,
          bubbles: true,
          cancelable: true,
          changedTouches: true,
          ctrlKey: true,
          detail: true,
          eventPhase: true,
          metaKey: true,
          pageX: true,
          pageY: true,
          shiftKey: true,
          view: true,
          "char": true,
          code: true,
          charCode: true,
          key: true,
          keyCode: true,
          button: true,
          buttons: true,
          clientX: true,
          clientY: true,
          offsetX: true,
          offsetY: true,
          pointerId: true,
          pointerType: true,
          screenX: true,
          screenY: true,
          targetTouches: true,
          toElement: true,
          touches: true,
          which: function(event) {
            var button = event.button;
            if (event.which == null && rkeyEvent.test(event.type)) {
              return event.charCode != null ? event.charCode : event.keyCode;
            }
            if (!event.which && button !== void 0 && rmouseEvent.test(event.type)) {
              if (button & 1) {
                return 1;
              }
              if (button & 2) {
                return 3;
              }
              if (button & 4) {
                return 2;
              }
              return 0;
            }
            return event.which;
          }
        }, jQuery2.event.addProp);
        jQuery2.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
          jQuery2.event.special[type] = {
            setup: function() {
              leverageNative(this, type, expectSync);
              return false;
            },
            trigger: function() {
              leverageNative(this, type);
              return true;
            },
            delegateType
          };
        });
        jQuery2.each({
          mouseenter: "mouseover",
          mouseleave: "mouseout",
          pointerenter: "pointerover",
          pointerleave: "pointerout"
        }, function(orig, fix) {
          jQuery2.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
              var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
              if (!related || related !== target && !jQuery2.contains(target, related)) {
                event.type = handleObj.origType;
                ret = handleObj.handler.apply(this, arguments);
                event.type = fix;
              }
              return ret;
            }
          };
        });
        jQuery2.fn.extend({
          on: function(types, selector, data, fn2) {
            return on(this, types, selector, data, fn2);
          },
          one: function(types, selector, data, fn2) {
            return on(this, types, selector, data, fn2, 1);
          },
          off: function(types, selector, fn2) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
              handleObj = types.handleObj;
              jQuery2(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
              return this;
            }
            if (typeof types === "object") {
              for (type in types) {
                this.off(type, selector, types[type]);
              }
              return this;
            }
            if (selector === false || typeof selector === "function") {
              fn2 = selector;
              selector = void 0;
            }
            if (fn2 === false) {
              fn2 = returnFalse;
            }
            return this.each(function() {
              jQuery2.event.remove(this, types, fn2, selector);
            });
          }
        });
        var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
        function manipulationTarget(elem, content) {
          if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
            return jQuery2(elem).children("tbody")[0] || elem;
          }
          return elem;
        }
        function disableScript(elem) {
          elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
          return elem;
        }
        function restoreScript(elem) {
          if ((elem.type || "").slice(0, 5) === "true/") {
            elem.type = elem.type.slice(5);
          } else {
            elem.removeAttribute("type");
          }
          return elem;
        }
        function cloneCopyEvent(src, dest) {
          var i2, l2, type, pdataOld, udataOld, udataCur, events;
          if (dest.nodeType !== 1) {
            return;
          }
          if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.get(src);
            events = pdataOld.events;
            if (events) {
              dataPriv.remove(dest, "handle events");
              for (type in events) {
                for (i2 = 0, l2 = events[type].length; i2 < l2; i2++) {
                  jQuery2.event.add(dest, type, events[type][i2]);
                }
              }
            }
          }
          if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery2.extend({}, udataOld);
            dataUser.set(dest, udataCur);
          }
        }
        function fixInput(src, dest) {
          var nodeName2 = dest.nodeName.toLowerCase();
          if (nodeName2 === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
          } else if (nodeName2 === "input" || nodeName2 === "textarea") {
            dest.defaultValue = src.defaultValue;
          }
        }
        function domManip(collection, args, callback, ignored) {
          args = flat(args);
          var fragment, first, scripts, hasScripts, node, doc, i2 = 0, l2 = collection.length, iNoClone = l2 - 1, value = args[0], valueIsFunction = isFunction(value);
          if (valueIsFunction || l2 > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
            return collection.each(function(index) {
              var self2 = collection.eq(index);
              if (valueIsFunction) {
                args[0] = value.call(this, index, self2.html());
              }
              domManip(self2, args, callback, ignored);
            });
          }
          if (l2) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;
            if (fragment.childNodes.length === 1) {
              fragment = first;
            }
            if (first || ignored) {
              scripts = jQuery2.map(getAll(fragment, "script"), disableScript);
              hasScripts = scripts.length;
              for (; i2 < l2; i2++) {
                node = fragment;
                if (i2 !== iNoClone) {
                  node = jQuery2.clone(node, true, true);
                  if (hasScripts) {
                    jQuery2.merge(scripts, getAll(node, "script"));
                  }
                }
                callback.call(collection[i2], node, i2);
              }
              if (hasScripts) {
                doc = scripts[scripts.length - 1].ownerDocument;
                jQuery2.map(scripts, restoreScript);
                for (i2 = 0; i2 < hasScripts; i2++) {
                  node = scripts[i2];
                  if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery2.contains(doc, node)) {
                    if (node.src && (node.type || "").toLowerCase() !== "module") {
                      if (jQuery2._evalUrl && !node.noModule) {
                        jQuery2._evalUrl(node.src, {
                          nonce: node.nonce || node.getAttribute("nonce")
                        }, doc);
                      }
                    } else {
                      DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                    }
                  }
                }
              }
            }
          }
          return collection;
        }
        function remove(elem, selector, keepData) {
          var node, nodes = selector ? jQuery2.filter(selector, elem) : elem, i2 = 0;
          for (; (node = nodes[i2]) != null; i2++) {
            if (!keepData && node.nodeType === 1) {
              jQuery2.cleanData(getAll(node));
            }
            if (node.parentNode) {
              if (keepData && isAttached(node)) {
                setGlobalEval(getAll(node, "script"));
              }
              node.parentNode.removeChild(node);
            }
          }
          return elem;
        }
        jQuery2.extend({
          htmlPrefilter: function(html) {
            return html;
          },
          clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i2, l2, srcElements, destElements, clone = elem.cloneNode(true), inPage = isAttached(elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery2.isXMLDoc(elem)) {
              destElements = getAll(clone);
              srcElements = getAll(elem);
              for (i2 = 0, l2 = srcElements.length; i2 < l2; i2++) {
                fixInput(srcElements[i2], destElements[i2]);
              }
            }
            if (dataAndEvents) {
              if (deepDataAndEvents) {
                srcElements = srcElements || getAll(elem);
                destElements = destElements || getAll(clone);
                for (i2 = 0, l2 = srcElements.length; i2 < l2; i2++) {
                  cloneCopyEvent(srcElements[i2], destElements[i2]);
                }
              } else {
                cloneCopyEvent(elem, clone);
              }
            }
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
              setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }
            return clone;
          },
          cleanData: function(elems) {
            var data, elem, type, special = jQuery2.event.special, i2 = 0;
            for (; (elem = elems[i2]) !== void 0; i2++) {
              if (acceptData(elem)) {
                if (data = elem[dataPriv.expando]) {
                  if (data.events) {
                    for (type in data.events) {
                      if (special[type]) {
                        jQuery2.event.remove(elem, type);
                      } else {
                        jQuery2.removeEvent(elem, type, data.handle);
                      }
                    }
                  }
                  elem[dataPriv.expando] = void 0;
                }
                if (elem[dataUser.expando]) {
                  elem[dataUser.expando] = void 0;
                }
              }
            }
          }
        });
        jQuery2.fn.extend({
          detach: function(selector) {
            return remove(this, selector, true);
          },
          remove: function(selector) {
            return remove(this, selector);
          },
          text: function(value) {
            return access(this, function(value2) {
              return value2 === void 0 ? jQuery2.text(this) : this.empty().each(function() {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                  this.textContent = value2;
                }
              });
            }, null, value, arguments.length);
          },
          append: function() {
            return domManip(this, arguments, function(elem) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var target = manipulationTarget(this, elem);
                target.appendChild(elem);
              }
            });
          },
          prepend: function() {
            return domManip(this, arguments, function(elem) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var target = manipulationTarget(this, elem);
                target.insertBefore(elem, target.firstChild);
              }
            });
          },
          before: function() {
            return domManip(this, arguments, function(elem) {
              if (this.parentNode) {
                this.parentNode.insertBefore(elem, this);
              }
            });
          },
          after: function() {
            return domManip(this, arguments, function(elem) {
              if (this.parentNode) {
                this.parentNode.insertBefore(elem, this.nextSibling);
              }
            });
          },
          empty: function() {
            var elem, i2 = 0;
            for (; (elem = this[i2]) != null; i2++) {
              if (elem.nodeType === 1) {
                jQuery2.cleanData(getAll(elem, false));
                elem.textContent = "";
              }
            }
            return this;
          },
          clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
              return jQuery2.clone(this, dataAndEvents, deepDataAndEvents);
            });
          },
          html: function(value) {
            return access(this, function(value2) {
              var elem = this[0] || {}, i2 = 0, l2 = this.length;
              if (value2 === void 0 && elem.nodeType === 1) {
                return elem.innerHTML;
              }
              if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
                value2 = jQuery2.htmlPrefilter(value2);
                try {
                  for (; i2 < l2; i2++) {
                    elem = this[i2] || {};
                    if (elem.nodeType === 1) {
                      jQuery2.cleanData(getAll(elem, false));
                      elem.innerHTML = value2;
                    }
                  }
                  elem = 0;
                } catch (e2) {
                }
              }
              if (elem) {
                this.empty().append(value2);
              }
            }, null, value, arguments.length);
          },
          replaceWith: function() {
            var ignored = [];
            return domManip(this, arguments, function(elem) {
              var parent = this.parentNode;
              if (jQuery2.inArray(this, ignored) < 0) {
                jQuery2.cleanData(getAll(this));
                if (parent) {
                  parent.replaceChild(elem, this);
                }
              }
            }, ignored);
          }
        });
        jQuery2.each({
          appendTo: "append",
          prependTo: "prepend",
          insertBefore: "before",
          insertAfter: "after",
          replaceAll: "replaceWith"
        }, function(name, original) {
          jQuery2.fn[name] = function(selector) {
            var elems, ret = [], insert = jQuery2(selector), last = insert.length - 1, i2 = 0;
            for (; i2 <= last; i2++) {
              elems = i2 === last ? this : this.clone(true);
              jQuery2(insert[i2])[original](elems);
              push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
          };
        });
        var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
        var getStyles = function(elem) {
          var view = elem.ownerDocument.defaultView;
          if (!view || !view.opener) {
            view = window2;
          }
          return view.getComputedStyle(elem);
        };
        var swap = function(elem, options, callback) {
          var ret, name, old = {};
          for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
          }
          ret = callback.call(elem);
          for (name in options) {
            elem.style[name] = old[name];
          }
          return ret;
        };
        var rboxStyle = new RegExp(cssExpand.join("|"), "i");
        (function() {
          function computeStyleTests() {
            if (!div2) {
              return;
            }
            container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
            div2.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
            documentElement.appendChild(container).appendChild(div2);
            var divStyle = window2.getComputedStyle(div2);
            pixelPositionVal = divStyle.top !== "1%";
            reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
            div2.style.right = "60%";
            pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
            boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
            div2.style.position = "absolute";
            scrollboxSizeVal = roundPixelMeasures(div2.offsetWidth / 3) === 12;
            documentElement.removeChild(container);
            div2 = null;
          }
          function roundPixelMeasures(measure) {
            return Math.round(parseFloat(measure));
          }
          var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div2 = document2.createElement("div");
          if (!div2.style) {
            return;
          }
          div2.style.backgroundClip = "content-box";
          div2.cloneNode(true).style.backgroundClip = "";
          support.clearCloneStyle = div2.style.backgroundClip === "content-box";
          jQuery2.extend(support, {
            boxSizingReliable: function() {
              computeStyleTests();
              return boxSizingReliableVal;
            },
            pixelBoxStyles: function() {
              computeStyleTests();
              return pixelBoxStylesVal;
            },
            pixelPosition: function() {
              computeStyleTests();
              return pixelPositionVal;
            },
            reliableMarginLeft: function() {
              computeStyleTests();
              return reliableMarginLeftVal;
            },
            scrollboxSize: function() {
              computeStyleTests();
              return scrollboxSizeVal;
            },
            reliableTrDimensions: function() {
              var table, tr, trChild, trStyle;
              if (reliableTrDimensionsVal == null) {
                table = document2.createElement("table");
                tr = document2.createElement("tr");
                trChild = document2.createElement("div");
                table.style.cssText = "position:absolute;left:-11111px";
                tr.style.height = "1px";
                trChild.style.height = "9px";
                documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
                trStyle = window2.getComputedStyle(tr);
                reliableTrDimensionsVal = parseInt(trStyle.height) > 3;
                documentElement.removeChild(table);
              }
              return reliableTrDimensionsVal;
            }
          });
        })();
        function curCSS(elem, name, computed) {
          var width, minWidth, maxWidth, ret, style = elem.style;
          computed = computed || getStyles(elem);
          if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
            if (ret === "" && !isAttached(elem)) {
              ret = jQuery2.style(elem, name);
            }
            if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
              width = style.width;
              minWidth = style.minWidth;
              maxWidth = style.maxWidth;
              style.minWidth = style.maxWidth = style.width = ret;
              ret = computed.width;
              style.width = width;
              style.minWidth = minWidth;
              style.maxWidth = maxWidth;
            }
          }
          return ret !== void 0 ? ret + "" : ret;
        }
        function addGetHookIf(conditionFn, hookFn) {
          return {
            get: function() {
              if (conditionFn()) {
                delete this.get;
                return;
              }
              return (this.get = hookFn).apply(this, arguments);
            }
          };
        }
        var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
        function vendorPropName(name) {
          var capName = name[0].toUpperCase() + name.slice(1), i2 = cssPrefixes.length;
          while (i2--) {
            name = cssPrefixes[i2] + capName;
            if (name in emptyStyle) {
              return name;
            }
          }
        }
        function finalPropName(name) {
          var final = jQuery2.cssProps[name] || vendorProps[name];
          if (final) {
            return final;
          }
          if (name in emptyStyle) {
            return name;
          }
          return vendorProps[name] = vendorPropName(name) || name;
        }
        var rdisplayswap = /^(none|table(?!-c[ea]).+)/, rcustomProp = /^--/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
          letterSpacing: "0",
          fontWeight: "400"
        };
        function setPositiveNumber(_elem, value, subtract) {
          var matches = rcssNum.exec(value);
          return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
        }
        function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
          var i2 = dimension === "width" ? 1 : 0, extra = 0, delta = 0;
          if (box === (isBorderBox ? "border" : "content")) {
            return 0;
          }
          for (; i2 < 4; i2 += 2) {
            if (box === "margin") {
              delta += jQuery2.css(elem, box + cssExpand[i2], true, styles);
            }
            if (!isBorderBox) {
              delta += jQuery2.css(elem, "padding" + cssExpand[i2], true, styles);
              if (box !== "padding") {
                delta += jQuery2.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
              } else {
                extra += jQuery2.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
              }
            } else {
              if (box === "content") {
                delta -= jQuery2.css(elem, "padding" + cssExpand[i2], true, styles);
              }
              if (box !== "margin") {
                delta -= jQuery2.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
              }
            }
          }
          if (!isBorderBox && computedVal >= 0) {
            delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5)) || 0;
          }
          return delta;
        }
        function getWidthOrHeight(elem, dimension, extra) {
          var styles = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery2.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
          if (rnumnonpx.test(val)) {
            if (!extra) {
              return val;
            }
            val = "auto";
          }
          if ((!support.boxSizingReliable() && isBorderBox || !support.reliableTrDimensions() && nodeName(elem, "tr") || val === "auto" || !parseFloat(val) && jQuery2.css(elem, "display", false, styles) === "inline") && elem.getClientRects().length) {
            isBorderBox = jQuery2.css(elem, "boxSizing", false, styles) === "border-box";
            valueIsBorderBox = offsetProp in elem;
            if (valueIsBorderBox) {
              val = elem[offsetProp];
            }
          }
          val = parseFloat(val) || 0;
          return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, val) + "px";
        }
        jQuery2.extend({
          cssHooks: {
            opacity: {
              get: function(elem, computed) {
                if (computed) {
                  var ret = curCSS(elem, "opacity");
                  return ret === "" ? "1" : ret;
                }
              }
            }
          },
          cssNumber: {
            "animationIterationCount": true,
            "columnCount": true,
            "fillOpacity": true,
            "flexGrow": true,
            "flexShrink": true,
            "fontWeight": true,
            "gridArea": true,
            "gridColumn": true,
            "gridColumnEnd": true,
            "gridColumnStart": true,
            "gridRow": true,
            "gridRowEnd": true,
            "gridRowStart": true,
            "lineHeight": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
          },
          cssProps: {},
          style: function(elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
              return;
            }
            var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
            if (!isCustomProp) {
              name = finalPropName(origName);
            }
            hooks = jQuery2.cssHooks[name] || jQuery2.cssHooks[origName];
            if (value !== void 0) {
              type = typeof value;
              if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                value = adjustCSS(elem, name, ret);
                type = "number";
              }
              if (value == null || value !== value) {
                return;
              }
              if (type === "number" && !isCustomProp) {
                value += ret && ret[3] || (jQuery2.cssNumber[origName] ? "" : "px");
              }
              if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                style[name] = "inherit";
              }
              if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
                if (isCustomProp) {
                  style.setProperty(name, value);
                } else {
                  style[name] = value;
                }
              }
            } else {
              if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
                return ret;
              }
              return style[name];
            }
          },
          css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
            if (!isCustomProp) {
              name = finalPropName(origName);
            }
            hooks = jQuery2.cssHooks[name] || jQuery2.cssHooks[origName];
            if (hooks && "get" in hooks) {
              val = hooks.get(elem, true, extra);
            }
            if (val === void 0) {
              val = curCSS(elem, name, styles);
            }
            if (val === "normal" && name in cssNormalTransform) {
              val = cssNormalTransform[name];
            }
            if (extra === "" || extra) {
              num = parseFloat(val);
              return extra === true || isFinite(num) ? num || 0 : val;
            }
            return val;
          }
        });
        jQuery2.each(["height", "width"], function(_i, dimension) {
          jQuery2.cssHooks[dimension] = {
            get: function(elem, computed, extra) {
              if (computed) {
                return rdisplayswap.test(jQuery2.css(elem, "display")) && (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                  return getWidthOrHeight(elem, dimension, extra);
                }) : getWidthOrHeight(elem, dimension, extra);
              }
            },
            set: function(elem, value, extra) {
              var matches, styles = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery2.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0;
              if (isBorderBox && scrollboxSizeBuggy) {
                subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
              }
              if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
                elem.style[dimension] = value;
                value = jQuery2.css(elem, dimension);
              }
              return setPositiveNumber(elem, value, subtract);
            }
          };
        });
        jQuery2.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
          if (computed) {
            return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
              return elem.getBoundingClientRect().left;
            })) + "px";
          }
        });
        jQuery2.each({
          margin: "",
          padding: "",
          border: "Width"
        }, function(prefix, suffix) {
          jQuery2.cssHooks[prefix + suffix] = {
            expand: function(value) {
              var i2 = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
              for (; i2 < 4; i2++) {
                expanded[prefix + cssExpand[i2] + suffix] = parts[i2] || parts[i2 - 2] || parts[0];
              }
              return expanded;
            }
          };
          if (prefix !== "margin") {
            jQuery2.cssHooks[prefix + suffix].set = setPositiveNumber;
          }
        });
        jQuery2.fn.extend({
          css: function(name, value) {
            return access(this, function(elem, name2, value2) {
              var styles, len, map = {}, i2 = 0;
              if (Array.isArray(name2)) {
                styles = getStyles(elem);
                len = name2.length;
                for (; i2 < len; i2++) {
                  map[name2[i2]] = jQuery2.css(elem, name2[i2], false, styles);
                }
                return map;
              }
              return value2 !== void 0 ? jQuery2.style(elem, name2, value2) : jQuery2.css(elem, name2);
            }, name, value, arguments.length > 1);
          }
        });
        function Tween(elem, options, prop, end2, easing) {
          return new Tween.prototype.init(elem, options, prop, end2, easing);
        }
        jQuery2.Tween = Tween;
        Tween.prototype = {
          constructor: Tween,
          init: function(elem, options, prop, end2, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery2.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end2;
            this.unit = unit || (jQuery2.cssNumber[prop] ? "" : "px");
          },
          cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
          },
          run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
              this.pos = eased = jQuery2.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
              this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
              this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
              hooks.set(this);
            } else {
              Tween.propHooks._default.set(this);
            }
            return this;
          }
        };
        Tween.prototype.init.prototype = Tween.prototype;
        Tween.propHooks = {
          _default: {
            get: function(tween) {
              var result;
              if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                return tween.elem[tween.prop];
              }
              result = jQuery2.css(tween.elem, tween.prop, "");
              return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
              if (jQuery2.fx.step[tween.prop]) {
                jQuery2.fx.step[tween.prop](tween);
              } else if (tween.elem.nodeType === 1 && (jQuery2.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
                jQuery2.style(tween.elem, tween.prop, tween.now + tween.unit);
              } else {
                tween.elem[tween.prop] = tween.now;
              }
            }
          }
        };
        Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
          set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
              tween.elem[tween.prop] = tween.now;
            }
          }
        };
        jQuery2.easing = {
          linear: function(p2) {
            return p2;
          },
          swing: function(p2) {
            return 0.5 - Math.cos(p2 * Math.PI) / 2;
          },
          _default: "swing"
        };
        jQuery2.fx = Tween.prototype.init;
        jQuery2.fx.step = {};
        var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
        function schedule() {
          if (inProgress) {
            if (document2.hidden === false && window2.requestAnimationFrame) {
              window2.requestAnimationFrame(schedule);
            } else {
              window2.setTimeout(schedule, jQuery2.fx.interval);
            }
            jQuery2.fx.tick();
          }
        }
        function createFxNow() {
          window2.setTimeout(function() {
            fxNow = void 0;
          });
          return fxNow = Date.now();
        }
        function genFx(type, includeWidth) {
          var which, i2 = 0, attrs = { height: type };
          includeWidth = includeWidth ? 1 : 0;
          for (; i2 < 4; i2 += 2 - includeWidth) {
            which = cssExpand[i2];
            attrs["margin" + which] = attrs["padding" + which] = type;
          }
          if (includeWidth) {
            attrs.opacity = attrs.width = type;
          }
          return attrs;
        }
        function createTween(value, prop, animation) {
          var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
          for (; index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
              return tween;
            }
          }
        }
        function defaultPrefilter(elem, props, opts) {
          var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
          if (!opts.queue) {
            hooks = jQuery2._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
              hooks.unqueued = 0;
              oldfire = hooks.empty.fire;
              hooks.empty.fire = function() {
                if (!hooks.unqueued) {
                  oldfire();
                }
              };
            }
            hooks.unqueued++;
            anim.always(function() {
              anim.always(function() {
                hooks.unqueued--;
                if (!jQuery2.queue(elem, "fx").length) {
                  hooks.empty.fire();
                }
              });
            });
          }
          for (prop in props) {
            value = props[prop];
            if (rfxtypes.test(value)) {
              delete props[prop];
              toggle = toggle || value === "toggle";
              if (value === (hidden ? "hide" : "show")) {
                if (value === "show" && dataShow && dataShow[prop] !== void 0) {
                  hidden = true;
                } else {
                  continue;
                }
              }
              orig[prop] = dataShow && dataShow[prop] || jQuery2.style(elem, prop);
            }
          }
          propTween = !jQuery2.isEmptyObject(props);
          if (!propTween && jQuery2.isEmptyObject(orig)) {
            return;
          }
          if (isBox && elem.nodeType === 1) {
            opts.overflow = [style.overflow, style.overflowX, style.overflowY];
            restoreDisplay = dataShow && dataShow.display;
            if (restoreDisplay == null) {
              restoreDisplay = dataPriv.get(elem, "display");
            }
            display = jQuery2.css(elem, "display");
            if (display === "none") {
              if (restoreDisplay) {
                display = restoreDisplay;
              } else {
                showHide([elem], true);
                restoreDisplay = elem.style.display || restoreDisplay;
                display = jQuery2.css(elem, "display");
                showHide([elem]);
              }
            }
            if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
              if (jQuery2.css(elem, "float") === "none") {
                if (!propTween) {
                  anim.done(function() {
                    style.display = restoreDisplay;
                  });
                  if (restoreDisplay == null) {
                    display = style.display;
                    restoreDisplay = display === "none" ? "" : display;
                  }
                }
                style.display = "inline-block";
              }
            }
          }
          if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
              style.overflow = opts.overflow[0];
              style.overflowX = opts.overflow[1];
              style.overflowY = opts.overflow[2];
            });
          }
          propTween = false;
          for (prop in orig) {
            if (!propTween) {
              if (dataShow) {
                if ("hidden" in dataShow) {
                  hidden = dataShow.hidden;
                }
              } else {
                dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
              }
              if (toggle) {
                dataShow.hidden = !hidden;
              }
              if (hidden) {
                showHide([elem], true);
              }
              anim.done(function() {
                if (!hidden) {
                  showHide([elem]);
                }
                dataPriv.remove(elem, "fxshow");
                for (prop in orig) {
                  jQuery2.style(elem, prop, orig[prop]);
                }
              });
            }
            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
              dataShow[prop] = propTween.start;
              if (hidden) {
                propTween.end = propTween.start;
                propTween.start = 0;
              }
            }
          }
        }
        function propFilter(props, specialEasing) {
          var index, name, easing, value, hooks;
          for (index in props) {
            name = camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (Array.isArray(value)) {
              easing = value[1];
              value = props[index] = value[0];
            }
            if (index !== name) {
              props[name] = value;
              delete props[index];
            }
            hooks = jQuery2.cssHooks[name];
            if (hooks && "expand" in hooks) {
              value = hooks.expand(value);
              delete props[name];
              for (index in value) {
                if (!(index in props)) {
                  props[index] = value[index];
                  specialEasing[index] = easing;
                }
              }
            } else {
              specialEasing[name] = easing;
            }
          }
        }
        function Animation(elem, properties, options) {
          var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery2.Deferred().always(function() {
            delete tick.elem;
          }), tick = function() {
            if (stopped) {
              return false;
            }
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index2 = 0, length2 = animation.tweens.length;
            for (; index2 < length2; index2++) {
              animation.tweens[index2].run(percent);
            }
            deferred.notifyWith(elem, [animation, percent, remaining]);
            if (percent < 1 && length2) {
              return remaining;
            }
            if (!length2) {
              deferred.notifyWith(elem, [animation, 1, 0]);
            }
            deferred.resolveWith(elem, [animation]);
            return false;
          }, animation = deferred.promise({
            elem,
            props: jQuery2.extend({}, properties),
            opts: jQuery2.extend(true, {
              specialEasing: {},
              easing: jQuery2.easing._default
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end2) {
              var tween = jQuery2.Tween(elem, animation.opts, prop, end2, animation.opts.specialEasing[prop] || animation.opts.easing);
              animation.tweens.push(tween);
              return tween;
            },
            stop: function(gotoEnd) {
              var index2 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
              if (stopped) {
                return this;
              }
              stopped = true;
              for (; index2 < length2; index2++) {
                animation.tweens[index2].run(1);
              }
              if (gotoEnd) {
                deferred.notifyWith(elem, [animation, 1, 0]);
                deferred.resolveWith(elem, [animation, gotoEnd]);
              } else {
                deferred.rejectWith(elem, [animation, gotoEnd]);
              }
              return this;
            }
          }), props = animation.props;
          propFilter(props, animation.opts.specialEasing);
          for (; index < length; index++) {
            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
              if (isFunction(result.stop)) {
                jQuery2._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
              }
              return result;
            }
          }
          jQuery2.map(props, createTween, animation);
          if (isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
          }
          animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
          jQuery2.fx.timer(jQuery2.extend(tick, {
            elem,
            anim: animation,
            queue: animation.opts.queue
          }));
          return animation;
        }
        jQuery2.Animation = jQuery2.extend(Animation, {
          tweeners: {
            "*": [function(prop, value) {
              var tween = this.createTween(prop, value);
              adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
              return tween;
            }]
          },
          tweener: function(props, callback) {
            if (isFunction(props)) {
              callback = props;
              props = ["*"];
            } else {
              props = props.match(rnothtmlwhite);
            }
            var prop, index = 0, length = props.length;
            for (; index < length; index++) {
              prop = props[index];
              Animation.tweeners[prop] = Animation.tweeners[prop] || [];
              Animation.tweeners[prop].unshift(callback);
            }
          },
          prefilters: [defaultPrefilter],
          prefilter: function(callback, prepend) {
            if (prepend) {
              Animation.prefilters.unshift(callback);
            } else {
              Animation.prefilters.push(callback);
            }
          }
        });
        jQuery2.speed = function(speed, easing, fn2) {
          var opt = speed && typeof speed === "object" ? jQuery2.extend({}, speed) : {
            complete: fn2 || !fn2 && easing || isFunction(speed) && speed,
            duration: speed,
            easing: fn2 && easing || easing && !isFunction(easing) && easing
          };
          if (jQuery2.fx.off) {
            opt.duration = 0;
          } else {
            if (typeof opt.duration !== "number") {
              if (opt.duration in jQuery2.fx.speeds) {
                opt.duration = jQuery2.fx.speeds[opt.duration];
              } else {
                opt.duration = jQuery2.fx.speeds._default;
              }
            }
          }
          if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
          }
          opt.old = opt.complete;
          opt.complete = function() {
            if (isFunction(opt.old)) {
              opt.old.call(this);
            }
            if (opt.queue) {
              jQuery2.dequeue(this, opt.queue);
            }
          };
          return opt;
        };
        jQuery2.fn.extend({
          fadeTo: function(speed, to, easing, callback) {
            return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
          },
          animate: function(prop, speed, easing, callback) {
            var empty = jQuery2.isEmptyObject(prop), optall = jQuery2.speed(speed, easing, callback), doAnimation = function() {
              var anim = Animation(this, jQuery2.extend({}, prop), optall);
              if (empty || dataPriv.get(this, "finish")) {
                anim.stop(true);
              }
            };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
          },
          stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
              var stop = hooks.stop;
              delete hooks.stop;
              stop(gotoEnd);
            };
            if (typeof type !== "string") {
              gotoEnd = clearQueue;
              clearQueue = type;
              type = void 0;
            }
            if (clearQueue) {
              this.queue(type || "fx", []);
            }
            return this.each(function() {
              var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery2.timers, data = dataPriv.get(this);
              if (index) {
                if (data[index] && data[index].stop) {
                  stopQueue(data[index]);
                }
              } else {
                for (index in data) {
                  if (data[index] && data[index].stop && rrun.test(index)) {
                    stopQueue(data[index]);
                  }
                }
              }
              for (index = timers.length; index--; ) {
                if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                  timers[index].anim.stop(gotoEnd);
                  dequeue = false;
                  timers.splice(index, 1);
                }
              }
              if (dequeue || !gotoEnd) {
                jQuery2.dequeue(this, type);
              }
            });
          },
          finish: function(type) {
            if (type !== false) {
              type = type || "fx";
            }
            return this.each(function() {
              var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery2.timers, length = queue ? queue.length : 0;
              data.finish = true;
              jQuery2.queue(this, type, []);
              if (hooks && hooks.stop) {
                hooks.stop.call(this, true);
              }
              for (index = timers.length; index--; ) {
                if (timers[index].elem === this && timers[index].queue === type) {
                  timers[index].anim.stop(true);
                  timers.splice(index, 1);
                }
              }
              for (index = 0; index < length; index++) {
                if (queue[index] && queue[index].finish) {
                  queue[index].finish.call(this);
                }
              }
              delete data.finish;
            });
          }
        });
        jQuery2.each(["toggle", "show", "hide"], function(_i, name) {
          var cssFn = jQuery2.fn[name];
          jQuery2.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
          };
        });
        jQuery2.each({
          slideDown: genFx("show"),
          slideUp: genFx("hide"),
          slideToggle: genFx("toggle"),
          fadeIn: { opacity: "show" },
          fadeOut: { opacity: "hide" },
          fadeToggle: { opacity: "toggle" }
        }, function(name, props) {
          jQuery2.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
          };
        });
        jQuery2.timers = [];
        jQuery2.fx.tick = function() {
          var timer, i2 = 0, timers = jQuery2.timers;
          fxNow = Date.now();
          for (; i2 < timers.length; i2++) {
            timer = timers[i2];
            if (!timer() && timers[i2] === timer) {
              timers.splice(i2--, 1);
            }
          }
          if (!timers.length) {
            jQuery2.fx.stop();
          }
          fxNow = void 0;
        };
        jQuery2.fx.timer = function(timer) {
          jQuery2.timers.push(timer);
          jQuery2.fx.start();
        };
        jQuery2.fx.interval = 13;
        jQuery2.fx.start = function() {
          if (inProgress) {
            return;
          }
          inProgress = true;
          schedule();
        };
        jQuery2.fx.stop = function() {
          inProgress = null;
        };
        jQuery2.fx.speeds = {
          slow: 600,
          fast: 200,
          _default: 400
        };
        jQuery2.fn.delay = function(time, type) {
          time = jQuery2.fx ? jQuery2.fx.speeds[time] || time : time;
          type = type || "fx";
          return this.queue(type, function(next, hooks) {
            var timeout = window2.setTimeout(next, time);
            hooks.stop = function() {
              window2.clearTimeout(timeout);
            };
          });
        };
        (function() {
          var input = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
          input.type = "checkbox";
          support.checkOn = input.value !== "";
          support.optSelected = opt.selected;
          input = document2.createElement("input");
          input.value = "t";
          input.type = "radio";
          support.radioValue = input.value === "t";
        })();
        var boolHook, attrHandle = jQuery2.expr.attrHandle;
        jQuery2.fn.extend({
          attr: function(name, value) {
            return access(this, jQuery2.attr, name, value, arguments.length > 1);
          },
          removeAttr: function(name) {
            return this.each(function() {
              jQuery2.removeAttr(this, name);
            });
          }
        });
        jQuery2.extend({
          attr: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
              return;
            }
            if (typeof elem.getAttribute === "undefined") {
              return jQuery2.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery2.isXMLDoc(elem)) {
              hooks = jQuery2.attrHooks[name.toLowerCase()] || (jQuery2.expr.match.bool.test(name) ? boolHook : void 0);
            }
            if (value !== void 0) {
              if (value === null) {
                jQuery2.removeAttr(elem, name);
                return;
              }
              if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
                return ret;
              }
              elem.setAttribute(name, value + "");
              return value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
              return ret;
            }
            ret = jQuery2.find.attr(elem, name);
            return ret == null ? void 0 : ret;
          },
          attrHooks: {
            type: {
              set: function(elem, value) {
                if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                  var val = elem.value;
                  elem.setAttribute("type", value);
                  if (val) {
                    elem.value = val;
                  }
                  return value;
                }
              }
            }
          },
          removeAttr: function(elem, value) {
            var name, i2 = 0, attrNames = value && value.match(rnothtmlwhite);
            if (attrNames && elem.nodeType === 1) {
              while (name = attrNames[i2++]) {
                elem.removeAttribute(name);
              }
            }
          }
        });
        boolHook = {
          set: function(elem, value, name) {
            if (value === false) {
              jQuery2.removeAttr(elem, name);
            } else {
              elem.setAttribute(name, name);
            }
            return name;
          }
        };
        jQuery2.each(jQuery2.expr.match.bool.source.match(/\w+/g), function(_i, name) {
          var getter = attrHandle[name] || jQuery2.find.attr;
          attrHandle[name] = function(elem, name2, isXML) {
            var ret, handle, lowercaseName = name2.toLowerCase();
            if (!isXML) {
              handle = attrHandle[lowercaseName];
              attrHandle[lowercaseName] = ret;
              ret = getter(elem, name2, isXML) != null ? lowercaseName : null;
              attrHandle[lowercaseName] = handle;
            }
            return ret;
          };
        });
        var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
        jQuery2.fn.extend({
          prop: function(name, value) {
            return access(this, jQuery2.prop, name, value, arguments.length > 1);
          },
          removeProp: function(name) {
            return this.each(function() {
              delete this[jQuery2.propFix[name] || name];
            });
          }
        });
        jQuery2.extend({
          prop: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
              return;
            }
            if (nType !== 1 || !jQuery2.isXMLDoc(elem)) {
              name = jQuery2.propFix[name] || name;
              hooks = jQuery2.propHooks[name];
            }
            if (value !== void 0) {
              if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
                return ret;
              }
              return elem[name] = value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
              return ret;
            }
            return elem[name];
          },
          propHooks: {
            tabIndex: {
              get: function(elem) {
                var tabindex = jQuery2.find.attr(elem, "tabindex");
                if (tabindex) {
                  return parseInt(tabindex, 10);
                }
                if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                  return 0;
                }
                return -1;
              }
            }
          },
          propFix: {
            "for": "htmlFor",
            "class": "className"
          }
        });
        if (!support.optSelected) {
          jQuery2.propHooks.selected = {
            get: function(elem) {
              var parent = elem.parentNode;
              if (parent && parent.parentNode) {
                parent.parentNode.selectedIndex;
              }
              return null;
            },
            set: function(elem) {
              var parent = elem.parentNode;
              if (parent) {
                parent.selectedIndex;
                if (parent.parentNode) {
                  parent.parentNode.selectedIndex;
                }
              }
            }
          };
        }
        jQuery2.each([
          "tabIndex",
          "readOnly",
          "maxLength",
          "cellSpacing",
          "cellPadding",
          "rowSpan",
          "colSpan",
          "useMap",
          "frameBorder",
          "contentEditable"
        ], function() {
          jQuery2.propFix[this.toLowerCase()] = this;
        });
        function stripAndCollapse(value) {
          var tokens = value.match(rnothtmlwhite) || [];
          return tokens.join(" ");
        }
        function getClass(elem) {
          return elem.getAttribute && elem.getAttribute("class") || "";
        }
        function classesToArray(value) {
          if (Array.isArray(value)) {
            return value;
          }
          if (typeof value === "string") {
            return value.match(rnothtmlwhite) || [];
          }
          return [];
        }
        jQuery2.fn.extend({
          addClass: function(value) {
            var classes, elem, cur, curValue, clazz, j2, finalValue, i2 = 0;
            if (isFunction(value)) {
              return this.each(function(j3) {
                jQuery2(this).addClass(value.call(this, j3, getClass(this)));
              });
            }
            classes = classesToArray(value);
            if (classes.length) {
              while (elem = this[i2++]) {
                curValue = getClass(elem);
                cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                  j2 = 0;
                  while (clazz = classes[j2++]) {
                    if (cur.indexOf(" " + clazz + " ") < 0) {
                      cur += clazz + " ";
                    }
                  }
                  finalValue = stripAndCollapse(cur);
                  if (curValue !== finalValue) {
                    elem.setAttribute("class", finalValue);
                  }
                }
              }
            }
            return this;
          },
          removeClass: function(value) {
            var classes, elem, cur, curValue, clazz, j2, finalValue, i2 = 0;
            if (isFunction(value)) {
              return this.each(function(j3) {
                jQuery2(this).removeClass(value.call(this, j3, getClass(this)));
              });
            }
            if (!arguments.length) {
              return this.attr("class", "");
            }
            classes = classesToArray(value);
            if (classes.length) {
              while (elem = this[i2++]) {
                curValue = getClass(elem);
                cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                  j2 = 0;
                  while (clazz = classes[j2++]) {
                    while (cur.indexOf(" " + clazz + " ") > -1) {
                      cur = cur.replace(" " + clazz + " ", " ");
                    }
                  }
                  finalValue = stripAndCollapse(cur);
                  if (curValue !== finalValue) {
                    elem.setAttribute("class", finalValue);
                  }
                }
              }
            }
            return this;
          },
          toggleClass: function(value, stateVal) {
            var type = typeof value, isValidValue = type === "string" || Array.isArray(value);
            if (typeof stateVal === "boolean" && isValidValue) {
              return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            if (isFunction(value)) {
              return this.each(function(i2) {
                jQuery2(this).toggleClass(value.call(this, i2, getClass(this), stateVal), stateVal);
              });
            }
            return this.each(function() {
              var className, i2, self2, classNames;
              if (isValidValue) {
                i2 = 0;
                self2 = jQuery2(this);
                classNames = classesToArray(value);
                while (className = classNames[i2++]) {
                  if (self2.hasClass(className)) {
                    self2.removeClass(className);
                  } else {
                    self2.addClass(className);
                  }
                }
              } else if (value === void 0 || type === "boolean") {
                className = getClass(this);
                if (className) {
                  dataPriv.set(this, "__className__", className);
                }
                if (this.setAttribute) {
                  this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
                }
              }
            });
          },
          hasClass: function(selector) {
            var className, elem, i2 = 0;
            className = " " + selector + " ";
            while (elem = this[i2++]) {
              if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
                return true;
              }
            }
            return false;
          }
        });
        var rreturn = /\r/g;
        jQuery2.fn.extend({
          val: function(value) {
            var hooks, ret, valueIsFunction, elem = this[0];
            if (!arguments.length) {
              if (elem) {
                hooks = jQuery2.valHooks[elem.type] || jQuery2.valHooks[elem.nodeName.toLowerCase()];
                if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
                  return ret;
                }
                ret = elem.value;
                if (typeof ret === "string") {
                  return ret.replace(rreturn, "");
                }
                return ret == null ? "" : ret;
              }
              return;
            }
            valueIsFunction = isFunction(value);
            return this.each(function(i2) {
              var val;
              if (this.nodeType !== 1) {
                return;
              }
              if (valueIsFunction) {
                val = value.call(this, i2, jQuery2(this).val());
              } else {
                val = value;
              }
              if (val == null) {
                val = "";
              } else if (typeof val === "number") {
                val += "";
              } else if (Array.isArray(val)) {
                val = jQuery2.map(val, function(value2) {
                  return value2 == null ? "" : value2 + "";
                });
              }
              hooks = jQuery2.valHooks[this.type] || jQuery2.valHooks[this.nodeName.toLowerCase()];
              if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
                this.value = val;
              }
            });
          }
        });
        jQuery2.extend({
          valHooks: {
            option: {
              get: function(elem) {
                var val = jQuery2.find.attr(elem, "value");
                return val != null ? val : stripAndCollapse(jQuery2.text(elem));
              }
            },
            select: {
              get: function(elem) {
                var value, option, i2, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max2 = one ? index + 1 : options.length;
                if (index < 0) {
                  i2 = max2;
                } else {
                  i2 = one ? index : 0;
                }
                for (; i2 < max2; i2++) {
                  option = options[i2];
                  if ((option.selected || i2 === index) && !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                    value = jQuery2(option).val();
                    if (one) {
                      return value;
                    }
                    values.push(value);
                  }
                }
                return values;
              },
              set: function(elem, value) {
                var optionSet, option, options = elem.options, values = jQuery2.makeArray(value), i2 = options.length;
                while (i2--) {
                  option = options[i2];
                  if (option.selected = jQuery2.inArray(jQuery2.valHooks.option.get(option), values) > -1) {
                    optionSet = true;
                  }
                }
                if (!optionSet) {
                  elem.selectedIndex = -1;
                }
                return values;
              }
            }
          }
        });
        jQuery2.each(["radio", "checkbox"], function() {
          jQuery2.valHooks[this] = {
            set: function(elem, value) {
              if (Array.isArray(value)) {
                return elem.checked = jQuery2.inArray(jQuery2(elem).val(), value) > -1;
              }
            }
          };
          if (!support.checkOn) {
            jQuery2.valHooks[this].get = function(elem) {
              return elem.getAttribute("value") === null ? "on" : elem.value;
            };
          }
        });
        support.focusin = "onfocusin" in window2;
        var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e2) {
          e2.stopPropagation();
        };
        jQuery2.extend(jQuery2.event, {
          trigger: function(event, data, elem, onlyHandlers) {
            var i2, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = lastElement = tmp = elem = elem || document2;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
              return;
            }
            if (rfocusMorph.test(type + jQuery2.event.triggered)) {
              return;
            }
            if (type.indexOf(".") > -1) {
              namespaces = type.split(".");
              type = namespaces.shift();
              namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            event = event[jQuery2.expando] ? event : new jQuery2.Event(type, typeof event === "object" && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            event.result = void 0;
            if (!event.target) {
              event.target = elem;
            }
            data = data == null ? [event] : jQuery2.makeArray(data, [event]);
            special = jQuery2.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
              return;
            }
            if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
              bubbleType = special.delegateType || type;
              if (!rfocusMorph.test(bubbleType + type)) {
                cur = cur.parentNode;
              }
              for (; cur; cur = cur.parentNode) {
                eventPath.push(cur);
                tmp = cur;
              }
              if (tmp === (elem.ownerDocument || document2)) {
                eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
              }
            }
            i2 = 0;
            while ((cur = eventPath[i2++]) && !event.isPropagationStopped()) {
              lastElement = cur;
              event.type = i2 > 1 ? bubbleType : special.bindType || type;
              handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
              if (handle) {
                handle.apply(cur, data);
              }
              handle = ontype && cur[ontype];
              if (handle && handle.apply && acceptData(cur)) {
                event.result = handle.apply(cur, data);
                if (event.result === false) {
                  event.preventDefault();
                }
              }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
              if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
                if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
                  tmp = elem[ontype];
                  if (tmp) {
                    elem[ontype] = null;
                  }
                  jQuery2.event.triggered = type;
                  if (event.isPropagationStopped()) {
                    lastElement.addEventListener(type, stopPropagationCallback);
                  }
                  elem[type]();
                  if (event.isPropagationStopped()) {
                    lastElement.removeEventListener(type, stopPropagationCallback);
                  }
                  jQuery2.event.triggered = void 0;
                  if (tmp) {
                    elem[ontype] = tmp;
                  }
                }
              }
            }
            return event.result;
          },
          simulate: function(type, elem, event) {
            var e2 = jQuery2.extend(new jQuery2.Event(), event, {
              type,
              isSimulated: true
            });
            jQuery2.event.trigger(e2, null, elem);
          }
        });
        jQuery2.fn.extend({
          trigger: function(type, data) {
            return this.each(function() {
              jQuery2.event.trigger(type, data, this);
            });
          },
          triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) {
              return jQuery2.event.trigger(type, data, elem, true);
            }
          }
        });
        if (!support.focusin) {
          jQuery2.each({ focus: "focusin", blur: "focusout" }, function(orig, fix) {
            var handler = function(event) {
              jQuery2.event.simulate(fix, event.target, jQuery2.event.fix(event));
            };
            jQuery2.event.special[fix] = {
              setup: function() {
                var doc = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc, fix);
                if (!attaches) {
                  doc.addEventListener(orig, handler, true);
                }
                dataPriv.access(doc, fix, (attaches || 0) + 1);
              },
              teardown: function() {
                var doc = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc, fix) - 1;
                if (!attaches) {
                  doc.removeEventListener(orig, handler, true);
                  dataPriv.remove(doc, fix);
                } else {
                  dataPriv.access(doc, fix, attaches);
                }
              }
            };
          });
        }
        var location2 = window2.location;
        var nonce = { guid: Date.now() };
        var rquery = /\?/;
        jQuery2.parseXML = function(data) {
          var xml;
          if (!data || typeof data !== "string") {
            return null;
          }
          try {
            xml = new window2.DOMParser().parseFromString(data, "text/xml");
          } catch (e2) {
            xml = void 0;
          }
          if (!xml || xml.getElementsByTagName("parsererror").length) {
            jQuery2.error("Invalid XML: " + data);
          }
          return xml;
        };
        var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
        function buildParams(prefix, obj, traditional, add3) {
          var name;
          if (Array.isArray(obj)) {
            jQuery2.each(obj, function(i2, v2) {
              if (traditional || rbracket.test(prefix)) {
                add3(prefix, v2);
              } else {
                buildParams(prefix + "[" + (typeof v2 === "object" && v2 != null ? i2 : "") + "]", v2, traditional, add3);
              }
            });
          } else if (!traditional && toType(obj) === "object") {
            for (name in obj) {
              buildParams(prefix + "[" + name + "]", obj[name], traditional, add3);
            }
          } else {
            add3(prefix, obj);
          }
        }
        jQuery2.param = function(a2, traditional) {
          var prefix, s2 = [], add3 = function(key, valueOrFunction) {
            var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
            s2[s2.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
          };
          if (a2 == null) {
            return "";
          }
          if (Array.isArray(a2) || a2.jquery && !jQuery2.isPlainObject(a2)) {
            jQuery2.each(a2, function() {
              add3(this.name, this.value);
            });
          } else {
            for (prefix in a2) {
              buildParams(prefix, a2[prefix], traditional, add3);
            }
          }
          return s2.join("&");
        };
        jQuery2.fn.extend({
          serialize: function() {
            return jQuery2.param(this.serializeArray());
          },
          serializeArray: function() {
            return this.map(function() {
              var elements = jQuery2.prop(this, "elements");
              return elements ? jQuery2.makeArray(elements) : this;
            }).filter(function() {
              var type = this.type;
              return this.name && !jQuery2(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(_i, elem) {
              var val = jQuery2(this).val();
              if (val == null) {
                return null;
              }
              if (Array.isArray(val)) {
                return jQuery2.map(val, function(val2) {
                  return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
                });
              }
              return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
            }).get();
          }
        });
        var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
        originAnchor.href = location2.href;
        function addToPrefiltersOrTransports(structure) {
          return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
              func = dataTypeExpression;
              dataTypeExpression = "*";
            }
            var dataType, i2 = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
            if (isFunction(func)) {
              while (dataType = dataTypes[i2++]) {
                if (dataType[0] === "+") {
                  dataType = dataType.slice(1) || "*";
                  (structure[dataType] = structure[dataType] || []).unshift(func);
                } else {
                  (structure[dataType] = structure[dataType] || []).push(func);
                }
              }
            }
          };
        }
        function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
          var inspected = {}, seekingTransport = structure === transports;
          function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery2.each(structure[dataType] || [], function(_2, prefilterOrFactory) {
              var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
              if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                options.dataTypes.unshift(dataTypeOrTransport);
                inspect(dataTypeOrTransport);
                return false;
              } else if (seekingTransport) {
                return !(selected = dataTypeOrTransport);
              }
            });
            return selected;
          }
          return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
        }
        function ajaxExtend(target, src) {
          var key, deep, flatOptions = jQuery2.ajaxSettings.flatOptions || {};
          for (key in src) {
            if (src[key] !== void 0) {
              (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
          }
          if (deep) {
            jQuery2.extend(true, target, deep);
          }
          return target;
        }
        function ajaxHandleResponses(s2, jqXHR, responses) {
          var ct, type, finalDataType, firstDataType, contents = s2.contents, dataTypes = s2.dataTypes;
          while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === void 0) {
              ct = s2.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
          }
          if (ct) {
            for (type in contents) {
              if (contents[type] && contents[type].test(ct)) {
                dataTypes.unshift(type);
                break;
              }
            }
          }
          if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
          } else {
            for (type in responses) {
              if (!dataTypes[0] || s2.converters[type + " " + dataTypes[0]]) {
                finalDataType = type;
                break;
              }
              if (!firstDataType) {
                firstDataType = type;
              }
            }
            finalDataType = finalDataType || firstDataType;
          }
          if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
              dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
          }
        }
        function ajaxConvert(s2, response, jqXHR, isSuccess) {
          var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s2.dataTypes.slice();
          if (dataTypes[1]) {
            for (conv in s2.converters) {
              converters[conv.toLowerCase()] = s2.converters[conv];
            }
          }
          current = dataTypes.shift();
          while (current) {
            if (s2.responseFields[current]) {
              jqXHR[s2.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s2.dataFilter) {
              response = s2.dataFilter(response, s2.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
              if (current === "*") {
                current = prev;
              } else if (prev !== "*" && prev !== current) {
                conv = converters[prev + " " + current] || converters["* " + current];
                if (!conv) {
                  for (conv2 in converters) {
                    tmp = conv2.split(" ");
                    if (tmp[1] === current) {
                      conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                      if (conv) {
                        if (conv === true) {
                          conv = converters[conv2];
                        } else if (converters[conv2] !== true) {
                          current = tmp[0];
                          dataTypes.unshift(tmp[1]);
                        }
                        break;
                      }
                    }
                  }
                }
                if (conv !== true) {
                  if (conv && s2.throws) {
                    response = conv(response);
                  } else {
                    try {
                      response = conv(response);
                    } catch (e2) {
                      return {
                        state: "parsererror",
                        error: conv ? e2 : "No conversion from " + prev + " to " + current
                      };
                    }
                  }
                }
              }
            }
          }
          return { state: "success", data: response };
        }
        jQuery2.extend({
          active: 0,
          lastModified: {},
          etag: {},
          ajaxSettings: {
            url: location2.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location2.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
              "*": allTypes,
              text: "text/plain",
              html: "text/html",
              xml: "application/xml, text/xml",
              json: "application/json, text/javascript"
            },
            contents: {
              xml: /\bxml\b/,
              html: /\bhtml/,
              json: /\bjson\b/
            },
            responseFields: {
              xml: "responseXML",
              text: "responseText",
              json: "responseJSON"
            },
            converters: {
              "* text": String,
              "text html": true,
              "text json": JSON.parse,
              "text xml": jQuery2.parseXML
            },
            flatOptions: {
              url: true,
              context: true
            }
          },
          ajaxSetup: function(target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery2.ajaxSettings), settings) : ajaxExtend(jQuery2.ajaxSettings, target);
          },
          ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
          ajaxTransport: addToPrefiltersOrTransports(transports),
          ajax: function(url, options) {
            if (typeof url === "object") {
              options = url;
              url = void 0;
            }
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i2, uncached, s2 = jQuery2.ajaxSetup({}, options), callbackContext = s2.context || s2, globalEventContext = s2.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery2(callbackContext) : jQuery2.event, deferred = jQuery2.Deferred(), completeDeferred = jQuery2.Callbacks("once memory"), statusCode = s2.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
              readyState: 0,
              getResponseHeader: function(key) {
                var match;
                if (completed2) {
                  if (!responseHeaders) {
                    responseHeaders = {};
                    while (match = rheaders.exec(responseHeadersString)) {
                      responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                    }
                  }
                  match = responseHeaders[key.toLowerCase() + " "];
                }
                return match == null ? null : match.join(", ");
              },
              getAllResponseHeaders: function() {
                return completed2 ? responseHeadersString : null;
              },
              setRequestHeader: function(name, value) {
                if (completed2 == null) {
                  name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                  requestHeaders[name] = value;
                }
                return this;
              },
              overrideMimeType: function(type) {
                if (completed2 == null) {
                  s2.mimeType = type;
                }
                return this;
              },
              statusCode: function(map) {
                var code3;
                if (map) {
                  if (completed2) {
                    jqXHR.always(map[jqXHR.status]);
                  } else {
                    for (code3 in map) {
                      statusCode[code3] = [statusCode[code3], map[code3]];
                    }
                  }
                }
                return this;
              },
              abort: function(statusText) {
                var finalText = statusText || strAbort;
                if (transport) {
                  transport.abort(finalText);
                }
                done(0, finalText);
                return this;
              }
            };
            deferred.promise(jqXHR);
            s2.url = ((url || s2.url || location2.href) + "").replace(rprotocol, location2.protocol + "//");
            s2.type = options.method || options.type || s2.method || s2.type;
            s2.dataTypes = (s2.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
            if (s2.crossDomain == null) {
              urlAnchor = document2.createElement("a");
              try {
                urlAnchor.href = s2.url;
                urlAnchor.href = urlAnchor.href;
                s2.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
              } catch (e2) {
                s2.crossDomain = true;
              }
            }
            if (s2.data && s2.processData && typeof s2.data !== "string") {
              s2.data = jQuery2.param(s2.data, s2.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s2, options, jqXHR);
            if (completed2) {
              return jqXHR;
            }
            fireGlobals = jQuery2.event && s2.global;
            if (fireGlobals && jQuery2.active++ === 0) {
              jQuery2.event.trigger("ajaxStart");
            }
            s2.type = s2.type.toUpperCase();
            s2.hasContent = !rnoContent.test(s2.type);
            cacheURL = s2.url.replace(rhash, "");
            if (!s2.hasContent) {
              uncached = s2.url.slice(cacheURL.length);
              if (s2.data && (s2.processData || typeof s2.data === "string")) {
                cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s2.data;
                delete s2.data;
              }
              if (s2.cache === false) {
                cacheURL = cacheURL.replace(rantiCache, "$1");
                uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
              }
              s2.url = cacheURL + uncached;
            } else if (s2.data && s2.processData && (s2.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
              s2.data = s2.data.replace(r20, "+");
            }
            if (s2.ifModified) {
              if (jQuery2.lastModified[cacheURL]) {
                jqXHR.setRequestHeader("If-Modified-Since", jQuery2.lastModified[cacheURL]);
              }
              if (jQuery2.etag[cacheURL]) {
                jqXHR.setRequestHeader("If-None-Match", jQuery2.etag[cacheURL]);
              }
            }
            if (s2.data && s2.hasContent && s2.contentType !== false || options.contentType) {
              jqXHR.setRequestHeader("Content-Type", s2.contentType);
            }
            jqXHR.setRequestHeader("Accept", s2.dataTypes[0] && s2.accepts[s2.dataTypes[0]] ? s2.accepts[s2.dataTypes[0]] + (s2.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s2.accepts["*"]);
            for (i2 in s2.headers) {
              jqXHR.setRequestHeader(i2, s2.headers[i2]);
            }
            if (s2.beforeSend && (s2.beforeSend.call(callbackContext, jqXHR, s2) === false || completed2)) {
              return jqXHR.abort();
            }
            strAbort = "abort";
            completeDeferred.add(s2.complete);
            jqXHR.done(s2.success);
            jqXHR.fail(s2.error);
            transport = inspectPrefiltersOrTransports(transports, s2, options, jqXHR);
            if (!transport) {
              done(-1, "No Transport");
            } else {
              jqXHR.readyState = 1;
              if (fireGlobals) {
                globalEventContext.trigger("ajaxSend", [jqXHR, s2]);
              }
              if (completed2) {
                return jqXHR;
              }
              if (s2.async && s2.timeout > 0) {
                timeoutTimer = window2.setTimeout(function() {
                  jqXHR.abort("timeout");
                }, s2.timeout);
              }
              try {
                completed2 = false;
                transport.send(requestHeaders, done);
              } catch (e2) {
                if (completed2) {
                  throw e2;
                }
                done(-1, e2);
              }
            }
            function done(status, nativeStatusText, responses, headers) {
              var isSuccess, success, error2, response, modified, statusText = nativeStatusText;
              if (completed2) {
                return;
              }
              completed2 = true;
              if (timeoutTimer) {
                window2.clearTimeout(timeoutTimer);
              }
              transport = void 0;
              responseHeadersString = headers || "";
              jqXHR.readyState = status > 0 ? 4 : 0;
              isSuccess = status >= 200 && status < 300 || status === 304;
              if (responses) {
                response = ajaxHandleResponses(s2, jqXHR, responses);
              }
              if (!isSuccess && jQuery2.inArray("script", s2.dataTypes) > -1) {
                s2.converters["text script"] = function() {
                };
              }
              response = ajaxConvert(s2, response, jqXHR, isSuccess);
              if (isSuccess) {
                if (s2.ifModified) {
                  modified = jqXHR.getResponseHeader("Last-Modified");
                  if (modified) {
                    jQuery2.lastModified[cacheURL] = modified;
                  }
                  modified = jqXHR.getResponseHeader("etag");
                  if (modified) {
                    jQuery2.etag[cacheURL] = modified;
                  }
                }
                if (status === 204 || s2.type === "HEAD") {
                  statusText = "nocontent";
                } else if (status === 304) {
                  statusText = "notmodified";
                } else {
                  statusText = response.state;
                  success = response.data;
                  error2 = response.error;
                  isSuccess = !error2;
                }
              } else {
                error2 = statusText;
                if (status || !statusText) {
                  statusText = "error";
                  if (status < 0) {
                    status = 0;
                  }
                }
              }
              jqXHR.status = status;
              jqXHR.statusText = (nativeStatusText || statusText) + "";
              if (isSuccess) {
                deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
              } else {
                deferred.rejectWith(callbackContext, [jqXHR, statusText, error2]);
              }
              jqXHR.statusCode(statusCode);
              statusCode = void 0;
              if (fireGlobals) {
                globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s2, isSuccess ? success : error2]);
              }
              completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
              if (fireGlobals) {
                globalEventContext.trigger("ajaxComplete", [jqXHR, s2]);
                if (!--jQuery2.active) {
                  jQuery2.event.trigger("ajaxStop");
                }
              }
            }
            return jqXHR;
          },
          getJSON: function(url, data, callback) {
            return jQuery2.get(url, data, callback, "json");
          },
          getScript: function(url, callback) {
            return jQuery2.get(url, void 0, callback, "script");
          }
        });
        jQuery2.each(["get", "post"], function(_i, method) {
          jQuery2[method] = function(url, data, callback, type) {
            if (isFunction(data)) {
              type = type || callback;
              callback = data;
              data = void 0;
            }
            return jQuery2.ajax(jQuery2.extend({
              url,
              type: method,
              dataType: type,
              data,
              success: callback
            }, jQuery2.isPlainObject(url) && url));
          };
        });
        jQuery2.ajaxPrefilter(function(s2) {
          var i2;
          for (i2 in s2.headers) {
            if (i2.toLowerCase() === "content-type") {
              s2.contentType = s2.headers[i2] || "";
            }
          }
        });
        jQuery2._evalUrl = function(url, options, doc) {
          return jQuery2.ajax({
            url,
            type: "GET",
            dataType: "script",
            cache: true,
            async: false,
            global: false,
            converters: {
              "text script": function() {
              }
            },
            dataFilter: function(response) {
              jQuery2.globalEval(response, options, doc);
            }
          });
        };
        jQuery2.fn.extend({
          wrapAll: function(html) {
            var wrap2;
            if (this[0]) {
              if (isFunction(html)) {
                html = html.call(this[0]);
              }
              wrap2 = jQuery2(html, this[0].ownerDocument).eq(0).clone(true);
              if (this[0].parentNode) {
                wrap2.insertBefore(this[0]);
              }
              wrap2.map(function() {
                var elem = this;
                while (elem.firstElementChild) {
                  elem = elem.firstElementChild;
                }
                return elem;
              }).append(this);
            }
            return this;
          },
          wrapInner: function(html) {
            if (isFunction(html)) {
              return this.each(function(i2) {
                jQuery2(this).wrapInner(html.call(this, i2));
              });
            }
            return this.each(function() {
              var self2 = jQuery2(this), contents = self2.contents();
              if (contents.length) {
                contents.wrapAll(html);
              } else {
                self2.append(html);
              }
            });
          },
          wrap: function(html) {
            var htmlIsFunction = isFunction(html);
            return this.each(function(i2) {
              jQuery2(this).wrapAll(htmlIsFunction ? html.call(this, i2) : html);
            });
          },
          unwrap: function(selector) {
            this.parent(selector).not("body").each(function() {
              jQuery2(this).replaceWith(this.childNodes);
            });
            return this;
          }
        });
        jQuery2.expr.pseudos.hidden = function(elem) {
          return !jQuery2.expr.pseudos.visible(elem);
        };
        jQuery2.expr.pseudos.visible = function(elem) {
          return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
        };
        jQuery2.ajaxSettings.xhr = function() {
          try {
            return new window2.XMLHttpRequest();
          } catch (e2) {
          }
        };
        var xhrSuccessStatus = {
          0: 200,
          1223: 204
        }, xhrSupported = jQuery2.ajaxSettings.xhr();
        support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
        support.ajax = xhrSupported = !!xhrSupported;
        jQuery2.ajaxTransport(function(options) {
          var callback, errorCallback;
          if (support.cors || xhrSupported && !options.crossDomain) {
            return {
              send: function(headers, complete) {
                var i2, xhr = options.xhr();
                xhr.open(options.type, options.url, options.async, options.username, options.password);
                if (options.xhrFields) {
                  for (i2 in options.xhrFields) {
                    xhr[i2] = options.xhrFields[i2];
                  }
                }
                if (options.mimeType && xhr.overrideMimeType) {
                  xhr.overrideMimeType(options.mimeType);
                }
                if (!options.crossDomain && !headers["X-Requested-With"]) {
                  headers["X-Requested-With"] = "XMLHttpRequest";
                }
                for (i2 in headers) {
                  xhr.setRequestHeader(i2, headers[i2]);
                }
                callback = function(type) {
                  return function() {
                    if (callback) {
                      callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                      if (type === "abort") {
                        xhr.abort();
                      } else if (type === "error") {
                        if (typeof xhr.status !== "number") {
                          complete(0, "error");
                        } else {
                          complete(xhr.status, xhr.statusText);
                        }
                      } else {
                        complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText }, xhr.getAllResponseHeaders());
                      }
                    }
                  };
                };
                xhr.onload = callback();
                errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
                if (xhr.onabort !== void 0) {
                  xhr.onabort = errorCallback;
                } else {
                  xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                      window2.setTimeout(function() {
                        if (callback) {
                          errorCallback();
                        }
                      });
                    }
                  };
                }
                callback = callback("abort");
                try {
                  xhr.send(options.hasContent && options.data || null);
                } catch (e2) {
                  if (callback) {
                    throw e2;
                  }
                }
              },
              abort: function() {
                if (callback) {
                  callback();
                }
              }
            };
          }
        });
        jQuery2.ajaxPrefilter(function(s2) {
          if (s2.crossDomain) {
            s2.contents.script = false;
          }
        });
        jQuery2.ajaxSetup({
          accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
          },
          contents: {
            script: /\b(?:java|ecma)script\b/
          },
          converters: {
            "text script": function(text) {
              jQuery2.globalEval(text);
              return text;
            }
          }
        });
        jQuery2.ajaxPrefilter("script", function(s2) {
          if (s2.cache === void 0) {
            s2.cache = false;
          }
          if (s2.crossDomain) {
            s2.type = "GET";
          }
        });
        jQuery2.ajaxTransport("script", function(s2) {
          if (s2.crossDomain || s2.scriptAttrs) {
            var script, callback;
            return {
              send: function(_2, complete) {
                script = jQuery2("<script>").attr(s2.scriptAttrs || {}).prop({ charset: s2.scriptCharset, src: s2.url }).on("load error", callback = function(evt) {
                  script.remove();
                  callback = null;
                  if (evt) {
                    complete(evt.type === "error" ? 404 : 200, evt.type);
                  }
                });
                document2.head.appendChild(script[0]);
              },
              abort: function() {
                if (callback) {
                  callback();
                }
              }
            };
          }
        });
        var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
        jQuery2.ajaxSetup({
          jsonp: "callback",
          jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery2.expando + "_" + nonce.guid++;
            this[callback] = true;
            return callback;
          }
        });
        jQuery2.ajaxPrefilter("json jsonp", function(s2, originalSettings, jqXHR) {
          var callbackName, overwritten, responseContainer, jsonProp = s2.jsonp !== false && (rjsonp.test(s2.url) ? "url" : typeof s2.data === "string" && (s2.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s2.data) && "data");
          if (jsonProp || s2.dataTypes[0] === "jsonp") {
            callbackName = s2.jsonpCallback = isFunction(s2.jsonpCallback) ? s2.jsonpCallback() : s2.jsonpCallback;
            if (jsonProp) {
              s2[jsonProp] = s2[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s2.jsonp !== false) {
              s2.url += (rquery.test(s2.url) ? "&" : "?") + s2.jsonp + "=" + callbackName;
            }
            s2.converters["script json"] = function() {
              if (!responseContainer) {
                jQuery2.error(callbackName + " was not called");
              }
              return responseContainer[0];
            };
            s2.dataTypes[0] = "json";
            overwritten = window2[callbackName];
            window2[callbackName] = function() {
              responseContainer = arguments;
            };
            jqXHR.always(function() {
              if (overwritten === void 0) {
                jQuery2(window2).removeProp(callbackName);
              } else {
                window2[callbackName] = overwritten;
              }
              if (s2[callbackName]) {
                s2.jsonpCallback = originalSettings.jsonpCallback;
                oldCallbacks.push(callbackName);
              }
              if (responseContainer && isFunction(overwritten)) {
                overwritten(responseContainer[0]);
              }
              responseContainer = overwritten = void 0;
            });
            return "script";
          }
        });
        support.createHTMLDocument = function() {
          var body = document2.implementation.createHTMLDocument("").body;
          body.innerHTML = "<form></form><form></form>";
          return body.childNodes.length === 2;
        }();
        jQuery2.parseHTML = function(data, context, keepScripts) {
          if (typeof data !== "string") {
            return [];
          }
          if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
          }
          var base, parsed, scripts;
          if (!context) {
            if (support.createHTMLDocument) {
              context = document2.implementation.createHTMLDocument("");
              base = context.createElement("base");
              base.href = document2.location.href;
              context.head.appendChild(base);
            } else {
              context = document2;
            }
          }
          parsed = rsingleTag.exec(data);
          scripts = !keepScripts && [];
          if (parsed) {
            return [context.createElement(parsed[1])];
          }
          parsed = buildFragment([data], context, scripts);
          if (scripts && scripts.length) {
            jQuery2(scripts).remove();
          }
          return jQuery2.merge([], parsed.childNodes);
        };
        jQuery2.fn.load = function(url, params, callback) {
          var selector, type, response, self2 = this, off = url.indexOf(" ");
          if (off > -1) {
            selector = stripAndCollapse(url.slice(off));
            url = url.slice(0, off);
          }
          if (isFunction(params)) {
            callback = params;
            params = void 0;
          } else if (params && typeof params === "object") {
            type = "POST";
          }
          if (self2.length > 0) {
            jQuery2.ajax({
              url,
              type: type || "GET",
              dataType: "html",
              data: params
            }).done(function(responseText) {
              response = arguments;
              self2.html(selector ? jQuery2("<div>").append(jQuery2.parseHTML(responseText)).find(selector) : responseText);
            }).always(callback && function(jqXHR, status) {
              self2.each(function() {
                callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
              });
            });
          }
          return this;
        };
        jQuery2.expr.pseudos.animated = function(elem) {
          return jQuery2.grep(jQuery2.timers, function(fn2) {
            return elem === fn2.elem;
          }).length;
        };
        jQuery2.offset = {
          setOffset: function(elem, options, i2) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery2.css(elem, "position"), curElem = jQuery2(elem), props = {};
            if (position === "static") {
              elem.style.position = "relative";
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery2.css(elem, "top");
            curCSSLeft = jQuery2.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            if (calculatePosition) {
              curPosition = curElem.position();
              curTop = curPosition.top;
              curLeft = curPosition.left;
            } else {
              curTop = parseFloat(curCSSTop) || 0;
              curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (isFunction(options)) {
              options = options.call(elem, i2, jQuery2.extend({}, curOffset));
            }
            if (options.top != null) {
              props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
              props.left = options.left - curOffset.left + curLeft;
            }
            if ("using" in options) {
              options.using.call(elem, props);
            } else {
              if (typeof props.top === "number") {
                props.top += "px";
              }
              if (typeof props.left === "number") {
                props.left += "px";
              }
              curElem.css(props);
            }
          }
        };
        jQuery2.fn.extend({
          offset: function(options) {
            if (arguments.length) {
              return options === void 0 ? this : this.each(function(i2) {
                jQuery2.offset.setOffset(this, options, i2);
              });
            }
            var rect, win, elem = this[0];
            if (!elem) {
              return;
            }
            if (!elem.getClientRects().length) {
              return { top: 0, left: 0 };
            }
            rect = elem.getBoundingClientRect();
            win = elem.ownerDocument.defaultView;
            return {
              top: rect.top + win.pageYOffset,
              left: rect.left + win.pageXOffset
            };
          },
          position: function() {
            if (!this[0]) {
              return;
            }
            var offsetParent, offset2, doc, elem = this[0], parentOffset = { top: 0, left: 0 };
            if (jQuery2.css(elem, "position") === "fixed") {
              offset2 = elem.getBoundingClientRect();
            } else {
              offset2 = this.offset();
              doc = elem.ownerDocument;
              offsetParent = elem.offsetParent || doc.documentElement;
              while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery2.css(offsetParent, "position") === "static") {
                offsetParent = offsetParent.parentNode;
              }
              if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
                parentOffset = jQuery2(offsetParent).offset();
                parentOffset.top += jQuery2.css(offsetParent, "borderTopWidth", true);
                parentOffset.left += jQuery2.css(offsetParent, "borderLeftWidth", true);
              }
            }
            return {
              top: offset2.top - parentOffset.top - jQuery2.css(elem, "marginTop", true),
              left: offset2.left - parentOffset.left - jQuery2.css(elem, "marginLeft", true)
            };
          },
          offsetParent: function() {
            return this.map(function() {
              var offsetParent = this.offsetParent;
              while (offsetParent && jQuery2.css(offsetParent, "position") === "static") {
                offsetParent = offsetParent.offsetParent;
              }
              return offsetParent || documentElement;
            });
          }
        });
        jQuery2.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
          var top2 = prop === "pageYOffset";
          jQuery2.fn[method] = function(val) {
            return access(this, function(elem, method2, val2) {
              var win;
              if (isWindow(elem)) {
                win = elem;
              } else if (elem.nodeType === 9) {
                win = elem.defaultView;
              }
              if (val2 === void 0) {
                return win ? win[prop] : elem[method2];
              }
              if (win) {
                win.scrollTo(!top2 ? val2 : win.pageXOffset, top2 ? val2 : win.pageYOffset);
              } else {
                elem[method2] = val2;
              }
            }, method, val, arguments.length);
          };
        });
        jQuery2.each(["top", "left"], function(_i, prop) {
          jQuery2.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
            if (computed) {
              computed = curCSS(elem, prop);
              return rnumnonpx.test(computed) ? jQuery2(elem).position()[prop] + "px" : computed;
            }
          });
        });
        jQuery2.each({ Height: "height", Width: "width" }, function(name, type) {
          jQuery2.each({ padding: "inner" + name, content: type, "": "outer" + name }, function(defaultExtra, funcName) {
            jQuery2.fn[funcName] = function(margin, value) {
              var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
              return access(this, function(elem, type2, value2) {
                var doc;
                if (isWindow(elem)) {
                  return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
                }
                if (elem.nodeType === 9) {
                  doc = elem.documentElement;
                  return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
                }
                return value2 === void 0 ? jQuery2.css(elem, type2, extra) : jQuery2.style(elem, type2, value2, extra);
              }, type, chainable ? margin : void 0, chainable);
            };
          });
        });
        jQuery2.each([
          "ajaxStart",
          "ajaxStop",
          "ajaxComplete",
          "ajaxError",
          "ajaxSuccess",
          "ajaxSend"
        ], function(_i, type) {
          jQuery2.fn[type] = function(fn2) {
            return this.on(type, fn2);
          };
        });
        jQuery2.fn.extend({
          bind: function(types, data, fn2) {
            return this.on(types, null, data, fn2);
          },
          unbind: function(types, fn2) {
            return this.off(types, null, fn2);
          },
          delegate: function(selector, types, data, fn2) {
            return this.on(types, selector, data, fn2);
          },
          undelegate: function(selector, types, fn2) {
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn2);
          },
          hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
          }
        });
        jQuery2.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(_i, name) {
          jQuery2.fn[name] = function(data, fn2) {
            return arguments.length > 0 ? this.on(name, null, data, fn2) : this.trigger(name);
          };
        });
        var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
        jQuery2.proxy = function(fn2, context) {
          var tmp, args, proxy;
          if (typeof context === "string") {
            tmp = fn2[context];
            context = fn2;
            fn2 = tmp;
          }
          if (!isFunction(fn2)) {
            return void 0;
          }
          args = slice.call(arguments, 2);
          proxy = function() {
            return fn2.apply(context || this, args.concat(slice.call(arguments)));
          };
          proxy.guid = fn2.guid = fn2.guid || jQuery2.guid++;
          return proxy;
        };
        jQuery2.holdReady = function(hold) {
          if (hold) {
            jQuery2.readyWait++;
          } else {
            jQuery2.ready(true);
          }
        };
        jQuery2.isArray = Array.isArray;
        jQuery2.parseJSON = JSON.parse;
        jQuery2.nodeName = nodeName;
        jQuery2.isFunction = isFunction;
        jQuery2.isWindow = isWindow;
        jQuery2.camelCase = camelCase;
        jQuery2.type = toType;
        jQuery2.now = Date.now;
        jQuery2.isNumeric = function(obj) {
          var type = jQuery2.type(obj);
          return (type === "number" || type === "string") && !isNaN(obj - parseFloat(obj));
        };
        jQuery2.trim = function(text) {
          return text == null ? "" : (text + "").replace(rtrim, "");
        };
        if (typeof define === "function" && define.amd) {
          define("jquery", [], function() {
            return jQuery2;
          });
        }
        var _jQuery = window2.jQuery, _$ = window2.$;
        jQuery2.noConflict = function(deep) {
          if (window2.$ === jQuery2) {
            window2.$ = _$;
          }
          if (deep && window2.jQuery === jQuery2) {
            window2.jQuery = _jQuery;
          }
          return jQuery2;
        };
        if (typeof noGlobal === "undefined") {
          window2.jQuery = window2.$ = jQuery2;
        }
        return jQuery2;
      });
    }
  });

  // node_modules/toastr/build/toastr.min.js
  var require_toastr_min = __commonJS({
    "node_modules/toastr/build/toastr.min.js"(exports, module) {
      !function(e2) {
        e2(["jquery"], function(e3) {
          return function() {
            function t2(e4, t3, n3) {
              return g2({ type: O.error, iconClass: m2().iconClasses.error, message: e4, optionsOverride: n3, title: t3 });
            }
            function n2(t3, n3) {
              return t3 || (t3 = m2()), v2 = e3("#" + t3.containerId), v2.length ? v2 : (n3 && (v2 = d2(t3)), v2);
            }
            function o2(e4, t3, n3) {
              return g2({ type: O.info, iconClass: m2().iconClasses.info, message: e4, optionsOverride: n3, title: t3 });
            }
            function s2(e4) {
              C2 = e4;
            }
            function i2(e4, t3, n3) {
              return g2({ type: O.success, iconClass: m2().iconClasses.success, message: e4, optionsOverride: n3, title: t3 });
            }
            function a2(e4, t3, n3) {
              return g2({ type: O.warning, iconClass: m2().iconClasses.warning, message: e4, optionsOverride: n3, title: t3 });
            }
            function r2(e4, t3) {
              var o3 = m2();
              v2 || n2(o3), u2(e4, o3, t3) || l2(o3);
            }
            function c2(t3) {
              var o3 = m2();
              return v2 || n2(o3), t3 && e3(":focus", t3).length === 0 ? void h(t3) : void (v2.children().length && v2.remove());
            }
            function l2(t3) {
              for (var n3 = v2.children(), o3 = n3.length - 1; o3 >= 0; o3--)
                u2(e3(n3[o3]), t3);
            }
            function u2(t3, n3, o3) {
              var s3 = !(!o3 || !o3.force) && o3.force;
              return !(!t3 || !s3 && e3(":focus", t3).length !== 0) && (t3[n3.hideMethod]({ duration: n3.hideDuration, easing: n3.hideEasing, complete: function() {
                h(t3);
              } }), true);
            }
            function d2(t3) {
              return v2 = e3("<div/>").attr("id", t3.containerId).addClass(t3.positionClass), v2.appendTo(e3(t3.target)), v2;
            }
            function p2() {
              return { tapToDismiss: true, toastClass: "toast", containerId: "toast-container", debug: false, showMethod: "fadeIn", showDuration: 300, showEasing: "swing", onShown: void 0, hideMethod: "fadeOut", hideDuration: 1e3, hideEasing: "swing", onHidden: void 0, closeMethod: false, closeDuration: false, closeEasing: false, closeOnHover: true, extendedTimeOut: 1e3, iconClasses: { error: "toast-error", info: "toast-info", success: "toast-success", warning: "toast-warning" }, iconClass: "toast-info", positionClass: "toast-top-right", timeOut: 5e3, titleClass: "toast-title", messageClass: "toast-message", escapeHtml: false, target: "body", closeHtml: '<button type="button">&times;</button>', closeClass: "toast-close-button", newestOnTop: true, preventDuplicates: false, progressBar: false, progressClass: "toast-progress", rtl: false };
            }
            function f2(e4) {
              C2 && C2(e4);
            }
            function g2(t3) {
              function o3(e4) {
                return e4 == null && (e4 = ""), e4.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
              }
              function s3() {
                c3(), u3(), d3(), p3(), g3(), C3(), l3(), i3();
              }
              function i3() {
                var e4 = "";
                switch (t3.iconClass) {
                  case "toast-success":
                  case "toast-info":
                    e4 = "polite";
                    break;
                  default:
                    e4 = "assertive";
                }
                I2.attr("aria-live", e4);
              }
              function a3() {
                E.closeOnHover && I2.hover(H2, D), !E.onclick && E.tapToDismiss && I2.click(b3), E.closeButton && j2 && j2.click(function(e4) {
                  e4.stopPropagation ? e4.stopPropagation() : e4.cancelBubble !== void 0 && e4.cancelBubble !== true && (e4.cancelBubble = true), E.onCloseClick && E.onCloseClick(e4), b3(true);
                }), E.onclick && I2.click(function(e4) {
                  E.onclick(e4), b3();
                });
              }
              function r3() {
                I2.hide(), I2[E.showMethod]({ duration: E.showDuration, easing: E.showEasing, complete: E.onShown }), E.timeOut > 0 && (k2 = setTimeout(b3, E.timeOut), F.maxHideTime = parseFloat(E.timeOut), F.hideEta = new Date().getTime() + F.maxHideTime, E.progressBar && (F.intervalId = setInterval(x2, 10)));
              }
              function c3() {
                t3.iconClass && I2.addClass(E.toastClass).addClass(y2);
              }
              function l3() {
                E.newestOnTop ? v2.prepend(I2) : v2.append(I2);
              }
              function u3() {
                if (t3.title) {
                  var e4 = t3.title;
                  E.escapeHtml && (e4 = o3(t3.title)), M2.append(e4).addClass(E.titleClass), I2.append(M2);
                }
              }
              function d3() {
                if (t3.message) {
                  var e4 = t3.message;
                  E.escapeHtml && (e4 = o3(t3.message)), B.append(e4).addClass(E.messageClass), I2.append(B);
                }
              }
              function p3() {
                E.closeButton && (j2.addClass(E.closeClass).attr("role", "button"), I2.prepend(j2));
              }
              function g3() {
                E.progressBar && (q.addClass(E.progressClass), I2.prepend(q));
              }
              function C3() {
                E.rtl && I2.addClass("rtl");
              }
              function O2(e4, t4) {
                if (e4.preventDuplicates) {
                  if (t4.message === w)
                    return true;
                  w = t4.message;
                }
                return false;
              }
              function b3(t4) {
                var n3 = t4 && E.closeMethod !== false ? E.closeMethod : E.hideMethod, o4 = t4 && E.closeDuration !== false ? E.closeDuration : E.hideDuration, s4 = t4 && E.closeEasing !== false ? E.closeEasing : E.hideEasing;
                if (!e3(":focus", I2).length || t4)
                  return clearTimeout(F.intervalId), I2[n3]({ duration: o4, easing: s4, complete: function() {
                    h(I2), clearTimeout(k2), E.onHidden && P2.state !== "hidden" && E.onHidden(), P2.state = "hidden", P2.endTime = new Date(), f2(P2);
                  } });
              }
              function D() {
                (E.timeOut > 0 || E.extendedTimeOut > 0) && (k2 = setTimeout(b3, E.extendedTimeOut), F.maxHideTime = parseFloat(E.extendedTimeOut), F.hideEta = new Date().getTime() + F.maxHideTime);
              }
              function H2() {
                clearTimeout(k2), F.hideEta = 0, I2.stop(true, true)[E.showMethod]({ duration: E.showDuration, easing: E.showEasing });
              }
              function x2() {
                var e4 = (F.hideEta - new Date().getTime()) / F.maxHideTime * 100;
                q.width(e4 + "%");
              }
              var E = m2(), y2 = t3.iconClass || E.iconClass;
              if (typeof t3.optionsOverride != "undefined" && (E = e3.extend(E, t3.optionsOverride), y2 = t3.optionsOverride.iconClass || y2), !O2(E, t3)) {
                T2++, v2 = n2(E, true);
                var k2 = null, I2 = e3("<div/>"), M2 = e3("<div/>"), B = e3("<div/>"), q = e3("<div/>"), j2 = e3(E.closeHtml), F = { intervalId: null, hideEta: null, maxHideTime: null }, P2 = { toastId: T2, state: "visible", startTime: new Date(), options: E, map: t3 };
                return s3(), r3(), a3(), f2(P2), E.debug && console && console.log(P2), I2;
              }
            }
            function m2() {
              return e3.extend({}, p2(), b2.options);
            }
            function h(e4) {
              v2 || (v2 = n2()), e4.is(":visible") || (e4.remove(), e4 = null, v2.children().length === 0 && (v2.remove(), w = void 0));
            }
            var v2, C2, w, T2 = 0, O = { error: "error", info: "info", success: "success", warning: "warning" }, b2 = { clear: r2, remove: c2, error: t2, getContainer: n2, info: o2, options: {}, subscribe: s2, success: i2, version: "2.1.4", warning: a2 };
            return b2;
          }();
        });
      }(typeof define == "function" && define.amd ? define : function(e2, t2) {
        typeof module != "undefined" && module.exports ? module.exports = t2(require_jquery()) : window.toastr = t2(window.jQuery);
      });
    }
  });

  // app/javascript/avo.js
  var import_stable = __toESM(require_stable());
  var import_runtime = __toESM(require_runtime());
  var ActiveStorage = __toESM(require_activestorage());
  var Mousetrap2 = __toESM(require_mousetrap());

  // node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js
  var turbo_es2017_esm_exports = {};
  __export(turbo_es2017_esm_exports, {
    PageRenderer: () => PageRenderer,
    PageSnapshot: () => PageSnapshot,
    clearCache: () => clearCache,
    connectStreamSource: () => connectStreamSource,
    disconnectStreamSource: () => disconnectStreamSource,
    navigator: () => navigator$1,
    registerAdapter: () => registerAdapter,
    renderStreamMessage: () => renderStreamMessage,
    session: () => session,
    setConfirmMethod: () => setConfirmMethod,
    setProgressBarDelay: () => setProgressBarDelay,
    start: () => start,
    visit: () => visit
  });
  (function() {
    if (window.Reflect === void 0 || window.customElements === void 0 || window.customElements.polyfillWrapFlushCallback) {
      return;
    }
    const BuiltInHTMLElement = HTMLElement;
    const wrapperForTheName = {
      "HTMLElement": function HTMLElement2() {
        return Reflect.construct(BuiltInHTMLElement, [], this.constructor);
      }
    };
    window.HTMLElement = wrapperForTheName["HTMLElement"];
    HTMLElement.prototype = BuiltInHTMLElement.prototype;
    HTMLElement.prototype.constructor = HTMLElement;
    Object.setPrototypeOf(HTMLElement, BuiltInHTMLElement);
  })();
  (function(prototype) {
    if (typeof prototype.requestSubmit == "function")
      return;
    prototype.requestSubmit = function(submitter) {
      if (submitter) {
        validateSubmitter(submitter, this);
        submitter.click();
      } else {
        submitter = document.createElement("input");
        submitter.type = "submit";
        submitter.hidden = true;
        this.appendChild(submitter);
        submitter.click();
        this.removeChild(submitter);
      }
    };
    function validateSubmitter(submitter, form) {
      submitter instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
      submitter.type == "submit" || raise(TypeError, "The specified element is not a submit button");
      submitter.form == form || raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
    }
    function raise(errorConstructor, message, name) {
      throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name);
    }
  })(HTMLFormElement.prototype);
  var submittersByForm = /* @__PURE__ */ new WeakMap();
  function findSubmitterFromClickTarget(target) {
    const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
    const candidate = element ? element.closest("input, button") : null;
    return (candidate === null || candidate === void 0 ? void 0 : candidate.type) == "submit" ? candidate : null;
  }
  function clickCaptured(event) {
    const submitter = findSubmitterFromClickTarget(event.target);
    if (submitter && submitter.form) {
      submittersByForm.set(submitter.form, submitter);
    }
  }
  (function() {
    if ("submitter" in Event.prototype)
      return;
    let prototype;
    if ("SubmitEvent" in window && /Apple Computer/.test(navigator.vendor)) {
      prototype = window.SubmitEvent.prototype;
    } else if ("SubmitEvent" in window) {
      return;
    } else {
      prototype = window.Event.prototype;
    }
    addEventListener("click", clickCaptured, true);
    Object.defineProperty(prototype, "submitter", {
      get() {
        if (this.type == "submit" && this.target instanceof HTMLFormElement) {
          return submittersByForm.get(this.target);
        }
      }
    });
  })();
  var FrameLoadingStyle;
  (function(FrameLoadingStyle2) {
    FrameLoadingStyle2["eager"] = "eager";
    FrameLoadingStyle2["lazy"] = "lazy";
  })(FrameLoadingStyle || (FrameLoadingStyle = {}));
  var FrameElement = class extends HTMLElement {
    constructor() {
      super();
      this.loaded = Promise.resolve();
      this.delegate = new FrameElement.delegateConstructor(this);
    }
    static get observedAttributes() {
      return ["disabled", "loading", "src"];
    }
    connectedCallback() {
      this.delegate.connect();
    }
    disconnectedCallback() {
      this.delegate.disconnect();
    }
    reload() {
      const { src } = this;
      this.src = null;
      this.src = src;
    }
    attributeChangedCallback(name) {
      if (name == "loading") {
        this.delegate.loadingStyleChanged();
      } else if (name == "src") {
        this.delegate.sourceURLChanged();
      } else {
        this.delegate.disabledChanged();
      }
    }
    get src() {
      return this.getAttribute("src");
    }
    set src(value) {
      if (value) {
        this.setAttribute("src", value);
      } else {
        this.removeAttribute("src");
      }
    }
    get loading() {
      return frameLoadingStyleFromString(this.getAttribute("loading") || "");
    }
    set loading(value) {
      if (value) {
        this.setAttribute("loading", value);
      } else {
        this.removeAttribute("loading");
      }
    }
    get disabled() {
      return this.hasAttribute("disabled");
    }
    set disabled(value) {
      if (value) {
        this.setAttribute("disabled", "");
      } else {
        this.removeAttribute("disabled");
      }
    }
    get autoscroll() {
      return this.hasAttribute("autoscroll");
    }
    set autoscroll(value) {
      if (value) {
        this.setAttribute("autoscroll", "");
      } else {
        this.removeAttribute("autoscroll");
      }
    }
    get complete() {
      return !this.delegate.isLoading;
    }
    get isActive() {
      return this.ownerDocument === document && !this.isPreview;
    }
    get isPreview() {
      var _a, _b;
      return (_b = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.documentElement) === null || _b === void 0 ? void 0 : _b.hasAttribute("data-turbo-preview");
    }
  };
  function frameLoadingStyleFromString(style) {
    switch (style.toLowerCase()) {
      case "lazy":
        return FrameLoadingStyle.lazy;
      default:
        return FrameLoadingStyle.eager;
    }
  }
  function expandURL(locatable) {
    return new URL(locatable.toString(), document.baseURI);
  }
  function getAnchor(url) {
    let anchorMatch;
    if (url.hash) {
      return url.hash.slice(1);
    } else if (anchorMatch = url.href.match(/#(.*)$/)) {
      return anchorMatch[1];
    }
  }
  function getAction(form, submitter) {
    const action = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formaction")) || form.getAttribute("action") || form.action;
    return expandURL(action);
  }
  function getExtension(url) {
    return (getLastPathComponent(url).match(/\.[^.]*$/) || [])[0] || "";
  }
  function isHTML(url) {
    return !!getExtension(url).match(/^(?:|\.(?:htm|html|xhtml))$/);
  }
  function isPrefixedBy(baseURL, url) {
    const prefix = getPrefix(url);
    return baseURL.href === expandURL(prefix).href || baseURL.href.startsWith(prefix);
  }
  function locationIsVisitable(location2, rootLocation) {
    return isPrefixedBy(location2, rootLocation) && isHTML(location2);
  }
  function getRequestURL(url) {
    const anchor = getAnchor(url);
    return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href;
  }
  function toCacheKey(url) {
    return getRequestURL(url);
  }
  function urlsAreEqual(left2, right2) {
    return expandURL(left2).href == expandURL(right2).href;
  }
  function getPathComponents(url) {
    return url.pathname.split("/").slice(1);
  }
  function getLastPathComponent(url) {
    return getPathComponents(url).slice(-1)[0];
  }
  function getPrefix(url) {
    return addTrailingSlash(url.origin + url.pathname);
  }
  function addTrailingSlash(value) {
    return value.endsWith("/") ? value : value + "/";
  }
  var FetchResponse = class {
    constructor(response) {
      this.response = response;
    }
    get succeeded() {
      return this.response.ok;
    }
    get failed() {
      return !this.succeeded;
    }
    get clientError() {
      return this.statusCode >= 400 && this.statusCode <= 499;
    }
    get serverError() {
      return this.statusCode >= 500 && this.statusCode <= 599;
    }
    get redirected() {
      return this.response.redirected;
    }
    get location() {
      return expandURL(this.response.url);
    }
    get isHTML() {
      return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/);
    }
    get statusCode() {
      return this.response.status;
    }
    get contentType() {
      return this.header("Content-Type");
    }
    get responseText() {
      return this.response.clone().text();
    }
    get responseHTML() {
      if (this.isHTML) {
        return this.response.clone().text();
      } else {
        return Promise.resolve(void 0);
      }
    }
    header(name) {
      return this.response.headers.get(name);
    }
  };
  function dispatch(eventName, { target, cancelable, detail } = {}) {
    const event = new CustomEvent(eventName, { cancelable, bubbles: true, detail });
    if (target && target.isConnected) {
      target.dispatchEvent(event);
    } else {
      document.documentElement.dispatchEvent(event);
    }
    return event;
  }
  function nextAnimationFrame() {
    return new Promise((resolve2) => requestAnimationFrame(() => resolve2()));
  }
  function nextEventLoopTick() {
    return new Promise((resolve2) => setTimeout(() => resolve2(), 0));
  }
  function nextMicrotask() {
    return Promise.resolve();
  }
  function parseHTMLDocument(html = "") {
    return new DOMParser().parseFromString(html, "text/html");
  }
  function unindent(strings, ...values) {
    const lines = interpolate(strings, values).replace(/^\n/, "").split("\n");
    const match = lines[0].match(/^\s+/);
    const indent = match ? match[0].length : 0;
    return lines.map((line) => line.slice(indent)).join("\n");
  }
  function interpolate(strings, values) {
    return strings.reduce((result, string, i2) => {
      const value = values[i2] == void 0 ? "" : values[i2];
      return result + string + value;
    }, "");
  }
  function uuid() {
    return Array.apply(null, { length: 36 }).map((_2, i2) => {
      if (i2 == 8 || i2 == 13 || i2 == 18 || i2 == 23) {
        return "-";
      } else if (i2 == 14) {
        return "4";
      } else if (i2 == 19) {
        return (Math.floor(Math.random() * 4) + 8).toString(16);
      } else {
        return Math.floor(Math.random() * 15).toString(16);
      }
    }).join("");
  }
  function getAttribute(attributeName, ...elements) {
    for (const value of elements.map((element) => element === null || element === void 0 ? void 0 : element.getAttribute(attributeName))) {
      if (typeof value == "string")
        return value;
    }
    return null;
  }
  function markAsBusy(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.setAttribute("busy", "");
      }
      element.setAttribute("aria-busy", "true");
    }
  }
  function clearBusyState(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.removeAttribute("busy");
      }
      element.removeAttribute("aria-busy");
    }
  }
  var FetchMethod;
  (function(FetchMethod2) {
    FetchMethod2[FetchMethod2["get"] = 0] = "get";
    FetchMethod2[FetchMethod2["post"] = 1] = "post";
    FetchMethod2[FetchMethod2["put"] = 2] = "put";
    FetchMethod2[FetchMethod2["patch"] = 3] = "patch";
    FetchMethod2[FetchMethod2["delete"] = 4] = "delete";
  })(FetchMethod || (FetchMethod = {}));
  function fetchMethodFromString(method) {
    switch (method.toLowerCase()) {
      case "get":
        return FetchMethod.get;
      case "post":
        return FetchMethod.post;
      case "put":
        return FetchMethod.put;
      case "patch":
        return FetchMethod.patch;
      case "delete":
        return FetchMethod.delete;
    }
  }
  var FetchRequest = class {
    constructor(delegate, method, location2, body = new URLSearchParams(), target = null) {
      this.abortController = new AbortController();
      this.resolveRequestPromise = (value) => {
      };
      this.delegate = delegate;
      this.method = method;
      this.headers = this.defaultHeaders;
      this.body = body;
      this.url = location2;
      this.target = target;
    }
    get location() {
      return this.url;
    }
    get params() {
      return this.url.searchParams;
    }
    get entries() {
      return this.body ? Array.from(this.body.entries()) : [];
    }
    cancel() {
      this.abortController.abort();
    }
    async perform() {
      var _a, _b;
      const { fetchOptions } = this;
      (_b = (_a = this.delegate).prepareHeadersForRequest) === null || _b === void 0 ? void 0 : _b.call(_a, this.headers, this);
      await this.allowRequestToBeIntercepted(fetchOptions);
      try {
        this.delegate.requestStarted(this);
        const response = await fetch(this.url.href, fetchOptions);
        return await this.receive(response);
      } catch (error2) {
        if (error2.name !== "AbortError") {
          this.delegate.requestErrored(this, error2);
          throw error2;
        }
      } finally {
        this.delegate.requestFinished(this);
      }
    }
    async receive(response) {
      const fetchResponse = new FetchResponse(response);
      const event = dispatch("turbo:before-fetch-response", { cancelable: true, detail: { fetchResponse }, target: this.target });
      if (event.defaultPrevented) {
        this.delegate.requestPreventedHandlingResponse(this, fetchResponse);
      } else if (fetchResponse.succeeded) {
        this.delegate.requestSucceededWithResponse(this, fetchResponse);
      } else {
        this.delegate.requestFailedWithResponse(this, fetchResponse);
      }
      return fetchResponse;
    }
    get fetchOptions() {
      var _a;
      return {
        method: FetchMethod[this.method].toUpperCase(),
        credentials: "same-origin",
        headers: this.headers,
        redirect: "follow",
        body: this.isIdempotent ? null : this.body,
        signal: this.abortSignal,
        referrer: (_a = this.delegate.referrer) === null || _a === void 0 ? void 0 : _a.href
      };
    }
    get defaultHeaders() {
      return {
        "Accept": "text/html, application/xhtml+xml"
      };
    }
    get isIdempotent() {
      return this.method == FetchMethod.get;
    }
    get abortSignal() {
      return this.abortController.signal;
    }
    async allowRequestToBeIntercepted(fetchOptions) {
      const requestInterception = new Promise((resolve2) => this.resolveRequestPromise = resolve2);
      const event = dispatch("turbo:before-fetch-request", {
        cancelable: true,
        detail: {
          fetchOptions,
          url: this.url,
          resume: this.resolveRequestPromise
        },
        target: this.target
      });
      if (event.defaultPrevented)
        await requestInterception;
    }
  };
  var AppearanceObserver = class {
    constructor(delegate, element) {
      this.started = false;
      this.intersect = (entries) => {
        const lastEntry = entries.slice(-1)[0];
        if (lastEntry === null || lastEntry === void 0 ? void 0 : lastEntry.isIntersecting) {
          this.delegate.elementAppearedInViewport(this.element);
        }
      };
      this.delegate = delegate;
      this.element = element;
      this.intersectionObserver = new IntersectionObserver(this.intersect);
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.intersectionObserver.observe(this.element);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.intersectionObserver.unobserve(this.element);
      }
    }
  };
  var StreamMessage = class {
    constructor(html) {
      this.templateElement = document.createElement("template");
      this.templateElement.innerHTML = html;
    }
    static wrap(message) {
      if (typeof message == "string") {
        return new this(message);
      } else {
        return message;
      }
    }
    get fragment() {
      const fragment = document.createDocumentFragment();
      for (const element of this.foreignElements) {
        fragment.appendChild(document.importNode(element, true));
      }
      return fragment;
    }
    get foreignElements() {
      return this.templateChildren.reduce((streamElements, child) => {
        if (child.tagName.toLowerCase() == "turbo-stream") {
          return [...streamElements, child];
        } else {
          return streamElements;
        }
      }, []);
    }
    get templateChildren() {
      return Array.from(this.templateElement.content.children);
    }
  };
  StreamMessage.contentType = "text/vnd.turbo-stream.html";
  var FormSubmissionState;
  (function(FormSubmissionState2) {
    FormSubmissionState2[FormSubmissionState2["initialized"] = 0] = "initialized";
    FormSubmissionState2[FormSubmissionState2["requesting"] = 1] = "requesting";
    FormSubmissionState2[FormSubmissionState2["waiting"] = 2] = "waiting";
    FormSubmissionState2[FormSubmissionState2["receiving"] = 3] = "receiving";
    FormSubmissionState2[FormSubmissionState2["stopping"] = 4] = "stopping";
    FormSubmissionState2[FormSubmissionState2["stopped"] = 5] = "stopped";
  })(FormSubmissionState || (FormSubmissionState = {}));
  var FormEnctype;
  (function(FormEnctype2) {
    FormEnctype2["urlEncoded"] = "application/x-www-form-urlencoded";
    FormEnctype2["multipart"] = "multipart/form-data";
    FormEnctype2["plain"] = "text/plain";
  })(FormEnctype || (FormEnctype = {}));
  function formEnctypeFromString(encoding) {
    switch (encoding.toLowerCase()) {
      case FormEnctype.multipart:
        return FormEnctype.multipart;
      case FormEnctype.plain:
        return FormEnctype.plain;
      default:
        return FormEnctype.urlEncoded;
    }
  }
  var FormSubmission = class {
    constructor(delegate, formElement, submitter, mustRedirect = false) {
      this.state = FormSubmissionState.initialized;
      this.delegate = delegate;
      this.formElement = formElement;
      this.submitter = submitter;
      this.formData = buildFormData(formElement, submitter);
      this.location = expandURL(this.action);
      if (this.method == FetchMethod.get) {
        mergeFormDataEntries(this.location, [...this.body.entries()]);
      }
      this.fetchRequest = new FetchRequest(this, this.method, this.location, this.body, this.formElement);
      this.mustRedirect = mustRedirect;
    }
    static confirmMethod(message, element) {
      return confirm(message);
    }
    get method() {
      var _a;
      const method = ((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute("formmethod")) || this.formElement.getAttribute("method") || "";
      return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;
    }
    get action() {
      var _a;
      const formElementAction = typeof this.formElement.action === "string" ? this.formElement.action : null;
      return ((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute("formaction")) || this.formElement.getAttribute("action") || formElementAction || "";
    }
    get body() {
      if (this.enctype == FormEnctype.urlEncoded || this.method == FetchMethod.get) {
        return new URLSearchParams(this.stringFormData);
      } else {
        return this.formData;
      }
    }
    get enctype() {
      var _a;
      return formEnctypeFromString(((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute("formenctype")) || this.formElement.enctype);
    }
    get isIdempotent() {
      return this.fetchRequest.isIdempotent;
    }
    get stringFormData() {
      return [...this.formData].reduce((entries, [name, value]) => {
        return entries.concat(typeof value == "string" ? [[name, value]] : []);
      }, []);
    }
    get confirmationMessage() {
      return this.formElement.getAttribute("data-turbo-confirm");
    }
    get needsConfirmation() {
      return this.confirmationMessage !== null;
    }
    async start() {
      const { initialized, requesting } = FormSubmissionState;
      if (this.needsConfirmation) {
        const answer = FormSubmission.confirmMethod(this.confirmationMessage, this.formElement);
        if (!answer) {
          return;
        }
      }
      if (this.state == initialized) {
        this.state = requesting;
        return this.fetchRequest.perform();
      }
    }
    stop() {
      const { stopping, stopped } = FormSubmissionState;
      if (this.state != stopping && this.state != stopped) {
        this.state = stopping;
        this.fetchRequest.cancel();
        return true;
      }
    }
    prepareHeadersForRequest(headers, request) {
      if (!request.isIdempotent) {
        const token = getCookieValue(getMetaContent("csrf-param")) || getMetaContent("csrf-token");
        if (token) {
          headers["X-CSRF-Token"] = token;
        }
        headers["Accept"] = [StreamMessage.contentType, headers["Accept"]].join(", ");
      }
    }
    requestStarted(request) {
      var _a;
      this.state = FormSubmissionState.waiting;
      (_a = this.submitter) === null || _a === void 0 ? void 0 : _a.setAttribute("disabled", "");
      dispatch("turbo:submit-start", { target: this.formElement, detail: { formSubmission: this } });
      this.delegate.formSubmissionStarted(this);
    }
    requestPreventedHandlingResponse(request, response) {
      this.result = { success: response.succeeded, fetchResponse: response };
    }
    requestSucceededWithResponse(request, response) {
      if (response.clientError || response.serverError) {
        this.delegate.formSubmissionFailedWithResponse(this, response);
      } else if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {
        const error2 = new Error("Form responses must redirect to another location");
        this.delegate.formSubmissionErrored(this, error2);
      } else {
        this.state = FormSubmissionState.receiving;
        this.result = { success: true, fetchResponse: response };
        this.delegate.formSubmissionSucceededWithResponse(this, response);
      }
    }
    requestFailedWithResponse(request, response) {
      this.result = { success: false, fetchResponse: response };
      this.delegate.formSubmissionFailedWithResponse(this, response);
    }
    requestErrored(request, error2) {
      this.result = { success: false, error: error2 };
      this.delegate.formSubmissionErrored(this, error2);
    }
    requestFinished(request) {
      var _a;
      this.state = FormSubmissionState.stopped;
      (_a = this.submitter) === null || _a === void 0 ? void 0 : _a.removeAttribute("disabled");
      dispatch("turbo:submit-end", { target: this.formElement, detail: Object.assign({ formSubmission: this }, this.result) });
      this.delegate.formSubmissionFinished(this);
    }
    requestMustRedirect(request) {
      return !request.isIdempotent && this.mustRedirect;
    }
  };
  function buildFormData(formElement, submitter) {
    const formData = new FormData(formElement);
    const name = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("name");
    const value = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("value");
    if (name && value != null && formData.get(name) != value) {
      formData.append(name, value);
    }
    return formData;
  }
  function getCookieValue(cookieName) {
    if (cookieName != null) {
      const cookies = document.cookie ? document.cookie.split("; ") : [];
      const cookie = cookies.find((cookie2) => cookie2.startsWith(cookieName));
      if (cookie) {
        const value = cookie.split("=").slice(1).join("=");
        return value ? decodeURIComponent(value) : void 0;
      }
    }
  }
  function getMetaContent(name) {
    const element = document.querySelector(`meta[name="${name}"]`);
    return element && element.content;
  }
  function responseSucceededWithoutRedirect(response) {
    return response.statusCode == 200 && !response.redirected;
  }
  function mergeFormDataEntries(url, entries) {
    const searchParams = new URLSearchParams();
    for (const [name, value] of entries) {
      if (value instanceof File)
        continue;
      searchParams.append(name, value);
    }
    url.search = searchParams.toString();
    return url;
  }
  var Snapshot = class {
    constructor(element) {
      this.element = element;
    }
    get children() {
      return [...this.element.children];
    }
    hasAnchor(anchor) {
      return this.getElementForAnchor(anchor) != null;
    }
    getElementForAnchor(anchor) {
      return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null;
    }
    get isConnected() {
      return this.element.isConnected;
    }
    get firstAutofocusableElement() {
      return this.element.querySelector("[autofocus]");
    }
    get permanentElements() {
      return [...this.element.querySelectorAll("[id][data-turbo-permanent]")];
    }
    getPermanentElementById(id) {
      return this.element.querySelector(`#${id}[data-turbo-permanent]`);
    }
    getPermanentElementMapForSnapshot(snapshot) {
      const permanentElementMap = {};
      for (const currentPermanentElement of this.permanentElements) {
        const { id } = currentPermanentElement;
        const newPermanentElement = snapshot.getPermanentElementById(id);
        if (newPermanentElement) {
          permanentElementMap[id] = [currentPermanentElement, newPermanentElement];
        }
      }
      return permanentElementMap;
    }
  };
  var FormInterceptor = class {
    constructor(delegate, element) {
      this.submitBubbled = (event) => {
        const form = event.target;
        if (!event.defaultPrevented && form instanceof HTMLFormElement && form.closest("turbo-frame, html") == this.element) {
          const submitter = event.submitter || void 0;
          const method = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formmethod")) || form.method;
          if (method != "dialog" && this.delegate.shouldInterceptFormSubmission(form, submitter)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            this.delegate.formSubmissionIntercepted(form, submitter);
          }
        }
      };
      this.delegate = delegate;
      this.element = element;
    }
    start() {
      this.element.addEventListener("submit", this.submitBubbled);
    }
    stop() {
      this.element.removeEventListener("submit", this.submitBubbled);
    }
  };
  var View = class {
    constructor(delegate, element) {
      this.resolveRenderPromise = (value) => {
      };
      this.resolveInterceptionPromise = (value) => {
      };
      this.delegate = delegate;
      this.element = element;
    }
    scrollToAnchor(anchor) {
      const element = this.snapshot.getElementForAnchor(anchor);
      if (element) {
        this.scrollToElement(element);
        this.focusElement(element);
      } else {
        this.scrollToPosition({ x: 0, y: 0 });
      }
    }
    scrollToAnchorFromLocation(location2) {
      this.scrollToAnchor(getAnchor(location2));
    }
    scrollToElement(element) {
      element.scrollIntoView();
    }
    focusElement(element) {
      if (element instanceof HTMLElement) {
        if (element.hasAttribute("tabindex")) {
          element.focus();
        } else {
          element.setAttribute("tabindex", "-1");
          element.focus();
          element.removeAttribute("tabindex");
        }
      }
    }
    scrollToPosition({ x: x2, y: y2 }) {
      this.scrollRoot.scrollTo(x2, y2);
    }
    scrollToTop() {
      this.scrollToPosition({ x: 0, y: 0 });
    }
    get scrollRoot() {
      return window;
    }
    async render(renderer) {
      const { isPreview, shouldRender, newSnapshot: snapshot } = renderer;
      if (shouldRender) {
        try {
          this.renderPromise = new Promise((resolve2) => this.resolveRenderPromise = resolve2);
          this.renderer = renderer;
          this.prepareToRenderSnapshot(renderer);
          const renderInterception = new Promise((resolve2) => this.resolveInterceptionPromise = resolve2);
          const immediateRender = this.delegate.allowsImmediateRender(snapshot, this.resolveInterceptionPromise);
          if (!immediateRender)
            await renderInterception;
          await this.renderSnapshot(renderer);
          this.delegate.viewRenderedSnapshot(snapshot, isPreview);
          this.finishRenderingSnapshot(renderer);
        } finally {
          delete this.renderer;
          this.resolveRenderPromise(void 0);
          delete this.renderPromise;
        }
      } else {
        this.invalidate();
      }
    }
    invalidate() {
      this.delegate.viewInvalidated();
    }
    prepareToRenderSnapshot(renderer) {
      this.markAsPreview(renderer.isPreview);
      renderer.prepareToRender();
    }
    markAsPreview(isPreview) {
      if (isPreview) {
        this.element.setAttribute("data-turbo-preview", "");
      } else {
        this.element.removeAttribute("data-turbo-preview");
      }
    }
    async renderSnapshot(renderer) {
      await renderer.render();
    }
    finishRenderingSnapshot(renderer) {
      renderer.finishRendering();
    }
  };
  var FrameView = class extends View {
    invalidate() {
      this.element.innerHTML = "";
    }
    get snapshot() {
      return new Snapshot(this.element);
    }
  };
  var LinkInterceptor = class {
    constructor(delegate, element) {
      this.clickBubbled = (event) => {
        if (this.respondsToEventTarget(event.target)) {
          this.clickEvent = event;
        } else {
          delete this.clickEvent;
        }
      };
      this.linkClicked = (event) => {
        if (this.clickEvent && this.respondsToEventTarget(event.target) && event.target instanceof Element) {
          if (this.delegate.shouldInterceptLinkClick(event.target, event.detail.url)) {
            this.clickEvent.preventDefault();
            event.preventDefault();
            this.delegate.linkClickIntercepted(event.target, event.detail.url);
          }
        }
        delete this.clickEvent;
      };
      this.willVisit = () => {
        delete this.clickEvent;
      };
      this.delegate = delegate;
      this.element = element;
    }
    start() {
      this.element.addEventListener("click", this.clickBubbled);
      document.addEventListener("turbo:click", this.linkClicked);
      document.addEventListener("turbo:before-visit", this.willVisit);
    }
    stop() {
      this.element.removeEventListener("click", this.clickBubbled);
      document.removeEventListener("turbo:click", this.linkClicked);
      document.removeEventListener("turbo:before-visit", this.willVisit);
    }
    respondsToEventTarget(target) {
      const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
      return element && element.closest("turbo-frame, html") == this.element;
    }
  };
  var Bardo = class {
    constructor(permanentElementMap) {
      this.permanentElementMap = permanentElementMap;
    }
    static preservingPermanentElements(permanentElementMap, callback) {
      const bardo = new this(permanentElementMap);
      bardo.enter();
      callback();
      bardo.leave();
    }
    enter() {
      for (const id in this.permanentElementMap) {
        const [, newPermanentElement] = this.permanentElementMap[id];
        this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);
      }
    }
    leave() {
      for (const id in this.permanentElementMap) {
        const [currentPermanentElement] = this.permanentElementMap[id];
        this.replaceCurrentPermanentElementWithClone(currentPermanentElement);
        this.replacePlaceholderWithPermanentElement(currentPermanentElement);
      }
    }
    replaceNewPermanentElementWithPlaceholder(permanentElement) {
      const placeholder = createPlaceholderForPermanentElement(permanentElement);
      permanentElement.replaceWith(placeholder);
    }
    replaceCurrentPermanentElementWithClone(permanentElement) {
      const clone = permanentElement.cloneNode(true);
      permanentElement.replaceWith(clone);
    }
    replacePlaceholderWithPermanentElement(permanentElement) {
      const placeholder = this.getPlaceholderById(permanentElement.id);
      placeholder === null || placeholder === void 0 ? void 0 : placeholder.replaceWith(permanentElement);
    }
    getPlaceholderById(id) {
      return this.placeholders.find((element) => element.content == id);
    }
    get placeholders() {
      return [...document.querySelectorAll("meta[name=turbo-permanent-placeholder][content]")];
    }
  };
  function createPlaceholderForPermanentElement(permanentElement) {
    const element = document.createElement("meta");
    element.setAttribute("name", "turbo-permanent-placeholder");
    element.setAttribute("content", permanentElement.id);
    return element;
  }
  var Renderer = class {
    constructor(currentSnapshot, newSnapshot, isPreview, willRender = true) {
      this.currentSnapshot = currentSnapshot;
      this.newSnapshot = newSnapshot;
      this.isPreview = isPreview;
      this.willRender = willRender;
      this.promise = new Promise((resolve2, reject) => this.resolvingFunctions = { resolve: resolve2, reject });
    }
    get shouldRender() {
      return true;
    }
    prepareToRender() {
      return;
    }
    finishRendering() {
      if (this.resolvingFunctions) {
        this.resolvingFunctions.resolve();
        delete this.resolvingFunctions;
      }
    }
    createScriptElement(element) {
      if (element.getAttribute("data-turbo-eval") == "false") {
        return element;
      } else {
        const createdScriptElement = document.createElement("script");
        if (this.cspNonce) {
          createdScriptElement.nonce = this.cspNonce;
        }
        createdScriptElement.textContent = element.textContent;
        createdScriptElement.async = false;
        copyElementAttributes(createdScriptElement, element);
        return createdScriptElement;
      }
    }
    preservingPermanentElements(callback) {
      Bardo.preservingPermanentElements(this.permanentElementMap, callback);
    }
    focusFirstAutofocusableElement() {
      const element = this.connectedSnapshot.firstAutofocusableElement;
      if (elementIsFocusable(element)) {
        element.focus();
      }
    }
    get connectedSnapshot() {
      return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;
    }
    get currentElement() {
      return this.currentSnapshot.element;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    get permanentElementMap() {
      return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);
    }
    get cspNonce() {
      var _a;
      return (_a = document.head.querySelector('meta[name="csp-nonce"]')) === null || _a === void 0 ? void 0 : _a.getAttribute("content");
    }
  };
  function copyElementAttributes(destinationElement, sourceElement) {
    for (const { name, value } of [...sourceElement.attributes]) {
      destinationElement.setAttribute(name, value);
    }
  }
  function elementIsFocusable(element) {
    return element && typeof element.focus == "function";
  }
  var FrameRenderer = class extends Renderer {
    get shouldRender() {
      return true;
    }
    async render() {
      await nextAnimationFrame();
      this.preservingPermanentElements(() => {
        this.loadFrameElement();
      });
      this.scrollFrameIntoView();
      await nextAnimationFrame();
      this.focusFirstAutofocusableElement();
      await nextAnimationFrame();
      this.activateScriptElements();
    }
    loadFrameElement() {
      var _a;
      const destinationRange = document.createRange();
      destinationRange.selectNodeContents(this.currentElement);
      destinationRange.deleteContents();
      const frameElement = this.newElement;
      const sourceRange = (_a = frameElement.ownerDocument) === null || _a === void 0 ? void 0 : _a.createRange();
      if (sourceRange) {
        sourceRange.selectNodeContents(frameElement);
        this.currentElement.appendChild(sourceRange.extractContents());
      }
    }
    scrollFrameIntoView() {
      if (this.currentElement.autoscroll || this.newElement.autoscroll) {
        const element = this.currentElement.firstElementChild;
        const block = readScrollLogicalPosition(this.currentElement.getAttribute("data-autoscroll-block"), "end");
        if (element) {
          element.scrollIntoView({ block });
          return true;
        }
      }
      return false;
    }
    activateScriptElements() {
      for (const inertScriptElement of this.newScriptElements) {
        const activatedScriptElement = this.createScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    get newScriptElements() {
      return this.currentElement.querySelectorAll("script");
    }
  };
  function readScrollLogicalPosition(value, defaultValue) {
    if (value == "end" || value == "start" || value == "center" || value == "nearest") {
      return value;
    } else {
      return defaultValue;
    }
  }
  var ProgressBar = class {
    constructor() {
      this.hiding = false;
      this.value = 0;
      this.visible = false;
      this.trickle = () => {
        this.setValue(this.value + Math.random() / 100);
      };
      this.stylesheetElement = this.createStylesheetElement();
      this.progressElement = this.createProgressElement();
      this.installStylesheetElement();
      this.setValue(0);
    }
    static get defaultCSS() {
      return unindent`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 9999;
        transition:
          width ${ProgressBar.animationDuration}ms ease-out,
          opacity ${ProgressBar.animationDuration / 2}ms ${ProgressBar.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `;
    }
    show() {
      if (!this.visible) {
        this.visible = true;
        this.installProgressElement();
        this.startTrickling();
      }
    }
    hide() {
      if (this.visible && !this.hiding) {
        this.hiding = true;
        this.fadeProgressElement(() => {
          this.uninstallProgressElement();
          this.stopTrickling();
          this.visible = false;
          this.hiding = false;
        });
      }
    }
    setValue(value) {
      this.value = value;
      this.refresh();
    }
    installStylesheetElement() {
      document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
    }
    installProgressElement() {
      this.progressElement.style.width = "0";
      this.progressElement.style.opacity = "1";
      document.documentElement.insertBefore(this.progressElement, document.body);
      this.refresh();
    }
    fadeProgressElement(callback) {
      this.progressElement.style.opacity = "0";
      setTimeout(callback, ProgressBar.animationDuration * 1.5);
    }
    uninstallProgressElement() {
      if (this.progressElement.parentNode) {
        document.documentElement.removeChild(this.progressElement);
      }
    }
    startTrickling() {
      if (!this.trickleInterval) {
        this.trickleInterval = window.setInterval(this.trickle, ProgressBar.animationDuration);
      }
    }
    stopTrickling() {
      window.clearInterval(this.trickleInterval);
      delete this.trickleInterval;
    }
    refresh() {
      requestAnimationFrame(() => {
        this.progressElement.style.width = `${10 + this.value * 90}%`;
      });
    }
    createStylesheetElement() {
      const element = document.createElement("style");
      element.type = "text/css";
      element.textContent = ProgressBar.defaultCSS;
      return element;
    }
    createProgressElement() {
      const element = document.createElement("div");
      element.className = "turbo-progress-bar";
      return element;
    }
  };
  ProgressBar.animationDuration = 300;
  var HeadSnapshot = class extends Snapshot {
    constructor() {
      super(...arguments);
      this.detailsByOuterHTML = this.children.filter((element) => !elementIsNoscript(element)).map((element) => elementWithoutNonce(element)).reduce((result, element) => {
        const { outerHTML } = element;
        const details = outerHTML in result ? result[outerHTML] : {
          type: elementType(element),
          tracked: elementIsTracked(element),
          elements: []
        };
        return Object.assign(Object.assign({}, result), { [outerHTML]: Object.assign(Object.assign({}, details), { elements: [...details.elements, element] }) });
      }, {});
    }
    get trackedElementSignature() {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => this.detailsByOuterHTML[outerHTML].tracked).join("");
    }
    getScriptElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("script", snapshot);
    }
    getStylesheetElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("stylesheet", snapshot);
    }
    getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => !(outerHTML in snapshot.detailsByOuterHTML)).map((outerHTML) => this.detailsByOuterHTML[outerHTML]).filter(({ type }) => type == matchedType).map(({ elements: [element] }) => element);
    }
    get provisionalElements() {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const { type, tracked, elements } = this.detailsByOuterHTML[outerHTML];
        if (type == null && !tracked) {
          return [...result, ...elements];
        } else if (elements.length > 1) {
          return [...result, ...elements.slice(1)];
        } else {
          return result;
        }
      }, []);
    }
    getMetaValue(name) {
      const element = this.findMetaElementByName(name);
      return element ? element.getAttribute("content") : null;
    }
    findMetaElementByName(name) {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const { elements: [element] } = this.detailsByOuterHTML[outerHTML];
        return elementIsMetaElementWithName(element, name) ? element : result;
      }, void 0);
    }
  };
  function elementType(element) {
    if (elementIsScript(element)) {
      return "script";
    } else if (elementIsStylesheet(element)) {
      return "stylesheet";
    }
  }
  function elementIsTracked(element) {
    return element.getAttribute("data-turbo-track") == "reload";
  }
  function elementIsScript(element) {
    const tagName = element.tagName.toLowerCase();
    return tagName == "script";
  }
  function elementIsNoscript(element) {
    const tagName = element.tagName.toLowerCase();
    return tagName == "noscript";
  }
  function elementIsStylesheet(element) {
    const tagName = element.tagName.toLowerCase();
    return tagName == "style" || tagName == "link" && element.getAttribute("rel") == "stylesheet";
  }
  function elementIsMetaElementWithName(element, name) {
    const tagName = element.tagName.toLowerCase();
    return tagName == "meta" && element.getAttribute("name") == name;
  }
  function elementWithoutNonce(element) {
    if (element.hasAttribute("nonce")) {
      element.setAttribute("nonce", "");
    }
    return element;
  }
  var PageSnapshot = class extends Snapshot {
    constructor(element, headSnapshot) {
      super(element);
      this.headSnapshot = headSnapshot;
    }
    static fromHTMLString(html = "") {
      return this.fromDocument(parseHTMLDocument(html));
    }
    static fromElement(element) {
      return this.fromDocument(element.ownerDocument);
    }
    static fromDocument({ head, body }) {
      return new this(body, new HeadSnapshot(head));
    }
    clone() {
      return new PageSnapshot(this.element.cloneNode(true), this.headSnapshot);
    }
    get headElement() {
      return this.headSnapshot.element;
    }
    get rootLocation() {
      var _a;
      const root = (_a = this.getSetting("root")) !== null && _a !== void 0 ? _a : "/";
      return expandURL(root);
    }
    get cacheControlValue() {
      return this.getSetting("cache-control");
    }
    get isPreviewable() {
      return this.cacheControlValue != "no-preview";
    }
    get isCacheable() {
      return this.cacheControlValue != "no-cache";
    }
    get isVisitable() {
      return this.getSetting("visit-control") != "reload";
    }
    getSetting(name) {
      return this.headSnapshot.getMetaValue(`turbo-${name}`);
    }
  };
  var TimingMetric;
  (function(TimingMetric2) {
    TimingMetric2["visitStart"] = "visitStart";
    TimingMetric2["requestStart"] = "requestStart";
    TimingMetric2["requestEnd"] = "requestEnd";
    TimingMetric2["visitEnd"] = "visitEnd";
  })(TimingMetric || (TimingMetric = {}));
  var VisitState;
  (function(VisitState2) {
    VisitState2["initialized"] = "initialized";
    VisitState2["started"] = "started";
    VisitState2["canceled"] = "canceled";
    VisitState2["failed"] = "failed";
    VisitState2["completed"] = "completed";
  })(VisitState || (VisitState = {}));
  var defaultOptions = {
    action: "advance",
    historyChanged: false,
    visitCachedSnapshot: () => {
    },
    willRender: true
  };
  var SystemStatusCode;
  (function(SystemStatusCode2) {
    SystemStatusCode2[SystemStatusCode2["networkFailure"] = 0] = "networkFailure";
    SystemStatusCode2[SystemStatusCode2["timeoutFailure"] = -1] = "timeoutFailure";
    SystemStatusCode2[SystemStatusCode2["contentTypeMismatch"] = -2] = "contentTypeMismatch";
  })(SystemStatusCode || (SystemStatusCode = {}));
  var Visit = class {
    constructor(delegate, location2, restorationIdentifier, options = {}) {
      this.identifier = uuid();
      this.timingMetrics = {};
      this.followedRedirect = false;
      this.historyChanged = false;
      this.scrolled = false;
      this.snapshotCached = false;
      this.state = VisitState.initialized;
      this.delegate = delegate;
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier || uuid();
      const { action, historyChanged, referrer, snapshotHTML, response, visitCachedSnapshot, willRender } = Object.assign(Object.assign({}, defaultOptions), options);
      this.action = action;
      this.historyChanged = historyChanged;
      this.referrer = referrer;
      this.snapshotHTML = snapshotHTML;
      this.response = response;
      this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);
      this.visitCachedSnapshot = visitCachedSnapshot;
      this.willRender = willRender;
      this.scrolled = !willRender;
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get history() {
      return this.delegate.history;
    }
    get restorationData() {
      return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);
    }
    get silent() {
      return this.isSamePage;
    }
    start() {
      if (this.state == VisitState.initialized) {
        this.recordTimingMetric(TimingMetric.visitStart);
        this.state = VisitState.started;
        this.adapter.visitStarted(this);
        this.delegate.visitStarted(this);
      }
    }
    cancel() {
      if (this.state == VisitState.started) {
        if (this.request) {
          this.request.cancel();
        }
        this.cancelRender();
        this.state = VisitState.canceled;
      }
    }
    complete() {
      if (this.state == VisitState.started) {
        this.recordTimingMetric(TimingMetric.visitEnd);
        this.state = VisitState.completed;
        this.adapter.visitCompleted(this);
        this.delegate.visitCompleted(this);
        this.followRedirect();
      }
    }
    fail() {
      if (this.state == VisitState.started) {
        this.state = VisitState.failed;
        this.adapter.visitFailed(this);
      }
    }
    changeHistory() {
      var _a;
      if (!this.historyChanged) {
        const actionForHistory = this.location.href === ((_a = this.referrer) === null || _a === void 0 ? void 0 : _a.href) ? "replace" : this.action;
        const method = this.getHistoryMethodForAction(actionForHistory);
        this.history.update(method, this.location, this.restorationIdentifier);
        this.historyChanged = true;
      }
    }
    issueRequest() {
      if (this.hasPreloadedResponse()) {
        this.simulateRequest();
      } else if (this.shouldIssueRequest() && !this.request) {
        this.request = new FetchRequest(this, FetchMethod.get, this.location);
        this.request.perform();
      }
    }
    simulateRequest() {
      if (this.response) {
        this.startRequest();
        this.recordResponse();
        this.finishRequest();
      }
    }
    startRequest() {
      this.recordTimingMetric(TimingMetric.requestStart);
      this.adapter.visitRequestStarted(this);
    }
    recordResponse(response = this.response) {
      this.response = response;
      if (response) {
        const { statusCode } = response;
        if (isSuccessful(statusCode)) {
          this.adapter.visitRequestCompleted(this);
        } else {
          this.adapter.visitRequestFailedWithStatusCode(this, statusCode);
        }
      }
    }
    finishRequest() {
      this.recordTimingMetric(TimingMetric.requestEnd);
      this.adapter.visitRequestFinished(this);
    }
    loadResponse() {
      if (this.response) {
        const { statusCode, responseHTML } = this.response;
        this.render(async () => {
          this.cacheSnapshot();
          if (this.view.renderPromise)
            await this.view.renderPromise;
          if (isSuccessful(statusCode) && responseHTML != null) {
            await this.view.renderPage(PageSnapshot.fromHTMLString(responseHTML), false, this.willRender);
            this.adapter.visitRendered(this);
            this.complete();
          } else {
            await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML));
            this.adapter.visitRendered(this);
            this.fail();
          }
        });
      }
    }
    getCachedSnapshot() {
      const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();
      if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {
        if (this.action == "restore" || snapshot.isPreviewable) {
          return snapshot;
        }
      }
    }
    getPreloadedSnapshot() {
      if (this.snapshotHTML) {
        return PageSnapshot.fromHTMLString(this.snapshotHTML);
      }
    }
    hasCachedSnapshot() {
      return this.getCachedSnapshot() != null;
    }
    loadCachedSnapshot() {
      const snapshot = this.getCachedSnapshot();
      if (snapshot) {
        const isPreview = this.shouldIssueRequest();
        this.render(async () => {
          this.cacheSnapshot();
          if (this.isSamePage) {
            this.adapter.visitRendered(this);
          } else {
            if (this.view.renderPromise)
              await this.view.renderPromise;
            await this.view.renderPage(snapshot, isPreview, this.willRender);
            this.adapter.visitRendered(this);
            if (!isPreview) {
              this.complete();
            }
          }
        });
      }
    }
    followRedirect() {
      var _a;
      if (this.redirectedToLocation && !this.followedRedirect && ((_a = this.response) === null || _a === void 0 ? void 0 : _a.redirected)) {
        this.adapter.visitProposedToLocation(this.redirectedToLocation, {
          action: "replace",
          response: this.response
        });
        this.followedRedirect = true;
      }
    }
    goToSamePageAnchor() {
      if (this.isSamePage) {
        this.render(async () => {
          this.cacheSnapshot();
          this.adapter.visitRendered(this);
        });
      }
    }
    requestStarted() {
      this.startRequest();
    }
    requestPreventedHandlingResponse(request, response) {
    }
    async requestSucceededWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({ statusCode: SystemStatusCode.contentTypeMismatch, redirected });
      } else {
        this.redirectedToLocation = response.redirected ? response.location : void 0;
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    async requestFailedWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({ statusCode: SystemStatusCode.contentTypeMismatch, redirected });
      } else {
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    requestErrored(request, error2) {
      this.recordResponse({ statusCode: SystemStatusCode.networkFailure, redirected: false });
    }
    requestFinished() {
      this.finishRequest();
    }
    performScroll() {
      if (!this.scrolled) {
        if (this.action == "restore") {
          this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();
        } else {
          this.scrollToAnchor() || this.view.scrollToTop();
        }
        if (this.isSamePage) {
          this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);
        }
        this.scrolled = true;
      }
    }
    scrollToRestoredPosition() {
      const { scrollPosition } = this.restorationData;
      if (scrollPosition) {
        this.view.scrollToPosition(scrollPosition);
        return true;
      }
    }
    scrollToAnchor() {
      const anchor = getAnchor(this.location);
      if (anchor != null) {
        this.view.scrollToAnchor(anchor);
        return true;
      }
    }
    recordTimingMetric(metric) {
      this.timingMetrics[metric] = new Date().getTime();
    }
    getTimingMetrics() {
      return Object.assign({}, this.timingMetrics);
    }
    getHistoryMethodForAction(action) {
      switch (action) {
        case "replace":
          return history.replaceState;
        case "advance":
        case "restore":
          return history.pushState;
      }
    }
    hasPreloadedResponse() {
      return typeof this.response == "object";
    }
    shouldIssueRequest() {
      if (this.isSamePage) {
        return false;
      } else if (this.action == "restore") {
        return !this.hasCachedSnapshot();
      } else {
        return this.willRender;
      }
    }
    cacheSnapshot() {
      if (!this.snapshotCached) {
        this.view.cacheSnapshot().then((snapshot) => snapshot && this.visitCachedSnapshot(snapshot));
        this.snapshotCached = true;
      }
    }
    async render(callback) {
      this.cancelRender();
      await new Promise((resolve2) => {
        this.frame = requestAnimationFrame(() => resolve2());
      });
      await callback();
      delete this.frame;
      this.performScroll();
    }
    cancelRender() {
      if (this.frame) {
        cancelAnimationFrame(this.frame);
        delete this.frame;
      }
    }
  };
  function isSuccessful(statusCode) {
    return statusCode >= 200 && statusCode < 300;
  }
  var BrowserAdapter = class {
    constructor(session2) {
      this.progressBar = new ProgressBar();
      this.showProgressBar = () => {
        this.progressBar.show();
      };
      this.session = session2;
    }
    visitProposedToLocation(location2, options) {
      this.navigator.startVisit(location2, uuid(), options);
    }
    visitStarted(visit2) {
      visit2.loadCachedSnapshot();
      visit2.issueRequest();
      visit2.changeHistory();
      visit2.goToSamePageAnchor();
    }
    visitRequestStarted(visit2) {
      this.progressBar.setValue(0);
      if (visit2.hasCachedSnapshot() || visit2.action != "restore") {
        this.showVisitProgressBarAfterDelay();
      } else {
        this.showProgressBar();
      }
    }
    visitRequestCompleted(visit2) {
      visit2.loadResponse();
    }
    visitRequestFailedWithStatusCode(visit2, statusCode) {
      switch (statusCode) {
        case SystemStatusCode.networkFailure:
        case SystemStatusCode.timeoutFailure:
        case SystemStatusCode.contentTypeMismatch:
          return this.reload();
        default:
          return visit2.loadResponse();
      }
    }
    visitRequestFinished(visit2) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    visitCompleted(visit2) {
    }
    pageInvalidated() {
      this.reload();
    }
    visitFailed(visit2) {
    }
    visitRendered(visit2) {
    }
    formSubmissionStarted(formSubmission) {
      this.progressBar.setValue(0);
      this.showFormProgressBarAfterDelay();
    }
    formSubmissionFinished(formSubmission) {
      this.progressBar.setValue(1);
      this.hideFormProgressBar();
    }
    showVisitProgressBarAfterDelay() {
      this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
    }
    hideVisitProgressBar() {
      this.progressBar.hide();
      if (this.visitProgressBarTimeout != null) {
        window.clearTimeout(this.visitProgressBarTimeout);
        delete this.visitProgressBarTimeout;
      }
    }
    showFormProgressBarAfterDelay() {
      if (this.formProgressBarTimeout == null) {
        this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
      }
    }
    hideFormProgressBar() {
      this.progressBar.hide();
      if (this.formProgressBarTimeout != null) {
        window.clearTimeout(this.formProgressBarTimeout);
        delete this.formProgressBarTimeout;
      }
    }
    reload() {
      window.location.reload();
    }
    get navigator() {
      return this.session.navigator;
    }
  };
  var CacheObserver = class {
    constructor() {
      this.started = false;
    }
    start() {
      if (!this.started) {
        this.started = true;
        addEventListener("turbo:before-cache", this.removeStaleElements, false);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        removeEventListener("turbo:before-cache", this.removeStaleElements, false);
      }
    }
    removeStaleElements() {
      const staleElements = [...document.querySelectorAll('[data-turbo-cache="false"]')];
      for (const element of staleElements) {
        element.remove();
      }
    }
  };
  var FormSubmitObserver = class {
    constructor(delegate) {
      this.started = false;
      this.submitCaptured = () => {
        removeEventListener("submit", this.submitBubbled, false);
        addEventListener("submit", this.submitBubbled, false);
      };
      this.submitBubbled = (event) => {
        if (!event.defaultPrevented) {
          const form = event.target instanceof HTMLFormElement ? event.target : void 0;
          const submitter = event.submitter || void 0;
          if (form) {
            const method = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formmethod")) || form.getAttribute("method");
            if (method != "dialog" && this.delegate.willSubmitForm(form, submitter)) {
              event.preventDefault();
              this.delegate.formSubmitted(form, submitter);
            }
          }
        }
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("submit", this.submitCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("submit", this.submitCaptured, true);
        this.started = false;
      }
    }
  };
  var FrameRedirector = class {
    constructor(element) {
      this.element = element;
      this.linkInterceptor = new LinkInterceptor(this, element);
      this.formInterceptor = new FormInterceptor(this, element);
    }
    start() {
      this.linkInterceptor.start();
      this.formInterceptor.start();
    }
    stop() {
      this.linkInterceptor.stop();
      this.formInterceptor.stop();
    }
    shouldInterceptLinkClick(element, url) {
      return this.shouldRedirect(element);
    }
    linkClickIntercepted(element, url) {
      const frame = this.findFrameElement(element);
      if (frame) {
        frame.delegate.linkClickIntercepted(element, url);
      }
    }
    shouldInterceptFormSubmission(element, submitter) {
      return this.shouldSubmit(element, submitter);
    }
    formSubmissionIntercepted(element, submitter) {
      const frame = this.findFrameElement(element, submitter);
      if (frame) {
        frame.removeAttribute("reloadable");
        frame.delegate.formSubmissionIntercepted(element, submitter);
      }
    }
    shouldSubmit(form, submitter) {
      var _a;
      const action = getAction(form, submitter);
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const rootLocation = expandURL((_a = meta === null || meta === void 0 ? void 0 : meta.content) !== null && _a !== void 0 ? _a : "/");
      return this.shouldRedirect(form, submitter) && locationIsVisitable(action, rootLocation);
    }
    shouldRedirect(element, submitter) {
      const frame = this.findFrameElement(element, submitter);
      return frame ? frame != element.closest("turbo-frame") : false;
    }
    findFrameElement(element, submitter) {
      const id = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("data-turbo-frame")) || element.getAttribute("data-turbo-frame");
      if (id && id != "_top") {
        const frame = this.element.querySelector(`#${id}:not([disabled])`);
        if (frame instanceof FrameElement) {
          return frame;
        }
      }
    }
  };
  var History = class {
    constructor(delegate) {
      this.restorationIdentifier = uuid();
      this.restorationData = {};
      this.started = false;
      this.pageLoaded = false;
      this.onPopState = (event) => {
        if (this.shouldHandlePopState()) {
          const { turbo } = event.state || {};
          if (turbo) {
            this.location = new URL(window.location.href);
            const { restorationIdentifier } = turbo;
            this.restorationIdentifier = restorationIdentifier;
            this.delegate.historyPoppedToLocationWithRestorationIdentifier(this.location, restorationIdentifier);
          }
        }
      };
      this.onPageLoad = async (event) => {
        await nextMicrotask();
        this.pageLoaded = true;
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("popstate", this.onPopState, false);
        addEventListener("load", this.onPageLoad, false);
        this.started = true;
        this.replace(new URL(window.location.href));
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("popstate", this.onPopState, false);
        removeEventListener("load", this.onPageLoad, false);
        this.started = false;
      }
    }
    push(location2, restorationIdentifier) {
      this.update(history.pushState, location2, restorationIdentifier);
    }
    replace(location2, restorationIdentifier) {
      this.update(history.replaceState, location2, restorationIdentifier);
    }
    update(method, location2, restorationIdentifier = uuid()) {
      const state = { turbo: { restorationIdentifier } };
      method.call(history, state, "", location2.href);
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier;
    }
    getRestorationDataForIdentifier(restorationIdentifier) {
      return this.restorationData[restorationIdentifier] || {};
    }
    updateRestorationData(additionalData) {
      const { restorationIdentifier } = this;
      const restorationData = this.restorationData[restorationIdentifier];
      this.restorationData[restorationIdentifier] = Object.assign(Object.assign({}, restorationData), additionalData);
    }
    assumeControlOfScrollRestoration() {
      var _a;
      if (!this.previousScrollRestoration) {
        this.previousScrollRestoration = (_a = history.scrollRestoration) !== null && _a !== void 0 ? _a : "auto";
        history.scrollRestoration = "manual";
      }
    }
    relinquishControlOfScrollRestoration() {
      if (this.previousScrollRestoration) {
        history.scrollRestoration = this.previousScrollRestoration;
        delete this.previousScrollRestoration;
      }
    }
    shouldHandlePopState() {
      return this.pageIsLoaded();
    }
    pageIsLoaded() {
      return this.pageLoaded || document.readyState == "complete";
    }
  };
  var LinkClickObserver = class {
    constructor(delegate) {
      this.started = false;
      this.clickCaptured = () => {
        removeEventListener("click", this.clickBubbled, false);
        addEventListener("click", this.clickBubbled, false);
      };
      this.clickBubbled = (event) => {
        if (this.clickEventIsSignificant(event)) {
          const target = event.composedPath && event.composedPath()[0] || event.target;
          const link = this.findLinkFromClickTarget(target);
          if (link) {
            const location2 = this.getLocationForLink(link);
            if (this.delegate.willFollowLinkToLocation(link, location2)) {
              event.preventDefault();
              this.delegate.followedLinkToLocation(link, location2);
            }
          }
        }
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("click", this.clickCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("click", this.clickCaptured, true);
        this.started = false;
      }
    }
    clickEventIsSignificant(event) {
      return !(event.target && event.target.isContentEditable || event.defaultPrevented || event.which > 1 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey);
    }
    findLinkFromClickTarget(target) {
      if (target instanceof Element) {
        return target.closest("a[href]:not([target^=_]):not([download])");
      }
    }
    getLocationForLink(link) {
      return expandURL(link.getAttribute("href") || "");
    }
  };
  function isAction(action) {
    return action == "advance" || action == "replace" || action == "restore";
  }
  var Navigator = class {
    constructor(delegate) {
      this.delegate = delegate;
    }
    proposeVisit(location2, options = {}) {
      if (this.delegate.allowsVisitingLocationWithAction(location2, options.action)) {
        if (locationIsVisitable(location2, this.view.snapshot.rootLocation)) {
          this.delegate.visitProposedToLocation(location2, options);
        } else {
          window.location.href = location2.toString();
        }
      }
    }
    startVisit(locatable, restorationIdentifier, options = {}) {
      this.stop();
      this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, Object.assign({ referrer: this.location }, options));
      this.currentVisit.start();
    }
    submitForm(form, submitter) {
      this.stop();
      this.formSubmission = new FormSubmission(this, form, submitter, true);
      this.formSubmission.start();
    }
    stop() {
      if (this.formSubmission) {
        this.formSubmission.stop();
        delete this.formSubmission;
      }
      if (this.currentVisit) {
        this.currentVisit.cancel();
        delete this.currentVisit;
      }
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get history() {
      return this.delegate.history;
    }
    formSubmissionStarted(formSubmission) {
      if (typeof this.adapter.formSubmissionStarted === "function") {
        this.adapter.formSubmissionStarted(formSubmission);
      }
    }
    async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {
      if (formSubmission == this.formSubmission) {
        const responseHTML = await fetchResponse.responseHTML;
        if (responseHTML) {
          if (formSubmission.method != FetchMethod.get) {
            this.view.clearSnapshotCache();
          }
          const { statusCode, redirected } = fetchResponse;
          const action = this.getActionForFormSubmission(formSubmission);
          const visitOptions = { action, response: { statusCode, responseHTML, redirected } };
          this.proposeVisit(fetchResponse.location, visitOptions);
        }
      }
    }
    async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      const responseHTML = await fetchResponse.responseHTML;
      if (responseHTML) {
        const snapshot = PageSnapshot.fromHTMLString(responseHTML);
        if (fetchResponse.serverError) {
          await this.view.renderError(snapshot);
        } else {
          await this.view.renderPage(snapshot);
        }
        this.view.scrollToTop();
        this.view.clearSnapshotCache();
      }
    }
    formSubmissionErrored(formSubmission, error2) {
      console.error(error2);
    }
    formSubmissionFinished(formSubmission) {
      if (typeof this.adapter.formSubmissionFinished === "function") {
        this.adapter.formSubmissionFinished(formSubmission);
      }
    }
    visitStarted(visit2) {
      this.delegate.visitStarted(visit2);
    }
    visitCompleted(visit2) {
      this.delegate.visitCompleted(visit2);
    }
    locationWithActionIsSamePage(location2, action) {
      const anchor = getAnchor(location2);
      const currentAnchor = getAnchor(this.view.lastRenderedLocation);
      const isRestorationToTop = action === "restore" && typeof anchor === "undefined";
      return action !== "replace" && getRequestURL(location2) === getRequestURL(this.view.lastRenderedLocation) && (isRestorationToTop || anchor != null && anchor !== currentAnchor);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);
    }
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    getActionForFormSubmission(formSubmission) {
      const { formElement, submitter } = formSubmission;
      const action = getAttribute("data-turbo-action", submitter, formElement);
      return isAction(action) ? action : "advance";
    }
  };
  var PageStage;
  (function(PageStage2) {
    PageStage2[PageStage2["initial"] = 0] = "initial";
    PageStage2[PageStage2["loading"] = 1] = "loading";
    PageStage2[PageStage2["interactive"] = 2] = "interactive";
    PageStage2[PageStage2["complete"] = 3] = "complete";
  })(PageStage || (PageStage = {}));
  var PageObserver = class {
    constructor(delegate) {
      this.stage = PageStage.initial;
      this.started = false;
      this.interpretReadyState = () => {
        const { readyState } = this;
        if (readyState == "interactive") {
          this.pageIsInteractive();
        } else if (readyState == "complete") {
          this.pageIsComplete();
        }
      };
      this.pageWillUnload = () => {
        this.delegate.pageWillUnload();
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        if (this.stage == PageStage.initial) {
          this.stage = PageStage.loading;
        }
        document.addEventListener("readystatechange", this.interpretReadyState, false);
        addEventListener("pagehide", this.pageWillUnload, false);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        document.removeEventListener("readystatechange", this.interpretReadyState, false);
        removeEventListener("pagehide", this.pageWillUnload, false);
        this.started = false;
      }
    }
    pageIsInteractive() {
      if (this.stage == PageStage.loading) {
        this.stage = PageStage.interactive;
        this.delegate.pageBecameInteractive();
      }
    }
    pageIsComplete() {
      this.pageIsInteractive();
      if (this.stage == PageStage.interactive) {
        this.stage = PageStage.complete;
        this.delegate.pageLoaded();
      }
    }
    get readyState() {
      return document.readyState;
    }
  };
  var ScrollObserver = class {
    constructor(delegate) {
      this.started = false;
      this.onScroll = () => {
        this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("scroll", this.onScroll, false);
        this.onScroll();
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("scroll", this.onScroll, false);
        this.started = false;
      }
    }
    updatePosition(position) {
      this.delegate.scrollPositionChanged(position);
    }
  };
  var StreamObserver = class {
    constructor(delegate) {
      this.sources = /* @__PURE__ */ new Set();
      this.started = false;
      this.inspectFetchResponse = (event) => {
        const response = fetchResponseFromEvent(event);
        if (response && fetchResponseIsStream(response)) {
          event.preventDefault();
          this.receiveMessageResponse(response);
        }
      };
      this.receiveMessageEvent = (event) => {
        if (this.started && typeof event.data == "string") {
          this.receiveMessageHTML(event.data);
        }
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        this.started = true;
        addEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        removeEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    connectStreamSource(source) {
      if (!this.streamSourceIsConnected(source)) {
        this.sources.add(source);
        source.addEventListener("message", this.receiveMessageEvent, false);
      }
    }
    disconnectStreamSource(source) {
      if (this.streamSourceIsConnected(source)) {
        this.sources.delete(source);
        source.removeEventListener("message", this.receiveMessageEvent, false);
      }
    }
    streamSourceIsConnected(source) {
      return this.sources.has(source);
    }
    async receiveMessageResponse(response) {
      const html = await response.responseHTML;
      if (html) {
        this.receiveMessageHTML(html);
      }
    }
    receiveMessageHTML(html) {
      this.delegate.receivedMessageFromStream(new StreamMessage(html));
    }
  };
  function fetchResponseFromEvent(event) {
    var _a;
    const fetchResponse = (_a = event.detail) === null || _a === void 0 ? void 0 : _a.fetchResponse;
    if (fetchResponse instanceof FetchResponse) {
      return fetchResponse;
    }
  }
  function fetchResponseIsStream(response) {
    var _a;
    const contentType = (_a = response.contentType) !== null && _a !== void 0 ? _a : "";
    return contentType.startsWith(StreamMessage.contentType);
  }
  var ErrorRenderer = class extends Renderer {
    async render() {
      this.replaceHeadAndBody();
      this.activateScriptElements();
    }
    replaceHeadAndBody() {
      const { documentElement, head, body } = document;
      documentElement.replaceChild(this.newHead, head);
      documentElement.replaceChild(this.newElement, body);
    }
    activateScriptElements() {
      for (const replaceableElement of this.scriptElements) {
        const parentNode = replaceableElement.parentNode;
        if (parentNode) {
          const element = this.createScriptElement(replaceableElement);
          parentNode.replaceChild(element, replaceableElement);
        }
      }
    }
    get newHead() {
      return this.newSnapshot.headSnapshot.element;
    }
    get scriptElements() {
      return [...document.documentElement.querySelectorAll("script")];
    }
  };
  var PageRenderer = class extends Renderer {
    get shouldRender() {
      return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical;
    }
    prepareToRender() {
      this.mergeHead();
    }
    async render() {
      if (this.willRender) {
        this.replaceBody();
      }
    }
    finishRendering() {
      super.finishRendering();
      if (!this.isPreview) {
        this.focusFirstAutofocusableElement();
      }
    }
    get currentHeadSnapshot() {
      return this.currentSnapshot.headSnapshot;
    }
    get newHeadSnapshot() {
      return this.newSnapshot.headSnapshot;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    mergeHead() {
      this.copyNewHeadStylesheetElements();
      this.copyNewHeadScriptElements();
      this.removeCurrentHeadProvisionalElements();
      this.copyNewHeadProvisionalElements();
    }
    replaceBody() {
      this.preservingPermanentElements(() => {
        this.activateNewBody();
        this.assignNewBody();
      });
    }
    get trackedElementsAreIdentical() {
      return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;
    }
    copyNewHeadStylesheetElements() {
      for (const element of this.newHeadStylesheetElements) {
        document.head.appendChild(element);
      }
    }
    copyNewHeadScriptElements() {
      for (const element of this.newHeadScriptElements) {
        document.head.appendChild(this.createScriptElement(element));
      }
    }
    removeCurrentHeadProvisionalElements() {
      for (const element of this.currentHeadProvisionalElements) {
        document.head.removeChild(element);
      }
    }
    copyNewHeadProvisionalElements() {
      for (const element of this.newHeadProvisionalElements) {
        document.head.appendChild(element);
      }
    }
    activateNewBody() {
      document.adoptNode(this.newElement);
      this.activateNewBodyScriptElements();
    }
    activateNewBodyScriptElements() {
      for (const inertScriptElement of this.newBodyScriptElements) {
        const activatedScriptElement = this.createScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    assignNewBody() {
      if (document.body && this.newElement instanceof HTMLBodyElement) {
        document.body.replaceWith(this.newElement);
      } else {
        document.documentElement.appendChild(this.newElement);
      }
    }
    get newHeadStylesheetElements() {
      return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get newHeadScriptElements() {
      return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get currentHeadProvisionalElements() {
      return this.currentHeadSnapshot.provisionalElements;
    }
    get newHeadProvisionalElements() {
      return this.newHeadSnapshot.provisionalElements;
    }
    get newBodyScriptElements() {
      return this.newElement.querySelectorAll("script");
    }
  };
  var SnapshotCache = class {
    constructor(size) {
      this.keys = [];
      this.snapshots = {};
      this.size = size;
    }
    has(location2) {
      return toCacheKey(location2) in this.snapshots;
    }
    get(location2) {
      if (this.has(location2)) {
        const snapshot = this.read(location2);
        this.touch(location2);
        return snapshot;
      }
    }
    put(location2, snapshot) {
      this.write(location2, snapshot);
      this.touch(location2);
      return snapshot;
    }
    clear() {
      this.snapshots = {};
    }
    read(location2) {
      return this.snapshots[toCacheKey(location2)];
    }
    write(location2, snapshot) {
      this.snapshots[toCacheKey(location2)] = snapshot;
    }
    touch(location2) {
      const key = toCacheKey(location2);
      const index = this.keys.indexOf(key);
      if (index > -1)
        this.keys.splice(index, 1);
      this.keys.unshift(key);
      this.trim();
    }
    trim() {
      for (const key of this.keys.splice(this.size)) {
        delete this.snapshots[key];
      }
    }
  };
  var PageView = class extends View {
    constructor() {
      super(...arguments);
      this.snapshotCache = new SnapshotCache(10);
      this.lastRenderedLocation = new URL(location.href);
    }
    renderPage(snapshot, isPreview = false, willRender = true) {
      const renderer = new PageRenderer(this.snapshot, snapshot, isPreview, willRender);
      return this.render(renderer);
    }
    renderError(snapshot) {
      const renderer = new ErrorRenderer(this.snapshot, snapshot, false);
      return this.render(renderer);
    }
    clearSnapshotCache() {
      this.snapshotCache.clear();
    }
    async cacheSnapshot() {
      if (this.shouldCacheSnapshot) {
        this.delegate.viewWillCacheSnapshot();
        const { snapshot, lastRenderedLocation: location2 } = this;
        await nextEventLoopTick();
        const cachedSnapshot = snapshot.clone();
        this.snapshotCache.put(location2, cachedSnapshot);
        return cachedSnapshot;
      }
    }
    getCachedSnapshotForLocation(location2) {
      return this.snapshotCache.get(location2);
    }
    get snapshot() {
      return PageSnapshot.fromElement(this.element);
    }
    get shouldCacheSnapshot() {
      return this.snapshot.isCacheable;
    }
  };
  var Session = class {
    constructor() {
      this.navigator = new Navigator(this);
      this.history = new History(this);
      this.view = new PageView(this, document.documentElement);
      this.adapter = new BrowserAdapter(this);
      this.pageObserver = new PageObserver(this);
      this.cacheObserver = new CacheObserver();
      this.linkClickObserver = new LinkClickObserver(this);
      this.formSubmitObserver = new FormSubmitObserver(this);
      this.scrollObserver = new ScrollObserver(this);
      this.streamObserver = new StreamObserver(this);
      this.frameRedirector = new FrameRedirector(document.documentElement);
      this.drive = true;
      this.enabled = true;
      this.progressBarDelay = 500;
      this.started = false;
    }
    start() {
      if (!this.started) {
        this.pageObserver.start();
        this.cacheObserver.start();
        this.linkClickObserver.start();
        this.formSubmitObserver.start();
        this.scrollObserver.start();
        this.streamObserver.start();
        this.frameRedirector.start();
        this.history.start();
        this.started = true;
        this.enabled = true;
      }
    }
    disable() {
      this.enabled = false;
    }
    stop() {
      if (this.started) {
        this.pageObserver.stop();
        this.cacheObserver.stop();
        this.linkClickObserver.stop();
        this.formSubmitObserver.stop();
        this.scrollObserver.stop();
        this.streamObserver.stop();
        this.frameRedirector.stop();
        this.history.stop();
        this.started = false;
      }
    }
    registerAdapter(adapter) {
      this.adapter = adapter;
    }
    visit(location2, options = {}) {
      this.navigator.proposeVisit(expandURL(location2), options);
    }
    connectStreamSource(source) {
      this.streamObserver.connectStreamSource(source);
    }
    disconnectStreamSource(source) {
      this.streamObserver.disconnectStreamSource(source);
    }
    renderStreamMessage(message) {
      document.documentElement.appendChild(StreamMessage.wrap(message).fragment);
    }
    clearCache() {
      this.view.clearSnapshotCache();
    }
    setProgressBarDelay(delay) {
      this.progressBarDelay = delay;
    }
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    historyPoppedToLocationWithRestorationIdentifier(location2, restorationIdentifier) {
      if (this.enabled) {
        this.navigator.startVisit(location2, restorationIdentifier, { action: "restore", historyChanged: true });
      } else {
        this.adapter.pageInvalidated();
      }
    }
    scrollPositionChanged(position) {
      this.history.updateRestorationData({ scrollPosition: position });
    }
    willFollowLinkToLocation(link, location2) {
      return this.elementDriveEnabled(link) && locationIsVisitable(location2, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(link, location2);
    }
    followedLinkToLocation(link, location2) {
      const action = this.getActionForLink(link);
      this.convertLinkWithMethodClickToFormSubmission(link) || this.visit(location2.href, { action });
    }
    convertLinkWithMethodClickToFormSubmission(link) {
      const linkMethod = link.getAttribute("data-turbo-method");
      if (linkMethod) {
        const form = document.createElement("form");
        form.method = linkMethod;
        form.action = link.getAttribute("href") || "undefined";
        form.hidden = true;
        if (link.hasAttribute("data-turbo-confirm")) {
          form.setAttribute("data-turbo-confirm", link.getAttribute("data-turbo-confirm"));
        }
        const frame = this.getTargetFrameForLink(link);
        if (frame) {
          form.setAttribute("data-turbo-frame", frame);
          form.addEventListener("turbo:submit-start", () => form.remove());
        } else {
          form.addEventListener("submit", () => form.remove());
        }
        document.body.appendChild(form);
        return dispatch("submit", { cancelable: true, target: form });
      } else {
        return false;
      }
    }
    allowsVisitingLocationWithAction(location2, action) {
      return this.locationWithActionIsSamePage(location2, action) || this.applicationAllowsVisitingLocation(location2);
    }
    visitProposedToLocation(location2, options) {
      extendURLWithDeprecatedProperties(location2);
      this.adapter.visitProposedToLocation(location2, options);
    }
    visitStarted(visit2) {
      extendURLWithDeprecatedProperties(visit2.location);
      if (!visit2.silent) {
        this.notifyApplicationAfterVisitingLocation(visit2.location, visit2.action);
      }
    }
    visitCompleted(visit2) {
      this.notifyApplicationAfterPageLoad(visit2.getTimingMetrics());
    }
    locationWithActionIsSamePage(location2, action) {
      return this.navigator.locationWithActionIsSamePage(location2, action);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);
    }
    willSubmitForm(form, submitter) {
      const action = getAction(form, submitter);
      return this.elementDriveEnabled(form) && (!submitter || this.elementDriveEnabled(submitter)) && locationIsVisitable(expandURL(action), this.snapshot.rootLocation);
    }
    formSubmitted(form, submitter) {
      this.navigator.submitForm(form, submitter);
    }
    pageBecameInteractive() {
      this.view.lastRenderedLocation = this.location;
      this.notifyApplicationAfterPageLoad();
    }
    pageLoaded() {
      this.history.assumeControlOfScrollRestoration();
    }
    pageWillUnload() {
      this.history.relinquishControlOfScrollRestoration();
    }
    receivedMessageFromStream(message) {
      this.renderStreamMessage(message);
    }
    viewWillCacheSnapshot() {
      var _a;
      if (!((_a = this.navigator.currentVisit) === null || _a === void 0 ? void 0 : _a.silent)) {
        this.notifyApplicationBeforeCachingSnapshot();
      }
    }
    allowsImmediateRender({ element }, resume) {
      const event = this.notifyApplicationBeforeRender(element, resume);
      return !event.defaultPrevented;
    }
    viewRenderedSnapshot(snapshot, isPreview) {
      this.view.lastRenderedLocation = this.history.location;
      this.notifyApplicationAfterRender();
    }
    viewInvalidated() {
      this.adapter.pageInvalidated();
    }
    frameLoaded(frame) {
      this.notifyApplicationAfterFrameLoad(frame);
    }
    frameRendered(fetchResponse, frame) {
      this.notifyApplicationAfterFrameRender(fetchResponse, frame);
    }
    applicationAllowsFollowingLinkToLocation(link, location2) {
      const event = this.notifyApplicationAfterClickingLinkToLocation(link, location2);
      return !event.defaultPrevented;
    }
    applicationAllowsVisitingLocation(location2) {
      const event = this.notifyApplicationBeforeVisitingLocation(location2);
      return !event.defaultPrevented;
    }
    notifyApplicationAfterClickingLinkToLocation(link, location2) {
      return dispatch("turbo:click", { target: link, detail: { url: location2.href }, cancelable: true });
    }
    notifyApplicationBeforeVisitingLocation(location2) {
      return dispatch("turbo:before-visit", { detail: { url: location2.href }, cancelable: true });
    }
    notifyApplicationAfterVisitingLocation(location2, action) {
      markAsBusy(document.documentElement);
      return dispatch("turbo:visit", { detail: { url: location2.href, action } });
    }
    notifyApplicationBeforeCachingSnapshot() {
      return dispatch("turbo:before-cache");
    }
    notifyApplicationBeforeRender(newBody, resume) {
      return dispatch("turbo:before-render", { detail: { newBody, resume }, cancelable: true });
    }
    notifyApplicationAfterRender() {
      return dispatch("turbo:render");
    }
    notifyApplicationAfterPageLoad(timing = {}) {
      clearBusyState(document.documentElement);
      return dispatch("turbo:load", { detail: { url: this.location.href, timing } });
    }
    notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {
      dispatchEvent(new HashChangeEvent("hashchange", { oldURL: oldURL.toString(), newURL: newURL.toString() }));
    }
    notifyApplicationAfterFrameLoad(frame) {
      return dispatch("turbo:frame-load", { target: frame });
    }
    notifyApplicationAfterFrameRender(fetchResponse, frame) {
      return dispatch("turbo:frame-render", { detail: { fetchResponse }, target: frame, cancelable: true });
    }
    elementDriveEnabled(element) {
      const container = element === null || element === void 0 ? void 0 : element.closest("[data-turbo]");
      if (this.drive) {
        if (container) {
          return container.getAttribute("data-turbo") != "false";
        } else {
          return true;
        }
      } else {
        if (container) {
          return container.getAttribute("data-turbo") == "true";
        } else {
          return false;
        }
      }
    }
    getActionForLink(link) {
      const action = link.getAttribute("data-turbo-action");
      return isAction(action) ? action : "advance";
    }
    getTargetFrameForLink(link) {
      const frame = link.getAttribute("data-turbo-frame");
      if (frame) {
        return frame;
      } else {
        const container = link.closest("turbo-frame");
        if (container) {
          return container.id;
        }
      }
    }
    get snapshot() {
      return this.view.snapshot;
    }
  };
  function extendURLWithDeprecatedProperties(url) {
    Object.defineProperties(url, deprecatedLocationPropertyDescriptors);
  }
  var deprecatedLocationPropertyDescriptors = {
    absoluteURL: {
      get() {
        return this.toString();
      }
    }
  };
  var session = new Session();
  var { navigator: navigator$1 } = session;
  function start() {
    session.start();
  }
  function registerAdapter(adapter) {
    session.registerAdapter(adapter);
  }
  function visit(location2, options) {
    session.visit(location2, options);
  }
  function connectStreamSource(source) {
    session.connectStreamSource(source);
  }
  function disconnectStreamSource(source) {
    session.disconnectStreamSource(source);
  }
  function renderStreamMessage(message) {
    session.renderStreamMessage(message);
  }
  function clearCache() {
    session.clearCache();
  }
  function setProgressBarDelay(delay) {
    session.setProgressBarDelay(delay);
  }
  function setConfirmMethod(confirmMethod) {
    FormSubmission.confirmMethod = confirmMethod;
  }
  var Turbo = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    navigator: navigator$1,
    session,
    PageRenderer,
    PageSnapshot,
    start,
    registerAdapter,
    visit,
    connectStreamSource,
    disconnectStreamSource,
    renderStreamMessage,
    clearCache,
    setProgressBarDelay,
    setConfirmMethod
  });
  var FrameController = class {
    constructor(element) {
      this.fetchResponseLoaded = (fetchResponse) => {
      };
      this.currentFetchRequest = null;
      this.resolveVisitPromise = () => {
      };
      this.connected = false;
      this.hasBeenLoaded = false;
      this.settingSourceURL = false;
      this.element = element;
      this.view = new FrameView(this, this.element);
      this.appearanceObserver = new AppearanceObserver(this, this.element);
      this.linkInterceptor = new LinkInterceptor(this, this.element);
      this.formInterceptor = new FormInterceptor(this, this.element);
    }
    connect() {
      if (!this.connected) {
        this.connected = true;
        this.reloadable = false;
        if (this.loadingStyle == FrameLoadingStyle.lazy) {
          this.appearanceObserver.start();
        }
        this.linkInterceptor.start();
        this.formInterceptor.start();
        this.sourceURLChanged();
      }
    }
    disconnect() {
      if (this.connected) {
        this.connected = false;
        this.appearanceObserver.stop();
        this.linkInterceptor.stop();
        this.formInterceptor.stop();
      }
    }
    disabledChanged() {
      if (this.loadingStyle == FrameLoadingStyle.eager) {
        this.loadSourceURL();
      }
    }
    sourceURLChanged() {
      if (this.loadingStyle == FrameLoadingStyle.eager || this.hasBeenLoaded) {
        this.loadSourceURL();
      }
    }
    loadingStyleChanged() {
      if (this.loadingStyle == FrameLoadingStyle.lazy) {
        this.appearanceObserver.start();
      } else {
        this.appearanceObserver.stop();
        this.loadSourceURL();
      }
    }
    async loadSourceURL() {
      if (!this.settingSourceURL && this.enabled && this.isActive && (this.reloadable || this.sourceURL != this.currentURL)) {
        const previousURL = this.currentURL;
        this.currentURL = this.sourceURL;
        if (this.sourceURL) {
          try {
            this.element.loaded = this.visit(expandURL(this.sourceURL));
            this.appearanceObserver.stop();
            await this.element.loaded;
            this.hasBeenLoaded = true;
          } catch (error2) {
            this.currentURL = previousURL;
            throw error2;
          }
        }
      }
    }
    async loadResponse(fetchResponse) {
      if (fetchResponse.redirected || fetchResponse.succeeded && fetchResponse.isHTML) {
        this.sourceURL = fetchResponse.response.url;
      }
      try {
        const html = await fetchResponse.responseHTML;
        if (html) {
          const { body } = parseHTMLDocument(html);
          const snapshot = new Snapshot(await this.extractForeignFrameElement(body));
          const renderer = new FrameRenderer(this.view.snapshot, snapshot, false, false);
          if (this.view.renderPromise)
            await this.view.renderPromise;
          await this.view.render(renderer);
          session.frameRendered(fetchResponse, this.element);
          session.frameLoaded(this.element);
          this.fetchResponseLoaded(fetchResponse);
        }
      } catch (error2) {
        console.error(error2);
        this.view.invalidate();
      } finally {
        this.fetchResponseLoaded = () => {
        };
      }
    }
    elementAppearedInViewport(element) {
      this.loadSourceURL();
    }
    shouldInterceptLinkClick(element, url) {
      if (element.hasAttribute("data-turbo-method")) {
        return false;
      } else {
        return this.shouldInterceptNavigation(element);
      }
    }
    linkClickIntercepted(element, url) {
      this.reloadable = true;
      this.navigateFrame(element, url);
    }
    shouldInterceptFormSubmission(element, submitter) {
      return this.shouldInterceptNavigation(element, submitter);
    }
    formSubmissionIntercepted(element, submitter) {
      if (this.formSubmission) {
        this.formSubmission.stop();
      }
      this.reloadable = false;
      this.formSubmission = new FormSubmission(this, element, submitter);
      const { fetchRequest } = this.formSubmission;
      this.prepareHeadersForRequest(fetchRequest.headers, fetchRequest);
      this.formSubmission.start();
    }
    prepareHeadersForRequest(headers, request) {
      headers["Turbo-Frame"] = this.id;
    }
    requestStarted(request) {
      markAsBusy(this.element);
    }
    requestPreventedHandlingResponse(request, response) {
      this.resolveVisitPromise();
    }
    async requestSucceededWithResponse(request, response) {
      await this.loadResponse(response);
      this.resolveVisitPromise();
    }
    requestFailedWithResponse(request, response) {
      console.error(response);
      this.resolveVisitPromise();
    }
    requestErrored(request, error2) {
      console.error(error2);
      this.resolveVisitPromise();
    }
    requestFinished(request) {
      clearBusyState(this.element);
    }
    formSubmissionStarted({ formElement }) {
      markAsBusy(formElement, this.findFrameElement(formElement));
    }
    formSubmissionSucceededWithResponse(formSubmission, response) {
      const frame = this.findFrameElement(formSubmission.formElement, formSubmission.submitter);
      this.proposeVisitIfNavigatedWithAction(frame, formSubmission.formElement, formSubmission.submitter);
      frame.delegate.loadResponse(response);
    }
    formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      this.element.delegate.loadResponse(fetchResponse);
    }
    formSubmissionErrored(formSubmission, error2) {
      console.error(error2);
    }
    formSubmissionFinished({ formElement }) {
      clearBusyState(formElement, this.findFrameElement(formElement));
    }
    allowsImmediateRender(snapshot, resume) {
      return true;
    }
    viewRenderedSnapshot(snapshot, isPreview) {
    }
    viewInvalidated() {
    }
    async visit(url) {
      var _a;
      const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams(), this.element);
      (_a = this.currentFetchRequest) === null || _a === void 0 ? void 0 : _a.cancel();
      this.currentFetchRequest = request;
      return new Promise((resolve2) => {
        this.resolveVisitPromise = () => {
          this.resolveVisitPromise = () => {
          };
          this.currentFetchRequest = null;
          resolve2();
        };
        request.perform();
      });
    }
    navigateFrame(element, url, submitter) {
      const frame = this.findFrameElement(element, submitter);
      this.proposeVisitIfNavigatedWithAction(frame, element, submitter);
      frame.setAttribute("reloadable", "");
      frame.src = url;
    }
    proposeVisitIfNavigatedWithAction(frame, element, submitter) {
      const action = getAttribute("data-turbo-action", submitter, element, frame);
      if (isAction(action)) {
        const { visitCachedSnapshot } = new SnapshotSubstitution(frame);
        frame.delegate.fetchResponseLoaded = (fetchResponse) => {
          if (frame.src) {
            const { statusCode, redirected } = fetchResponse;
            const responseHTML = frame.ownerDocument.documentElement.outerHTML;
            const response = { statusCode, redirected, responseHTML };
            session.visit(frame.src, { action, response, visitCachedSnapshot, willRender: false });
          }
        };
      }
    }
    findFrameElement(element, submitter) {
      var _a;
      const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
      return (_a = getFrameElementById(id)) !== null && _a !== void 0 ? _a : this.element;
    }
    async extractForeignFrameElement(container) {
      let element;
      const id = CSS.escape(this.id);
      try {
        if (element = activateElement(container.querySelector(`turbo-frame#${id}`), this.currentURL)) {
          return element;
        }
        if (element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id}]`), this.currentURL)) {
          await element.loaded;
          return await this.extractForeignFrameElement(element);
        }
        console.error(`Response has no matching <turbo-frame id="${id}"> element`);
      } catch (error2) {
        console.error(error2);
      }
      return new FrameElement();
    }
    formActionIsVisitable(form, submitter) {
      const action = getAction(form, submitter);
      return locationIsVisitable(expandURL(action), this.rootLocation);
    }
    shouldInterceptNavigation(element, submitter) {
      const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
      if (element instanceof HTMLFormElement && !this.formActionIsVisitable(element, submitter)) {
        return false;
      }
      if (!this.enabled || id == "_top") {
        return false;
      }
      if (id) {
        const frameElement = getFrameElementById(id);
        if (frameElement) {
          return !frameElement.disabled;
        }
      }
      if (!session.elementDriveEnabled(element)) {
        return false;
      }
      if (submitter && !session.elementDriveEnabled(submitter)) {
        return false;
      }
      return true;
    }
    get id() {
      return this.element.id;
    }
    get enabled() {
      return !this.element.disabled;
    }
    get sourceURL() {
      if (this.element.src) {
        return this.element.src;
      }
    }
    get reloadable() {
      const frame = this.findFrameElement(this.element);
      return frame.hasAttribute("reloadable");
    }
    set reloadable(value) {
      const frame = this.findFrameElement(this.element);
      if (value) {
        frame.setAttribute("reloadable", "");
      } else {
        frame.removeAttribute("reloadable");
      }
    }
    set sourceURL(sourceURL) {
      this.settingSourceURL = true;
      this.element.src = sourceURL !== null && sourceURL !== void 0 ? sourceURL : null;
      this.currentURL = this.element.src;
      this.settingSourceURL = false;
    }
    get loadingStyle() {
      return this.element.loading;
    }
    get isLoading() {
      return this.formSubmission !== void 0 || this.resolveVisitPromise() !== void 0;
    }
    get isActive() {
      return this.element.isActive && this.connected;
    }
    get rootLocation() {
      var _a;
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const root = (_a = meta === null || meta === void 0 ? void 0 : meta.content) !== null && _a !== void 0 ? _a : "/";
      return expandURL(root);
    }
  };
  var SnapshotSubstitution = class {
    constructor(element) {
      this.visitCachedSnapshot = ({ element: element2 }) => {
        var _a;
        const { id, clone } = this;
        (_a = element2.querySelector("#" + id)) === null || _a === void 0 ? void 0 : _a.replaceWith(clone);
      };
      this.clone = element.cloneNode(true);
      this.id = element.id;
    }
  };
  function getFrameElementById(id) {
    if (id != null) {
      const element = document.getElementById(id);
      if (element instanceof FrameElement) {
        return element;
      }
    }
  }
  function activateElement(element, currentURL) {
    if (element) {
      const src = element.getAttribute("src");
      if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {
        throw new Error(`Matching <turbo-frame id="${element.id}"> element has a source URL which references itself`);
      }
      if (element.ownerDocument !== document) {
        element = document.importNode(element, true);
      }
      if (element instanceof FrameElement) {
        element.connectedCallback();
        element.disconnectedCallback();
        return element;
      }
    }
  }
  var StreamActions = {
    after() {
      this.targetElements.forEach((e2) => {
        var _a;
        return (_a = e2.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(this.templateContent, e2.nextSibling);
      });
    },
    append() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e2) => e2.append(this.templateContent));
    },
    before() {
      this.targetElements.forEach((e2) => {
        var _a;
        return (_a = e2.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(this.templateContent, e2);
      });
    },
    prepend() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e2) => e2.prepend(this.templateContent));
    },
    remove() {
      this.targetElements.forEach((e2) => e2.remove());
    },
    replace() {
      this.targetElements.forEach((e2) => e2.replaceWith(this.templateContent));
    },
    update() {
      this.targetElements.forEach((e2) => {
        e2.innerHTML = "";
        e2.append(this.templateContent);
      });
    }
  };
  var StreamElement = class extends HTMLElement {
    async connectedCallback() {
      try {
        await this.render();
      } catch (error2) {
        console.error(error2);
      } finally {
        this.disconnect();
      }
    }
    async render() {
      var _a;
      return (_a = this.renderPromise) !== null && _a !== void 0 ? _a : this.renderPromise = (async () => {
        if (this.dispatchEvent(this.beforeRenderEvent)) {
          await nextAnimationFrame();
          this.performAction();
        }
      })();
    }
    disconnect() {
      try {
        this.remove();
      } catch (_a) {
      }
    }
    removeDuplicateTargetChildren() {
      this.duplicateChildren.forEach((c2) => c2.remove());
    }
    get duplicateChildren() {
      var _a;
      const existingChildren = this.targetElements.flatMap((e2) => [...e2.children]).filter((c2) => !!c2.id);
      const newChildrenIds = [...(_a = this.templateContent) === null || _a === void 0 ? void 0 : _a.children].filter((c2) => !!c2.id).map((c2) => c2.id);
      return existingChildren.filter((c2) => newChildrenIds.includes(c2.id));
    }
    get performAction() {
      if (this.action) {
        const actionFunction = StreamActions[this.action];
        if (actionFunction) {
          return actionFunction;
        }
        this.raise("unknown action");
      }
      this.raise("action attribute is missing");
    }
    get targetElements() {
      if (this.target) {
        return this.targetElementsById;
      } else if (this.targets) {
        return this.targetElementsByQuery;
      } else {
        this.raise("target or targets attribute is missing");
      }
    }
    get templateContent() {
      return this.templateElement.content.cloneNode(true);
    }
    get templateElement() {
      if (this.firstElementChild instanceof HTMLTemplateElement) {
        return this.firstElementChild;
      }
      this.raise("first child element must be a <template> element");
    }
    get action() {
      return this.getAttribute("action");
    }
    get target() {
      return this.getAttribute("target");
    }
    get targets() {
      return this.getAttribute("targets");
    }
    raise(message) {
      throw new Error(`${this.description}: ${message}`);
    }
    get description() {
      var _a, _b;
      return (_b = ((_a = this.outerHTML.match(/<[^>]+>/)) !== null && _a !== void 0 ? _a : [])[0]) !== null && _b !== void 0 ? _b : "<turbo-stream>";
    }
    get beforeRenderEvent() {
      return new CustomEvent("turbo:before-stream-render", { bubbles: true, cancelable: true });
    }
    get targetElementsById() {
      var _a;
      const element = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.getElementById(this.target);
      if (element !== null) {
        return [element];
      } else {
        return [];
      }
    }
    get targetElementsByQuery() {
      var _a;
      const elements = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.querySelectorAll(this.targets);
      if (elements.length !== 0) {
        return Array.prototype.slice.call(elements);
      } else {
        return [];
      }
    }
  };
  FrameElement.delegateConstructor = FrameController;
  customElements.define("turbo-frame", FrameElement);
  customElements.define("turbo-stream", StreamElement);
  (() => {
    let element = document.currentScript;
    if (!element)
      return;
    if (element.hasAttribute("data-turbo-suppress-warning"))
      return;
    while (element = element.parentElement) {
      if (element == document.body) {
        return console.warn(unindent`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your applications JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `, element.outerHTML);
      }
    }
  })();
  window.Turbo = Turbo;
  start();

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable.js
  var consumer;
  async function getConsumer() {
    return consumer || setConsumer(createConsumer2().then(setConsumer));
  }
  function setConsumer(newConsumer) {
    return consumer = newConsumer;
  }
  async function createConsumer2() {
    const { createConsumer: createConsumer3 } = await Promise.resolve().then(() => (init_src(), src_exports));
    return createConsumer3();
  }
  async function subscribeTo(channel, mixin) {
    const { subscriptions } = await getConsumer();
    return subscriptions.create(channel, mixin);
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable_stream_source_element.js
  var TurboCableStreamSourceElement = class extends HTMLElement {
    async connectedCallback() {
      connectStreamSource(this);
      this.subscription = await subscribeTo(this.channel, { received: this.dispatchMessageEvent.bind(this) });
    }
    disconnectedCallback() {
      disconnectStreamSource(this);
      if (this.subscription)
        this.subscription.unsubscribe();
    }
    dispatchMessageEvent(data) {
      const event = new MessageEvent("message", { data });
      return this.dispatchEvent(event);
    }
    get channel() {
      const channel = this.getAttribute("channel");
      const signed_stream_name = this.getAttribute("signed-stream-name");
      return { channel, signed_stream_name };
    }
  };
  customElements.define("turbo-cable-stream-source", TurboCableStreamSourceElement);

  // app/javascript/avo.js
  var import_ujs = __toESM(require_rails_ujs());

  // node_modules/@popperjs/core/lib/enums.js
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start2 = "start";
  var end = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
    return acc.concat([placement + "-" + start2, placement + "-" + end]);
  }, []);
  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start2, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  // node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindow.js
  function getWindow(node) {
    if (node.toString() !== "[object Window]") {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
  }

  // node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }
  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }
  function isShadowRoot(node) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }

  // node_modules/@popperjs/core/lib/modifiers/applyStyles.js
  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
      var style = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name];
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(name2) {
        var value = attributes[name2];
        if (value === false) {
          element.removeAttribute(name2);
        } else {
          element.setAttribute(name2, value === true ? "" : value);
        }
      });
    });
  }
  function effect(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
        var style = styleProperties.reduce(function(style2, property) {
          style2[property] = "";
          return style2;
        }, {});
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  var applyStyles_default = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect,
    requires: ["computeStyles"]
  };

  // node_modules/@popperjs/core/lib/utils/getBasePlacement.js
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }

  // node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
  function getLayoutRect(element) {
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/contains.js
  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child)) {
      return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;
      do {
        if (next && parent.isSameNode(next)) {
          return true;
        }
        next = next.parentNode || next.host;
      } while (next);
    }
    return false;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
  function getComputedStyle2(element) {
    return getWindow(element).getComputedStyle(element);
  }

  // node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
  }

  // node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = navigator.userAgent.toLowerCase().includes("firefox");
    var currentNode = getParentNode(element);
    while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle2(currentNode);
      if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].includes(css.willChange) || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }

  // node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }

  // node_modules/@popperjs/core/lib/utils/math.js
  var max = Math.max;
  var min = Math.min;
  var round = Math.round;

  // node_modules/@popperjs/core/lib/utils/within.js
  function within(min2, value, max2) {
    return max(min2, min(value, max2));
  }

  // node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  // node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  // node_modules/@popperjs/core/lib/utils/expandToHashMap.js
  function expandToHashMap(value, keys) {
    return keys.reduce(function(hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  // node_modules/@popperjs/core/lib/modifiers/arrow.js
  var toPaddingObject = function toPaddingObject2(padding, state) {
    padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  };
  function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) {
      return;
    }
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min2 = paddingObject[minProp];
    var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset2 = within(min2, center, max2);
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
  }
  function effect2(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (true) {
      if (!isHTMLElement(arrowElement)) {
        console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
      }
    }
    if (!contains(state.elements.popper, arrowElement)) {
      if (true) {
        console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      }
      return;
    }
    state.elements.arrow = arrowElement;
  }
  var arrow_default = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect2,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };

  // node_modules/@popperjs/core/lib/modifiers/computeStyles.js
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref) {
    var x2 = _ref.x, y2 = _ref.y;
    var win = window;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(round(x2 * dpr) / dpr) || 0,
      y: round(round(y2 * dpr) / dpr) || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets;
    var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === "function" ? roundOffsets(offsets) : offsets, _ref3$x = _ref3.x, x2 = _ref3$x === void 0 ? 0 : _ref3$x, _ref3$y = _ref3.y, y2 = _ref3$y === void 0 ? 0 : _ref3$y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper2);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper2)) {
        offsetParent = getDocumentElement(popper2);
        if (getComputedStyle2(offsetParent).position !== "static") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      if (placement === top) {
        sideY = bottom;
        y2 -= offsetParent[heightProp] - popperRect.height;
        y2 *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left) {
        sideX = right;
        x2 -= offsetParent[widthProp] - popperRect.width;
        x2 *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position
    }, adaptive && unsetSides);
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref4) {
    var state = _ref4.state, options = _ref4.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    if (true) {
      var transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
      if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
        return transitionProperty.indexOf(property) >= 0;
      })) {
        console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
      }
    }
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  var computeStyles_default = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };

  // node_modules/@popperjs/core/lib/modifiers/eventListeners.js
  var passive = {
    passive: true
  };
  function effect3(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance.update, passive);
      }
    };
  }
  var eventListeners_default = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect: effect3,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
  var hash = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash[matched];
    });
  }

  // node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
  var hash2 = {
    start: "end",
    end: "start"
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash2[matched];
    });
  }

  // node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
  function getBoundingClientRect(element) {
    var rect = element.getBoundingClientRect();
    return {
      width: rect.width,
      height: rect.height,
      top: rect.top,
      right: rect.right,
      bottom: rect.bottom,
      left: rect.left,
      x: rect.left,
      y: rect.top
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
  function getViewportRect(element) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x2 = 0;
    var y2 = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
        x2 = visualViewport.offsetLeft;
        y2 = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x2 + getWindowScrollBarX(element),
      y: y2
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
  function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y2 = -winScroll.scrollTop;
    if (getComputedStyle2(body || html).direction === "rtl") {
      x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }
    return {
      width,
      height,
      x: x2,
      y: y2
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  // node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
  function getScrollParent(node) {
    if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
      return node.ownerDocument.body;
    }
    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }
    return getScrollParent(getParentNode(node));
  }

  // node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
  }

  // node_modules/@popperjs/core/lib/utils/rectToClientRect.js
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  // node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
  function getInnerBoundingClientRect(element) {
    var rect = getBoundingClientRect(element);
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType(element, clippingParent) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }
  function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) {
      return [];
    }
    return clippingParents2.filter(function(clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
  }
  function getClippingRect(element, boundary, rootBoundary) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  // node_modules/@popperjs/core/lib/utils/getVariation.js
  function getVariation(placement) {
    return placement.split("-")[1];
  }

  // node_modules/@popperjs/core/lib/utils/computeOffsets.js
  function computeOffsets(_ref) {
    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference2.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case right:
        offsets = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference2.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference2.x,
          y: reference2.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start2:
          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
          break;
        default:
      }
    }
    return offsets;
  }

  // node_modules/@popperjs/core/lib/utils/detectOverflow.js
  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var referenceElement = state.elements.reference;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
    var referenceClientRect = getBoundingClientRect(referenceElement);
    var popperOffsets2 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset2 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset2[axis] * multiply;
      });
    }
    return overflowOffsets;
  }

  // node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements2.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements2;
      if (true) {
        console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
      }
    }
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      acc[placement2] = detectOverflow(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding
      })[getBasePlacement(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function(a2, b2) {
      return overflows[a2] - overflows[b2];
    });
  }

  // node_modules/@popperjs/core/lib/modifiers/flip.js
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) {
      return;
    }
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements2[0];
    for (var i2 = 0; i2 < placements2.length; i2++) {
      var placement = placements2[i2];
      var _basePlacement = getBasePlacement(placement);
      var isStartVariation = getVariation(placement) === start2;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function(check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop2(_i2) {
        var fittingPlacement = placements2.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i2).every(function(check) {
              return check;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);
        if (_ret === "break")
          break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  }
  var flip_default = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };

  // node_modules/@popperjs/core/lib/modifiers/hide.js
  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  var hide_default = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
  };

  // node_modules/@popperjs/core/lib/modifiers/offset.js
  function distanceAndSkiddingToXY(placement, rects, offset2) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
      placement
    })) : offset2, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x2;
      state.modifiersData.popperOffsets.y += y2;
    }
    state.modifiersData[name] = data;
  }
  var offset_default = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };

  // node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
  function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  var popperOffsets_default = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getAltAxis.js
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }

  // node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
  function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary,
      rootBoundary,
      padding,
      altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var data = {
      x: 0,
      y: 0
    };
    if (!popperOffsets2) {
      return;
    }
    if (checkMainAxis || checkAltAxis) {
      var mainSide = mainAxis === "y" ? top : left;
      var altSide = mainAxis === "y" ? bottom : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset2 = popperOffsets2[mainAxis];
      var min2 = popperOffsets2[mainAxis] + overflow[mainSide];
      var max2 = popperOffsets2[mainAxis] - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start2 ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start2 ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
      var tetherMin = popperOffsets2[mainAxis] + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = popperOffsets2[mainAxis] + maxOffset - offsetModifierValue;
      if (checkMainAxis) {
        var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
        popperOffsets2[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset2;
      }
      if (checkAltAxis) {
        var _mainSide = mainAxis === "x" ? top : left;
        var _altSide = mainAxis === "x" ? bottom : right;
        var _offset = popperOffsets2[altAxis];
        var _min = _offset + overflow[_mainSide];
        var _max = _offset - overflow[_altSide];
        var _preventedOffset = within(tether ? min(_min, tetherMin) : _min, _offset, tether ? max(_max, tetherMax) : _max);
        popperOffsets2[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
      }
    }
    state.modifiersData[name] = data;
  }
  var preventOverflow_default = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
  };

  // node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }

  // node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement);
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  // node_modules/@popperjs/core/lib/utils/orderModifiers.js
  function order(modifiers) {
    var map = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
      map.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  // node_modules/@popperjs/core/lib/utils/debounce.js
  function debounce(fn2) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve2) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve2(fn2());
          });
        });
      }
      return pending;
    };
  }

  // node_modules/@popperjs/core/lib/utils/format.js
  function format(str) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return [].concat(args).reduce(function(p2, c2) {
      return p2.replace(/%s/, c2);
    }, str);
  }

  // node_modules/@popperjs/core/lib/utils/validateModifiers.js
  var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
  var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
  var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
  function validateModifiers(modifiers) {
    modifiers.forEach(function(modifier) {
      Object.keys(modifier).forEach(function(key) {
        switch (key) {
          case "name":
            if (typeof modifier.name !== "string") {
              console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
            }
            break;
          case "enabled":
            if (typeof modifier.enabled !== "boolean") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
            }
          case "phase":
            if (modifierPhases.indexOf(modifier.phase) < 0) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
            }
            break;
          case "fn":
            if (typeof modifier.fn !== "function") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "effect":
            if (typeof modifier.effect !== "function") {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "requires":
            if (!Array.isArray(modifier.requires)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
            }
            break;
          case "requiresIfExists":
            if (!Array.isArray(modifier.requiresIfExists)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
            }
            break;
          case "options":
          case "data":
            break;
          default:
            console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s2) {
              return '"' + s2 + '"';
            }).join(", ") + '; but "' + key + '" was provided.');
        }
        modifier.requires && modifier.requires.forEach(function(requirement) {
          if (modifiers.find(function(mod) {
            return mod.name === requirement;
          }) == null) {
            console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
          }
        });
      });
    });
  }

  // node_modules/@popperjs/core/lib/utils/uniqueBy.js
  function uniqueBy(arr, fn2) {
    var identifiers = /* @__PURE__ */ new Set();
    return arr.filter(function(item) {
      var identifier = fn2(item);
      if (!identifiers.has(identifier)) {
        identifiers.add(identifier);
        return true;
      }
    });
  }

  // node_modules/@popperjs/core/lib/utils/mergeByName.js
  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }

  // node_modules/@popperjs/core/lib/createPopper.js
  var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
  var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper2(reference2, popper2, options) {
      if (options === void 0) {
        options = defaultOptions2;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
        modifiersData: {},
        elements: {
          reference: reference2,
          popper: popper2
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state,
        setOptions: function setOptions(options2) {
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions2, state.options, options2);
          state.scrollParents = {
            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
            popper: listScrollParents(popper2)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m2) {
            return m2.enabled;
          });
          if (true) {
            var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
              var name = _ref.name;
              return name;
            });
            validateModifiers(modifiers);
            if (getBasePlacement(state.options.placement) === auto) {
              var flipModifier = state.orderedModifiers.find(function(_ref2) {
                var name = _ref2.name;
                return name === "flip";
              });
              if (!flipModifier) {
                console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
              }
            }
            var _getComputedStyle = getComputedStyle2(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
            if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
              return parseFloat(margin);
            })) {
              console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
            }
          }
          runModifierEffects();
          return instance.update();
        },
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
          if (!areValidElements(reference3, popper3)) {
            if (true) {
              console.error(INVALID_ELEMENT_ERROR);
            }
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper3)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          var __debug_loops__ = 0;
          for (var index = 0; index < state.orderedModifiers.length; index++) {
            if (true) {
              __debug_loops__ += 1;
              if (__debug_loops__ > 100) {
                console.error(INFINITE_LOOP_ERROR);
                break;
              }
            }
            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
            if (typeof fn2 === "function") {
              state = fn2({
                state,
                options: _options,
                name,
                instance
              }) || state;
            }
          }
        },
        update: debounce(function() {
          return new Promise(function(resolve2) {
            instance.forceUpdate();
            resolve2(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference2, popper2)) {
        if (true) {
          console.error(INVALID_ELEMENT_ERROR);
        }
        return instance;
      }
      instance.setOptions(options).then(function(state2) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref3) {
          var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
          if (typeof effect4 === "function") {
            var cleanupFn = effect4({
              state,
              name,
              instance,
              options: options2
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn2) {
          return fn2();
        });
        effectCleanupFns = [];
      }
      return instance;
    };
  }

  // node_modules/@popperjs/core/lib/popper.js
  var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
  var createPopper = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });

  // node_modules/tippy.js/dist/tippy.esm.js
  var BOX_CLASS = "tippy-box";
  var CONTENT_CLASS = "tippy-content";
  var BACKDROP_CLASS = "tippy-backdrop";
  var ARROW_CLASS = "tippy-arrow";
  var SVG_ARROW_CLASS = "tippy-svg-arrow";
  var TOUCH_OPTIONS = {
    passive: true,
    capture: true
  };
  function hasOwnProperty(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
  }
  function getValueAtIndexOrReturn(value, index, defaultValue) {
    if (Array.isArray(value)) {
      var v2 = value[index];
      return v2 == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v2;
    }
    return value;
  }
  function isType(value, type) {
    var str = {}.toString.call(value);
    return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
  }
  function invokeWithArgsOrReturn(value, args) {
    return typeof value === "function" ? value.apply(void 0, args) : value;
  }
  function debounce2(fn2, ms) {
    if (ms === 0) {
      return fn2;
    }
    var timeout;
    return function(arg) {
      clearTimeout(timeout);
      timeout = setTimeout(function() {
        fn2(arg);
      }, ms);
    };
  }
  function removeProperties(obj, keys) {
    var clone = Object.assign({}, obj);
    keys.forEach(function(key) {
      delete clone[key];
    });
    return clone;
  }
  function splitBySpaces(value) {
    return value.split(/\s+/).filter(Boolean);
  }
  function normalizeToArray(value) {
    return [].concat(value);
  }
  function pushIfUnique(arr, value) {
    if (arr.indexOf(value) === -1) {
      arr.push(value);
    }
  }
  function unique(arr) {
    return arr.filter(function(item, index) {
      return arr.indexOf(item) === index;
    });
  }
  function getBasePlacement2(placement) {
    return placement.split("-")[0];
  }
  function arrayFrom(value) {
    return [].slice.call(value);
  }
  function removeUndefinedProps(obj) {
    return Object.keys(obj).reduce(function(acc, key) {
      if (obj[key] !== void 0) {
        acc[key] = obj[key];
      }
      return acc;
    }, {});
  }
  function div() {
    return document.createElement("div");
  }
  function isElement2(value) {
    return ["Element", "Fragment"].some(function(type) {
      return isType(value, type);
    });
  }
  function isNodeList(value) {
    return isType(value, "NodeList");
  }
  function isMouseEvent(value) {
    return isType(value, "MouseEvent");
  }
  function isReferenceElement(value) {
    return !!(value && value._tippy && value._tippy.reference === value);
  }
  function getArrayOfElements(value) {
    if (isElement2(value)) {
      return [value];
    }
    if (isNodeList(value)) {
      return arrayFrom(value);
    }
    if (Array.isArray(value)) {
      return value;
    }
    return arrayFrom(document.querySelectorAll(value));
  }
  function setTransitionDuration(els, value) {
    els.forEach(function(el) {
      if (el) {
        el.style.transitionDuration = value + "ms";
      }
    });
  }
  function setVisibilityState(els, state) {
    els.forEach(function(el) {
      if (el) {
        el.setAttribute("data-state", state);
      }
    });
  }
  function getOwnerDocument(elementOrElements) {
    var _element$ownerDocumen;
    var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];
    return (element == null ? void 0 : (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body) ? element.ownerDocument : document;
  }
  function isCursorOutsideInteractiveBorder(popperTreeData, event) {
    var clientX = event.clientX, clientY = event.clientY;
    return popperTreeData.every(function(_ref) {
      var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
      var interactiveBorder = props.interactiveBorder;
      var basePlacement = getBasePlacement2(popperState.placement);
      var offsetData = popperState.modifiersData.offset;
      if (!offsetData) {
        return true;
      }
      var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
      var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
      var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
      var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
      var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
      var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
      var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
      var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
      return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
    });
  }
  function updateTransitionEndListener(box, action, listener) {
    var method = action + "EventListener";
    ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
      box[method](event, listener);
    });
  }
  var currentInput = {
    isTouch: false
  };
  var lastMouseMoveTime = 0;
  function onDocumentTouchStart() {
    if (currentInput.isTouch) {
      return;
    }
    currentInput.isTouch = true;
    if (window.performance) {
      document.addEventListener("mousemove", onDocumentMouseMove);
    }
  }
  function onDocumentMouseMove() {
    var now2 = performance.now();
    if (now2 - lastMouseMoveTime < 20) {
      currentInput.isTouch = false;
      document.removeEventListener("mousemove", onDocumentMouseMove);
    }
    lastMouseMoveTime = now2;
  }
  function onWindowBlur() {
    var activeElement = document.activeElement;
    if (isReferenceElement(activeElement)) {
      var instance = activeElement._tippy;
      if (activeElement.blur && !instance.state.isVisible) {
        activeElement.blur();
      }
    }
  }
  function bindGlobalEventListeners() {
    document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
    window.addEventListener("blur", onWindowBlur);
  }
  var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
  var ua = isBrowser ? navigator.userAgent : "";
  var isIE = /MSIE |Trident\//.test(ua);
  function createMemoryLeakWarning(method) {
    var txt = method === "destroy" ? "n already-" : " ";
    return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
  }
  function clean(value) {
    var spacesAndTabs = /[ \t]{2,}/g;
    var lineStartWithSpaces = /^[ \t]*/gm;
    return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
  }
  function getDevMessage(message) {
    return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\u{1F477}\u200D This is a development-only message. It will be removed in production.\n  ");
  }
  function getFormattedMessage(message) {
    return [
      getDevMessage(message),
      "color: #00C584; font-size: 1.3em; font-weight: bold;",
      "line-height: 1.5",
      "color: #a6a095;"
    ];
  }
  var visitedMessages;
  if (true) {
    resetVisitedMessages();
  }
  function resetVisitedMessages() {
    visitedMessages = /* @__PURE__ */ new Set();
  }
  function warnWhen(condition, message) {
    if (condition && !visitedMessages.has(message)) {
      var _console;
      visitedMessages.add(message);
      (_console = console).warn.apply(_console, getFormattedMessage(message));
    }
  }
  function errorWhen(condition, message) {
    if (condition && !visitedMessages.has(message)) {
      var _console2;
      visitedMessages.add(message);
      (_console2 = console).error.apply(_console2, getFormattedMessage(message));
    }
  }
  function validateTargets(targets) {
    var didPassFalsyValue = !targets;
    var didPassPlainObject = Object.prototype.toString.call(targets) === "[object Object]" && !targets.addEventListener;
    errorWhen(didPassFalsyValue, ["tippy() was passed", "`" + String(targets) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" "));
    errorWhen(didPassPlainObject, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
  }
  var pluginProps = {
    animateFill: false,
    followCursor: false,
    inlinePositioning: false,
    sticky: false
  };
  var renderProps = {
    allowHTML: false,
    animation: "fade",
    arrow: true,
    content: "",
    inertia: false,
    maxWidth: 350,
    role: "tooltip",
    theme: "",
    zIndex: 9999
  };
  var defaultProps = Object.assign({
    appendTo: function appendTo() {
      return document.body;
    },
    aria: {
      content: "auto",
      expanded: "auto"
    },
    delay: 0,
    duration: [300, 250],
    getReferenceClientRect: null,
    hideOnClick: true,
    ignoreAttributes: false,
    interactive: false,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    moveTransition: "",
    offset: [0, 10],
    onAfterUpdate: function onAfterUpdate() {
    },
    onBeforeUpdate: function onBeforeUpdate() {
    },
    onCreate: function onCreate() {
    },
    onDestroy: function onDestroy() {
    },
    onHidden: function onHidden() {
    },
    onHide: function onHide() {
    },
    onMount: function onMount() {
    },
    onShow: function onShow() {
    },
    onShown: function onShown() {
    },
    onTrigger: function onTrigger() {
    },
    onUntrigger: function onUntrigger() {
    },
    onClickOutside: function onClickOutside() {
    },
    placement: "top",
    plugins: [],
    popperOptions: {},
    render: null,
    showOnCreate: false,
    touch: true,
    trigger: "mouseenter focus",
    triggerTarget: null
  }, pluginProps, {}, renderProps);
  var defaultKeys = Object.keys(defaultProps);
  var setDefaultProps = function setDefaultProps2(partialProps) {
    if (true) {
      validateProps(partialProps, []);
    }
    var keys = Object.keys(partialProps);
    keys.forEach(function(key) {
      defaultProps[key] = partialProps[key];
    });
  };
  function getExtendedPassedProps(passedProps) {
    var plugins = passedProps.plugins || [];
    var pluginProps2 = plugins.reduce(function(acc, plugin) {
      var name = plugin.name, defaultValue = plugin.defaultValue;
      if (name) {
        acc[name] = passedProps[name] !== void 0 ? passedProps[name] : defaultValue;
      }
      return acc;
    }, {});
    return Object.assign({}, passedProps, {}, pluginProps2);
  }
  function getDataAttributeProps(reference2, plugins) {
    var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
      plugins
    }))) : defaultKeys;
    var props = propKeys.reduce(function(acc, key) {
      var valueAsString = (reference2.getAttribute("data-tippy-" + key) || "").trim();
      if (!valueAsString) {
        return acc;
      }
      if (key === "content") {
        acc[key] = valueAsString;
      } else {
        try {
          acc[key] = JSON.parse(valueAsString);
        } catch (e2) {
          acc[key] = valueAsString;
        }
      }
      return acc;
    }, {});
    return props;
  }
  function evaluateProps(reference2, props) {
    var out = Object.assign({}, props, {
      content: invokeWithArgsOrReturn(props.content, [reference2])
    }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));
    out.aria = Object.assign({}, defaultProps.aria, {}, out.aria);
    out.aria = {
      expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
      content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
    };
    return out;
  }
  function validateProps(partialProps, plugins) {
    if (partialProps === void 0) {
      partialProps = {};
    }
    if (plugins === void 0) {
      plugins = [];
    }
    var keys = Object.keys(partialProps);
    keys.forEach(function(prop) {
      var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
      var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop);
      if (didPassUnknownProp) {
        didPassUnknownProp = plugins.filter(function(plugin) {
          return plugin.name === prop;
        }).length === 0;
      }
      warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", "\n\n", "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n", "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
    });
  }
  var innerHTML = function innerHTML2() {
    return "innerHTML";
  };
  function dangerouslySetInnerHTML(element, html) {
    element[innerHTML()] = html;
  }
  function createArrowElement(value) {
    var arrow2 = div();
    if (value === true) {
      arrow2.className = ARROW_CLASS;
    } else {
      arrow2.className = SVG_ARROW_CLASS;
      if (isElement2(value)) {
        arrow2.appendChild(value);
      } else {
        dangerouslySetInnerHTML(arrow2, value);
      }
    }
    return arrow2;
  }
  function setContent(content, props) {
    if (isElement2(props.content)) {
      dangerouslySetInnerHTML(content, "");
      content.appendChild(props.content);
    } else if (typeof props.content !== "function") {
      if (props.allowHTML) {
        dangerouslySetInnerHTML(content, props.content);
      } else {
        content.textContent = props.content;
      }
    }
  }
  function getChildren(popper2) {
    var box = popper2.firstElementChild;
    var boxChildren = arrayFrom(box.children);
    return {
      box,
      content: boxChildren.find(function(node) {
        return node.classList.contains(CONTENT_CLASS);
      }),
      arrow: boxChildren.find(function(node) {
        return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
      }),
      backdrop: boxChildren.find(function(node) {
        return node.classList.contains(BACKDROP_CLASS);
      })
    };
  }
  function render(instance) {
    var popper2 = div();
    var box = div();
    box.className = BOX_CLASS;
    box.setAttribute("data-state", "hidden");
    box.setAttribute("tabindex", "-1");
    var content = div();
    content.className = CONTENT_CLASS;
    content.setAttribute("data-state", "hidden");
    setContent(content, instance.props);
    popper2.appendChild(box);
    box.appendChild(content);
    onUpdate(instance.props, instance.props);
    function onUpdate(prevProps, nextProps) {
      var _getChildren = getChildren(popper2), box2 = _getChildren.box, content2 = _getChildren.content, arrow2 = _getChildren.arrow;
      if (nextProps.theme) {
        box2.setAttribute("data-theme", nextProps.theme);
      } else {
        box2.removeAttribute("data-theme");
      }
      if (typeof nextProps.animation === "string") {
        box2.setAttribute("data-animation", nextProps.animation);
      } else {
        box2.removeAttribute("data-animation");
      }
      if (nextProps.inertia) {
        box2.setAttribute("data-inertia", "");
      } else {
        box2.removeAttribute("data-inertia");
      }
      box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
      if (nextProps.role) {
        box2.setAttribute("role", nextProps.role);
      } else {
        box2.removeAttribute("role");
      }
      if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
        setContent(content2, instance.props);
      }
      if (nextProps.arrow) {
        if (!arrow2) {
          box2.appendChild(createArrowElement(nextProps.arrow));
        } else if (prevProps.arrow !== nextProps.arrow) {
          box2.removeChild(arrow2);
          box2.appendChild(createArrowElement(nextProps.arrow));
        }
      } else if (arrow2) {
        box2.removeChild(arrow2);
      }
    }
    return {
      popper: popper2,
      onUpdate
    };
  }
  render.$$tippy = true;
  var idCounter = 1;
  var mouseMoveListeners = [];
  var mountedInstances = [];
  function createTippy(reference2, passedProps) {
    var props = evaluateProps(reference2, Object.assign({}, defaultProps, {}, getExtendedPassedProps(removeUndefinedProps(passedProps))));
    var showTimeout;
    var hideTimeout;
    var scheduleHideAnimationFrame;
    var isVisibleFromClick = false;
    var didHideDueToDocumentMouseDown = false;
    var didTouchMove = false;
    var ignoreOnFirstUpdate = false;
    var lastTriggerEvent;
    var currentTransitionEndListener;
    var onFirstUpdate;
    var listeners = [];
    var debouncedOnMouseMove = debounce2(onMouseMove, props.interactiveDebounce);
    var currentTarget;
    var id = idCounter++;
    var popperInstance = null;
    var plugins = unique(props.plugins);
    var state = {
      isEnabled: true,
      isVisible: false,
      isDestroyed: false,
      isMounted: false,
      isShown: false
    };
    var instance = {
      id,
      reference: reference2,
      popper: div(),
      popperInstance,
      props,
      state,
      plugins,
      clearDelayTimeouts,
      setProps,
      setContent: setContent2,
      show,
      hide: hide2,
      hideWithInteractivity,
      enable,
      disable,
      unmount,
      destroy
    };
    if (!props.render) {
      if (true) {
        errorWhen(true, "render() function has not been supplied.");
      }
      return instance;
    }
    var _props$render = props.render(instance), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;
    popper2.setAttribute("data-tippy-root", "");
    popper2.id = "tippy-" + instance.id;
    instance.popper = popper2;
    reference2._tippy = instance;
    popper2._tippy = instance;
    var pluginsHooks = plugins.map(function(plugin) {
      return plugin.fn(instance);
    });
    var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
    addListeners();
    handleAriaExpandedAttribute();
    handleStyles();
    invokeHook("onCreate", [instance]);
    if (props.showOnCreate) {
      scheduleShow();
    }
    popper2.addEventListener("mouseenter", function() {
      if (instance.props.interactive && instance.state.isVisible) {
        instance.clearDelayTimeouts();
      }
    });
    popper2.addEventListener("mouseleave", function(event) {
      if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) {
        getDocument().addEventListener("mousemove", debouncedOnMouseMove);
        debouncedOnMouseMove(event);
      }
    });
    return instance;
    function getNormalizedTouchSettings() {
      var touch = instance.props.touch;
      return Array.isArray(touch) ? touch : [touch, 0];
    }
    function getIsCustomTouchBehavior() {
      return getNormalizedTouchSettings()[0] === "hold";
    }
    function getIsDefaultRenderFn() {
      var _instance$props$rende;
      return !!((_instance$props$rende = instance.props.render) == null ? void 0 : _instance$props$rende.$$tippy);
    }
    function getCurrentTarget() {
      return currentTarget || reference2;
    }
    function getDocument() {
      var parent = getCurrentTarget().parentNode;
      return parent ? getOwnerDocument(parent) : document;
    }
    function getDefaultTemplateChildren() {
      return getChildren(popper2);
    }
    function getDelay(isShow) {
      if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
        return 0;
      }
      return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
    }
    function handleStyles() {
      popper2.style.pointerEvents = instance.props.interactive && instance.state.isVisible ? "" : "none";
      popper2.style.zIndex = "" + instance.props.zIndex;
    }
    function invokeHook(hook, args, shouldInvokePropsHook) {
      if (shouldInvokePropsHook === void 0) {
        shouldInvokePropsHook = true;
      }
      pluginsHooks.forEach(function(pluginHooks) {
        if (pluginHooks[hook]) {
          pluginHooks[hook].apply(void 0, args);
        }
      });
      if (shouldInvokePropsHook) {
        var _instance$props;
        (_instance$props = instance.props)[hook].apply(_instance$props, args);
      }
    }
    function handleAriaContentAttribute() {
      var aria = instance.props.aria;
      if (!aria.content) {
        return;
      }
      var attr = "aria-" + aria.content;
      var id2 = popper2.id;
      var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
      nodes.forEach(function(node) {
        var currentValue = node.getAttribute(attr);
        if (instance.state.isVisible) {
          node.setAttribute(attr, currentValue ? currentValue + " " + id2 : id2);
        } else {
          var nextValue = currentValue && currentValue.replace(id2, "").trim();
          if (nextValue) {
            node.setAttribute(attr, nextValue);
          } else {
            node.removeAttribute(attr);
          }
        }
      });
    }
    function handleAriaExpandedAttribute() {
      if (hasAriaExpanded || !instance.props.aria.expanded) {
        return;
      }
      var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
      nodes.forEach(function(node) {
        if (instance.props.interactive) {
          node.setAttribute("aria-expanded", instance.state.isVisible && node === getCurrentTarget() ? "true" : "false");
        } else {
          node.removeAttribute("aria-expanded");
        }
      });
    }
    function cleanupInteractiveMouseListeners() {
      getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
      mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
        return listener !== debouncedOnMouseMove;
      });
    }
    function onDocumentPress(event) {
      if (currentInput.isTouch) {
        if (didTouchMove || event.type === "mousedown") {
          return;
        }
      }
      if (instance.props.interactive && popper2.contains(event.target)) {
        return;
      }
      if (getCurrentTarget().contains(event.target)) {
        if (currentInput.isTouch) {
          return;
        }
        if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) {
          return;
        }
      } else {
        invokeHook("onClickOutside", [instance, event]);
      }
      if (instance.props.hideOnClick === true) {
        instance.clearDelayTimeouts();
        instance.hide();
        didHideDueToDocumentMouseDown = true;
        setTimeout(function() {
          didHideDueToDocumentMouseDown = false;
        });
        if (!instance.state.isMounted) {
          removeDocumentPress();
        }
      }
    }
    function onTouchMove() {
      didTouchMove = true;
    }
    function onTouchStart() {
      didTouchMove = false;
    }
    function addDocumentPress() {
      var doc = getDocument();
      doc.addEventListener("mousedown", onDocumentPress, true);
      doc.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
      doc.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
      doc.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
    }
    function removeDocumentPress() {
      var doc = getDocument();
      doc.removeEventListener("mousedown", onDocumentPress, true);
      doc.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
      doc.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
      doc.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
    }
    function onTransitionedOut(duration2, callback) {
      onTransitionEnd(duration2, function() {
        if (!instance.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
          callback();
        }
      });
    }
    function onTransitionedIn(duration2, callback) {
      onTransitionEnd(duration2, callback);
    }
    function onTransitionEnd(duration2, callback) {
      var box = getDefaultTemplateChildren().box;
      function listener(event) {
        if (event.target === box) {
          updateTransitionEndListener(box, "remove", listener);
          callback();
        }
      }
      if (duration2 === 0) {
        return callback();
      }
      updateTransitionEndListener(box, "remove", currentTransitionEndListener);
      updateTransitionEndListener(box, "add", listener);
      currentTransitionEndListener = listener;
    }
    function on(eventType, handler, options) {
      if (options === void 0) {
        options = false;
      }
      var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
      nodes.forEach(function(node) {
        node.addEventListener(eventType, handler, options);
        listeners.push({
          node,
          eventType,
          handler,
          options
        });
      });
    }
    function addListeners() {
      if (getIsCustomTouchBehavior()) {
        on("touchstart", onTrigger2, {
          passive: true
        });
        on("touchend", onMouseLeave, {
          passive: true
        });
      }
      splitBySpaces(instance.props.trigger).forEach(function(eventType) {
        if (eventType === "manual") {
          return;
        }
        on(eventType, onTrigger2);
        switch (eventType) {
          case "mouseenter":
            on("mouseleave", onMouseLeave);
            break;
          case "focus":
            on(isIE ? "focusout" : "blur", onBlurOrFocusOut);
            break;
          case "focusin":
            on("focusout", onBlurOrFocusOut);
            break;
        }
      });
    }
    function removeListeners() {
      listeners.forEach(function(_ref) {
        var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
        node.removeEventListener(eventType, handler, options);
      });
      listeners = [];
    }
    function onTrigger2(event) {
      var _lastTriggerEvent;
      var shouldScheduleClickHide = false;
      if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
        return;
      }
      var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
      lastTriggerEvent = event;
      currentTarget = event.currentTarget;
      handleAriaExpandedAttribute();
      if (!instance.state.isVisible && isMouseEvent(event)) {
        mouseMoveListeners.forEach(function(listener) {
          return listener(event);
        });
      }
      if (event.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
        shouldScheduleClickHide = true;
      } else {
        scheduleShow(event);
      }
      if (event.type === "click") {
        isVisibleFromClick = !shouldScheduleClickHide;
      }
      if (shouldScheduleClickHide && !wasFocused) {
        scheduleHide(event);
      }
    }
    function onMouseMove(event) {
      var target = event.target;
      var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
      if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
        return;
      }
      var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
        var _instance$popperInsta;
        var instance2 = popper3._tippy;
        var state2 = (_instance$popperInsta = instance2.popperInstance) == null ? void 0 : _instance$popperInsta.state;
        if (state2) {
          return {
            popperRect: popper3.getBoundingClientRect(),
            popperState: state2,
            props
          };
        }
        return null;
      }).filter(Boolean);
      if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
        cleanupInteractiveMouseListeners();
        scheduleHide(event);
      }
    }
    function onMouseLeave(event) {
      var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
      if (shouldBail) {
        return;
      }
      if (instance.props.interactive) {
        instance.hideWithInteractivity(event);
        return;
      }
      scheduleHide(event);
    }
    function onBlurOrFocusOut(event) {
      if (instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
        return;
      }
      if (instance.props.interactive && event.relatedTarget && popper2.contains(event.relatedTarget)) {
        return;
      }
      scheduleHide(event);
    }
    function isEventListenerStopped(event) {
      return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
    }
    function createPopperInstance() {
      destroyPopperInstance();
      var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset2 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
      var arrow2 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;
      var computedReference = getReferenceClientRect ? {
        getBoundingClientRect: getReferenceClientRect,
        contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
      } : reference2;
      var tippyModifier = {
        name: "$$tippy",
        enabled: true,
        phase: "beforeWrite",
        requires: ["computeStyles"],
        fn: function fn2(_ref2) {
          var state2 = _ref2.state;
          if (getIsDefaultRenderFn()) {
            var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
            ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
              if (attr === "placement") {
                box.setAttribute("data-placement", state2.placement);
              } else {
                if (state2.attributes.popper["data-popper-" + attr]) {
                  box.setAttribute("data-" + attr, "");
                } else {
                  box.removeAttribute("data-" + attr);
                }
              }
            });
            state2.attributes.popper = {};
          }
        }
      };
      var modifiers = [{
        name: "offset",
        options: {
          offset: offset2
        }
      }, {
        name: "preventOverflow",
        options: {
          padding: {
            top: 2,
            bottom: 2,
            left: 5,
            right: 5
          }
        }
      }, {
        name: "flip",
        options: {
          padding: 5
        }
      }, {
        name: "computeStyles",
        options: {
          adaptive: !moveTransition
        }
      }, tippyModifier];
      if (getIsDefaultRenderFn() && arrow2) {
        modifiers.push({
          name: "arrow",
          options: {
            element: arrow2,
            padding: 3
          }
        });
      }
      modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
      instance.popperInstance = createPopper(computedReference, popper2, Object.assign({}, popperOptions, {
        placement,
        onFirstUpdate,
        modifiers
      }));
    }
    function destroyPopperInstance() {
      if (instance.popperInstance) {
        instance.popperInstance.destroy();
        instance.popperInstance = null;
      }
    }
    function mount() {
      var appendTo2 = instance.props.appendTo;
      var parentNode;
      var node = getCurrentTarget();
      if (instance.props.interactive && appendTo2 === defaultProps.appendTo || appendTo2 === "parent") {
        parentNode = node.parentNode;
      } else {
        parentNode = invokeWithArgsOrReturn(appendTo2, [node]);
      }
      if (!parentNode.contains(popper2)) {
        parentNode.appendChild(popper2);
      }
      createPopperInstance();
      if (true) {
        warnWhen(instance.props.interactive && appendTo2 === defaultProps.appendTo && node.nextElementSibling !== popper2, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", "\n\n", "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", "\n\n", "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", "\n\n", "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
      }
    }
    function getNestedPopperTree() {
      return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
    }
    function scheduleShow(event) {
      instance.clearDelayTimeouts();
      if (event) {
        invokeHook("onTrigger", [instance, event]);
      }
      addDocumentPress();
      var delay = getDelay(true);
      var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
      if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
        delay = touchDelay;
      }
      if (delay) {
        showTimeout = setTimeout(function() {
          instance.show();
        }, delay);
      } else {
        instance.show();
      }
    }
    function scheduleHide(event) {
      instance.clearDelayTimeouts();
      invokeHook("onUntrigger", [instance, event]);
      if (!instance.state.isVisible) {
        removeDocumentPress();
        return;
      }
      if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
        return;
      }
      var delay = getDelay(false);
      if (delay) {
        hideTimeout = setTimeout(function() {
          if (instance.state.isVisible) {
            instance.hide();
          }
        }, delay);
      } else {
        scheduleHideAnimationFrame = requestAnimationFrame(function() {
          instance.hide();
        });
      }
    }
    function enable() {
      instance.state.isEnabled = true;
    }
    function disable() {
      instance.hide();
      instance.state.isEnabled = false;
    }
    function clearDelayTimeouts() {
      clearTimeout(showTimeout);
      clearTimeout(hideTimeout);
      cancelAnimationFrame(scheduleHideAnimationFrame);
    }
    function setProps(partialProps) {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("setProps"));
      }
      if (instance.state.isDestroyed) {
        return;
      }
      invokeHook("onBeforeUpdate", [instance, partialProps]);
      removeListeners();
      var prevProps = instance.props;
      var nextProps = evaluateProps(reference2, Object.assign({}, instance.props, {}, partialProps, {
        ignoreAttributes: true
      }));
      instance.props = nextProps;
      addListeners();
      if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
        cleanupInteractiveMouseListeners();
        debouncedOnMouseMove = debounce2(onMouseMove, nextProps.interactiveDebounce);
      }
      if (prevProps.triggerTarget && !nextProps.triggerTarget) {
        normalizeToArray(prevProps.triggerTarget).forEach(function(node) {
          node.removeAttribute("aria-expanded");
        });
      } else if (nextProps.triggerTarget) {
        reference2.removeAttribute("aria-expanded");
      }
      handleAriaExpandedAttribute();
      handleStyles();
      if (onUpdate) {
        onUpdate(prevProps, nextProps);
      }
      if (instance.popperInstance) {
        createPopperInstance();
        getNestedPopperTree().forEach(function(nestedPopper) {
          requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
        });
      }
      invokeHook("onAfterUpdate", [instance, partialProps]);
    }
    function setContent2(content) {
      instance.setProps({
        content
      });
    }
    function show() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("show"));
      }
      var isAlreadyVisible = instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled = !instance.state.isEnabled;
      var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
      var duration2 = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
      if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
        return;
      }
      if (getCurrentTarget().hasAttribute("disabled")) {
        return;
      }
      invokeHook("onShow", [instance], false);
      if (instance.props.onShow(instance) === false) {
        return;
      }
      instance.state.isVisible = true;
      if (getIsDefaultRenderFn()) {
        popper2.style.visibility = "visible";
      }
      handleStyles();
      addDocumentPress();
      if (!instance.state.isMounted) {
        popper2.style.transition = "none";
      }
      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
        setTransitionDuration([box, content], 0);
      }
      onFirstUpdate = function onFirstUpdate2() {
        var _instance$popperInsta2;
        if (!instance.state.isVisible || ignoreOnFirstUpdate) {
          return;
        }
        ignoreOnFirstUpdate = true;
        void popper2.offsetHeight;
        popper2.style.transition = instance.props.moveTransition;
        if (getIsDefaultRenderFn() && instance.props.animation) {
          var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
          setTransitionDuration([_box, _content], duration2);
          setVisibilityState([_box, _content], "visible");
        }
        handleAriaContentAttribute();
        handleAriaExpandedAttribute();
        pushIfUnique(mountedInstances, instance);
        (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
        instance.state.isMounted = true;
        invokeHook("onMount", [instance]);
        if (instance.props.animation && getIsDefaultRenderFn()) {
          onTransitionedIn(duration2, function() {
            instance.state.isShown = true;
            invokeHook("onShown", [instance]);
          });
        }
      };
      mount();
    }
    function hide2() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hide"));
      }
      var isAlreadyHidden = !instance.state.isVisible;
      var isDestroyed = instance.state.isDestroyed;
      var isDisabled = !instance.state.isEnabled;
      var duration2 = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
      if (isAlreadyHidden || isDestroyed || isDisabled) {
        return;
      }
      invokeHook("onHide", [instance], false);
      if (instance.props.onHide(instance) === false) {
        return;
      }
      instance.state.isVisible = false;
      instance.state.isShown = false;
      ignoreOnFirstUpdate = false;
      isVisibleFromClick = false;
      if (getIsDefaultRenderFn()) {
        popper2.style.visibility = "hidden";
      }
      cleanupInteractiveMouseListeners();
      removeDocumentPress();
      handleStyles();
      if (getIsDefaultRenderFn()) {
        var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
        if (instance.props.animation) {
          setTransitionDuration([box, content], duration2);
          setVisibilityState([box, content], "hidden");
        }
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      if (instance.props.animation) {
        if (getIsDefaultRenderFn()) {
          onTransitionedOut(duration2, instance.unmount);
        }
      } else {
        instance.unmount();
      }
    }
    function hideWithInteractivity(event) {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hideWithInteractivity"));
      }
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
      pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
      debouncedOnMouseMove(event);
    }
    function unmount() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("unmount"));
      }
      if (instance.state.isVisible) {
        instance.hide();
      }
      if (!instance.state.isMounted) {
        return;
      }
      destroyPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        nestedPopper._tippy.unmount();
      });
      if (popper2.parentNode) {
        popper2.parentNode.removeChild(popper2);
      }
      mountedInstances = mountedInstances.filter(function(i2) {
        return i2 !== instance;
      });
      instance.state.isMounted = false;
      invokeHook("onHidden", [instance]);
    }
    function destroy() {
      if (true) {
        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("destroy"));
      }
      if (instance.state.isDestroyed) {
        return;
      }
      instance.clearDelayTimeouts();
      instance.unmount();
      removeListeners();
      delete reference2._tippy;
      instance.state.isDestroyed = true;
      invokeHook("onDestroy", [instance]);
    }
  }
  function tippy(targets, optionalProps) {
    if (optionalProps === void 0) {
      optionalProps = {};
    }
    var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
    if (true) {
      validateTargets(targets);
      validateProps(optionalProps, plugins);
    }
    bindGlobalEventListeners();
    var passedProps = Object.assign({}, optionalProps, {
      plugins
    });
    var elements = getArrayOfElements(targets);
    if (true) {
      var isSingleContentElement = isElement2(passedProps.content);
      var isMoreThanOneReferenceElement = elements.length > 1;
      warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", "\n\n", "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", "\n\n", "1) content: element.innerHTML\n", "2) content: () => element.cloneNode(true)"].join(" "));
    }
    var instances = elements.reduce(function(acc, reference2) {
      var instance = reference2 && createTippy(reference2, passedProps);
      if (instance) {
        acc.push(instance);
      }
      return acc;
    }, []);
    return isElement2(targets) ? instances[0] : instances;
  }
  tippy.defaultProps = defaultProps;
  tippy.setDefaultProps = setDefaultProps;
  tippy.currentInput = currentInput;
  tippy.setDefaultProps({
    render
  });
  var tippy_esm_default = tippy;

  // app/javascript/js/active-storage.js
  document.addEventListener("direct-upload:initialize", (event) => {
    const { target, detail } = event;
    const { id, file } = detail;
    target.insertAdjacentHTML("beforebegin", `
    <div id="direct-upload-${id}" class="direct-upload direct-upload--pending">
      <div id="direct-upload-progress-${id}" class="direct-upload__progress" style="width: 0%"></div>
      <span class="direct-upload__filename"></span>
    </div>
  `);
    target.previousElementSibling.querySelector(".direct-upload__filename").textContent = file.name;
  });
  document.addEventListener("direct-upload:start", (event) => {
    const { id } = event.detail;
    const element = document.getElementById(`direct-upload-${id}`);
    element.classList.remove("direct-upload--pending");
  });
  document.addEventListener("direct-upload:progress", (event) => {
    const { id, progress } = event.detail;
    const progressElement = document.getElementById(`direct-upload-progress-${id}`);
    progressElement.style.width = `${progress}%`;
  });
  document.addEventListener("direct-upload:error", (event) => {
    event.preventDefault();
    const { id, error: error2 } = event.detail;
    const element = document.getElementById(`direct-upload-${id}`);
    element.classList.add("direct-upload--error");
    element.setAttribute("title", error2);
  });
  document.addEventListener("direct-upload:end", (event) => {
    const { id } = event.detail;
    const element = document.getElementById(`direct-upload-${id}`);
    element.classList.add("direct-upload--complete");
  });

  // node_modules/@hotwired/stimulus/dist/stimulus.js
  var EventListener = class {
    constructor(eventTarget, eventName, eventOptions) {
      this.eventTarget = eventTarget;
      this.eventName = eventName;
      this.eventOptions = eventOptions;
      this.unorderedBindings = /* @__PURE__ */ new Set();
    }
    connect() {
      this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
    }
    disconnect() {
      this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
    }
    bindingConnected(binding) {
      this.unorderedBindings.add(binding);
    }
    bindingDisconnected(binding) {
      this.unorderedBindings.delete(binding);
    }
    handleEvent(event) {
      const extendedEvent2 = extendEvent(event);
      for (const binding of this.bindings) {
        if (extendedEvent2.immediatePropagationStopped) {
          break;
        } else {
          binding.handleEvent(extendedEvent2);
        }
      }
    }
    get bindings() {
      return Array.from(this.unorderedBindings).sort((left2, right2) => {
        const leftIndex = left2.index, rightIndex = right2.index;
        return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
      });
    }
  };
  function extendEvent(event) {
    if ("immediatePropagationStopped" in event) {
      return event;
    } else {
      const { stopImmediatePropagation } = event;
      return Object.assign(event, {
        immediatePropagationStopped: false,
        stopImmediatePropagation() {
          this.immediatePropagationStopped = true;
          stopImmediatePropagation.call(this);
        }
      });
    }
  }
  var Dispatcher = class {
    constructor(application2) {
      this.application = application2;
      this.eventListenerMaps = /* @__PURE__ */ new Map();
      this.started = false;
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.eventListeners.forEach((eventListener) => eventListener.connect());
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.eventListeners.forEach((eventListener) => eventListener.disconnect());
      }
    }
    get eventListeners() {
      return Array.from(this.eventListenerMaps.values()).reduce((listeners, map) => listeners.concat(Array.from(map.values())), []);
    }
    bindingConnected(binding) {
      this.fetchEventListenerForBinding(binding).bindingConnected(binding);
    }
    bindingDisconnected(binding) {
      this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
    }
    handleError(error2, message, detail = {}) {
      this.application.handleError(error2, `Error ${message}`, detail);
    }
    fetchEventListenerForBinding(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      return this.fetchEventListener(eventTarget, eventName, eventOptions);
    }
    fetchEventListener(eventTarget, eventName, eventOptions) {
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      let eventListener = eventListenerMap.get(cacheKey);
      if (!eventListener) {
        eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
        eventListenerMap.set(cacheKey, eventListener);
      }
      return eventListener;
    }
    createEventListener(eventTarget, eventName, eventOptions) {
      const eventListener = new EventListener(eventTarget, eventName, eventOptions);
      if (this.started) {
        eventListener.connect();
      }
      return eventListener;
    }
    fetchEventListenerMapForEventTarget(eventTarget) {
      let eventListenerMap = this.eventListenerMaps.get(eventTarget);
      if (!eventListenerMap) {
        eventListenerMap = /* @__PURE__ */ new Map();
        this.eventListenerMaps.set(eventTarget, eventListenerMap);
      }
      return eventListenerMap;
    }
    cacheKey(eventName, eventOptions) {
      const parts = [eventName];
      Object.keys(eventOptions).sort().forEach((key) => {
        parts.push(`${eventOptions[key] ? "" : "!"}${key}`);
      });
      return parts.join(":");
    }
  };
  var descriptorPattern = /^((.+?)(@(window|document))?->)?(.+?)(#([^:]+?))(:(.+))?$/;
  function parseActionDescriptorString(descriptorString) {
    const source = descriptorString.trim();
    const matches = source.match(descriptorPattern) || [];
    return {
      eventTarget: parseEventTarget(matches[4]),
      eventName: matches[2],
      eventOptions: matches[9] ? parseEventOptions(matches[9]) : {},
      identifier: matches[5],
      methodName: matches[7]
    };
  }
  function parseEventTarget(eventTargetName) {
    if (eventTargetName == "window") {
      return window;
    } else if (eventTargetName == "document") {
      return document;
    }
  }
  function parseEventOptions(eventOptions) {
    return eventOptions.split(":").reduce((options, token) => Object.assign(options, { [token.replace(/^!/, "")]: !/^!/.test(token) }), {});
  }
  function stringifyEventTarget(eventTarget) {
    if (eventTarget == window) {
      return "window";
    } else if (eventTarget == document) {
      return "document";
    }
  }
  function camelize(value) {
    return value.replace(/(?:[_-])([a-z0-9])/g, (_2, char) => char.toUpperCase());
  }
  function capitalize(value) {
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
  function dasherize(value) {
    return value.replace(/([A-Z])/g, (_2, char) => `-${char.toLowerCase()}`);
  }
  function tokenize(value) {
    return value.match(/[^\s]+/g) || [];
  }
  var Action = class {
    constructor(element, index, descriptor) {
      this.element = element;
      this.index = index;
      this.eventTarget = descriptor.eventTarget || element;
      this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
      this.eventOptions = descriptor.eventOptions || {};
      this.identifier = descriptor.identifier || error("missing identifier");
      this.methodName = descriptor.methodName || error("missing method name");
    }
    static forToken(token) {
      return new this(token.element, token.index, parseActionDescriptorString(token.content));
    }
    toString() {
      const eventNameSuffix = this.eventTargetName ? `@${this.eventTargetName}` : "";
      return `${this.eventName}${eventNameSuffix}->${this.identifier}#${this.methodName}`;
    }
    get params() {
      if (this.eventTarget instanceof Element) {
        return this.getParamsFromEventTargetAttributes(this.eventTarget);
      } else {
        return {};
      }
    }
    getParamsFromEventTargetAttributes(eventTarget) {
      const params = {};
      const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`);
      const attributes = Array.from(eventTarget.attributes);
      attributes.forEach(({ name, value }) => {
        const match = name.match(pattern);
        const key = match && match[1];
        if (key) {
          Object.assign(params, { [camelize(key)]: typecast(value) });
        }
      });
      return params;
    }
    get eventTargetName() {
      return stringifyEventTarget(this.eventTarget);
    }
  };
  var defaultEventNames = {
    "a": (e2) => "click",
    "button": (e2) => "click",
    "form": (e2) => "submit",
    "details": (e2) => "toggle",
    "input": (e2) => e2.getAttribute("type") == "submit" ? "click" : "input",
    "select": (e2) => "change",
    "textarea": (e2) => "input"
  };
  function getDefaultEventNameForElement(element) {
    const tagName = element.tagName.toLowerCase();
    if (tagName in defaultEventNames) {
      return defaultEventNames[tagName](element);
    }
  }
  function error(message) {
    throw new Error(message);
  }
  function typecast(value) {
    try {
      return JSON.parse(value);
    } catch (o_O) {
      return value;
    }
  }
  var Binding = class {
    constructor(context, action) {
      this.context = context;
      this.action = action;
    }
    get index() {
      return this.action.index;
    }
    get eventTarget() {
      return this.action.eventTarget;
    }
    get eventOptions() {
      return this.action.eventOptions;
    }
    get identifier() {
      return this.context.identifier;
    }
    handleEvent(event) {
      if (this.willBeInvokedByEvent(event)) {
        this.invokeWithEvent(event);
      }
    }
    get eventName() {
      return this.action.eventName;
    }
    get method() {
      const method = this.controller[this.methodName];
      if (typeof method == "function") {
        return method;
      }
      throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
    }
    invokeWithEvent(event) {
      const { target, currentTarget } = event;
      try {
        const { params } = this.action;
        const actionEvent = Object.assign(event, { params });
        this.method.call(this.controller, actionEvent);
        this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });
      } catch (error2) {
        const { identifier, controller, element, index } = this;
        const detail = { identifier, controller, element, index, event };
        this.context.handleError(error2, `invoking action "${this.action}"`, detail);
      }
    }
    willBeInvokedByEvent(event) {
      const eventTarget = event.target;
      if (this.element === eventTarget) {
        return true;
      } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
        return this.scope.containsElement(eventTarget);
      } else {
        return this.scope.containsElement(this.action.element);
      }
    }
    get controller() {
      return this.context.controller;
    }
    get methodName() {
      return this.action.methodName;
    }
    get element() {
      return this.scope.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  var ElementObserver = class {
    constructor(element, delegate) {
      this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
      this.element = element;
      this.started = false;
      this.delegate = delegate;
      this.elements = /* @__PURE__ */ new Set();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.refresh();
      }
    }
    pause(callback) {
      if (this.started) {
        this.mutationObserver.disconnect();
        this.started = false;
      }
      callback();
      if (!this.started) {
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        const matches = new Set(this.matchElementsInTree());
        for (const element of Array.from(this.elements)) {
          if (!matches.has(element)) {
            this.removeElement(element);
          }
        }
        for (const element of Array.from(matches)) {
          this.addElement(element);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      if (mutation.type == "attributes") {
        this.processAttributeChange(mutation.target, mutation.attributeName);
      } else if (mutation.type == "childList") {
        this.processRemovedNodes(mutation.removedNodes);
        this.processAddedNodes(mutation.addedNodes);
      }
    }
    processAttributeChange(node, attributeName) {
      const element = node;
      if (this.elements.has(element)) {
        if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
          this.delegate.elementAttributeChanged(element, attributeName);
        } else {
          this.removeElement(element);
        }
      } else if (this.matchElement(element)) {
        this.addElement(element);
      }
    }
    processRemovedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element) {
          this.processTree(element, this.removeElement);
        }
      }
    }
    processAddedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element && this.elementIsActive(element)) {
          this.processTree(element, this.addElement);
        }
      }
    }
    matchElement(element) {
      return this.delegate.matchElement(element);
    }
    matchElementsInTree(tree = this.element) {
      return this.delegate.matchElementsInTree(tree);
    }
    processTree(tree, processor) {
      for (const element of this.matchElementsInTree(tree)) {
        processor.call(this, element);
      }
    }
    elementFromNode(node) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        return node;
      }
    }
    elementIsActive(element) {
      if (element.isConnected != this.element.isConnected) {
        return false;
      } else {
        return this.element.contains(element);
      }
    }
    addElement(element) {
      if (!this.elements.has(element)) {
        if (this.elementIsActive(element)) {
          this.elements.add(element);
          if (this.delegate.elementMatched) {
            this.delegate.elementMatched(element);
          }
        }
      }
    }
    removeElement(element) {
      if (this.elements.has(element)) {
        this.elements.delete(element);
        if (this.delegate.elementUnmatched) {
          this.delegate.elementUnmatched(element);
        }
      }
    }
  };
  var AttributeObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeName = attributeName;
      this.delegate = delegate;
      this.elementObserver = new ElementObserver(element, this);
    }
    get element() {
      return this.elementObserver.element;
    }
    get selector() {
      return `[${this.attributeName}]`;
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback) {
      this.elementObserver.pause(callback);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get started() {
      return this.elementObserver.started;
    }
    matchElement(element) {
      return element.hasAttribute(this.attributeName);
    }
    matchElementsInTree(tree) {
      const match = this.matchElement(tree) ? [tree] : [];
      const matches = Array.from(tree.querySelectorAll(this.selector));
      return match.concat(matches);
    }
    elementMatched(element) {
      if (this.delegate.elementMatchedAttribute) {
        this.delegate.elementMatchedAttribute(element, this.attributeName);
      }
    }
    elementUnmatched(element) {
      if (this.delegate.elementUnmatchedAttribute) {
        this.delegate.elementUnmatchedAttribute(element, this.attributeName);
      }
    }
    elementAttributeChanged(element, attributeName) {
      if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
        this.delegate.elementAttributeValueChanged(element, attributeName);
      }
    }
  };
  var StringMapObserver = class {
    constructor(element, delegate) {
      this.element = element;
      this.delegate = delegate;
      this.started = false;
      this.stringMap = /* @__PURE__ */ new Map();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
        this.refresh();
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        for (const attributeName of this.knownAttributeNames) {
          this.refreshAttribute(attributeName, null);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      const attributeName = mutation.attributeName;
      if (attributeName) {
        this.refreshAttribute(attributeName, mutation.oldValue);
      }
    }
    refreshAttribute(attributeName, oldValue) {
      const key = this.delegate.getStringMapKeyForAttribute(attributeName);
      if (key != null) {
        if (!this.stringMap.has(attributeName)) {
          this.stringMapKeyAdded(key, attributeName);
        }
        const value = this.element.getAttribute(attributeName);
        if (this.stringMap.get(attributeName) != value) {
          this.stringMapValueChanged(value, key, oldValue);
        }
        if (value == null) {
          const oldValue2 = this.stringMap.get(attributeName);
          this.stringMap.delete(attributeName);
          if (oldValue2)
            this.stringMapKeyRemoved(key, attributeName, oldValue2);
        } else {
          this.stringMap.set(attributeName, value);
        }
      }
    }
    stringMapKeyAdded(key, attributeName) {
      if (this.delegate.stringMapKeyAdded) {
        this.delegate.stringMapKeyAdded(key, attributeName);
      }
    }
    stringMapValueChanged(value, key, oldValue) {
      if (this.delegate.stringMapValueChanged) {
        this.delegate.stringMapValueChanged(value, key, oldValue);
      }
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      if (this.delegate.stringMapKeyRemoved) {
        this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
      }
    }
    get knownAttributeNames() {
      return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
    }
    get currentAttributeNames() {
      return Array.from(this.element.attributes).map((attribute) => attribute.name);
    }
    get recordedAttributeNames() {
      return Array.from(this.stringMap.keys());
    }
  };
  function add(map, key, value) {
    fetch2(map, key).add(value);
  }
  function del(map, key, value) {
    fetch2(map, key).delete(value);
    prune(map, key);
  }
  function fetch2(map, key) {
    let values = map.get(key);
    if (!values) {
      values = /* @__PURE__ */ new Set();
      map.set(key, values);
    }
    return values;
  }
  function prune(map, key) {
    const values = map.get(key);
    if (values != null && values.size == 0) {
      map.delete(key);
    }
  }
  var Multimap = class {
    constructor() {
      this.valuesByKey = /* @__PURE__ */ new Map();
    }
    get keys() {
      return Array.from(this.valuesByKey.keys());
    }
    get values() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((values, set) => values.concat(Array.from(set)), []);
    }
    get size() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((size, set) => size + set.size, 0);
    }
    add(key, value) {
      add(this.valuesByKey, key, value);
    }
    delete(key, value) {
      del(this.valuesByKey, key, value);
    }
    has(key, value) {
      const values = this.valuesByKey.get(key);
      return values != null && values.has(value);
    }
    hasKey(key) {
      return this.valuesByKey.has(key);
    }
    hasValue(value) {
      const sets = Array.from(this.valuesByKey.values());
      return sets.some((set) => set.has(value));
    }
    getValuesForKey(key) {
      const values = this.valuesByKey.get(key);
      return values ? Array.from(values) : [];
    }
    getKeysForValue(value) {
      return Array.from(this.valuesByKey).filter(([key, values]) => values.has(value)).map(([key, values]) => key);
    }
  };
  var TokenListObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeObserver = new AttributeObserver(element, attributeName, this);
      this.delegate = delegate;
      this.tokensByElement = new Multimap();
    }
    get started() {
      return this.attributeObserver.started;
    }
    start() {
      this.attributeObserver.start();
    }
    pause(callback) {
      this.attributeObserver.pause(callback);
    }
    stop() {
      this.attributeObserver.stop();
    }
    refresh() {
      this.attributeObserver.refresh();
    }
    get element() {
      return this.attributeObserver.element;
    }
    get attributeName() {
      return this.attributeObserver.attributeName;
    }
    elementMatchedAttribute(element) {
      this.tokensMatched(this.readTokensForElement(element));
    }
    elementAttributeValueChanged(element) {
      const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
      this.tokensUnmatched(unmatchedTokens);
      this.tokensMatched(matchedTokens);
    }
    elementUnmatchedAttribute(element) {
      this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
    }
    tokensMatched(tokens) {
      tokens.forEach((token) => this.tokenMatched(token));
    }
    tokensUnmatched(tokens) {
      tokens.forEach((token) => this.tokenUnmatched(token));
    }
    tokenMatched(token) {
      this.delegate.tokenMatched(token);
      this.tokensByElement.add(token.element, token);
    }
    tokenUnmatched(token) {
      this.delegate.tokenUnmatched(token);
      this.tokensByElement.delete(token.element, token);
    }
    refreshTokensForElement(element) {
      const previousTokens = this.tokensByElement.getValuesForKey(element);
      const currentTokens = this.readTokensForElement(element);
      const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
      if (firstDifferingIndex == -1) {
        return [[], []];
      } else {
        return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
      }
    }
    readTokensForElement(element) {
      const attributeName = this.attributeName;
      const tokenString = element.getAttribute(attributeName) || "";
      return parseTokenString(tokenString, element, attributeName);
    }
  };
  function parseTokenString(tokenString, element, attributeName) {
    return tokenString.trim().split(/\s+/).filter((content) => content.length).map((content, index) => ({ element, attributeName, content, index }));
  }
  function zip(left2, right2) {
    const length = Math.max(left2.length, right2.length);
    return Array.from({ length }, (_2, index) => [left2[index], right2[index]]);
  }
  function tokensAreEqual(left2, right2) {
    return left2 && right2 && left2.index == right2.index && left2.content == right2.content;
  }
  var ValueListObserver = class {
    constructor(element, attributeName, delegate) {
      this.tokenListObserver = new TokenListObserver(element, attributeName, this);
      this.delegate = delegate;
      this.parseResultsByToken = /* @__PURE__ */ new WeakMap();
      this.valuesByTokenByElement = /* @__PURE__ */ new WeakMap();
    }
    get started() {
      return this.tokenListObserver.started;
    }
    start() {
      this.tokenListObserver.start();
    }
    stop() {
      this.tokenListObserver.stop();
    }
    refresh() {
      this.tokenListObserver.refresh();
    }
    get element() {
      return this.tokenListObserver.element;
    }
    get attributeName() {
      return this.tokenListObserver.attributeName;
    }
    tokenMatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).set(token, value);
        this.delegate.elementMatchedValue(element, value);
      }
    }
    tokenUnmatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).delete(token);
        this.delegate.elementUnmatchedValue(element, value);
      }
    }
    fetchParseResultForToken(token) {
      let parseResult = this.parseResultsByToken.get(token);
      if (!parseResult) {
        parseResult = this.parseToken(token);
        this.parseResultsByToken.set(token, parseResult);
      }
      return parseResult;
    }
    fetchValuesByTokenForElement(element) {
      let valuesByToken = this.valuesByTokenByElement.get(element);
      if (!valuesByToken) {
        valuesByToken = /* @__PURE__ */ new Map();
        this.valuesByTokenByElement.set(element, valuesByToken);
      }
      return valuesByToken;
    }
    parseToken(token) {
      try {
        const value = this.delegate.parseValueForToken(token);
        return { value };
      } catch (error2) {
        return { error: error2 };
      }
    }
  };
  var BindingObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.bindingsByAction = /* @__PURE__ */ new Map();
    }
    start() {
      if (!this.valueListObserver) {
        this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
        this.valueListObserver.start();
      }
    }
    stop() {
      if (this.valueListObserver) {
        this.valueListObserver.stop();
        delete this.valueListObserver;
        this.disconnectAllActions();
      }
    }
    get element() {
      return this.context.element;
    }
    get identifier() {
      return this.context.identifier;
    }
    get actionAttribute() {
      return this.schema.actionAttribute;
    }
    get schema() {
      return this.context.schema;
    }
    get bindings() {
      return Array.from(this.bindingsByAction.values());
    }
    connectAction(action) {
      const binding = new Binding(this.context, action);
      this.bindingsByAction.set(action, binding);
      this.delegate.bindingConnected(binding);
    }
    disconnectAction(action) {
      const binding = this.bindingsByAction.get(action);
      if (binding) {
        this.bindingsByAction.delete(action);
        this.delegate.bindingDisconnected(binding);
      }
    }
    disconnectAllActions() {
      this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding));
      this.bindingsByAction.clear();
    }
    parseValueForToken(token) {
      const action = Action.forToken(token);
      if (action.identifier == this.identifier) {
        return action;
      }
    }
    elementMatchedValue(element, action) {
      this.connectAction(action);
    }
    elementUnmatchedValue(element, action) {
      this.disconnectAction(action);
    }
  };
  var ValueObserver = class {
    constructor(context, receiver) {
      this.context = context;
      this.receiver = receiver;
      this.stringMapObserver = new StringMapObserver(this.element, this);
      this.valueDescriptorMap = this.controller.valueDescriptorMap;
      this.invokeChangedCallbacksForDefaultValues();
    }
    start() {
      this.stringMapObserver.start();
    }
    stop() {
      this.stringMapObserver.stop();
    }
    get element() {
      return this.context.element;
    }
    get controller() {
      return this.context.controller;
    }
    getStringMapKeyForAttribute(attributeName) {
      if (attributeName in this.valueDescriptorMap) {
        return this.valueDescriptorMap[attributeName].name;
      }
    }
    stringMapKeyAdded(key, attributeName) {
      const descriptor = this.valueDescriptorMap[attributeName];
      if (!this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
      }
    }
    stringMapValueChanged(value, name, oldValue) {
      const descriptor = this.valueDescriptorNameMap[name];
      if (value === null)
        return;
      if (oldValue === null) {
        oldValue = descriptor.writer(descriptor.defaultValue);
      }
      this.invokeChangedCallback(name, value, oldValue);
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      const descriptor = this.valueDescriptorNameMap[key];
      if (this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
      } else {
        this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
      }
    }
    invokeChangedCallbacksForDefaultValues() {
      for (const { key, name, defaultValue, writer } of this.valueDescriptors) {
        if (defaultValue != void 0 && !this.controller.data.has(key)) {
          this.invokeChangedCallback(name, writer(defaultValue), void 0);
        }
      }
    }
    invokeChangedCallback(name, rawValue, rawOldValue) {
      const changedMethodName = `${name}Changed`;
      const changedMethod = this.receiver[changedMethodName];
      if (typeof changedMethod == "function") {
        const descriptor = this.valueDescriptorNameMap[name];
        const value = descriptor.reader(rawValue);
        let oldValue = rawOldValue;
        if (rawOldValue) {
          oldValue = descriptor.reader(rawOldValue);
        }
        changedMethod.call(this.receiver, value, oldValue);
      }
    }
    get valueDescriptors() {
      const { valueDescriptorMap } = this;
      return Object.keys(valueDescriptorMap).map((key) => valueDescriptorMap[key]);
    }
    get valueDescriptorNameMap() {
      const descriptors = {};
      Object.keys(this.valueDescriptorMap).forEach((key) => {
        const descriptor = this.valueDescriptorMap[key];
        descriptors[descriptor.name] = descriptor;
      });
      return descriptors;
    }
    hasValue(attributeName) {
      const descriptor = this.valueDescriptorNameMap[attributeName];
      const hasMethodName = `has${capitalize(descriptor.name)}`;
      return this.receiver[hasMethodName];
    }
  };
  var TargetObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.targetsByName = new Multimap();
    }
    start() {
      if (!this.tokenListObserver) {
        this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
        this.tokenListObserver.start();
      }
    }
    stop() {
      if (this.tokenListObserver) {
        this.disconnectAllTargets();
        this.tokenListObserver.stop();
        delete this.tokenListObserver;
      }
    }
    tokenMatched({ element, content: name }) {
      if (this.scope.containsElement(element)) {
        this.connectTarget(element, name);
      }
    }
    tokenUnmatched({ element, content: name }) {
      this.disconnectTarget(element, name);
    }
    connectTarget(element, name) {
      var _a;
      if (!this.targetsByName.has(name, element)) {
        this.targetsByName.add(name, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetConnected(element, name));
      }
    }
    disconnectTarget(element, name) {
      var _a;
      if (this.targetsByName.has(name, element)) {
        this.targetsByName.delete(name, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetDisconnected(element, name));
      }
    }
    disconnectAllTargets() {
      for (const name of this.targetsByName.keys) {
        for (const element of this.targetsByName.getValuesForKey(name)) {
          this.disconnectTarget(element, name);
        }
      }
    }
    get attributeName() {
      return `data-${this.context.identifier}-target`;
    }
    get element() {
      return this.context.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  var Context = class {
    constructor(module, scope) {
      this.logDebugActivity = (functionName, detail = {}) => {
        const { identifier, controller, element } = this;
        detail = Object.assign({ identifier, controller, element }, detail);
        this.application.logDebugActivity(this.identifier, functionName, detail);
      };
      this.module = module;
      this.scope = scope;
      this.controller = new module.controllerConstructor(this);
      this.bindingObserver = new BindingObserver(this, this.dispatcher);
      this.valueObserver = new ValueObserver(this, this.controller);
      this.targetObserver = new TargetObserver(this, this);
      try {
        this.controller.initialize();
        this.logDebugActivity("initialize");
      } catch (error2) {
        this.handleError(error2, "initializing controller");
      }
    }
    connect() {
      this.bindingObserver.start();
      this.valueObserver.start();
      this.targetObserver.start();
      try {
        this.controller.connect();
        this.logDebugActivity("connect");
      } catch (error2) {
        this.handleError(error2, "connecting controller");
      }
    }
    disconnect() {
      try {
        this.controller.disconnect();
        this.logDebugActivity("disconnect");
      } catch (error2) {
        this.handleError(error2, "disconnecting controller");
      }
      this.targetObserver.stop();
      this.valueObserver.stop();
      this.bindingObserver.stop();
    }
    get application() {
      return this.module.application;
    }
    get identifier() {
      return this.module.identifier;
    }
    get schema() {
      return this.application.schema;
    }
    get dispatcher() {
      return this.application.dispatcher;
    }
    get element() {
      return this.scope.element;
    }
    get parentElement() {
      return this.element.parentElement;
    }
    handleError(error2, message, detail = {}) {
      const { identifier, controller, element } = this;
      detail = Object.assign({ identifier, controller, element }, detail);
      this.application.handleError(error2, `Error ${message}`, detail);
    }
    targetConnected(element, name) {
      this.invokeControllerMethod(`${name}TargetConnected`, element);
    }
    targetDisconnected(element, name) {
      this.invokeControllerMethod(`${name}TargetDisconnected`, element);
    }
    invokeControllerMethod(methodName, ...args) {
      const controller = this.controller;
      if (typeof controller[methodName] == "function") {
        controller[methodName](...args);
      }
    }
  };
  function readInheritableStaticArrayValues(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return Array.from(ancestors.reduce((values, constructor2) => {
      getOwnStaticArrayValues(constructor2, propertyName).forEach((name) => values.add(name));
      return values;
    }, /* @__PURE__ */ new Set()));
  }
  function readInheritableStaticObjectPairs(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return ancestors.reduce((pairs, constructor2) => {
      pairs.push(...getOwnStaticObjectPairs(constructor2, propertyName));
      return pairs;
    }, []);
  }
  function getAncestorsForConstructor(constructor) {
    const ancestors = [];
    while (constructor) {
      ancestors.push(constructor);
      constructor = Object.getPrototypeOf(constructor);
    }
    return ancestors.reverse();
  }
  function getOwnStaticArrayValues(constructor, propertyName) {
    const definition = constructor[propertyName];
    return Array.isArray(definition) ? definition : [];
  }
  function getOwnStaticObjectPairs(constructor, propertyName) {
    const definition = constructor[propertyName];
    return definition ? Object.keys(definition).map((key) => [key, definition[key]]) : [];
  }
  function bless(constructor) {
    return shadow(constructor, getBlessedProperties(constructor));
  }
  function shadow(constructor, properties) {
    const shadowConstructor = extend2(constructor);
    const shadowProperties = getShadowProperties(constructor.prototype, properties);
    Object.defineProperties(shadowConstructor.prototype, shadowProperties);
    return shadowConstructor;
  }
  function getBlessedProperties(constructor) {
    const blessings = readInheritableStaticArrayValues(constructor, "blessings");
    return blessings.reduce((blessedProperties, blessing) => {
      const properties = blessing(constructor);
      for (const key in properties) {
        const descriptor = blessedProperties[key] || {};
        blessedProperties[key] = Object.assign(descriptor, properties[key]);
      }
      return blessedProperties;
    }, {});
  }
  function getShadowProperties(prototype, properties) {
    return getOwnKeys(properties).reduce((shadowProperties, key) => {
      const descriptor = getShadowedDescriptor(prototype, properties, key);
      if (descriptor) {
        Object.assign(shadowProperties, { [key]: descriptor });
      }
      return shadowProperties;
    }, {});
  }
  function getShadowedDescriptor(prototype, properties, key) {
    const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
    const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
    if (!shadowedByValue) {
      const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
      if (shadowingDescriptor) {
        descriptor.get = shadowingDescriptor.get || descriptor.get;
        descriptor.set = shadowingDescriptor.set || descriptor.set;
      }
      return descriptor;
    }
  }
  var getOwnKeys = (() => {
    if (typeof Object.getOwnPropertySymbols == "function") {
      return (object) => [
        ...Object.getOwnPropertyNames(object),
        ...Object.getOwnPropertySymbols(object)
      ];
    } else {
      return Object.getOwnPropertyNames;
    }
  })();
  var extend2 = (() => {
    function extendWithReflect(constructor) {
      function extended() {
        return Reflect.construct(constructor, arguments, new.target);
      }
      extended.prototype = Object.create(constructor.prototype, {
        constructor: { value: extended }
      });
      Reflect.setPrototypeOf(extended, constructor);
      return extended;
    }
    function testReflectExtension() {
      const a2 = function() {
        this.a.call(this);
      };
      const b2 = extendWithReflect(a2);
      b2.prototype.a = function() {
      };
      return new b2();
    }
    try {
      testReflectExtension();
      return extendWithReflect;
    } catch (error2) {
      return (constructor) => class extended extends constructor {
      };
    }
  })();
  function blessDefinition(definition) {
    return {
      identifier: definition.identifier,
      controllerConstructor: bless(definition.controllerConstructor)
    };
  }
  var Module = class {
    constructor(application2, definition) {
      this.application = application2;
      this.definition = blessDefinition(definition);
      this.contextsByScope = /* @__PURE__ */ new WeakMap();
      this.connectedContexts = /* @__PURE__ */ new Set();
    }
    get identifier() {
      return this.definition.identifier;
    }
    get controllerConstructor() {
      return this.definition.controllerConstructor;
    }
    get contexts() {
      return Array.from(this.connectedContexts);
    }
    connectContextForScope(scope) {
      const context = this.fetchContextForScope(scope);
      this.connectedContexts.add(context);
      context.connect();
    }
    disconnectContextForScope(scope) {
      const context = this.contextsByScope.get(scope);
      if (context) {
        this.connectedContexts.delete(context);
        context.disconnect();
      }
    }
    fetchContextForScope(scope) {
      let context = this.contextsByScope.get(scope);
      if (!context) {
        context = new Context(this, scope);
        this.contextsByScope.set(scope, context);
      }
      return context;
    }
  };
  var ClassMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    has(name) {
      return this.data.has(this.getDataKey(name));
    }
    get(name) {
      return this.getAll(name)[0];
    }
    getAll(name) {
      const tokenString = this.data.get(this.getDataKey(name)) || "";
      return tokenize(tokenString);
    }
    getAttributeName(name) {
      return this.data.getAttributeNameForKey(this.getDataKey(name));
    }
    getDataKey(name) {
      return `${name}-class`;
    }
    get data() {
      return this.scope.data;
    }
  };
  var DataMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get(key) {
      const name = this.getAttributeNameForKey(key);
      return this.element.getAttribute(name);
    }
    set(key, value) {
      const name = this.getAttributeNameForKey(key);
      this.element.setAttribute(name, value);
      return this.get(key);
    }
    has(key) {
      const name = this.getAttributeNameForKey(key);
      return this.element.hasAttribute(name);
    }
    delete(key) {
      if (this.has(key)) {
        const name = this.getAttributeNameForKey(key);
        this.element.removeAttribute(name);
        return true;
      } else {
        return false;
      }
    }
    getAttributeNameForKey(key) {
      return `data-${this.identifier}-${dasherize(key)}`;
    }
  };
  var Guide = class {
    constructor(logger) {
      this.warnedKeysByObject = /* @__PURE__ */ new WeakMap();
      this.logger = logger;
    }
    warn(object, key, message) {
      let warnedKeys = this.warnedKeysByObject.get(object);
      if (!warnedKeys) {
        warnedKeys = /* @__PURE__ */ new Set();
        this.warnedKeysByObject.set(object, warnedKeys);
      }
      if (!warnedKeys.has(key)) {
        warnedKeys.add(key);
        this.logger.warn(message, object);
      }
    }
  };
  function attributeValueContainsToken(attributeName, token) {
    return `[${attributeName}~="${token}"]`;
  }
  var TargetSet = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(targetName) {
      return this.find(targetName) != null;
    }
    find(...targetNames) {
      return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), void 0);
    }
    findAll(...targetNames) {
      return targetNames.reduce((targets, targetName) => [
        ...targets,
        ...this.findAllTargets(targetName),
        ...this.findAllLegacyTargets(targetName)
      ], []);
    }
    findTarget(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findElement(selector);
    }
    findAllTargets(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findAllElements(selector);
    }
    getSelectorForTargetName(targetName) {
      const attributeName = this.schema.targetAttributeForScope(this.identifier);
      return attributeValueContainsToken(attributeName, targetName);
    }
    findLegacyTarget(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.deprecate(this.scope.findElement(selector), targetName);
    }
    findAllLegacyTargets(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName));
    }
    getLegacySelectorForTargetName(targetName) {
      const targetDescriptor = `${this.identifier}.${targetName}`;
      return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
    }
    deprecate(element, targetName) {
      if (element) {
        const { identifier } = this;
        const attributeName = this.schema.targetAttribute;
        const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
        this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
      }
      return element;
    }
    get guide() {
      return this.scope.guide;
    }
  };
  var Scope = class {
    constructor(schema, element, identifier, logger) {
      this.targets = new TargetSet(this);
      this.classes = new ClassMap(this);
      this.data = new DataMap(this);
      this.containsElement = (element2) => {
        return element2.closest(this.controllerSelector) === this.element;
      };
      this.schema = schema;
      this.element = element;
      this.identifier = identifier;
      this.guide = new Guide(logger);
    }
    findElement(selector) {
      return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
    }
    findAllElements(selector) {
      return [
        ...this.element.matches(selector) ? [this.element] : [],
        ...this.queryElements(selector).filter(this.containsElement)
      ];
    }
    queryElements(selector) {
      return Array.from(this.element.querySelectorAll(selector));
    }
    get controllerSelector() {
      return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
    }
  };
  var ScopeObserver = class {
    constructor(element, schema, delegate) {
      this.element = element;
      this.schema = schema;
      this.delegate = delegate;
      this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
      this.scopesByIdentifierByElement = /* @__PURE__ */ new WeakMap();
      this.scopeReferenceCounts = /* @__PURE__ */ new WeakMap();
    }
    start() {
      this.valueListObserver.start();
    }
    stop() {
      this.valueListObserver.stop();
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    parseValueForToken(token) {
      const { element, content: identifier } = token;
      const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
      let scope = scopesByIdentifier.get(identifier);
      if (!scope) {
        scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
        scopesByIdentifier.set(identifier, scope);
      }
      return scope;
    }
    elementMatchedValue(element, value) {
      const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
      this.scopeReferenceCounts.set(value, referenceCount);
      if (referenceCount == 1) {
        this.delegate.scopeConnected(value);
      }
    }
    elementUnmatchedValue(element, value) {
      const referenceCount = this.scopeReferenceCounts.get(value);
      if (referenceCount) {
        this.scopeReferenceCounts.set(value, referenceCount - 1);
        if (referenceCount == 1) {
          this.delegate.scopeDisconnected(value);
        }
      }
    }
    fetchScopesByIdentifierForElement(element) {
      let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
      if (!scopesByIdentifier) {
        scopesByIdentifier = /* @__PURE__ */ new Map();
        this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
      }
      return scopesByIdentifier;
    }
  };
  var Router = class {
    constructor(application2) {
      this.application = application2;
      this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
      this.scopesByIdentifier = new Multimap();
      this.modulesByIdentifier = /* @__PURE__ */ new Map();
    }
    get element() {
      return this.application.element;
    }
    get schema() {
      return this.application.schema;
    }
    get logger() {
      return this.application.logger;
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    get modules() {
      return Array.from(this.modulesByIdentifier.values());
    }
    get contexts() {
      return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);
    }
    start() {
      this.scopeObserver.start();
    }
    stop() {
      this.scopeObserver.stop();
    }
    loadDefinition(definition) {
      this.unloadIdentifier(definition.identifier);
      const module = new Module(this.application, definition);
      this.connectModule(module);
    }
    unloadIdentifier(identifier) {
      const module = this.modulesByIdentifier.get(identifier);
      if (module) {
        this.disconnectModule(module);
      }
    }
    getContextForElementAndIdentifier(element, identifier) {
      const module = this.modulesByIdentifier.get(identifier);
      if (module) {
        return module.contexts.find((context) => context.element == element);
      }
    }
    handleError(error2, message, detail) {
      this.application.handleError(error2, message, detail);
    }
    createScopeForElementAndIdentifier(element, identifier) {
      return new Scope(this.schema, element, identifier, this.logger);
    }
    scopeConnected(scope) {
      this.scopesByIdentifier.add(scope.identifier, scope);
      const module = this.modulesByIdentifier.get(scope.identifier);
      if (module) {
        module.connectContextForScope(scope);
      }
    }
    scopeDisconnected(scope) {
      this.scopesByIdentifier.delete(scope.identifier, scope);
      const module = this.modulesByIdentifier.get(scope.identifier);
      if (module) {
        module.disconnectContextForScope(scope);
      }
    }
    connectModule(module) {
      this.modulesByIdentifier.set(module.identifier, module);
      const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
      scopes.forEach((scope) => module.connectContextForScope(scope));
    }
    disconnectModule(module) {
      this.modulesByIdentifier.delete(module.identifier);
      const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
      scopes.forEach((scope) => module.disconnectContextForScope(scope));
    }
  };
  var defaultSchema = {
    controllerAttribute: "data-controller",
    actionAttribute: "data-action",
    targetAttribute: "data-target",
    targetAttributeForScope: (identifier) => `data-${identifier}-target`
  };
  var Application = class {
    constructor(element = document.documentElement, schema = defaultSchema) {
      this.logger = console;
      this.debug = false;
      this.logDebugActivity = (identifier, functionName, detail = {}) => {
        if (this.debug) {
          this.logFormattedMessage(identifier, functionName, detail);
        }
      };
      this.element = element;
      this.schema = schema;
      this.dispatcher = new Dispatcher(this);
      this.router = new Router(this);
    }
    static start(element, schema) {
      const application2 = new Application(element, schema);
      application2.start();
      return application2;
    }
    async start() {
      await domReady();
      this.logDebugActivity("application", "starting");
      this.dispatcher.start();
      this.router.start();
      this.logDebugActivity("application", "start");
    }
    stop() {
      this.logDebugActivity("application", "stopping");
      this.dispatcher.stop();
      this.router.stop();
      this.logDebugActivity("application", "stop");
    }
    register(identifier, controllerConstructor) {
      if (controllerConstructor.shouldLoad) {
        this.load({ identifier, controllerConstructor });
      }
    }
    load(head, ...rest) {
      const definitions = Array.isArray(head) ? head : [head, ...rest];
      definitions.forEach((definition) => this.router.loadDefinition(definition));
    }
    unload(head, ...rest) {
      const identifiers = Array.isArray(head) ? head : [head, ...rest];
      identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier));
    }
    get controllers() {
      return this.router.contexts.map((context) => context.controller);
    }
    getControllerForElementAndIdentifier(element, identifier) {
      const context = this.router.getContextForElementAndIdentifier(element, identifier);
      return context ? context.controller : null;
    }
    handleError(error2, message, detail) {
      var _a;
      this.logger.error(`%s

%o

%o`, message, error2, detail);
      (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, "", 0, 0, error2);
    }
    logFormattedMessage(identifier, functionName, detail = {}) {
      detail = Object.assign({ application: this }, detail);
      this.logger.groupCollapsed(`${identifier} #${functionName}`);
      this.logger.log("details:", Object.assign({}, detail));
      this.logger.groupEnd();
    }
  };
  function domReady() {
    return new Promise((resolve2) => {
      if (document.readyState == "loading") {
        document.addEventListener("DOMContentLoaded", () => resolve2());
      } else {
        resolve2();
      }
    });
  }
  function ClassPropertiesBlessing(constructor) {
    const classes = readInheritableStaticArrayValues(constructor, "classes");
    return classes.reduce((properties, classDefinition) => {
      return Object.assign(properties, propertiesForClassDefinition(classDefinition));
    }, {});
  }
  function propertiesForClassDefinition(key) {
    return {
      [`${key}Class`]: {
        get() {
          const { classes } = this;
          if (classes.has(key)) {
            return classes.get(key);
          } else {
            const attribute = classes.getAttributeName(key);
            throw new Error(`Missing attribute "${attribute}"`);
          }
        }
      },
      [`${key}Classes`]: {
        get() {
          return this.classes.getAll(key);
        }
      },
      [`has${capitalize(key)}Class`]: {
        get() {
          return this.classes.has(key);
        }
      }
    };
  }
  function TargetPropertiesBlessing(constructor) {
    const targets = readInheritableStaticArrayValues(constructor, "targets");
    return targets.reduce((properties, targetDefinition) => {
      return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
    }, {});
  }
  function propertiesForTargetDefinition(name) {
    return {
      [`${name}Target`]: {
        get() {
          const target = this.targets.find(name);
          if (target) {
            return target;
          } else {
            throw new Error(`Missing target element "${name}" for "${this.identifier}" controller`);
          }
        }
      },
      [`${name}Targets`]: {
        get() {
          return this.targets.findAll(name);
        }
      },
      [`has${capitalize(name)}Target`]: {
        get() {
          return this.targets.has(name);
        }
      }
    };
  }
  function ValuePropertiesBlessing(constructor) {
    const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
    const propertyDescriptorMap = {
      valueDescriptorMap: {
        get() {
          return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
            const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair);
            const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
            return Object.assign(result, { [attributeName]: valueDescriptor });
          }, {});
        }
      }
    };
    return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
      return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
    }, propertyDescriptorMap);
  }
  function propertiesForValueDefinitionPair(valueDefinitionPair) {
    const definition = parseValueDefinitionPair(valueDefinitionPair);
    const { key, name, reader: read2, writer: write2 } = definition;
    return {
      [name]: {
        get() {
          const value = this.data.get(key);
          if (value !== null) {
            return read2(value);
          } else {
            return definition.defaultValue;
          }
        },
        set(value) {
          if (value === void 0) {
            this.data.delete(key);
          } else {
            this.data.set(key, write2(value));
          }
        }
      },
      [`has${capitalize(name)}`]: {
        get() {
          return this.data.has(key) || definition.hasCustomDefaultValue;
        }
      }
    };
  }
  function parseValueDefinitionPair([token, typeDefinition]) {
    return valueDescriptorForTokenAndTypeDefinition(token, typeDefinition);
  }
  function parseValueTypeConstant(constant) {
    switch (constant) {
      case Array:
        return "array";
      case Boolean:
        return "boolean";
      case Number:
        return "number";
      case Object:
        return "object";
      case String:
        return "string";
    }
  }
  function parseValueTypeDefault(defaultValue) {
    switch (typeof defaultValue) {
      case "boolean":
        return "boolean";
      case "number":
        return "number";
      case "string":
        return "string";
    }
    if (Array.isArray(defaultValue))
      return "array";
    if (Object.prototype.toString.call(defaultValue) === "[object Object]")
      return "object";
  }
  function parseValueTypeObject(typeObject) {
    const typeFromObject = parseValueTypeConstant(typeObject.type);
    if (typeFromObject) {
      const defaultValueType = parseValueTypeDefault(typeObject.default);
      if (typeFromObject !== defaultValueType) {
        throw new Error(`Type "${typeFromObject}" must match the type of the default value. Given default value: "${typeObject.default}" as "${defaultValueType}"`);
      }
      return typeFromObject;
    }
  }
  function parseValueTypeDefinition(typeDefinition) {
    const typeFromObject = parseValueTypeObject(typeDefinition);
    const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);
    const typeFromConstant = parseValueTypeConstant(typeDefinition);
    const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
    if (type)
      return type;
    throw new Error(`Unknown value type "${typeDefinition}"`);
  }
  function defaultValueForDefinition(typeDefinition) {
    const constant = parseValueTypeConstant(typeDefinition);
    if (constant)
      return defaultValuesByType[constant];
    const defaultValue = typeDefinition.default;
    if (defaultValue !== void 0)
      return defaultValue;
    return typeDefinition;
  }
  function valueDescriptorForTokenAndTypeDefinition(token, typeDefinition) {
    const key = `${dasherize(token)}-value`;
    const type = parseValueTypeDefinition(typeDefinition);
    return {
      type,
      key,
      name: camelize(key),
      get defaultValue() {
        return defaultValueForDefinition(typeDefinition);
      },
      get hasCustomDefaultValue() {
        return parseValueTypeDefault(typeDefinition) !== void 0;
      },
      reader: readers[type],
      writer: writers[type] || writers.default
    };
  }
  var defaultValuesByType = {
    get array() {
      return [];
    },
    boolean: false,
    number: 0,
    get object() {
      return {};
    },
    string: ""
  };
  var readers = {
    array(value) {
      const array = JSON.parse(value);
      if (!Array.isArray(array)) {
        throw new TypeError("Expected array");
      }
      return array;
    },
    boolean(value) {
      return !(value == "0" || value == "false");
    },
    number(value) {
      return Number(value);
    },
    object(value) {
      const object = JSON.parse(value);
      if (object === null || typeof object != "object" || Array.isArray(object)) {
        throw new TypeError("Expected object");
      }
      return object;
    },
    string(value) {
      return value;
    }
  };
  var writers = {
    default: writeString,
    array: writeJSON,
    object: writeJSON
  };
  function writeJSON(value) {
    return JSON.stringify(value);
  }
  function writeString(value) {
    return `${value}`;
  }
  var Controller = class {
    constructor(context) {
      this.context = context;
    }
    static get shouldLoad() {
      return true;
    }
    get application() {
      return this.context.application;
    }
    get scope() {
      return this.context.scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get targets() {
      return this.scope.targets;
    }
    get classes() {
      return this.scope.classes;
    }
    get data() {
      return this.scope.data;
    }
    initialize() {
    }
    connect() {
    }
    disconnect() {
    }
    dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}) {
      const type = prefix ? `${prefix}:${eventName}` : eventName;
      const event = new CustomEvent(type, { detail, bubbles, cancelable });
      target.dispatchEvent(event);
      return event;
    }
  };
  Controller.blessings = [ClassPropertiesBlessing, TargetPropertiesBlessing, ValuePropertiesBlessing];
  Controller.targets = [];
  Controller.values = {};

  // app/javascript/js/application.js
  var application = Application.start();
  application.debug = false;
  window.Stimulus = application;

  // app/javascript/js/helpers/cast_boolean.js
  var castBoolean = (value) => value == "true";

  // app/javascript/js/controllers/action_controller.js
  var action_controller_default = class extends Controller {
    connect() {
      this.resourceIdsTarget.value = this.resourceIds;
      if (this.noConfirmation) {
        this.formTarget.submit();
      } else {
        this.controllerDivTarget.classList.remove("hidden");
      }
    }
    get noConfirmation() {
      return castBoolean(this.controllerDivTarget.dataset.noConfirmation);
    }
    get resourceName() {
      return this.controllerDivTarget.dataset.resourceName;
    }
    get resourceIds() {
      try {
        return JSON.parse(document.querySelector(`[data-selected-resources-name="${this.resourceName}"]`).dataset.selectedResources);
      } catch (error2) {
        return [];
      }
    }
  };
  __publicField(action_controller_default, "targets", ["controllerDiv", "resourceIds", "form"]);

  // node_modules/@stimulus/mutation-observers/dist/element_observer.js
  var ElementObserver2 = function() {
    function ElementObserver3(element, delegate) {
      var _this = this;
      this.element = element;
      this.started = false;
      this.delegate = delegate;
      this.elements = /* @__PURE__ */ new Set();
      this.mutationObserver = new MutationObserver(function(mutations) {
        return _this.processMutations(mutations);
      });
    }
    ElementObserver3.prototype.start = function() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, { attributes: true, childList: true, subtree: true });
        this.refresh();
      }
    };
    ElementObserver3.prototype.stop = function() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    };
    ElementObserver3.prototype.refresh = function() {
      if (this.started) {
        var matches = new Set(this.matchElementsInTree());
        for (var _i = 0, _a = Array.from(this.elements); _i < _a.length; _i++) {
          var element = _a[_i];
          if (!matches.has(element)) {
            this.removeElement(element);
          }
        }
        for (var _b = 0, _c = Array.from(matches); _b < _c.length; _b++) {
          var element = _c[_b];
          this.addElement(element);
        }
      }
    };
    ElementObserver3.prototype.processMutations = function(mutations) {
      if (this.started) {
        for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {
          var mutation = mutations_1[_i];
          this.processMutation(mutation);
        }
      }
    };
    ElementObserver3.prototype.processMutation = function(mutation) {
      if (mutation.type == "attributes") {
        this.processAttributeChange(mutation.target, mutation.attributeName);
      } else if (mutation.type == "childList") {
        this.processRemovedNodes(mutation.removedNodes);
        this.processAddedNodes(mutation.addedNodes);
      }
    };
    ElementObserver3.prototype.processAttributeChange = function(node, attributeName) {
      var element = node;
      if (this.elements.has(element)) {
        if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
          this.delegate.elementAttributeChanged(element, attributeName);
        } else {
          this.removeElement(element);
        }
      } else if (this.matchElement(element)) {
        this.addElement(element);
      }
    };
    ElementObserver3.prototype.processRemovedNodes = function(nodes) {
      for (var _i = 0, _a = Array.from(nodes); _i < _a.length; _i++) {
        var node = _a[_i];
        var element = this.elementFromNode(node);
        if (element) {
          this.processTree(element, this.removeElement);
        }
      }
    };
    ElementObserver3.prototype.processAddedNodes = function(nodes) {
      for (var _i = 0, _a = Array.from(nodes); _i < _a.length; _i++) {
        var node = _a[_i];
        var element = this.elementFromNode(node);
        if (element && this.elementIsActive(element)) {
          this.processTree(element, this.addElement);
        }
      }
    };
    ElementObserver3.prototype.matchElement = function(element) {
      return this.delegate.matchElement(element);
    };
    ElementObserver3.prototype.matchElementsInTree = function(tree) {
      if (tree === void 0) {
        tree = this.element;
      }
      return this.delegate.matchElementsInTree(tree);
    };
    ElementObserver3.prototype.processTree = function(tree, processor) {
      for (var _i = 0, _a = this.matchElementsInTree(tree); _i < _a.length; _i++) {
        var element = _a[_i];
        processor.call(this, element);
      }
    };
    ElementObserver3.prototype.elementFromNode = function(node) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        return node;
      }
    };
    ElementObserver3.prototype.elementIsActive = function(element) {
      if (element.isConnected != this.element.isConnected) {
        return false;
      } else {
        return this.element.contains(element);
      }
    };
    ElementObserver3.prototype.addElement = function(element) {
      if (!this.elements.has(element)) {
        if (this.elementIsActive(element)) {
          this.elements.add(element);
          if (this.delegate.elementMatched) {
            this.delegate.elementMatched(element);
          }
        }
      }
    };
    ElementObserver3.prototype.removeElement = function(element) {
      if (this.elements.has(element)) {
        this.elements.delete(element);
        if (this.delegate.elementUnmatched) {
          this.delegate.elementUnmatched(element);
        }
      }
    };
    return ElementObserver3;
  }();

  // node_modules/@stimulus/mutation-observers/dist/attribute_observer.js
  var AttributeObserver2 = function() {
    function AttributeObserver3(element, attributeName, delegate) {
      this.attributeName = attributeName;
      this.delegate = delegate;
      this.elementObserver = new ElementObserver2(element, this);
    }
    Object.defineProperty(AttributeObserver3.prototype, "element", {
      get: function() {
        return this.elementObserver.element;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(AttributeObserver3.prototype, "selector", {
      get: function() {
        return "[" + this.attributeName + "]";
      },
      enumerable: false,
      configurable: true
    });
    AttributeObserver3.prototype.start = function() {
      this.elementObserver.start();
    };
    AttributeObserver3.prototype.stop = function() {
      this.elementObserver.stop();
    };
    AttributeObserver3.prototype.refresh = function() {
      this.elementObserver.refresh();
    };
    Object.defineProperty(AttributeObserver3.prototype, "started", {
      get: function() {
        return this.elementObserver.started;
      },
      enumerable: false,
      configurable: true
    });
    AttributeObserver3.prototype.matchElement = function(element) {
      return element.hasAttribute(this.attributeName);
    };
    AttributeObserver3.prototype.matchElementsInTree = function(tree) {
      var match = this.matchElement(tree) ? [tree] : [];
      var matches = Array.from(tree.querySelectorAll(this.selector));
      return match.concat(matches);
    };
    AttributeObserver3.prototype.elementMatched = function(element) {
      if (this.delegate.elementMatchedAttribute) {
        this.delegate.elementMatchedAttribute(element, this.attributeName);
      }
    };
    AttributeObserver3.prototype.elementUnmatched = function(element) {
      if (this.delegate.elementUnmatchedAttribute) {
        this.delegate.elementUnmatchedAttribute(element, this.attributeName);
      }
    };
    AttributeObserver3.prototype.elementAttributeChanged = function(element, attributeName) {
      if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
        this.delegate.elementAttributeValueChanged(element, attributeName);
      }
    };
    return AttributeObserver3;
  }();

  // node_modules/@stimulus/mutation-observers/dist/string_map_observer.js
  var StringMapObserver2 = function() {
    function StringMapObserver3(element, delegate) {
      var _this = this;
      this.element = element;
      this.delegate = delegate;
      this.started = false;
      this.stringMap = /* @__PURE__ */ new Map();
      this.mutationObserver = new MutationObserver(function(mutations) {
        return _this.processMutations(mutations);
      });
    }
    StringMapObserver3.prototype.start = function() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, { attributes: true });
        this.refresh();
      }
    };
    StringMapObserver3.prototype.stop = function() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    };
    StringMapObserver3.prototype.refresh = function() {
      if (this.started) {
        for (var _i = 0, _a = this.knownAttributeNames; _i < _a.length; _i++) {
          var attributeName = _a[_i];
          this.refreshAttribute(attributeName);
        }
      }
    };
    StringMapObserver3.prototype.processMutations = function(mutations) {
      if (this.started) {
        for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {
          var mutation = mutations_1[_i];
          this.processMutation(mutation);
        }
      }
    };
    StringMapObserver3.prototype.processMutation = function(mutation) {
      var attributeName = mutation.attributeName;
      if (attributeName) {
        this.refreshAttribute(attributeName);
      }
    };
    StringMapObserver3.prototype.refreshAttribute = function(attributeName) {
      var key = this.delegate.getStringMapKeyForAttribute(attributeName);
      if (key != null) {
        if (!this.stringMap.has(attributeName)) {
          this.stringMapKeyAdded(key, attributeName);
        }
        var value = this.element.getAttribute(attributeName);
        if (this.stringMap.get(attributeName) != value) {
          this.stringMapValueChanged(value, key);
        }
        if (value == null) {
          this.stringMap.delete(attributeName);
          this.stringMapKeyRemoved(key, attributeName);
        } else {
          this.stringMap.set(attributeName, value);
        }
      }
    };
    StringMapObserver3.prototype.stringMapKeyAdded = function(key, attributeName) {
      if (this.delegate.stringMapKeyAdded) {
        this.delegate.stringMapKeyAdded(key, attributeName);
      }
    };
    StringMapObserver3.prototype.stringMapValueChanged = function(value, key) {
      if (this.delegate.stringMapValueChanged) {
        this.delegate.stringMapValueChanged(value, key);
      }
    };
    StringMapObserver3.prototype.stringMapKeyRemoved = function(key, attributeName) {
      if (this.delegate.stringMapKeyRemoved) {
        this.delegate.stringMapKeyRemoved(key, attributeName);
      }
    };
    Object.defineProperty(StringMapObserver3.prototype, "knownAttributeNames", {
      get: function() {
        return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(StringMapObserver3.prototype, "currentAttributeNames", {
      get: function() {
        return Array.from(this.element.attributes).map(function(attribute) {
          return attribute.name;
        });
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(StringMapObserver3.prototype, "recordedAttributeNames", {
      get: function() {
        return Array.from(this.stringMap.keys());
      },
      enumerable: false,
      configurable: true
    });
    return StringMapObserver3;
  }();

  // node_modules/@stimulus/multimap/dist/set_operations.js
  function add2(map, key, value) {
    fetch3(map, key).add(value);
  }
  function del2(map, key, value) {
    fetch3(map, key).delete(value);
    prune2(map, key);
  }
  function fetch3(map, key) {
    var values = map.get(key);
    if (!values) {
      values = /* @__PURE__ */ new Set();
      map.set(key, values);
    }
    return values;
  }
  function prune2(map, key) {
    var values = map.get(key);
    if (values != null && values.size == 0) {
      map.delete(key);
    }
  }

  // node_modules/@stimulus/multimap/dist/multimap.js
  var Multimap2 = function() {
    function Multimap3() {
      this.valuesByKey = /* @__PURE__ */ new Map();
    }
    Object.defineProperty(Multimap3.prototype, "values", {
      get: function() {
        var sets = Array.from(this.valuesByKey.values());
        return sets.reduce(function(values, set) {
          return values.concat(Array.from(set));
        }, []);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Multimap3.prototype, "size", {
      get: function() {
        var sets = Array.from(this.valuesByKey.values());
        return sets.reduce(function(size, set) {
          return size + set.size;
        }, 0);
      },
      enumerable: false,
      configurable: true
    });
    Multimap3.prototype.add = function(key, value) {
      add2(this.valuesByKey, key, value);
    };
    Multimap3.prototype.delete = function(key, value) {
      del2(this.valuesByKey, key, value);
    };
    Multimap3.prototype.has = function(key, value) {
      var values = this.valuesByKey.get(key);
      return values != null && values.has(value);
    };
    Multimap3.prototype.hasKey = function(key) {
      return this.valuesByKey.has(key);
    };
    Multimap3.prototype.hasValue = function(value) {
      var sets = Array.from(this.valuesByKey.values());
      return sets.some(function(set) {
        return set.has(value);
      });
    };
    Multimap3.prototype.getValuesForKey = function(key) {
      var values = this.valuesByKey.get(key);
      return values ? Array.from(values) : [];
    };
    Multimap3.prototype.getKeysForValue = function(value) {
      return Array.from(this.valuesByKey).filter(function(_a) {
        var key = _a[0], values = _a[1];
        return values.has(value);
      }).map(function(_a) {
        var key = _a[0], values = _a[1];
        return key;
      });
    };
    return Multimap3;
  }();

  // node_modules/@stimulus/multimap/dist/indexed_multimap.js
  var __extends = function() {
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3)
          if (b3.hasOwnProperty(p2))
            d3[p2] = b3[p2];
      };
      return extendStatics(d2, b2);
    };
    return function(d2, b2) {
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    };
  }();
  var IndexedMultimap = function(_super) {
    __extends(IndexedMultimap2, _super);
    function IndexedMultimap2() {
      var _this = _super.call(this) || this;
      _this.keysByValue = /* @__PURE__ */ new Map();
      return _this;
    }
    Object.defineProperty(IndexedMultimap2.prototype, "values", {
      get: function() {
        return Array.from(this.keysByValue.keys());
      },
      enumerable: false,
      configurable: true
    });
    IndexedMultimap2.prototype.add = function(key, value) {
      _super.prototype.add.call(this, key, value);
      add2(this.keysByValue, value, key);
    };
    IndexedMultimap2.prototype.delete = function(key, value) {
      _super.prototype.delete.call(this, key, value);
      del2(this.keysByValue, value, key);
    };
    IndexedMultimap2.prototype.hasValue = function(value) {
      return this.keysByValue.has(value);
    };
    IndexedMultimap2.prototype.getKeysForValue = function(value) {
      var set = this.keysByValue.get(value);
      return set ? Array.from(set) : [];
    };
    return IndexedMultimap2;
  }(Multimap2);

  // node_modules/@stimulus/mutation-observers/dist/token_list_observer.js
  var TokenListObserver2 = function() {
    function TokenListObserver3(element, attributeName, delegate) {
      this.attributeObserver = new AttributeObserver2(element, attributeName, this);
      this.delegate = delegate;
      this.tokensByElement = new Multimap2();
    }
    Object.defineProperty(TokenListObserver3.prototype, "started", {
      get: function() {
        return this.attributeObserver.started;
      },
      enumerable: false,
      configurable: true
    });
    TokenListObserver3.prototype.start = function() {
      this.attributeObserver.start();
    };
    TokenListObserver3.prototype.stop = function() {
      this.attributeObserver.stop();
    };
    TokenListObserver3.prototype.refresh = function() {
      this.attributeObserver.refresh();
    };
    Object.defineProperty(TokenListObserver3.prototype, "element", {
      get: function() {
        return this.attributeObserver.element;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TokenListObserver3.prototype, "attributeName", {
      get: function() {
        return this.attributeObserver.attributeName;
      },
      enumerable: false,
      configurable: true
    });
    TokenListObserver3.prototype.elementMatchedAttribute = function(element) {
      this.tokensMatched(this.readTokensForElement(element));
    };
    TokenListObserver3.prototype.elementAttributeValueChanged = function(element) {
      var _a = this.refreshTokensForElement(element), unmatchedTokens = _a[0], matchedTokens = _a[1];
      this.tokensUnmatched(unmatchedTokens);
      this.tokensMatched(matchedTokens);
    };
    TokenListObserver3.prototype.elementUnmatchedAttribute = function(element) {
      this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
    };
    TokenListObserver3.prototype.tokensMatched = function(tokens) {
      var _this = this;
      tokens.forEach(function(token) {
        return _this.tokenMatched(token);
      });
    };
    TokenListObserver3.prototype.tokensUnmatched = function(tokens) {
      var _this = this;
      tokens.forEach(function(token) {
        return _this.tokenUnmatched(token);
      });
    };
    TokenListObserver3.prototype.tokenMatched = function(token) {
      this.delegate.tokenMatched(token);
      this.tokensByElement.add(token.element, token);
    };
    TokenListObserver3.prototype.tokenUnmatched = function(token) {
      this.delegate.tokenUnmatched(token);
      this.tokensByElement.delete(token.element, token);
    };
    TokenListObserver3.prototype.refreshTokensForElement = function(element) {
      var previousTokens = this.tokensByElement.getValuesForKey(element);
      var currentTokens = this.readTokensForElement(element);
      var firstDifferingIndex = zip2(previousTokens, currentTokens).findIndex(function(_a) {
        var previousToken = _a[0], currentToken = _a[1];
        return !tokensAreEqual2(previousToken, currentToken);
      });
      if (firstDifferingIndex == -1) {
        return [[], []];
      } else {
        return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
      }
    };
    TokenListObserver3.prototype.readTokensForElement = function(element) {
      var attributeName = this.attributeName;
      var tokenString = element.getAttribute(attributeName) || "";
      return parseTokenString2(tokenString, element, attributeName);
    };
    return TokenListObserver3;
  }();
  function parseTokenString2(tokenString, element, attributeName) {
    return tokenString.trim().split(/\s+/).filter(function(content) {
      return content.length;
    }).map(function(content, index) {
      return { element, attributeName, content, index };
    });
  }
  function zip2(left2, right2) {
    var length = Math.max(left2.length, right2.length);
    return Array.from({ length }, function(_2, index) {
      return [left2[index], right2[index]];
    });
  }
  function tokensAreEqual2(left2, right2) {
    return left2 && right2 && left2.index == right2.index && left2.content == right2.content;
  }

  // node_modules/@stimulus/mutation-observers/dist/value_list_observer.js
  var ValueListObserver2 = function() {
    function ValueListObserver3(element, attributeName, delegate) {
      this.tokenListObserver = new TokenListObserver2(element, attributeName, this);
      this.delegate = delegate;
      this.parseResultsByToken = /* @__PURE__ */ new WeakMap();
      this.valuesByTokenByElement = /* @__PURE__ */ new WeakMap();
    }
    Object.defineProperty(ValueListObserver3.prototype, "started", {
      get: function() {
        return this.tokenListObserver.started;
      },
      enumerable: false,
      configurable: true
    });
    ValueListObserver3.prototype.start = function() {
      this.tokenListObserver.start();
    };
    ValueListObserver3.prototype.stop = function() {
      this.tokenListObserver.stop();
    };
    ValueListObserver3.prototype.refresh = function() {
      this.tokenListObserver.refresh();
    };
    Object.defineProperty(ValueListObserver3.prototype, "element", {
      get: function() {
        return this.tokenListObserver.element;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ValueListObserver3.prototype, "attributeName", {
      get: function() {
        return this.tokenListObserver.attributeName;
      },
      enumerable: false,
      configurable: true
    });
    ValueListObserver3.prototype.tokenMatched = function(token) {
      var element = token.element;
      var value = this.fetchParseResultForToken(token).value;
      if (value) {
        this.fetchValuesByTokenForElement(element).set(token, value);
        this.delegate.elementMatchedValue(element, value);
      }
    };
    ValueListObserver3.prototype.tokenUnmatched = function(token) {
      var element = token.element;
      var value = this.fetchParseResultForToken(token).value;
      if (value) {
        this.fetchValuesByTokenForElement(element).delete(token);
        this.delegate.elementUnmatchedValue(element, value);
      }
    };
    ValueListObserver3.prototype.fetchParseResultForToken = function(token) {
      var parseResult = this.parseResultsByToken.get(token);
      if (!parseResult) {
        parseResult = this.parseToken(token);
        this.parseResultsByToken.set(token, parseResult);
      }
      return parseResult;
    };
    ValueListObserver3.prototype.fetchValuesByTokenForElement = function(element) {
      var valuesByToken = this.valuesByTokenByElement.get(element);
      if (!valuesByToken) {
        valuesByToken = /* @__PURE__ */ new Map();
        this.valuesByTokenByElement.set(element, valuesByToken);
      }
      return valuesByToken;
    };
    ValueListObserver3.prototype.parseToken = function(token) {
      try {
        var value = this.delegate.parseValueForToken(token);
        return { value };
      } catch (error2) {
        return { error: error2 };
      }
    };
    return ValueListObserver3;
  }();

  // app/javascript/js/controllers/actions_picker_controller.js
  var actions_picker_controller_default = class extends Controller {
    constructor() {
      super(...arguments);
      __publicField(this, "target", {});
    }
    enableTarget() {
      if (this.targetIsDisabled(this.target)) {
        this.target.classList.remove("cursor-wait", "text-gray-500", "hover:bg-blue-300");
        this.target.classList.add("text-gray-700", "hover:bg-blue-500");
        this.target.dataset.disabled = false;
      }
    }
    disableTarget() {
      this.target.classList.add("cursor-wait", "text-gray-500", "hover:bg-blue-300");
      this.target.classList.remove("text-gray-700", "hover:bg-blue-500");
      this.target.dataset.disabled = true;
    }
    targetIsDisabled() {
      return this.target.dataset.disabled === "true";
    }
    visitAction(event) {
      this.target = event.target;
      if (this.targetIsDisabled()) {
        event.preventDefault();
        return;
      }
      this.disableTarget();
      const observer = new AttributeObserver2(document.querySelector("turbo-frame#actions_show"), "busy", {
        elementUnmatchedAttribute: () => {
          this.enableTarget(this.target);
          if (observer)
            observer.stop();
        }
      });
      observer.start();
    }
  };
  __publicField(actions_picker_controller_default, "targets", ["resourceAction", "standaloneAction"]);

  // app/javascript/js/controllers/alerts_controller.js
  var alerts_controller_default = class extends Controller {
    connect() {
      window.toastr[this.type](this.message);
    }
    get type() {
      const typeMap = {
        info: "info",
        warning: "warning",
        success: "success",
        error: "error",
        notice: "info",
        alert: "error"
      };
      return typeMap[this.containerTarget.dataset.alertType];
    }
    get message() {
      return this.containerTarget.innerHTML;
    }
  };
  __publicField(alerts_controller_default, "targets", ["container"]);

  // app/javascript/js/controllers/attachments_controller.js
  var attachments_controller_default = class extends Controller {
    connect() {
      this.formTarget.submit();
    }
  };
  __publicField(attachments_controller_default, "targets", ["form"]);

  // app/javascript/js/controllers/fields/belongs_to_field_controller.js
  var belongs_to_field_controller_default = class extends Controller {
    constructor() {
      super(...arguments);
      __publicField(this, "defaults", {});
    }
    get selectedType() {
      return this.selectTarget.value;
    }
    get isSearchable() {
      return this.context.scope.element.dataset.searchable === "true";
    }
    get association() {
      return this.context.scope.element.dataset.association;
    }
    get associationClass() {
      return this.context.scope.element.dataset.associationClass;
    }
    connect() {
      this.copyValidNames();
      this.changeType();
    }
    changeType() {
      this.hideAllTypes();
      this.showType(this.selectTarget.value);
    }
    hideAllTypes() {
      this.typeTargets.forEach((target) => {
        target.classList.add("hidden");
        this.invalidateTarget(target);
      });
    }
    copyValidNames() {
      this.typeTargets.forEach((target) => {
        const { type } = target.dataset;
        if (this.isSearchable) {
          const textInput = target.querySelector('input[type="text"]');
          if (textInput)
            this.nameToValidName(textInput);
          const hiddenInput = target.querySelector('input[type="hidden"]');
          if (hiddenInput)
            this.nameToValidName(hiddenInput);
        } else {
          const select = target.querySelector("select");
          if (select)
            this.nameToValidName(select);
          const hiddenInput = target.querySelector('input[type="hidden"]');
          if (hiddenInput)
            this.nameToValidName(hiddenInput);
          if (this.selectedType !== type) {
            select.selectedIndex = 0;
          }
        }
      });
    }
    showType(type) {
      const target = this.typeTargets.find((typeTarget) => typeTarget.dataset.type === type);
      if (target) {
        target.classList.remove("hidden");
        this.validateTarget(target);
      }
    }
    validateTarget(target) {
      if (this.isSearchable) {
        const textInput = target.querySelector('input[type="text"]');
        const hiddenInput = target.querySelector('input[type="hidden"]');
        this.validNameToName(textInput);
        this.validNameToName(hiddenInput);
      } else {
        const select = target.querySelector("select");
        const hiddenInput = target.querySelector('input[type="hidden"]');
        this.validNameToName(select);
        if (hiddenInput) {
          this.validNameToName(hiddenInput);
        }
      }
    }
    invalidateTarget(target) {
      if (this.isSearchable) {
        try {
          target.querySelector('input[type="text"]').setAttribute("name", "");
          target.querySelector('input[type="hidden"]').setAttribute("name", "");
        } catch (e2) {
        }
      } else if (target) {
        try {
          target.querySelector("select").setAttribute("name", "");
          target.querySelector('input[type="hidden"]').setAttribute("name", "");
        } catch (error2) {
        }
      }
    }
    validNameToName(target) {
      target.setAttribute("name", target.getAttribute("valid-name"));
    }
    nameToValidName(target) {
      target.setAttribute("valid-name", target.getAttribute("name"));
    }
  };
  __publicField(belongs_to_field_controller_default, "targets", ["select", "type", "loadAssociationLink"]);

  // app/javascript/js/controllers/filter_controller.js
  var import_urijs = __toESM(require_URI());
  var filter_controller_default = class extends Controller {
    uriParams() {
      return (0, import_urijs.default)(window.location.toString()).query(true);
    }
    viaResourceName() {
      return this.uriParams().via_resource_name;
    }
    uriParam(param) {
      const viaResourceName = this.viaResourceName();
      if (viaResourceName)
        return `${this.viaResourceName}_${param}`;
      return param;
    }
    b64EncodeUnicode(str) {
      return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (match, p1) => String.fromCharCode(`0x${p1}`)));
    }
    b64DecodeUnicode(str) {
      return decodeURIComponent(atob(str).split("").map((c2) => `%${`00${c2.charCodeAt(0).toString(16)}`.slice(-2)}`).join(""));
    }
    changeFilter() {
      const value = this.getFilterValue();
      const filterClass = this.getFilterClass();
      let filters = this.uriParams()[this.uriParam("filters")];
      if (filters) {
        filters = JSON.parse(this.b64DecodeUnicode(filters));
      } else {
        filters = {};
      }
      filters[filterClass] = value;
      const filtered = Object.keys(filters).filter((key) => filters[key] !== "").reduce((obj, key) => {
        obj[key] = filters[key];
        return obj;
      }, {});
      let encodedFilters;
      if (filtered && Object.keys(filtered).length > 0) {
        encodedFilters = this.b64EncodeUnicode(JSON.stringify(filtered));
      }
      const url = new import_urijs.default(this.urlRedirectTarget.href);
      const query = __spreadValues({}, url.query(true));
      if (encodedFilters) {
        query.filters = encodedFilters;
      } else {
        delete query.filters;
      }
      url.query(query);
      this.urlRedirectTarget.href = url;
      this.urlRedirectTarget.click();
    }
  };
  __publicField(filter_controller_default, "targets", ["urlRedirect"]);

  // app/javascript/js/controllers/boolean_filter_controller.js
  var boolean_filter_controller_default = class extends filter_controller_default {
    getFilterValue() {
      const filterValue = {};
      this.optionTargets.forEach((option) => {
        filterValue[option.value] = option.checked;
      });
      return filterValue;
    }
    getFilterClass() {
      const { filterClass } = this.optionTarget.dataset;
      return filterClass;
    }
  };
  __publicField(boolean_filter_controller_default, "targets", ["option"]);

  // app/javascript/js/controllers/fields/code_field_controller.js
  var import_css = __toESM(require_css());
  var import_dockerfile = __toESM(require_dockerfile());
  var import_htmlmixed = __toESM(require_htmlmixed());
  var import_javascript = __toESM(require_javascript());
  var import_markdown = __toESM(require_markdown());
  var import_nginx = __toESM(require_nginx());
  var import_php = __toESM(require_php());
  var import_ruby = __toESM(require_ruby());
  var import_sass = __toESM(require_sass());
  var import_shell = __toESM(require_shell());
  var import_sql = __toESM(require_sql());
  var import_vue = __toESM(require_vue());
  var import_xml = __toESM(require_xml());
  var import_yaml = __toESM(require_yaml());
  var import_codemirror = __toESM(require_codemirror());
  var code_field_controller_default = class extends Controller {
    connect() {
      const options = {
        readOnly: castBoolean(this.elementTarget.dataset.readOnly),
        mode: this.elementTarget.dataset.language,
        theme: this.elementTarget.dataset.theme,
        tabSize: this.elementTarget.dataset.tabSize,
        indentWithTabs: castBoolean(this.elementTarget.dataset.indentWithTabs),
        lineWrapping: castBoolean(this.elementTarget.dataset.lineWrapping),
        lineNumbers: true
      };
      setTimeout(() => {
        import_codemirror.default.fromTextArea(this.elementTarget, options);
      }, 1);
    }
  };
  __publicField(code_field_controller_default, "targets", ["element"]);

  // app/javascript/js/controllers/fields/date_field_controller.js
  var import_luxon = __toESM(require_luxon());

  // node_modules/flatpickr/dist/esm/types/options.js
  var HOOKS = [
    "onChange",
    "onClose",
    "onDayCreate",
    "onDestroy",
    "onKeyDown",
    "onMonthChange",
    "onOpen",
    "onParseConfig",
    "onReady",
    "onValueUpdate",
    "onYearChange",
    "onPreCalendarPosition"
  ];
  var defaults = {
    _disable: [],
    allowInput: false,
    allowInvalidPreload: false,
    altFormat: "F j, Y",
    altInput: false,
    altInputClass: "form-control input",
    animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
    ariaDateFormat: "F j, Y",
    autoFillDefaultTime: true,
    clickOpens: true,
    closeOnSelect: true,
    conjunction: ", ",
    dateFormat: "Y-m-d",
    defaultHour: 12,
    defaultMinute: 0,
    defaultSeconds: 0,
    disable: [],
    disableMobile: false,
    enableSeconds: false,
    enableTime: false,
    errorHandler: (err) => typeof console !== "undefined" && console.warn(err),
    getWeek: (givenDate) => {
      const date = new Date(givenDate.getTime());
      date.setHours(0, 0, 0, 0);
      date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
      var week1 = new Date(date.getFullYear(), 0, 4);
      return 1 + Math.round(((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
    },
    hourIncrement: 1,
    ignoredFocusElements: [],
    inline: false,
    locale: "default",
    minuteIncrement: 5,
    mode: "single",
    monthSelectorType: "dropdown",
    nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
    noCalendar: false,
    now: new Date(),
    onChange: [],
    onClose: [],
    onDayCreate: [],
    onDestroy: [],
    onKeyDown: [],
    onMonthChange: [],
    onOpen: [],
    onParseConfig: [],
    onReady: [],
    onValueUpdate: [],
    onYearChange: [],
    onPreCalendarPosition: [],
    plugins: [],
    position: "auto",
    positionElement: void 0,
    prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
    shorthandCurrentMonth: false,
    showMonths: 1,
    static: false,
    time_24hr: false,
    weekNumbers: false,
    wrap: false
  };

  // node_modules/flatpickr/dist/esm/l10n/default.js
  var english = {
    weekdays: {
      shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      longhand: [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ]
    },
    months: {
      shorthand: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ],
      longhand: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ]
    },
    daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    firstDayOfWeek: 0,
    ordinal: (nth) => {
      const s2 = nth % 100;
      if (s2 > 3 && s2 < 21)
        return "th";
      switch (s2 % 10) {
        case 1:
          return "st";
        case 2:
          return "nd";
        case 3:
          return "rd";
        default:
          return "th";
      }
    },
    rangeSeparator: " to ",
    weekAbbreviation: "Wk",
    scrollTitle: "Scroll to increment",
    toggleTitle: "Click to toggle",
    amPM: ["AM", "PM"],
    yearAriaLabel: "Year",
    monthAriaLabel: "Month",
    hourAriaLabel: "Hour",
    minuteAriaLabel: "Minute",
    time_24hr: false
  };
  var default_default = english;

  // node_modules/flatpickr/dist/esm/utils/index.js
  var pad = (number, length = 2) => `000${number}`.slice(length * -1);
  var int = (bool) => bool === true ? 1 : 0;
  function debounce3(fn2, wait) {
    let t2;
    return function() {
      clearTimeout(t2);
      t2 = setTimeout(() => fn2.apply(this, arguments), wait);
    };
  }
  var arrayify = (obj) => obj instanceof Array ? obj : [obj];

  // node_modules/flatpickr/dist/esm/utils/dom.js
  function toggleClass(elem, className, bool) {
    if (bool === true)
      return elem.classList.add(className);
    elem.classList.remove(className);
  }
  function createElement(tag, className, content) {
    const e2 = window.document.createElement(tag);
    className = className || "";
    content = content || "";
    e2.className = className;
    if (content !== void 0)
      e2.textContent = content;
    return e2;
  }
  function clearNode(node) {
    while (node.firstChild)
      node.removeChild(node.firstChild);
  }
  function findParent(node, condition) {
    if (condition(node))
      return node;
    else if (node.parentNode)
      return findParent(node.parentNode, condition);
    return void 0;
  }
  function createNumberInput(inputClassName, opts) {
    const wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
    if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
      numInput.type = "number";
    } else {
      numInput.type = "text";
      numInput.pattern = "\\d*";
    }
    if (opts !== void 0)
      for (const key in opts)
        numInput.setAttribute(key, opts[key]);
    wrapper.appendChild(numInput);
    wrapper.appendChild(arrowUp);
    wrapper.appendChild(arrowDown);
    return wrapper;
  }
  function getEventTarget(event) {
    try {
      if (typeof event.composedPath === "function") {
        const path = event.composedPath();
        return path[0];
      }
      return event.target;
    } catch (error2) {
      return event.target;
    }
  }

  // node_modules/flatpickr/dist/esm/utils/formatting.js
  var doNothing = () => void 0;
  var monthToStr = (monthNumber, shorthand, locale) => locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
  var revFormat = {
    D: doNothing,
    F: function(dateObj, monthName, locale) {
      dateObj.setMonth(locale.months.longhand.indexOf(monthName));
    },
    G: (dateObj, hour) => {
      dateObj.setHours(parseFloat(hour));
    },
    H: (dateObj, hour) => {
      dateObj.setHours(parseFloat(hour));
    },
    J: (dateObj, day) => {
      dateObj.setDate(parseFloat(day));
    },
    K: (dateObj, amPM, locale) => {
      dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
    },
    M: function(dateObj, shortMonth, locale) {
      dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
    },
    S: (dateObj, seconds) => {
      dateObj.setSeconds(parseFloat(seconds));
    },
    U: (_2, unixSeconds) => new Date(parseFloat(unixSeconds) * 1e3),
    W: function(dateObj, weekNum, locale) {
      const weekNumber = parseInt(weekNum);
      const date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
      date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
      return date;
    },
    Y: (dateObj, year) => {
      dateObj.setFullYear(parseFloat(year));
    },
    Z: (_2, ISODate) => new Date(ISODate),
    d: (dateObj, day) => {
      dateObj.setDate(parseFloat(day));
    },
    h: (dateObj, hour) => {
      dateObj.setHours(parseFloat(hour));
    },
    i: (dateObj, minutes) => {
      dateObj.setMinutes(parseFloat(minutes));
    },
    j: (dateObj, day) => {
      dateObj.setDate(parseFloat(day));
    },
    l: doNothing,
    m: (dateObj, month) => {
      dateObj.setMonth(parseFloat(month) - 1);
    },
    n: (dateObj, month) => {
      dateObj.setMonth(parseFloat(month) - 1);
    },
    s: (dateObj, seconds) => {
      dateObj.setSeconds(parseFloat(seconds));
    },
    u: (_2, unixMillSeconds) => new Date(parseFloat(unixMillSeconds)),
    w: doNothing,
    y: (dateObj, year) => {
      dateObj.setFullYear(2e3 + parseFloat(year));
    }
  };
  var tokenRegex = {
    D: "(\\w+)",
    F: "(\\w+)",
    G: "(\\d\\d|\\d)",
    H: "(\\d\\d|\\d)",
    J: "(\\d\\d|\\d)\\w+",
    K: "",
    M: "(\\w+)",
    S: "(\\d\\d|\\d)",
    U: "(.+)",
    W: "(\\d\\d|\\d)",
    Y: "(\\d{4})",
    Z: "(.+)",
    d: "(\\d\\d|\\d)",
    h: "(\\d\\d|\\d)",
    i: "(\\d\\d|\\d)",
    j: "(\\d\\d|\\d)",
    l: "(\\w+)",
    m: "(\\d\\d|\\d)",
    n: "(\\d\\d|\\d)",
    s: "(\\d\\d|\\d)",
    u: "(.+)",
    w: "(\\d\\d|\\d)",
    y: "(\\d{2})"
  };
  var formats = {
    Z: (date) => date.toISOString(),
    D: function(date, locale, options) {
      return locale.weekdays.shorthand[formats.w(date, locale, options)];
    },
    F: function(date, locale, options) {
      return monthToStr(formats.n(date, locale, options) - 1, false, locale);
    },
    G: function(date, locale, options) {
      return pad(formats.h(date, locale, options));
    },
    H: (date) => pad(date.getHours()),
    J: function(date, locale) {
      return locale.ordinal !== void 0 ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
    },
    K: (date, locale) => locale.amPM[int(date.getHours() > 11)],
    M: function(date, locale) {
      return monthToStr(date.getMonth(), true, locale);
    },
    S: (date) => pad(date.getSeconds()),
    U: (date) => date.getTime() / 1e3,
    W: function(date, _2, options) {
      return options.getWeek(date);
    },
    Y: (date) => pad(date.getFullYear(), 4),
    d: (date) => pad(date.getDate()),
    h: (date) => date.getHours() % 12 ? date.getHours() % 12 : 12,
    i: (date) => pad(date.getMinutes()),
    j: (date) => date.getDate(),
    l: function(date, locale) {
      return locale.weekdays.longhand[date.getDay()];
    },
    m: (date) => pad(date.getMonth() + 1),
    n: (date) => date.getMonth() + 1,
    s: (date) => date.getSeconds(),
    u: (date) => date.getTime(),
    w: (date) => date.getDay(),
    y: (date) => String(date.getFullYear()).substring(2)
  };

  // node_modules/flatpickr/dist/esm/utils/dates.js
  var createDateFormatter = ({ config = defaults, l10n = english, isMobile = false }) => (dateObj, frmt, overrideLocale) => {
    const locale = overrideLocale || l10n;
    if (config.formatDate !== void 0 && !isMobile) {
      return config.formatDate(dateObj, frmt, locale);
    }
    return frmt.split("").map((c2, i2, arr) => formats[c2] && arr[i2 - 1] !== "\\" ? formats[c2](dateObj, locale, config) : c2 !== "\\" ? c2 : "").join("");
  };
  var createDateParser = ({ config = defaults, l10n = english }) => (date, givenFormat, timeless, customLocale) => {
    if (date !== 0 && !date)
      return void 0;
    const locale = customLocale || l10n;
    let parsedDate;
    const dateOrig = date;
    if (date instanceof Date)
      parsedDate = new Date(date.getTime());
    else if (typeof date !== "string" && date.toFixed !== void 0)
      parsedDate = new Date(date);
    else if (typeof date === "string") {
      const format2 = givenFormat || (config || defaults).dateFormat;
      const datestr = String(date).trim();
      if (datestr === "today") {
        parsedDate = new Date();
        timeless = true;
      } else if (/Z$/.test(datestr) || /GMT$/.test(datestr))
        parsedDate = new Date(date);
      else if (config && config.parseDate)
        parsedDate = config.parseDate(date, format2);
      else {
        parsedDate = !config || !config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));
        let matched, ops = [];
        for (let i2 = 0, matchIndex = 0, regexStr = ""; i2 < format2.length; i2++) {
          const token = format2[i2];
          const isBackSlash = token === "\\";
          const escaped = format2[i2 - 1] === "\\" || isBackSlash;
          if (tokenRegex[token] && !escaped) {
            regexStr += tokenRegex[token];
            const match = new RegExp(regexStr).exec(date);
            if (match && (matched = true)) {
              ops[token !== "Y" ? "push" : "unshift"]({
                fn: revFormat[token],
                val: match[++matchIndex]
              });
            }
          } else if (!isBackSlash)
            regexStr += ".";
          ops.forEach(({ fn: fn2, val }) => parsedDate = fn2(parsedDate, val, locale) || parsedDate);
        }
        parsedDate = matched ? parsedDate : void 0;
      }
    }
    if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
      config.errorHandler(new Error(`Invalid date provided: ${dateOrig}`));
      return void 0;
    }
    if (timeless === true)
      parsedDate.setHours(0, 0, 0, 0);
    return parsedDate;
  };
  function compareDates(date1, date2, timeless = true) {
    if (timeless !== false) {
      return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
    }
    return date1.getTime() - date2.getTime();
  }
  var isBetween = (ts, ts1, ts2) => {
    return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
  };
  var duration = {
    DAY: 864e5
  };
  function getDefaultHours(config) {
    let hours = config.defaultHour;
    let minutes = config.defaultMinute;
    let seconds = config.defaultSeconds;
    if (config.minDate !== void 0) {
      const minHour = config.minDate.getHours();
      const minMinutes = config.minDate.getMinutes();
      const minSeconds = config.minDate.getSeconds();
      if (hours < minHour) {
        hours = minHour;
      }
      if (hours === minHour && minutes < minMinutes) {
        minutes = minMinutes;
      }
      if (hours === minHour && minutes === minMinutes && seconds < minSeconds)
        seconds = config.minDate.getSeconds();
    }
    if (config.maxDate !== void 0) {
      const maxHr = config.maxDate.getHours();
      const maxMinutes = config.maxDate.getMinutes();
      hours = Math.min(hours, maxHr);
      if (hours === maxHr)
        minutes = Math.min(maxMinutes, minutes);
      if (hours === maxHr && minutes === maxMinutes)
        seconds = config.maxDate.getSeconds();
    }
    return { hours, minutes, seconds };
  }

  // node_modules/flatpickr/dist/esm/utils/polyfills.js
  if (typeof Object.assign !== "function") {
    Object.assign = function(target, ...args) {
      if (!target) {
        throw TypeError("Cannot convert undefined or null to object");
      }
      for (const source of args) {
        if (source) {
          Object.keys(source).forEach((key) => target[key] = source[key]);
        }
      }
      return target;
    };
  }

  // node_modules/flatpickr/dist/esm/index.js
  var DEBOUNCED_CHANGE_MS = 300;
  function FlatpickrInstance(element, instanceConfig) {
    const self2 = {
      config: Object.assign(Object.assign({}, defaults), flatpickr.defaultConfig),
      l10n: default_default
    };
    self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
    self2._handlers = [];
    self2.pluginElements = [];
    self2.loadedPlugins = [];
    self2._bind = bind3;
    self2._setHoursFromDate = setHoursFromDate;
    self2._positionCalendar = positionCalendar;
    self2.changeMonth = changeMonth;
    self2.changeYear = changeYear;
    self2.clear = clear;
    self2.close = close;
    self2._createElement = createElement;
    self2.destroy = destroy;
    self2.isEnabled = isEnabled;
    self2.jumpToDate = jumpToDate;
    self2.open = open;
    self2.redraw = redraw;
    self2.set = set;
    self2.setDate = setDate;
    self2.toggle = toggle;
    function setupHelperFunctions() {
      self2.utils = {
        getDaysInMonth(month = self2.currentMonth, yr = self2.currentYear) {
          if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0))
            return 29;
          return self2.l10n.daysInMonth[month];
        }
      };
    }
    function init() {
      self2.element = self2.input = element;
      self2.isOpen = false;
      parseConfig();
      setupLocale();
      setupInputs();
      setupDates();
      setupHelperFunctions();
      if (!self2.isMobile)
        build();
      bindEvents();
      if (self2.selectedDates.length || self2.config.noCalendar) {
        if (self2.config.enableTime) {
          setHoursFromDate(self2.config.noCalendar ? self2.latestSelectedDateObj : void 0);
        }
        updateValue(false);
      }
      setCalendarWidth();
      const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      if (!self2.isMobile && isSafari) {
        positionCalendar();
      }
      triggerEvent("onReady");
    }
    function bindToInstance(fn2) {
      return fn2.bind(self2);
    }
    function setCalendarWidth() {
      const config = self2.config;
      if (config.weekNumbers === false && config.showMonths === 1) {
        return;
      } else if (config.noCalendar !== true) {
        window.requestAnimationFrame(function() {
          if (self2.calendarContainer !== void 0) {
            self2.calendarContainer.style.visibility = "hidden";
            self2.calendarContainer.style.display = "block";
          }
          if (self2.daysContainer !== void 0) {
            const daysWidth = (self2.days.offsetWidth + 1) * config.showMonths;
            self2.daysContainer.style.width = daysWidth + "px";
            self2.calendarContainer.style.width = daysWidth + (self2.weekWrapper !== void 0 ? self2.weekWrapper.offsetWidth : 0) + "px";
            self2.calendarContainer.style.removeProperty("visibility");
            self2.calendarContainer.style.removeProperty("display");
          }
        });
      }
    }
    function updateTime(e2) {
      if (self2.selectedDates.length === 0) {
        const defaultDate = self2.config.minDate === void 0 || compareDates(new Date(), self2.config.minDate) >= 0 ? new Date() : new Date(self2.config.minDate.getTime());
        const defaults2 = getDefaultHours(self2.config);
        defaultDate.setHours(defaults2.hours, defaults2.minutes, defaults2.seconds, defaultDate.getMilliseconds());
        self2.selectedDates = [defaultDate];
        self2.latestSelectedDateObj = defaultDate;
      }
      if (e2 !== void 0 && e2.type !== "blur") {
        timeWrapper(e2);
      }
      const prevValue = self2._input.value;
      setHoursFromInputs();
      updateValue();
      if (self2._input.value !== prevValue) {
        self2._debouncedChange();
      }
    }
    function ampm2military(hour, amPM) {
      return hour % 12 + 12 * int(amPM === self2.l10n.amPM[1]);
    }
    function military2ampm(hour) {
      switch (hour % 24) {
        case 0:
        case 12:
          return 12;
        default:
          return hour % 12;
      }
    }
    function setHoursFromInputs() {
      if (self2.hourElement === void 0 || self2.minuteElement === void 0)
        return;
      let hours = (parseInt(self2.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self2.minuteElement.value, 10) || 0) % 60, seconds = self2.secondElement !== void 0 ? (parseInt(self2.secondElement.value, 10) || 0) % 60 : 0;
      if (self2.amPM !== void 0) {
        hours = ampm2military(hours, self2.amPM.textContent);
      }
      const limitMinHours = self2.config.minTime !== void 0 || self2.config.minDate && self2.minDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.minDate, true) === 0;
      const limitMaxHours = self2.config.maxTime !== void 0 || self2.config.maxDate && self2.maxDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.maxDate, true) === 0;
      if (limitMaxHours) {
        const maxTime = self2.config.maxTime !== void 0 ? self2.config.maxTime : self2.config.maxDate;
        hours = Math.min(hours, maxTime.getHours());
        if (hours === maxTime.getHours())
          minutes = Math.min(minutes, maxTime.getMinutes());
        if (minutes === maxTime.getMinutes())
          seconds = Math.min(seconds, maxTime.getSeconds());
      }
      if (limitMinHours) {
        const minTime = self2.config.minTime !== void 0 ? self2.config.minTime : self2.config.minDate;
        hours = Math.max(hours, minTime.getHours());
        if (hours === minTime.getHours() && minutes < minTime.getMinutes())
          minutes = minTime.getMinutes();
        if (minutes === minTime.getMinutes())
          seconds = Math.max(seconds, minTime.getSeconds());
      }
      setHours(hours, minutes, seconds);
    }
    function setHoursFromDate(dateObj) {
      const date = dateObj || self2.latestSelectedDateObj;
      if (date) {
        setHours(date.getHours(), date.getMinutes(), date.getSeconds());
      }
    }
    function setHours(hours, minutes, seconds) {
      if (self2.latestSelectedDateObj !== void 0) {
        self2.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
      }
      if (!self2.hourElement || !self2.minuteElement || self2.isMobile)
        return;
      self2.hourElement.value = pad(!self2.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);
      self2.minuteElement.value = pad(minutes);
      if (self2.amPM !== void 0)
        self2.amPM.textContent = self2.l10n.amPM[int(hours >= 12)];
      if (self2.secondElement !== void 0)
        self2.secondElement.value = pad(seconds);
    }
    function onYearInput(event) {
      const eventTarget = getEventTarget(event);
      const year = parseInt(eventTarget.value) + (event.delta || 0);
      if (year / 1e3 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
        changeYear(year);
      }
    }
    function bind3(element2, event, handler, options) {
      if (event instanceof Array)
        return event.forEach((ev) => bind3(element2, ev, handler, options));
      if (element2 instanceof Array)
        return element2.forEach((el) => bind3(el, event, handler, options));
      element2.addEventListener(event, handler, options);
      self2._handlers.push({
        remove: () => element2.removeEventListener(event, handler)
      });
    }
    function triggerChange() {
      triggerEvent("onChange");
    }
    function bindEvents() {
      if (self2.config.wrap) {
        ["open", "close", "toggle", "clear"].forEach((evt) => {
          Array.prototype.forEach.call(self2.element.querySelectorAll(`[data-${evt}]`), (el) => bind3(el, "click", self2[evt]));
        });
      }
      if (self2.isMobile) {
        setupMobile();
        return;
      }
      const debouncedResize = debounce3(onResize, 50);
      self2._debouncedChange = debounce3(triggerChange, DEBOUNCED_CHANGE_MS);
      if (self2.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
        bind3(self2.daysContainer, "mouseover", (e2) => {
          if (self2.config.mode === "range")
            onMouseOver(getEventTarget(e2));
        });
      bind3(window.document.body, "keydown", onKeyDown2);
      if (!self2.config.inline && !self2.config.static)
        bind3(window, "resize", debouncedResize);
      if (window.ontouchstart !== void 0)
        bind3(window.document, "touchstart", documentClick);
      else
        bind3(window.document, "mousedown", documentClick);
      bind3(window.document, "focus", documentClick, { capture: true });
      if (self2.config.clickOpens === true) {
        bind3(self2._input, "focus", self2.open);
        bind3(self2._input, "click", self2.open);
      }
      if (self2.daysContainer !== void 0) {
        bind3(self2.monthNav, "click", onMonthNavClick);
        bind3(self2.monthNav, ["keyup", "increment"], onYearInput);
        bind3(self2.daysContainer, "click", selectDate);
      }
      if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0) {
        const selText = (e2) => getEventTarget(e2).select();
        bind3(self2.timeContainer, ["increment"], updateTime);
        bind3(self2.timeContainer, "blur", updateTime, { capture: true });
        bind3(self2.timeContainer, "click", timeIncrement);
        bind3([self2.hourElement, self2.minuteElement], ["focus", "click"], selText);
        if (self2.secondElement !== void 0)
          bind3(self2.secondElement, "focus", () => self2.secondElement && self2.secondElement.select());
        if (self2.amPM !== void 0) {
          bind3(self2.amPM, "click", (e2) => {
            updateTime(e2);
            triggerChange();
          });
        }
      }
      if (self2.config.allowInput) {
        bind3(self2._input, "blur", onBlur);
      }
    }
    function jumpToDate(jumpDate, triggerChange2) {
      const jumpTo = jumpDate !== void 0 ? self2.parseDate(jumpDate) : self2.latestSelectedDateObj || (self2.config.minDate && self2.config.minDate > self2.now ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate < self2.now ? self2.config.maxDate : self2.now);
      const oldYear = self2.currentYear;
      const oldMonth = self2.currentMonth;
      try {
        if (jumpTo !== void 0) {
          self2.currentYear = jumpTo.getFullYear();
          self2.currentMonth = jumpTo.getMonth();
        }
      } catch (e2) {
        e2.message = "Invalid date supplied: " + jumpTo;
        self2.config.errorHandler(e2);
      }
      if (triggerChange2 && self2.currentYear !== oldYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      if (triggerChange2 && (self2.currentYear !== oldYear || self2.currentMonth !== oldMonth)) {
        triggerEvent("onMonthChange");
      }
      self2.redraw();
    }
    function timeIncrement(e2) {
      const eventTarget = getEventTarget(e2);
      if (~eventTarget.className.indexOf("arrow"))
        incrementNumInput(e2, eventTarget.classList.contains("arrowUp") ? 1 : -1);
    }
    function incrementNumInput(e2, delta, inputElem) {
      const target = e2 && getEventTarget(e2);
      const input = inputElem || target && target.parentNode && target.parentNode.firstChild;
      const event = createEvent("increment");
      event.delta = delta;
      input && input.dispatchEvent(event);
    }
    function build() {
      const fragment = window.document.createDocumentFragment();
      self2.calendarContainer = createElement("div", "flatpickr-calendar");
      self2.calendarContainer.tabIndex = -1;
      if (!self2.config.noCalendar) {
        fragment.appendChild(buildMonthNav());
        self2.innerContainer = createElement("div", "flatpickr-innerContainer");
        if (self2.config.weekNumbers) {
          const { weekWrapper, weekNumbers } = buildWeeks();
          self2.innerContainer.appendChild(weekWrapper);
          self2.weekNumbers = weekNumbers;
          self2.weekWrapper = weekWrapper;
        }
        self2.rContainer = createElement("div", "flatpickr-rContainer");
        self2.rContainer.appendChild(buildWeekdays());
        if (!self2.daysContainer) {
          self2.daysContainer = createElement("div", "flatpickr-days");
          self2.daysContainer.tabIndex = -1;
        }
        buildDays();
        self2.rContainer.appendChild(self2.daysContainer);
        self2.innerContainer.appendChild(self2.rContainer);
        fragment.appendChild(self2.innerContainer);
      }
      if (self2.config.enableTime) {
        fragment.appendChild(buildTime());
      }
      toggleClass(self2.calendarContainer, "rangeMode", self2.config.mode === "range");
      toggleClass(self2.calendarContainer, "animate", self2.config.animate === true);
      toggleClass(self2.calendarContainer, "multiMonth", self2.config.showMonths > 1);
      self2.calendarContainer.appendChild(fragment);
      const customAppend = self2.config.appendTo !== void 0 && self2.config.appendTo.nodeType !== void 0;
      if (self2.config.inline || self2.config.static) {
        self2.calendarContainer.classList.add(self2.config.inline ? "inline" : "static");
        if (self2.config.inline) {
          if (!customAppend && self2.element.parentNode)
            self2.element.parentNode.insertBefore(self2.calendarContainer, self2._input.nextSibling);
          else if (self2.config.appendTo !== void 0)
            self2.config.appendTo.appendChild(self2.calendarContainer);
        }
        if (self2.config.static) {
          const wrapper = createElement("div", "flatpickr-wrapper");
          if (self2.element.parentNode)
            self2.element.parentNode.insertBefore(wrapper, self2.element);
          wrapper.appendChild(self2.element);
          if (self2.altInput)
            wrapper.appendChild(self2.altInput);
          wrapper.appendChild(self2.calendarContainer);
        }
      }
      if (!self2.config.static && !self2.config.inline)
        (self2.config.appendTo !== void 0 ? self2.config.appendTo : window.document.body).appendChild(self2.calendarContainer);
    }
    function createDay(className, date, dayNumber, i2) {
      const dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", "flatpickr-day " + className, date.getDate().toString());
      dayElement.dateObj = date;
      dayElement.$i = i2;
      dayElement.setAttribute("aria-label", self2.formatDate(date, self2.config.ariaDateFormat));
      if (className.indexOf("hidden") === -1 && compareDates(date, self2.now) === 0) {
        self2.todayDateElem = dayElement;
        dayElement.classList.add("today");
        dayElement.setAttribute("aria-current", "date");
      }
      if (dateIsEnabled) {
        dayElement.tabIndex = -1;
        if (isDateSelected(date)) {
          dayElement.classList.add("selected");
          self2.selectedDateElem = dayElement;
          if (self2.config.mode === "range") {
            toggleClass(dayElement, "startRange", self2.selectedDates[0] && compareDates(date, self2.selectedDates[0], true) === 0);
            toggleClass(dayElement, "endRange", self2.selectedDates[1] && compareDates(date, self2.selectedDates[1], true) === 0);
            if (className === "nextMonthDay")
              dayElement.classList.add("inRange");
          }
        }
      } else {
        dayElement.classList.add("flatpickr-disabled");
      }
      if (self2.config.mode === "range") {
        if (isDateInRange(date) && !isDateSelected(date))
          dayElement.classList.add("inRange");
      }
      if (self2.weekNumbers && self2.config.showMonths === 1 && className !== "prevMonthDay" && dayNumber % 7 === 1) {
        self2.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self2.config.getWeek(date) + "</span>");
      }
      triggerEvent("onDayCreate", dayElement);
      return dayElement;
    }
    function focusOnDayElem(targetNode) {
      targetNode.focus();
      if (self2.config.mode === "range")
        onMouseOver(targetNode);
    }
    function getFirstAvailableDay(delta) {
      const startMonth = delta > 0 ? 0 : self2.config.showMonths - 1;
      const endMonth = delta > 0 ? self2.config.showMonths : -1;
      for (let m2 = startMonth; m2 != endMonth; m2 += delta) {
        const month = self2.daysContainer.children[m2];
        const startIndex = delta > 0 ? 0 : month.children.length - 1;
        const endIndex = delta > 0 ? month.children.length : -1;
        for (let i2 = startIndex; i2 != endIndex; i2 += delta) {
          const c2 = month.children[i2];
          if (c2.className.indexOf("hidden") === -1 && isEnabled(c2.dateObj))
            return c2;
        }
      }
      return void 0;
    }
    function getNextAvailableDay(current, delta) {
      const givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self2.currentMonth;
      const endMonth = delta > 0 ? self2.config.showMonths : -1;
      const loopDelta = delta > 0 ? 1 : -1;
      for (let m2 = givenMonth - self2.currentMonth; m2 != endMonth; m2 += loopDelta) {
        const month = self2.daysContainer.children[m2];
        const startIndex = givenMonth - self2.currentMonth === m2 ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
        const numMonthDays = month.children.length;
        for (let i2 = startIndex; i2 >= 0 && i2 < numMonthDays && i2 != (delta > 0 ? numMonthDays : -1); i2 += loopDelta) {
          const c2 = month.children[i2];
          if (c2.className.indexOf("hidden") === -1 && isEnabled(c2.dateObj) && Math.abs(current.$i - i2) >= Math.abs(delta))
            return focusOnDayElem(c2);
        }
      }
      self2.changeMonth(loopDelta);
      focusOnDay(getFirstAvailableDay(loopDelta), 0);
      return void 0;
    }
    function focusOnDay(current, offset2) {
      const dayFocused = isInView(document.activeElement || document.body);
      const startElem = current !== void 0 ? current : dayFocused ? document.activeElement : self2.selectedDateElem !== void 0 && isInView(self2.selectedDateElem) ? self2.selectedDateElem : self2.todayDateElem !== void 0 && isInView(self2.todayDateElem) ? self2.todayDateElem : getFirstAvailableDay(offset2 > 0 ? 1 : -1);
      if (startElem === void 0) {
        self2._input.focus();
      } else if (!dayFocused) {
        focusOnDayElem(startElem);
      } else {
        getNextAvailableDay(startElem, offset2);
      }
    }
    function buildMonthDays(year, month) {
      const firstOfMonth = (new Date(year, month, 1).getDay() - self2.l10n.firstDayOfWeek + 7) % 7;
      const prevMonthDays = self2.utils.getDaysInMonth((month - 1 + 12) % 12, year);
      const daysInMonth = self2.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self2.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
      let dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
      for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
        days.appendChild(createDay(prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
      }
      for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
        days.appendChild(createDay("", new Date(year, month, dayNumber), dayNumber, dayIndex));
      }
      for (let dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self2.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
        days.appendChild(createDay(nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
      }
      const dayContainer = createElement("div", "dayContainer");
      dayContainer.appendChild(days);
      return dayContainer;
    }
    function buildDays() {
      if (self2.daysContainer === void 0) {
        return;
      }
      clearNode(self2.daysContainer);
      if (self2.weekNumbers)
        clearNode(self2.weekNumbers);
      const frag = document.createDocumentFragment();
      for (let i2 = 0; i2 < self2.config.showMonths; i2++) {
        const d2 = new Date(self2.currentYear, self2.currentMonth, 1);
        d2.setMonth(self2.currentMonth + i2);
        frag.appendChild(buildMonthDays(d2.getFullYear(), d2.getMonth()));
      }
      self2.daysContainer.appendChild(frag);
      self2.days = self2.daysContainer.firstChild;
      if (self2.config.mode === "range" && self2.selectedDates.length === 1) {
        onMouseOver();
      }
    }
    function buildMonthSwitch() {
      if (self2.config.showMonths > 1 || self2.config.monthSelectorType !== "dropdown")
        return;
      const shouldBuildMonth = function(month) {
        if (self2.config.minDate !== void 0 && self2.currentYear === self2.config.minDate.getFullYear() && month < self2.config.minDate.getMonth()) {
          return false;
        }
        return !(self2.config.maxDate !== void 0 && self2.currentYear === self2.config.maxDate.getFullYear() && month > self2.config.maxDate.getMonth());
      };
      self2.monthsDropdownContainer.tabIndex = -1;
      self2.monthsDropdownContainer.innerHTML = "";
      for (let i2 = 0; i2 < 12; i2++) {
        if (!shouldBuildMonth(i2))
          continue;
        const month = createElement("option", "flatpickr-monthDropdown-month");
        month.value = new Date(self2.currentYear, i2).getMonth().toString();
        month.textContent = monthToStr(i2, self2.config.shorthandCurrentMonth, self2.l10n);
        month.tabIndex = -1;
        if (self2.currentMonth === i2) {
          month.selected = true;
        }
        self2.monthsDropdownContainer.appendChild(month);
      }
    }
    function buildMonth() {
      const container = createElement("div", "flatpickr-month");
      const monthNavFragment = window.document.createDocumentFragment();
      let monthElement;
      if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
        monthElement = createElement("span", "cur-month");
      } else {
        self2.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
        self2.monthsDropdownContainer.setAttribute("aria-label", self2.l10n.monthAriaLabel);
        bind3(self2.monthsDropdownContainer, "change", (e2) => {
          const target = getEventTarget(e2);
          const selectedMonth = parseInt(target.value, 10);
          self2.changeMonth(selectedMonth - self2.currentMonth);
          triggerEvent("onMonthChange");
        });
        buildMonthSwitch();
        monthElement = self2.monthsDropdownContainer;
      }
      const yearInput = createNumberInput("cur-year", { tabindex: "-1" });
      const yearElement = yearInput.getElementsByTagName("input")[0];
      yearElement.setAttribute("aria-label", self2.l10n.yearAriaLabel);
      if (self2.config.minDate) {
        yearElement.setAttribute("min", self2.config.minDate.getFullYear().toString());
      }
      if (self2.config.maxDate) {
        yearElement.setAttribute("max", self2.config.maxDate.getFullYear().toString());
        yearElement.disabled = !!self2.config.minDate && self2.config.minDate.getFullYear() === self2.config.maxDate.getFullYear();
      }
      const currentMonth = createElement("div", "flatpickr-current-month");
      currentMonth.appendChild(monthElement);
      currentMonth.appendChild(yearInput);
      monthNavFragment.appendChild(currentMonth);
      container.appendChild(monthNavFragment);
      return {
        container,
        yearElement,
        monthElement
      };
    }
    function buildMonths() {
      clearNode(self2.monthNav);
      self2.monthNav.appendChild(self2.prevMonthNav);
      if (self2.config.showMonths) {
        self2.yearElements = [];
        self2.monthElements = [];
      }
      for (let m2 = self2.config.showMonths; m2--; ) {
        const month = buildMonth();
        self2.yearElements.push(month.yearElement);
        self2.monthElements.push(month.monthElement);
        self2.monthNav.appendChild(month.container);
      }
      self2.monthNav.appendChild(self2.nextMonthNav);
    }
    function buildMonthNav() {
      self2.monthNav = createElement("div", "flatpickr-months");
      self2.yearElements = [];
      self2.monthElements = [];
      self2.prevMonthNav = createElement("span", "flatpickr-prev-month");
      self2.prevMonthNav.innerHTML = self2.config.prevArrow;
      self2.nextMonthNav = createElement("span", "flatpickr-next-month");
      self2.nextMonthNav.innerHTML = self2.config.nextArrow;
      buildMonths();
      Object.defineProperty(self2, "_hidePrevMonthArrow", {
        get: () => self2.__hidePrevMonthArrow,
        set(bool) {
          if (self2.__hidePrevMonthArrow !== bool) {
            toggleClass(self2.prevMonthNav, "flatpickr-disabled", bool);
            self2.__hidePrevMonthArrow = bool;
          }
        }
      });
      Object.defineProperty(self2, "_hideNextMonthArrow", {
        get: () => self2.__hideNextMonthArrow,
        set(bool) {
          if (self2.__hideNextMonthArrow !== bool) {
            toggleClass(self2.nextMonthNav, "flatpickr-disabled", bool);
            self2.__hideNextMonthArrow = bool;
          }
        }
      });
      self2.currentYearElement = self2.yearElements[0];
      updateNavigationCurrentMonth();
      return self2.monthNav;
    }
    function buildTime() {
      self2.calendarContainer.classList.add("hasTime");
      if (self2.config.noCalendar)
        self2.calendarContainer.classList.add("noCalendar");
      const defaults2 = getDefaultHours(self2.config);
      self2.timeContainer = createElement("div", "flatpickr-time");
      self2.timeContainer.tabIndex = -1;
      const separator = createElement("span", "flatpickr-time-separator", ":");
      const hourInput = createNumberInput("flatpickr-hour", {
        "aria-label": self2.l10n.hourAriaLabel
      });
      self2.hourElement = hourInput.getElementsByTagName("input")[0];
      const minuteInput = createNumberInput("flatpickr-minute", {
        "aria-label": self2.l10n.minuteAriaLabel
      });
      self2.minuteElement = minuteInput.getElementsByTagName("input")[0];
      self2.hourElement.tabIndex = self2.minuteElement.tabIndex = -1;
      self2.hourElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getHours() : self2.config.time_24hr ? defaults2.hours : military2ampm(defaults2.hours));
      self2.minuteElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getMinutes() : defaults2.minutes);
      self2.hourElement.setAttribute("step", self2.config.hourIncrement.toString());
      self2.minuteElement.setAttribute("step", self2.config.minuteIncrement.toString());
      self2.hourElement.setAttribute("min", self2.config.time_24hr ? "0" : "1");
      self2.hourElement.setAttribute("max", self2.config.time_24hr ? "23" : "12");
      self2.hourElement.setAttribute("maxlength", "2");
      self2.minuteElement.setAttribute("min", "0");
      self2.minuteElement.setAttribute("max", "59");
      self2.minuteElement.setAttribute("maxlength", "2");
      self2.timeContainer.appendChild(hourInput);
      self2.timeContainer.appendChild(separator);
      self2.timeContainer.appendChild(minuteInput);
      if (self2.config.time_24hr)
        self2.timeContainer.classList.add("time24hr");
      if (self2.config.enableSeconds) {
        self2.timeContainer.classList.add("hasSeconds");
        const secondInput = createNumberInput("flatpickr-second");
        self2.secondElement = secondInput.getElementsByTagName("input")[0];
        self2.secondElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getSeconds() : defaults2.seconds);
        self2.secondElement.setAttribute("step", self2.minuteElement.getAttribute("step"));
        self2.secondElement.setAttribute("min", "0");
        self2.secondElement.setAttribute("max", "59");
        self2.secondElement.setAttribute("maxlength", "2");
        self2.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
        self2.timeContainer.appendChild(secondInput);
      }
      if (!self2.config.time_24hr) {
        self2.amPM = createElement("span", "flatpickr-am-pm", self2.l10n.amPM[int((self2.latestSelectedDateObj ? self2.hourElement.value : self2.config.defaultHour) > 11)]);
        self2.amPM.title = self2.l10n.toggleTitle;
        self2.amPM.tabIndex = -1;
        self2.timeContainer.appendChild(self2.amPM);
      }
      return self2.timeContainer;
    }
    function buildWeekdays() {
      if (!self2.weekdayContainer)
        self2.weekdayContainer = createElement("div", "flatpickr-weekdays");
      else
        clearNode(self2.weekdayContainer);
      for (let i2 = self2.config.showMonths; i2--; ) {
        const container = createElement("div", "flatpickr-weekdaycontainer");
        self2.weekdayContainer.appendChild(container);
      }
      updateWeekdays();
      return self2.weekdayContainer;
    }
    function updateWeekdays() {
      if (!self2.weekdayContainer) {
        return;
      }
      const firstDayOfWeek = self2.l10n.firstDayOfWeek;
      let weekdays = [...self2.l10n.weekdays.shorthand];
      if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
        weekdays = [
          ...weekdays.splice(firstDayOfWeek, weekdays.length),
          ...weekdays.splice(0, firstDayOfWeek)
        ];
      }
      for (let i2 = self2.config.showMonths; i2--; ) {
        self2.weekdayContainer.children[i2].innerHTML = `
      <span class='flatpickr-weekday'>
        ${weekdays.join("</span><span class='flatpickr-weekday'>")}
      </span>
      `;
      }
    }
    function buildWeeks() {
      self2.calendarContainer.classList.add("hasWeeks");
      const weekWrapper = createElement("div", "flatpickr-weekwrapper");
      weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self2.l10n.weekAbbreviation));
      const weekNumbers = createElement("div", "flatpickr-weeks");
      weekWrapper.appendChild(weekNumbers);
      return {
        weekWrapper,
        weekNumbers
      };
    }
    function changeMonth(value, isOffset = true) {
      const delta = isOffset ? value : value - self2.currentMonth;
      if (delta < 0 && self2._hidePrevMonthArrow === true || delta > 0 && self2._hideNextMonthArrow === true)
        return;
      self2.currentMonth += delta;
      if (self2.currentMonth < 0 || self2.currentMonth > 11) {
        self2.currentYear += self2.currentMonth > 11 ? 1 : -1;
        self2.currentMonth = (self2.currentMonth + 12) % 12;
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      buildDays();
      triggerEvent("onMonthChange");
      updateNavigationCurrentMonth();
    }
    function clear(triggerChangeEvent = true, toInitial = true) {
      self2.input.value = "";
      if (self2.altInput !== void 0)
        self2.altInput.value = "";
      if (self2.mobileInput !== void 0)
        self2.mobileInput.value = "";
      self2.selectedDates = [];
      self2.latestSelectedDateObj = void 0;
      if (toInitial === true) {
        self2.currentYear = self2._initialDate.getFullYear();
        self2.currentMonth = self2._initialDate.getMonth();
      }
      if (self2.config.enableTime === true) {
        const { hours, minutes, seconds } = getDefaultHours(self2.config);
        setHours(hours, minutes, seconds);
      }
      self2.redraw();
      if (triggerChangeEvent)
        triggerEvent("onChange");
    }
    function close() {
      self2.isOpen = false;
      if (!self2.isMobile) {
        if (self2.calendarContainer !== void 0) {
          self2.calendarContainer.classList.remove("open");
        }
        if (self2._input !== void 0) {
          self2._input.classList.remove("active");
        }
      }
      triggerEvent("onClose");
    }
    function destroy() {
      if (self2.config !== void 0)
        triggerEvent("onDestroy");
      for (let i2 = self2._handlers.length; i2--; ) {
        self2._handlers[i2].remove();
      }
      self2._handlers = [];
      if (self2.mobileInput) {
        if (self2.mobileInput.parentNode)
          self2.mobileInput.parentNode.removeChild(self2.mobileInput);
        self2.mobileInput = void 0;
      } else if (self2.calendarContainer && self2.calendarContainer.parentNode) {
        if (self2.config.static && self2.calendarContainer.parentNode) {
          const wrapper = self2.calendarContainer.parentNode;
          wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
          if (wrapper.parentNode) {
            while (wrapper.firstChild)
              wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
            wrapper.parentNode.removeChild(wrapper);
          }
        } else
          self2.calendarContainer.parentNode.removeChild(self2.calendarContainer);
      }
      if (self2.altInput) {
        self2.input.type = "text";
        if (self2.altInput.parentNode)
          self2.altInput.parentNode.removeChild(self2.altInput);
        delete self2.altInput;
      }
      if (self2.input) {
        self2.input.type = self2.input._type;
        self2.input.classList.remove("flatpickr-input");
        self2.input.removeAttribute("readonly");
      }
      [
        "_showTimeInput",
        "latestSelectedDateObj",
        "_hideNextMonthArrow",
        "_hidePrevMonthArrow",
        "__hideNextMonthArrow",
        "__hidePrevMonthArrow",
        "isMobile",
        "isOpen",
        "selectedDateElem",
        "minDateHasTime",
        "maxDateHasTime",
        "days",
        "daysContainer",
        "_input",
        "_positionElement",
        "innerContainer",
        "rContainer",
        "monthNav",
        "todayDateElem",
        "calendarContainer",
        "weekdayContainer",
        "prevMonthNav",
        "nextMonthNav",
        "monthsDropdownContainer",
        "currentMonthElement",
        "currentYearElement",
        "navigationCurrentMonth",
        "selectedDateElem",
        "config"
      ].forEach((k2) => {
        try {
          delete self2[k2];
        } catch (_2) {
        }
      });
    }
    function isCalendarElem(elem) {
      if (self2.config.appendTo && self2.config.appendTo.contains(elem))
        return true;
      return self2.calendarContainer.contains(elem);
    }
    function documentClick(e2) {
      if (self2.isOpen && !self2.config.inline) {
        const eventTarget = getEventTarget(e2);
        const isCalendarElement = isCalendarElem(eventTarget);
        const isInput = eventTarget === self2.input || eventTarget === self2.altInput || self2.element.contains(eventTarget) || e2.path && e2.path.indexOf && (~e2.path.indexOf(self2.input) || ~e2.path.indexOf(self2.altInput));
        const lostFocus = e2.type === "blur" ? isInput && e2.relatedTarget && !isCalendarElem(e2.relatedTarget) : !isInput && !isCalendarElement && !isCalendarElem(e2.relatedTarget);
        const isIgnored = !self2.config.ignoredFocusElements.some((elem) => elem.contains(eventTarget));
        if (lostFocus && isIgnored) {
          if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0 && self2.input.value !== "" && self2.input.value !== void 0) {
            updateTime();
          }
          self2.close();
          if (self2.config && self2.config.mode === "range" && self2.selectedDates.length === 1) {
            self2.clear(false);
            self2.redraw();
          }
        }
      }
    }
    function changeYear(newYear) {
      if (!newYear || self2.config.minDate && newYear < self2.config.minDate.getFullYear() || self2.config.maxDate && newYear > self2.config.maxDate.getFullYear())
        return;
      const newYearNum = newYear, isNewYear = self2.currentYear !== newYearNum;
      self2.currentYear = newYearNum || self2.currentYear;
      if (self2.config.maxDate && self2.currentYear === self2.config.maxDate.getFullYear()) {
        self2.currentMonth = Math.min(self2.config.maxDate.getMonth(), self2.currentMonth);
      } else if (self2.config.minDate && self2.currentYear === self2.config.minDate.getFullYear()) {
        self2.currentMonth = Math.max(self2.config.minDate.getMonth(), self2.currentMonth);
      }
      if (isNewYear) {
        self2.redraw();
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
    }
    function isEnabled(date, timeless = true) {
      var _a;
      const dateToCheck = self2.parseDate(date, void 0, timeless);
      if (self2.config.minDate && dateToCheck && compareDates(dateToCheck, self2.config.minDate, timeless !== void 0 ? timeless : !self2.minDateHasTime) < 0 || self2.config.maxDate && dateToCheck && compareDates(dateToCheck, self2.config.maxDate, timeless !== void 0 ? timeless : !self2.maxDateHasTime) > 0)
        return false;
      if (!self2.config.enable && self2.config.disable.length === 0)
        return true;
      if (dateToCheck === void 0)
        return false;
      const bool = !!self2.config.enable, array = (_a = self2.config.enable) !== null && _a !== void 0 ? _a : self2.config.disable;
      for (let i2 = 0, d2; i2 < array.length; i2++) {
        d2 = array[i2];
        if (typeof d2 === "function" && d2(dateToCheck))
          return bool;
        else if (d2 instanceof Date && dateToCheck !== void 0 && d2.getTime() === dateToCheck.getTime())
          return bool;
        else if (typeof d2 === "string") {
          const parsed = self2.parseDate(d2, void 0, true);
          return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
        } else if (typeof d2 === "object" && dateToCheck !== void 0 && d2.from && d2.to && dateToCheck.getTime() >= d2.from.getTime() && dateToCheck.getTime() <= d2.to.getTime())
          return bool;
      }
      return !bool;
    }
    function isInView(elem) {
      if (self2.daysContainer !== void 0)
        return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self2.daysContainer.contains(elem);
      return false;
    }
    function onBlur(e2) {
      const isInput = e2.target === self2._input;
      if (isInput && (self2.selectedDates.length > 0 || self2._input.value.length > 0) && !(e2.relatedTarget && isCalendarElem(e2.relatedTarget))) {
        self2.setDate(self2._input.value, true, e2.target === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
      }
    }
    function onKeyDown2(e2) {
      const eventTarget = getEventTarget(e2);
      const isInput = self2.config.wrap ? element.contains(eventTarget) : eventTarget === self2._input;
      const allowInput = self2.config.allowInput;
      const allowKeydown = self2.isOpen && (!allowInput || !isInput);
      const allowInlineKeydown = self2.config.inline && isInput && !allowInput;
      if (e2.keyCode === 13 && isInput) {
        if (allowInput) {
          self2.setDate(self2._input.value, true, eventTarget === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
          return eventTarget.blur();
        } else {
          self2.open();
        }
      } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
        const isTimeObj = !!self2.timeContainer && self2.timeContainer.contains(eventTarget);
        switch (e2.keyCode) {
          case 13:
            if (isTimeObj) {
              e2.preventDefault();
              updateTime();
              focusAndClose();
            } else
              selectDate(e2);
            break;
          case 27:
            e2.preventDefault();
            focusAndClose();
            break;
          case 8:
          case 46:
            if (isInput && !self2.config.allowInput) {
              e2.preventDefault();
              self2.clear();
            }
            break;
          case 37:
          case 39:
            if (!isTimeObj && !isInput) {
              e2.preventDefault();
              if (self2.daysContainer !== void 0 && (allowInput === false || document.activeElement && isInView(document.activeElement))) {
                const delta2 = e2.keyCode === 39 ? 1 : -1;
                if (!e2.ctrlKey)
                  focusOnDay(void 0, delta2);
                else {
                  e2.stopPropagation();
                  changeMonth(delta2);
                  focusOnDay(getFirstAvailableDay(1), 0);
                }
              }
            } else if (self2.hourElement)
              self2.hourElement.focus();
            break;
          case 38:
          case 40:
            e2.preventDefault();
            const delta = e2.keyCode === 40 ? 1 : -1;
            if (self2.daysContainer && eventTarget.$i !== void 0 || eventTarget === self2.input || eventTarget === self2.altInput) {
              if (e2.ctrlKey) {
                e2.stopPropagation();
                changeYear(self2.currentYear - delta);
                focusOnDay(getFirstAvailableDay(1), 0);
              } else if (!isTimeObj)
                focusOnDay(void 0, delta * 7);
            } else if (eventTarget === self2.currentYearElement) {
              changeYear(self2.currentYear - delta);
            } else if (self2.config.enableTime) {
              if (!isTimeObj && self2.hourElement)
                self2.hourElement.focus();
              updateTime(e2);
              self2._debouncedChange();
            }
            break;
          case 9:
            if (isTimeObj) {
              const elems = [
                self2.hourElement,
                self2.minuteElement,
                self2.secondElement,
                self2.amPM
              ].concat(self2.pluginElements).filter((x2) => x2);
              const i2 = elems.indexOf(eventTarget);
              if (i2 !== -1) {
                const target = elems[i2 + (e2.shiftKey ? -1 : 1)];
                e2.preventDefault();
                (target || self2._input).focus();
              }
            } else if (!self2.config.noCalendar && self2.daysContainer && self2.daysContainer.contains(eventTarget) && e2.shiftKey) {
              e2.preventDefault();
              self2._input.focus();
            }
            break;
          default:
            break;
        }
      }
      if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
        switch (e2.key) {
          case self2.l10n.amPM[0].charAt(0):
          case self2.l10n.amPM[0].charAt(0).toLowerCase():
            self2.amPM.textContent = self2.l10n.amPM[0];
            setHoursFromInputs();
            updateValue();
            break;
          case self2.l10n.amPM[1].charAt(0):
          case self2.l10n.amPM[1].charAt(0).toLowerCase():
            self2.amPM.textContent = self2.l10n.amPM[1];
            setHoursFromInputs();
            updateValue();
            break;
        }
      }
      if (isInput || isCalendarElem(eventTarget)) {
        triggerEvent("onKeyDown", e2);
      }
    }
    function onMouseOver(elem) {
      if (self2.selectedDates.length !== 1 || elem && (!elem.classList.contains("flatpickr-day") || elem.classList.contains("flatpickr-disabled")))
        return;
      const hoverDate = elem ? elem.dateObj.getTime() : self2.days.firstElementChild.dateObj.getTime(), initialDate = self2.parseDate(self2.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self2.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self2.selectedDates[0].getTime());
      let containsDisabled = false;
      let minRange = 0, maxRange = 0;
      for (let t2 = rangeStartDate; t2 < rangeEndDate; t2 += duration.DAY) {
        if (!isEnabled(new Date(t2), true)) {
          containsDisabled = containsDisabled || t2 > rangeStartDate && t2 < rangeEndDate;
          if (t2 < initialDate && (!minRange || t2 > minRange))
            minRange = t2;
          else if (t2 > initialDate && (!maxRange || t2 < maxRange))
            maxRange = t2;
        }
      }
      for (let m2 = 0; m2 < self2.config.showMonths; m2++) {
        const month = self2.daysContainer.children[m2];
        for (let i2 = 0, l2 = month.children.length; i2 < l2; i2++) {
          const dayElem = month.children[i2], date = dayElem.dateObj;
          const timestamp = date.getTime();
          const outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
          if (outOfRange) {
            dayElem.classList.add("notAllowed");
            ["inRange", "startRange", "endRange"].forEach((c2) => {
              dayElem.classList.remove(c2);
            });
            continue;
          } else if (containsDisabled && !outOfRange)
            continue;
          ["startRange", "inRange", "endRange", "notAllowed"].forEach((c2) => {
            dayElem.classList.remove(c2);
          });
          if (elem !== void 0) {
            elem.classList.add(hoverDate <= self2.selectedDates[0].getTime() ? "startRange" : "endRange");
            if (initialDate < hoverDate && timestamp === initialDate)
              dayElem.classList.add("startRange");
            else if (initialDate > hoverDate && timestamp === initialDate)
              dayElem.classList.add("endRange");
            if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate))
              dayElem.classList.add("inRange");
          }
        }
      }
    }
    function onResize() {
      if (self2.isOpen && !self2.config.static && !self2.config.inline)
        positionCalendar();
    }
    function open(e2, positionElement = self2._positionElement) {
      if (self2.isMobile === true) {
        if (e2) {
          e2.preventDefault();
          const eventTarget = getEventTarget(e2);
          if (eventTarget) {
            eventTarget.blur();
          }
        }
        if (self2.mobileInput !== void 0) {
          self2.mobileInput.focus();
          self2.mobileInput.click();
        }
        triggerEvent("onOpen");
        return;
      } else if (self2._input.disabled || self2.config.inline) {
        return;
      }
      const wasOpen = self2.isOpen;
      self2.isOpen = true;
      if (!wasOpen) {
        self2.calendarContainer.classList.add("open");
        self2._input.classList.add("active");
        triggerEvent("onOpen");
        positionCalendar(positionElement);
      }
      if (self2.config.enableTime === true && self2.config.noCalendar === true) {
        if (self2.config.allowInput === false && (e2 === void 0 || !self2.timeContainer.contains(e2.relatedTarget))) {
          setTimeout(() => self2.hourElement.select(), 50);
        }
      }
    }
    function minMaxDateSetter(type) {
      return (date) => {
        const dateObj = self2.config[`_${type}Date`] = self2.parseDate(date, self2.config.dateFormat);
        const inverseDateObj = self2.config[`_${type === "min" ? "max" : "min"}Date`];
        if (dateObj !== void 0) {
          self2[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
        }
        if (self2.selectedDates) {
          self2.selectedDates = self2.selectedDates.filter((d2) => isEnabled(d2));
          if (!self2.selectedDates.length && type === "min")
            setHoursFromDate(dateObj);
          updateValue();
        }
        if (self2.daysContainer) {
          redraw();
          if (dateObj !== void 0)
            self2.currentYearElement[type] = dateObj.getFullYear().toString();
          else
            self2.currentYearElement.removeAttribute(type);
          self2.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
        }
      };
    }
    function parseConfig() {
      const boolOpts = [
        "wrap",
        "weekNumbers",
        "allowInput",
        "allowInvalidPreload",
        "clickOpens",
        "time_24hr",
        "enableTime",
        "noCalendar",
        "altInput",
        "shorthandCurrentMonth",
        "inline",
        "static",
        "enableSeconds",
        "disableMobile"
      ];
      const userConfig = Object.assign(Object.assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
      const formats2 = {};
      self2.config.parseDate = userConfig.parseDate;
      self2.config.formatDate = userConfig.formatDate;
      Object.defineProperty(self2.config, "enable", {
        get: () => self2.config._enable,
        set: (dates) => {
          self2.config._enable = parseDateRules(dates);
        }
      });
      Object.defineProperty(self2.config, "disable", {
        get: () => self2.config._disable,
        set: (dates) => {
          self2.config._disable = parseDateRules(dates);
        }
      });
      const timeMode = userConfig.mode === "time";
      if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
        const defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
        formats2.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
      }
      if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
        const defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
        formats2.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + ` h:i${userConfig.enableSeconds ? ":S" : ""} K`;
      }
      Object.defineProperty(self2.config, "minDate", {
        get: () => self2.config._minDate,
        set: minMaxDateSetter("min")
      });
      Object.defineProperty(self2.config, "maxDate", {
        get: () => self2.config._maxDate,
        set: minMaxDateSetter("max")
      });
      const minMaxTimeSetter = (type) => (val) => {
        self2.config[type === "min" ? "_minTime" : "_maxTime"] = self2.parseDate(val, "H:i:S");
      };
      Object.defineProperty(self2.config, "minTime", {
        get: () => self2.config._minTime,
        set: minMaxTimeSetter("min")
      });
      Object.defineProperty(self2.config, "maxTime", {
        get: () => self2.config._maxTime,
        set: minMaxTimeSetter("max")
      });
      if (userConfig.mode === "time") {
        self2.config.noCalendar = true;
        self2.config.enableTime = true;
      }
      Object.assign(self2.config, formats2, userConfig);
      for (let i2 = 0; i2 < boolOpts.length; i2++)
        self2.config[boolOpts[i2]] = self2.config[boolOpts[i2]] === true || self2.config[boolOpts[i2]] === "true";
      HOOKS.filter((hook) => self2.config[hook] !== void 0).forEach((hook) => {
        self2.config[hook] = arrayify(self2.config[hook] || []).map(bindToInstance);
      });
      self2.isMobile = !self2.config.disableMobile && !self2.config.inline && self2.config.mode === "single" && !self2.config.disable.length && !self2.config.enable && !self2.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      for (let i2 = 0; i2 < self2.config.plugins.length; i2++) {
        const pluginConf = self2.config.plugins[i2](self2) || {};
        for (const key in pluginConf) {
          if (HOOKS.indexOf(key) > -1) {
            self2.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self2.config[key]);
          } else if (typeof userConfig[key] === "undefined")
            self2.config[key] = pluginConf[key];
        }
      }
      if (!userConfig.altInputClass) {
        self2.config.altInputClass = getInputElem().className + " " + self2.config.altInputClass;
      }
      triggerEvent("onParseConfig");
    }
    function getInputElem() {
      return self2.config.wrap ? element.querySelector("[data-input]") : element;
    }
    function setupLocale() {
      if (typeof self2.config.locale !== "object" && typeof flatpickr.l10ns[self2.config.locale] === "undefined")
        self2.config.errorHandler(new Error(`flatpickr: invalid locale ${self2.config.locale}`));
      self2.l10n = Object.assign(Object.assign({}, flatpickr.l10ns.default), typeof self2.config.locale === "object" ? self2.config.locale : self2.config.locale !== "default" ? flatpickr.l10ns[self2.config.locale] : void 0);
      tokenRegex.K = `(${self2.l10n.amPM[0]}|${self2.l10n.amPM[1]}|${self2.l10n.amPM[0].toLowerCase()}|${self2.l10n.amPM[1].toLowerCase()})`;
      const userConfig = Object.assign(Object.assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
      if (userConfig.time_24hr === void 0 && flatpickr.defaultConfig.time_24hr === void 0) {
        self2.config.time_24hr = self2.l10n.time_24hr;
      }
      self2.formatDate = createDateFormatter(self2);
      self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
    }
    function positionCalendar(customPositionElement) {
      if (typeof self2.config.position === "function") {
        return void self2.config.position(self2, customPositionElement);
      }
      if (self2.calendarContainer === void 0)
        return;
      triggerEvent("onPreCalendarPosition");
      const positionElement = customPositionElement || self2._positionElement;
      const calendarHeight = Array.prototype.reduce.call(self2.calendarContainer.children, (acc, child) => acc + child.offsetHeight, 0), calendarWidth = self2.calendarContainer.offsetWidth, configPos = self2.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
      const top2 = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
      toggleClass(self2.calendarContainer, "arrowTop", !showOnTop);
      toggleClass(self2.calendarContainer, "arrowBottom", showOnTop);
      if (self2.config.inline)
        return;
      let left2 = window.pageXOffset + inputBounds.left;
      let isCenter = false;
      let isRight = false;
      if (configPosHorizontal === "center") {
        left2 -= (calendarWidth - inputBounds.width) / 2;
        isCenter = true;
      } else if (configPosHorizontal === "right") {
        left2 -= calendarWidth - inputBounds.width;
        isRight = true;
      }
      toggleClass(self2.calendarContainer, "arrowLeft", !isCenter && !isRight);
      toggleClass(self2.calendarContainer, "arrowCenter", isCenter);
      toggleClass(self2.calendarContainer, "arrowRight", isRight);
      const right2 = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
      const rightMost = left2 + calendarWidth > window.document.body.offsetWidth;
      const centerMost = right2 + calendarWidth > window.document.body.offsetWidth;
      toggleClass(self2.calendarContainer, "rightMost", rightMost);
      if (self2.config.static)
        return;
      self2.calendarContainer.style.top = `${top2}px`;
      if (!rightMost) {
        self2.calendarContainer.style.left = `${left2}px`;
        self2.calendarContainer.style.right = "auto";
      } else if (!centerMost) {
        self2.calendarContainer.style.left = "auto";
        self2.calendarContainer.style.right = `${right2}px`;
      } else {
        const doc = getDocumentStyleSheet();
        if (doc === void 0)
          return;
        const bodyWidth = window.document.body.offsetWidth;
        const centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
        const centerBefore = ".flatpickr-calendar.centerMost:before";
        const centerAfter = ".flatpickr-calendar.centerMost:after";
        const centerIndex = doc.cssRules.length;
        const centerStyle = `{left:${inputBounds.left}px;right:auto;}`;
        toggleClass(self2.calendarContainer, "rightMost", false);
        toggleClass(self2.calendarContainer, "centerMost", true);
        doc.insertRule(`${centerBefore},${centerAfter}${centerStyle}`, centerIndex);
        self2.calendarContainer.style.left = `${centerLeft}px`;
        self2.calendarContainer.style.right = "auto";
      }
    }
    function getDocumentStyleSheet() {
      let editableSheet = null;
      for (let i2 = 0; i2 < document.styleSheets.length; i2++) {
        const sheet = document.styleSheets[i2];
        try {
          sheet.cssRules;
        } catch (err) {
          continue;
        }
        editableSheet = sheet;
        break;
      }
      return editableSheet != null ? editableSheet : createStyleSheet();
    }
    function createStyleSheet() {
      const style = document.createElement("style");
      document.head.appendChild(style);
      return style.sheet;
    }
    function redraw() {
      if (self2.config.noCalendar || self2.isMobile)
        return;
      buildMonthSwitch();
      updateNavigationCurrentMonth();
      buildDays();
    }
    function focusAndClose() {
      self2._input.focus();
      if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
        setTimeout(self2.close, 0);
      } else {
        self2.close();
      }
    }
    function selectDate(e2) {
      e2.preventDefault();
      e2.stopPropagation();
      const isSelectable = (day) => day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
      const t2 = findParent(getEventTarget(e2), isSelectable);
      if (t2 === void 0)
        return;
      const target = t2;
      const selectedDate = self2.latestSelectedDateObj = new Date(target.dateObj.getTime());
      const shouldChangeMonth = (selectedDate.getMonth() < self2.currentMonth || selectedDate.getMonth() > self2.currentMonth + self2.config.showMonths - 1) && self2.config.mode !== "range";
      self2.selectedDateElem = target;
      if (self2.config.mode === "single")
        self2.selectedDates = [selectedDate];
      else if (self2.config.mode === "multiple") {
        const selectedIndex = isDateSelected(selectedDate);
        if (selectedIndex)
          self2.selectedDates.splice(parseInt(selectedIndex), 1);
        else
          self2.selectedDates.push(selectedDate);
      } else if (self2.config.mode === "range") {
        if (self2.selectedDates.length === 2) {
          self2.clear(false, false);
        }
        self2.latestSelectedDateObj = selectedDate;
        self2.selectedDates.push(selectedDate);
        if (compareDates(selectedDate, self2.selectedDates[0], true) !== 0)
          self2.selectedDates.sort((a2, b2) => a2.getTime() - b2.getTime());
      }
      setHoursFromInputs();
      if (shouldChangeMonth) {
        const isNewYear = self2.currentYear !== selectedDate.getFullYear();
        self2.currentYear = selectedDate.getFullYear();
        self2.currentMonth = selectedDate.getMonth();
        if (isNewYear) {
          triggerEvent("onYearChange");
          buildMonthSwitch();
        }
        triggerEvent("onMonthChange");
      }
      updateNavigationCurrentMonth();
      buildDays();
      updateValue();
      if (!shouldChangeMonth && self2.config.mode !== "range" && self2.config.showMonths === 1)
        focusOnDayElem(target);
      else if (self2.selectedDateElem !== void 0 && self2.hourElement === void 0) {
        self2.selectedDateElem && self2.selectedDateElem.focus();
      }
      if (self2.hourElement !== void 0)
        self2.hourElement !== void 0 && self2.hourElement.focus();
      if (self2.config.closeOnSelect) {
        const single = self2.config.mode === "single" && !self2.config.enableTime;
        const range = self2.config.mode === "range" && self2.selectedDates.length === 2 && !self2.config.enableTime;
        if (single || range) {
          focusAndClose();
        }
      }
      triggerChange();
    }
    const CALLBACKS = {
      locale: [setupLocale, updateWeekdays],
      showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
      minDate: [jumpToDate],
      maxDate: [jumpToDate],
      clickOpens: [
        () => {
          if (self2.config.clickOpens === true) {
            bind3(self2._input, "focus", self2.open);
            bind3(self2._input, "click", self2.open);
          } else {
            self2._input.removeEventListener("focus", self2.open);
            self2._input.removeEventListener("click", self2.open);
          }
        }
      ]
    };
    function set(option, value) {
      if (option !== null && typeof option === "object") {
        Object.assign(self2.config, option);
        for (const key in option) {
          if (CALLBACKS[key] !== void 0)
            CALLBACKS[key].forEach((x2) => x2());
        }
      } else {
        self2.config[option] = value;
        if (CALLBACKS[option] !== void 0)
          CALLBACKS[option].forEach((x2) => x2());
        else if (HOOKS.indexOf(option) > -1)
          self2.config[option] = arrayify(value);
      }
      self2.redraw();
      updateValue(true);
    }
    function setSelectedDate(inputDate, format2) {
      let dates = [];
      if (inputDate instanceof Array)
        dates = inputDate.map((d2) => self2.parseDate(d2, format2));
      else if (inputDate instanceof Date || typeof inputDate === "number")
        dates = [self2.parseDate(inputDate, format2)];
      else if (typeof inputDate === "string") {
        switch (self2.config.mode) {
          case "single":
          case "time":
            dates = [self2.parseDate(inputDate, format2)];
            break;
          case "multiple":
            dates = inputDate.split(self2.config.conjunction).map((date) => self2.parseDate(date, format2));
            break;
          case "range":
            dates = inputDate.split(self2.l10n.rangeSeparator).map((date) => self2.parseDate(date, format2));
            break;
          default:
            break;
        }
      } else
        self2.config.errorHandler(new Error(`Invalid date supplied: ${JSON.stringify(inputDate)}`));
      self2.selectedDates = self2.config.allowInvalidPreload ? dates : dates.filter((d2) => d2 instanceof Date && isEnabled(d2, false));
      if (self2.config.mode === "range")
        self2.selectedDates.sort((a2, b2) => a2.getTime() - b2.getTime());
    }
    function setDate(date, triggerChange2 = false, format2 = self2.config.dateFormat) {
      if (date !== 0 && !date || date instanceof Array && date.length === 0)
        return self2.clear(triggerChange2);
      setSelectedDate(date, format2);
      self2.latestSelectedDateObj = self2.selectedDates[self2.selectedDates.length - 1];
      self2.redraw();
      jumpToDate(void 0, triggerChange2);
      setHoursFromDate();
      if (self2.selectedDates.length === 0) {
        self2.clear(false);
      }
      updateValue(triggerChange2);
      if (triggerChange2)
        triggerEvent("onChange");
    }
    function parseDateRules(arr) {
      return arr.slice().map((rule) => {
        if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
          return self2.parseDate(rule, void 0, true);
        } else if (rule && typeof rule === "object" && rule.from && rule.to)
          return {
            from: self2.parseDate(rule.from, void 0),
            to: self2.parseDate(rule.to, void 0)
          };
        return rule;
      }).filter((x2) => x2);
    }
    function setupDates() {
      self2.selectedDates = [];
      self2.now = self2.parseDate(self2.config.now) || new Date();
      const preloadedDate = self2.config.defaultDate || ((self2.input.nodeName === "INPUT" || self2.input.nodeName === "TEXTAREA") && self2.input.placeholder && self2.input.value === self2.input.placeholder ? null : self2.input.value);
      if (preloadedDate)
        setSelectedDate(preloadedDate, self2.config.dateFormat);
      self2._initialDate = self2.selectedDates.length > 0 ? self2.selectedDates[0] : self2.config.minDate && self2.config.minDate.getTime() > self2.now.getTime() ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate.getTime() < self2.now.getTime() ? self2.config.maxDate : self2.now;
      self2.currentYear = self2._initialDate.getFullYear();
      self2.currentMonth = self2._initialDate.getMonth();
      if (self2.selectedDates.length > 0)
        self2.latestSelectedDateObj = self2.selectedDates[0];
      if (self2.config.minTime !== void 0)
        self2.config.minTime = self2.parseDate(self2.config.minTime, "H:i");
      if (self2.config.maxTime !== void 0)
        self2.config.maxTime = self2.parseDate(self2.config.maxTime, "H:i");
      self2.minDateHasTime = !!self2.config.minDate && (self2.config.minDate.getHours() > 0 || self2.config.minDate.getMinutes() > 0 || self2.config.minDate.getSeconds() > 0);
      self2.maxDateHasTime = !!self2.config.maxDate && (self2.config.maxDate.getHours() > 0 || self2.config.maxDate.getMinutes() > 0 || self2.config.maxDate.getSeconds() > 0);
    }
    function setupInputs() {
      self2.input = getInputElem();
      if (!self2.input) {
        self2.config.errorHandler(new Error("Invalid input element specified"));
        return;
      }
      self2.input._type = self2.input.type;
      self2.input.type = "text";
      self2.input.classList.add("flatpickr-input");
      self2._input = self2.input;
      if (self2.config.altInput) {
        self2.altInput = createElement(self2.input.nodeName, self2.config.altInputClass);
        self2._input = self2.altInput;
        self2.altInput.placeholder = self2.input.placeholder;
        self2.altInput.disabled = self2.input.disabled;
        self2.altInput.required = self2.input.required;
        self2.altInput.tabIndex = self2.input.tabIndex;
        self2.altInput.type = "text";
        self2.input.setAttribute("type", "hidden");
        if (!self2.config.static && self2.input.parentNode)
          self2.input.parentNode.insertBefore(self2.altInput, self2.input.nextSibling);
      }
      if (!self2.config.allowInput)
        self2._input.setAttribute("readonly", "readonly");
      self2._positionElement = self2.config.positionElement || self2._input;
    }
    function setupMobile() {
      const inputType = self2.config.enableTime ? self2.config.noCalendar ? "time" : "datetime-local" : "date";
      self2.mobileInput = createElement("input", self2.input.className + " flatpickr-mobile");
      self2.mobileInput.tabIndex = 1;
      self2.mobileInput.type = inputType;
      self2.mobileInput.disabled = self2.input.disabled;
      self2.mobileInput.required = self2.input.required;
      self2.mobileInput.placeholder = self2.input.placeholder;
      self2.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
      if (self2.selectedDates.length > 0) {
        self2.mobileInput.defaultValue = self2.mobileInput.value = self2.formatDate(self2.selectedDates[0], self2.mobileFormatStr);
      }
      if (self2.config.minDate)
        self2.mobileInput.min = self2.formatDate(self2.config.minDate, "Y-m-d");
      if (self2.config.maxDate)
        self2.mobileInput.max = self2.formatDate(self2.config.maxDate, "Y-m-d");
      if (self2.input.getAttribute("step"))
        self2.mobileInput.step = String(self2.input.getAttribute("step"));
      self2.input.type = "hidden";
      if (self2.altInput !== void 0)
        self2.altInput.type = "hidden";
      try {
        if (self2.input.parentNode)
          self2.input.parentNode.insertBefore(self2.mobileInput, self2.input.nextSibling);
      } catch (_a) {
      }
      bind3(self2.mobileInput, "change", (e2) => {
        self2.setDate(getEventTarget(e2).value, false, self2.mobileFormatStr);
        triggerEvent("onChange");
        triggerEvent("onClose");
      });
    }
    function toggle(e2) {
      if (self2.isOpen === true)
        return self2.close();
      self2.open(e2);
    }
    function triggerEvent(event, data) {
      if (self2.config === void 0)
        return;
      const hooks = self2.config[event];
      if (hooks !== void 0 && hooks.length > 0) {
        for (let i2 = 0; hooks[i2] && i2 < hooks.length; i2++)
          hooks[i2](self2.selectedDates, self2.input.value, self2, data);
      }
      if (event === "onChange") {
        self2.input.dispatchEvent(createEvent("change"));
        self2.input.dispatchEvent(createEvent("input"));
      }
    }
    function createEvent(name) {
      const e2 = document.createEvent("Event");
      e2.initEvent(name, true, true);
      return e2;
    }
    function isDateSelected(date) {
      for (let i2 = 0; i2 < self2.selectedDates.length; i2++) {
        if (compareDates(self2.selectedDates[i2], date) === 0)
          return "" + i2;
      }
      return false;
    }
    function isDateInRange(date) {
      if (self2.config.mode !== "range" || self2.selectedDates.length < 2)
        return false;
      return compareDates(date, self2.selectedDates[0]) >= 0 && compareDates(date, self2.selectedDates[1]) <= 0;
    }
    function updateNavigationCurrentMonth() {
      if (self2.config.noCalendar || self2.isMobile || !self2.monthNav)
        return;
      self2.yearElements.forEach((yearElement, i2) => {
        const d2 = new Date(self2.currentYear, self2.currentMonth, 1);
        d2.setMonth(self2.currentMonth + i2);
        if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
          self2.monthElements[i2].textContent = monthToStr(d2.getMonth(), self2.config.shorthandCurrentMonth, self2.l10n) + " ";
        } else {
          self2.monthsDropdownContainer.value = d2.getMonth().toString();
        }
        yearElement.value = d2.getFullYear().toString();
      });
      self2._hidePrevMonthArrow = self2.config.minDate !== void 0 && (self2.currentYear === self2.config.minDate.getFullYear() ? self2.currentMonth <= self2.config.minDate.getMonth() : self2.currentYear < self2.config.minDate.getFullYear());
      self2._hideNextMonthArrow = self2.config.maxDate !== void 0 && (self2.currentYear === self2.config.maxDate.getFullYear() ? self2.currentMonth + 1 > self2.config.maxDate.getMonth() : self2.currentYear > self2.config.maxDate.getFullYear());
    }
    function getDateStr(format2) {
      return self2.selectedDates.map((dObj) => self2.formatDate(dObj, format2)).filter((d2, i2, arr) => self2.config.mode !== "range" || self2.config.enableTime || arr.indexOf(d2) === i2).join(self2.config.mode !== "range" ? self2.config.conjunction : self2.l10n.rangeSeparator);
    }
    function updateValue(triggerChange2 = true) {
      if (self2.mobileInput !== void 0 && self2.mobileFormatStr) {
        self2.mobileInput.value = self2.latestSelectedDateObj !== void 0 ? self2.formatDate(self2.latestSelectedDateObj, self2.mobileFormatStr) : "";
      }
      self2.input.value = getDateStr(self2.config.dateFormat);
      if (self2.altInput !== void 0) {
        self2.altInput.value = getDateStr(self2.config.altFormat);
      }
      if (triggerChange2 !== false)
        triggerEvent("onValueUpdate");
    }
    function onMonthNavClick(e2) {
      const eventTarget = getEventTarget(e2);
      const isPrevMonth = self2.prevMonthNav.contains(eventTarget);
      const isNextMonth = self2.nextMonthNav.contains(eventTarget);
      if (isPrevMonth || isNextMonth) {
        changeMonth(isPrevMonth ? -1 : 1);
      } else if (self2.yearElements.indexOf(eventTarget) >= 0) {
        eventTarget.select();
      } else if (eventTarget.classList.contains("arrowUp")) {
        self2.changeYear(self2.currentYear + 1);
      } else if (eventTarget.classList.contains("arrowDown")) {
        self2.changeYear(self2.currentYear - 1);
      }
    }
    function timeWrapper(e2) {
      e2.preventDefault();
      const isKeyDown = e2.type === "keydown", eventTarget = getEventTarget(e2), input = eventTarget;
      if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
        self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
      }
      const min2 = parseFloat(input.getAttribute("min")), max2 = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e2.delta || (isKeyDown ? e2.which === 38 ? 1 : -1 : 0);
      let newValue = curValue + step * delta;
      if (typeof input.value !== "undefined" && input.value.length === 2) {
        const isHourElem = input === self2.hourElement, isMinuteElem = input === self2.minuteElement;
        if (newValue < min2) {
          newValue = max2 + newValue + int(!isHourElem) + (int(isHourElem) && int(!self2.amPM));
          if (isMinuteElem)
            incrementNumInput(void 0, -1, self2.hourElement);
        } else if (newValue > max2) {
          newValue = input === self2.hourElement ? newValue - max2 - int(!self2.amPM) : min2;
          if (isMinuteElem)
            incrementNumInput(void 0, 1, self2.hourElement);
        }
        if (self2.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
          self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
        }
        input.value = pad(newValue);
      }
    }
    init();
    return self2;
  }
  function _flatpickr(nodeList, config) {
    const nodes = Array.prototype.slice.call(nodeList).filter((x2) => x2 instanceof HTMLElement);
    const instances = [];
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const node = nodes[i2];
      try {
        if (node.getAttribute("data-fp-omit") !== null)
          continue;
        if (node._flatpickr !== void 0) {
          node._flatpickr.destroy();
          node._flatpickr = void 0;
        }
        node._flatpickr = FlatpickrInstance(node, config || {});
        instances.push(node._flatpickr);
      } catch (e2) {
        console.error(e2);
      }
    }
    return instances.length === 1 ? instances[0] : instances;
  }
  if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
    HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config) {
      return _flatpickr(this, config);
    };
    HTMLElement.prototype.flatpickr = function(config) {
      return _flatpickr([this], config);
    };
  }
  var flatpickr = function(selector, config) {
    if (typeof selector === "string") {
      return _flatpickr(window.document.querySelectorAll(selector), config);
    } else if (selector instanceof Node) {
      return _flatpickr([selector], config);
    } else {
      return _flatpickr(selector, config);
    }
  };
  flatpickr.defaultConfig = {};
  flatpickr.l10ns = {
    en: Object.assign({}, default_default),
    default: Object.assign({}, default_default)
  };
  flatpickr.localize = (l10n) => {
    flatpickr.l10ns.default = Object.assign(Object.assign({}, flatpickr.l10ns.default), l10n);
  };
  flatpickr.setDefaults = (config) => {
    flatpickr.defaultConfig = Object.assign(Object.assign({}, flatpickr.defaultConfig), config);
  };
  flatpickr.parseDate = createDateParser({});
  flatpickr.formatDate = createDateFormatter({});
  flatpickr.compareDates = compareDates;
  if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
    jQuery.fn.flatpickr = function(config) {
      return _flatpickr(this, config);
    };
  }
  Date.prototype.fp_incr = function(days) {
    return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
  };
  if (typeof window !== "undefined") {
    window.flatpickr = flatpickr;
  }
  var esm_default = flatpickr;

  // app/javascript/js/controllers/fields/date_field_controller.js
  function universalTimestamp(timestampStr) {
    return new Date(new Date(timestampStr).getTime() + new Date(timestampStr).getTimezoneOffset() * 60 * 1e3);
  }
  var date_field_controller_default = class extends Controller {
    connect() {
      const options = {
        enableTime: false,
        enableSeconds: false,
        time_24hr: false,
        locale: {
          firstDayOfWeek: 0
        },
        altInput: true
      };
      const enableTime = castBoolean(this.inputTarget.dataset.enableTime);
      options.altFormat = this.inputTarget.dataset.pickerFormat;
      options.locale.firstDayOfWeek = this.inputTarget.dataset.firstDayOfWeek;
      options.enableTime = enableTime;
      options.enableSeconds = enableTime;
      let currentValue;
      if (enableTime) {
        currentValue = import_luxon.DateTime.fromISO(this.inputTarget.value, { zone: window.Avo.configuration.timezone });
        currentValue = currentValue.setZone(this.inputTarget.dataset.timezone);
        currentValue = currentValue.toISO();
        options.dateFormat = "Y-m-d H:i:S";
        options.time_24hr = castBoolean(this.inputTarget.dataset.time24hr);
        options.appTimezone = this.inputTarget.dataset.timezone;
      } else {
        currentValue = universalTimestamp(this.inputTarget.value);
      }
      options.defaultDate = currentValue;
      esm_default(this.inputTarget, options);
    }
  };
  __publicField(date_field_controller_default, "targets", ["input"]);

  // app/javascript/js/controllers/hidden_input_controller.js
  var hidden_input_controller_default = class extends Controller {
    showContent(event) {
      this.contentTarget.classList.toggle("hidden");
      event.target.classList.add("hidden");
    }
  };
  __publicField(hidden_input_controller_default, "targets", ["content"]);

  // app/javascript/js/controllers/item_select_all_controller.js
  var item_select_all_controller_default = class extends Controller {
    connect() {
      this.resourceName = this.element.dataset.resourceName;
    }
    toggle(event) {
      const value = !!event.target.checked;
      document.querySelectorAll(`[data-controller="item-selector"][data-resource-name="${this.resourceName}"] input[type=checkbox]`).forEach((checkbox) => checkbox.checked != value && checkbox.click());
    }
    update() {
      let allSelected = true;
      this.itemCheckboxTargets.forEach((checkbox) => allSelected = allSelected && checkbox.checked);
      this.checkboxTarget.checked = allSelected;
    }
  };
  __publicField(item_select_all_controller_default, "targets", ["itemCheckbox", "checkbox"]);

  // app/javascript/js/controllers/item_selector_controller.js
  var item_selector_controller_default = class extends Controller {
    constructor() {
      super(...arguments);
      __publicField(this, "checkbox", {});
    }
    get actionsPanelPresent() {
      return this.actionsButtonElement !== null;
    }
    get currentIds() {
      try {
        return JSON.parse(this.stateHolderElement.dataset.selectedResources);
      } catch (error2) {
        return [];
      }
    }
    get actionLinks() {
      return document.querySelectorAll('.js-actions-dropdown a[data-actions-picker-target="resourceAction"]');
    }
    set currentIds(value) {
      this.stateHolderElement.dataset.selectedResources = JSON.stringify(value);
      if (this.actionsPanelPresent) {
        if (value.length > 0) {
          this.enableResourceActions();
        } else {
          this.disableResourceActions();
        }
      }
    }
    connect() {
      this.resourceName = this.element.dataset.resourceName;
      this.resourceId = this.element.dataset.resourceId;
      this.actionsButtonElement = document.querySelector(`[data-actions-dropdown-button="${this.resourceName}"]`);
      this.stateHolderElement = document.querySelector(`[data-selected-resources-name="${this.resourceName}"]`);
    }
    addToSelected() {
      const ids = this.currentIds;
      ids.push(this.resourceId);
      this.currentIds = ids;
    }
    removeFromSelected() {
      this.currentIds = this.currentIds.filter((item) => item.toString() !== this.resourceId);
    }
    toggle(event) {
      this.checkbox = event.target;
      if (this.checkbox.checked) {
        this.addToSelected();
      } else {
        this.removeFromSelected();
      }
    }
    enableResourceActions() {
      this.actionLinks.forEach((link) => {
        link.classList.add("text-gray-700");
        link.classList.remove("text-gray-500");
        link.setAttribute("data-href", link.getAttribute("href"));
        link.dataset.disabled = false;
      });
    }
    disableResourceActions() {
      this.actionLinks.forEach((link) => {
        link.classList.remove("text-gray-700");
        link.classList.add("text-gray-500");
        link.setAttribute("href", link.getAttribute("data-href"));
        link.dataset.disabled = true;
      });
    }
  };
  __publicField(item_selector_controller_default, "targets", ["panel"]);

  // app/javascript/js/controllers/fields/key_value_controller.js
  var key_value_controller_default = class extends Controller {
    constructor() {
      super(...arguments);
      __publicField(this, "fieldValue", []);
      __publicField(this, "options", {});
    }
    get keyInputDisabled() {
      return !this.options.editable || this.options.disable_editing_keys;
    }
    get valueInputDisabled() {
      return !this.options.editable;
    }
    connect() {
      this.setOptions();
      try {
        const objectValue = JSON.parse(this.inputTarget.value);
        Object.keys(objectValue).forEach((key) => this.fieldValue.push([key, objectValue[key]]));
      } catch (error2) {
        this.fieldValue = [];
      }
      this.updateKeyValueComponent();
    }
    addRow() {
      if (this.options.disable_adding_rows || !this.options.editable)
        return;
      this.fieldValue.push(["", ""]);
      this.updateKeyValueComponent();
      this.focusLastRow();
    }
    deleteRow(event) {
      if (this.options.disable_deleting_rows || !this.options.editable)
        return;
      const { index } = event.params;
      this.fieldValue.splice(index, 1);
      this.updateTextareaInput();
      this.updateKeyValueComponent();
    }
    focusLastRow() {
      return this.rowsTarget.querySelector(".flex.key-value-row:last-child .key-value-input-key").focus();
    }
    valueFieldUpdated(event) {
      const { value } = event.target;
      const { index } = event.target.dataset;
      this.fieldValue[index][1] = value;
      this.updateTextareaInput();
    }
    keyFieldUpdated(event) {
      const { value } = event.target;
      const { index } = event.target.dataset;
      this.fieldValue[index][0] = value;
      this.updateTextareaInput();
    }
    updateTextareaInput() {
      if (!this.hasInputTarget)
        return;
      let result = {};
      if (this.fieldValue && this.fieldValue.length > 0) {
        result = Object.assign(...this.fieldValue.map(([key, val]) => ({ [key]: val })));
      }
      this.inputTarget.innerText = JSON.stringify(result);
    }
    updateKeyValueComponent() {
      let result = "";
      let index = 0;
      this.fieldValue.forEach((row) => {
        const [key, value] = row;
        result += this.interpolatedRow(key, value, index);
        index++;
      });
      this.rowsTarget.innerHTML = result;
      window.initTippy();
    }
    interpolatedRow(key, value, index) {
      let result = `<div class="flex key-value-row">
      ${this.inputField("key", index, key, value)}
      ${this.inputField("value", index, key, value)}`;
      if (this.options.editable) {
        result += `<a
  href="javascript:void(0);"
  data-key-value-index-param="${index}"
  data-action="click->key-value#deleteRow"
  title="${this.options.delete_text}"
  data-tippy="tooltip"
  data-button="delete-row"
  tabindex="-1"
  ${this.options.disable_deleting_rows ? "disabled='disabled'" : ""}
  class="flex items-center justify-center p-2 px-3 border-none ${this.options.disable_deleting_rows ? "cursor-not-allowed" : ""}"
><svg class="pointer-events-none text-gray-500 h-5 hover:text-gray-500" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor"><path d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></a>`;
      }
      result += "</div>";
      return result;
    }
    inputField(id = "key", index, key, value) {
      return `<input
  class="${this.options.inputClasses} !rounded-none border-gray-600 border-r border-l-0 border-b-0 border-t-0 focus:border-gray-300 w-1/2 focus:outline-none outline-none key-value-input-${id}"
  data-action="input->key-value#${id}FieldUpdated"
  placeholder="${this.options[`${id}_label`]}"
  data-index="${index}"
  ${this[`${id}InputDisabled`] ? "disabled='disabled'" : ""}
  value="${id === "key" ? key : value}"
/>`;
    }
    setOptions() {
      let fieldOptions;
      try {
        fieldOptions = JSON.parse(this.controllerTarget.dataset.options);
      } catch (error2) {
        fieldOptions = {};
      }
      this.options = __spreadProps(__spreadValues({}, fieldOptions), {
        inputClasses: this.controllerTarget.dataset.inputClasses,
        editable: castBoolean(this.controllerTarget.dataset.editable)
      });
    }
  };
  __publicField(key_value_controller_default, "targets", ["input", "controller", "rows"]);

  // app/javascript/js/controllers/loading_button_controller.js
  var loading_button_controller_default = class extends Controller {
    constructor() {
      super(...arguments);
      __publicField(this, "spinnerMarkup", `<div class="button-spinner">
  <div class="double-bounce1"></div>
  <div class="double-bounce2"></div>
</div>`);
    }
    connect() {
      const button = this.context.scope.element;
      this.context.scope.element.addEventListener("click", () => {
        button.style.width = `${button.getBoundingClientRect().width}px`;
        button.style.height = `${button.getBoundingClientRect().height}px`;
        button.innerHTML = this.spinnerMarkup;
        button.classList.add("justify-center");
        setTimeout(() => {
          button.setAttribute("disabled", "disabled");
        }, 1);
      });
    }
  };

  // app/javascript/js/controllers/mobile_controller.js
  var mobile_controller_default = class extends Controller {
    connect() {
      console.log("mobile_controller", this.sidebarTarget);
    }
    toggleSidebar() {
      console.log("toggleSidebar");
      this.sidebarTarget.classList.toggle("hidden");
    }
  };
  __publicField(mobile_controller_default, "targets", ["sidebar"]);

  // app/javascript/js/controllers/modal_controller.js
  var modal_controller_default = class extends Controller {
    close() {
      this.modalTarget.remove();
      document.dispatchEvent(new Event("actions-modal:close"));
    }
    delayedClose() {
      const vm = this;
      setTimeout(() => {
        vm.modalTarget.remove();
        document.dispatchEvent(new Event("actions-modal:close"));
      }, 500);
    }
  };
  __publicField(modal_controller_default, "targets", ["modal"]);

  // app/javascript/js/controllers/multiple_select_filter_controller.js
  var multiple_select_filter_controller_default = class extends filter_controller_default {
    getFilterValue() {
      return Array.from(this.selectorTarget.selectedOptions).map(({ value }) => value);
    }
    getFilterClass() {
      const { filterClass } = this.selectorTarget.dataset;
      return filterClass;
    }
  };
  __publicField(multiple_select_filter_controller_default, "targets", ["selector"]);

  // app/javascript/js/controllers/per_page_controller.js
  var per_page_controller_default = class extends Controller {
    get turboFrame() {
      return this.selectorTarget.dataset.turboFrame;
    }
    reload() {
      document.querySelector(`[data-per-page-option="${this.selectorTarget.value}"][data-turbo-frame="${this.turboFrame}"]`).click();
    }
  };
  __publicField(per_page_controller_default, "targets", ["selector"]);

  // app/javascript/js/controllers/search_controller.js
  var Mousetrap = __toESM(require_mousetrap());

  // node_modules/@algolia/autocomplete-shared/dist/esm/createRef.js
  function createRef(initialValue) {
    return {
      current: initialValue
    };
  }

  // node_modules/@algolia/autocomplete-shared/dist/esm/debounce.js
  function debounce4(fn2, time) {
    var timerId = void 0;
    return function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (timerId) {
        clearTimeout(timerId);
      }
      timerId = setTimeout(function() {
        return fn2.apply(void 0, args);
      }, time);
    };
  }

  // node_modules/@algolia/autocomplete-shared/dist/esm/generateAutocompleteId.js
  var autocompleteId = 0;
  function generateAutocompleteId() {
    return "autocomplete-".concat(autocompleteId++);
  }

  // node_modules/@algolia/autocomplete-shared/dist/esm/getAttributeValueByPath.js
  function getAttributeValueByPath(record, path) {
    return path.reduce(function(current, key) {
      return current && current[key];
    }, record);
  }

  // node_modules/@algolia/autocomplete-shared/dist/esm/getItemsCount.js
  function getItemsCount(state) {
    if (state.collections.length === 0) {
      return 0;
    }
    return state.collections.reduce(function(sum, collection) {
      return sum + collection.items.length;
    }, 0);
  }

  // node_modules/@algolia/autocomplete-shared/dist/esm/invariant.js
  function invariant(condition, message) {
    if (false) {
      return;
    }
    if (!condition) {
      throw new Error("[Autocomplete] ".concat(message));
    }
  }

  // node_modules/@algolia/autocomplete-shared/dist/esm/warn.js
  var warnCache = {
    current: {}
  };
  function warn(condition, message) {
    if (false) {
      return;
    }
    if (condition) {
      return;
    }
    var sanitizedMessage = message.trim();
    var hasAlreadyPrinted = warnCache.current[sanitizedMessage];
    if (!hasAlreadyPrinted) {
      warnCache.current[sanitizedMessage] = true;
      console.warn("[Autocomplete] ".concat(sanitizedMessage));
    }
  }

  // node_modules/@algolia/autocomplete-core/dist/esm/checkOptions.js
  function checkOptions(options) {
    true ? warn(!options.debug, "The `debug` option is meant for development debugging and should not be used in production.") : void 0;
  }

  // node_modules/@algolia/autocomplete-core/dist/esm/createStore.js
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function createStore(reducer, props, onStoreStateChange) {
    var state = props.initialState;
    return {
      getState: function getState() {
        return state;
      },
      dispatch: function dispatch3(action, payload) {
        var prevState = _objectSpread({}, state);
        state = reducer(state, {
          type: action,
          props,
          payload
        });
        onStoreStateChange({
          state,
          prevState
        });
      }
    };
  }

  // node_modules/@algolia/autocomplete-core/dist/esm/utils/flatten.js
  function flatten(values) {
    return values.reduce(function(a2, b2) {
      return a2.concat(b2);
    }, []);
  }

  // node_modules/@algolia/autocomplete-core/dist/esm/utils/getNextActiveItemId.js
  function getNextActiveItemId(moveAmount, baseIndex, itemCount, defaultActiveItemId) {
    if (moveAmount < 0 && (baseIndex === null || defaultActiveItemId !== null && baseIndex === 0)) {
      return itemCount + moveAmount;
    }
    var numericIndex = (baseIndex === null ? -1 : baseIndex) + moveAmount;
    if (numericIndex <= -1 || numericIndex >= itemCount) {
      return defaultActiveItemId === null ? null : 0;
    }
    return numericIndex;
  }

  // node_modules/@algolia/autocomplete-core/dist/esm/utils/noop.js
  var noop = function noop2() {
  };

  // node_modules/@algolia/autocomplete-core/dist/esm/utils/getNormalizedSources.js
  function ownKeys2(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys2(Object(source), true).forEach(function(key) {
          _defineProperty2(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof4(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof4(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  function getNormalizedSources(getSources, params) {
    var seenSourceIds = [];
    return Promise.resolve(getSources(params)).then(function(sources) {
      invariant(Array.isArray(sources), "The `getSources` function must return an array of sources but returned type ".concat(JSON.stringify(_typeof(sources)), ":\n\n").concat(JSON.stringify(sources, null, 2)));
      return Promise.all(sources.filter(function(maybeSource) {
        return Boolean(maybeSource);
      }).map(function(source) {
        invariant(typeof source.sourceId === "string", "A source must provide a `sourceId` string.");
        if (seenSourceIds.includes(source.sourceId)) {
          throw new Error("[Autocomplete] The `sourceId` ".concat(JSON.stringify(source.sourceId), " is not unique."));
        }
        seenSourceIds.push(source.sourceId);
        var normalizedSource = _objectSpread2({
          getItemInputValue: function getItemInputValue(_ref) {
            var state = _ref.state;
            return state.query;
          },
          getItemUrl: function getItemUrl() {
            return void 0;
          },
          onSelect: function onSelect(_ref2) {
            var setIsOpen = _ref2.setIsOpen;
            setIsOpen(false);
          },
          onActive: noop
        }, source);
        return Promise.resolve(normalizedSource);
      }));
    });
  }

  // node_modules/@algolia/autocomplete-core/dist/esm/utils/getActiveItem.js
  function getCollectionFromActiveItemId(state) {
    var accumulatedCollectionsCount = state.collections.map(function(collections) {
      return collections.items.length;
    }).reduce(function(acc, collectionsCount, index) {
      var previousValue = acc[index - 1] || 0;
      var nextValue = previousValue + collectionsCount;
      acc.push(nextValue);
      return acc;
    }, []);
    var collectionIndex = accumulatedCollectionsCount.reduce(function(acc, current) {
      if (current <= state.activeItemId) {
        return acc + 1;
      }
      return acc;
    }, 0);
    return state.collections[collectionIndex];
  }
  function getRelativeActiveItemId(_ref) {
    var state = _ref.state, collection = _ref.collection;
    var isOffsetFound = false;
    var counter = 0;
    var previousItemsOffset = 0;
    while (isOffsetFound === false) {
      var currentCollection = state.collections[counter];
      if (currentCollection === collection) {
        isOffsetFound = true;
        break;
      }
      previousItemsOffset += currentCollection.items.length;
      counter++;
    }
    return state.activeItemId - previousItemsOffset;
  }
  function getActiveItem(state) {
    var collection = getCollectionFromActiveItemId(state);
    if (!collection) {
      return null;
    }
    var item = collection.items[getRelativeActiveItemId({
      state,
      collection
    })];
    var source = collection.source;
    var itemInputValue = source.getItemInputValue({
      item,
      state
    });
    var itemUrl = source.getItemUrl({
      item,
      state
    });
    return {
      item,
      itemInputValue,
      itemUrl,
      source
    };
  }

  // node_modules/@algolia/autocomplete-core/dist/esm/utils/isOrContainsNode.js
  function isOrContainsNode(parent, child) {
    return parent === child || parent.contains(child);
  }

  // node_modules/@algolia/autocomplete-core/dist/esm/utils/mapToAlgoliaResponse.js
  function mapToAlgoliaResponse(results) {
    return {
      results,
      hits: results.map(function(result) {
        return result.hits;
      }).filter(Boolean),
      facetHits: results.map(function(result) {
        var _facetHits;
        return (_facetHits = result.facetHits) === null || _facetHits === void 0 ? void 0 : _facetHits.map(function(facetHit) {
          return {
            label: facetHit.value,
            count: facetHit.count,
            _highlightResult: {
              label: {
                value: facetHit.highlighted
              }
            }
          };
        });
      }).filter(Boolean)
    };
  }

  // node_modules/@algolia/autocomplete-core/dist/esm/getAutocompleteSetters.js
  function ownKeys3(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread3(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys3(Object(source), true).forEach(function(key) {
          _defineProperty3(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty3(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function getAutocompleteSetters(_ref) {
    var store = _ref.store;
    var setActiveItemId = function setActiveItemId2(value) {
      store.dispatch("setActiveItemId", value);
    };
    var setQuery = function setQuery2(value) {
      store.dispatch("setQuery", value);
    };
    var setCollections = function setCollections2(rawValue) {
      var baseItemId = 0;
      var value = rawValue.map(function(collection) {
        return _objectSpread3(_objectSpread3({}, collection), {}, {
          items: flatten(collection.items).map(function(item) {
            return _objectSpread3(_objectSpread3({}, item), {}, {
              __autocomplete_id: baseItemId++
            });
          })
        });
      });
      store.dispatch("setCollections", value);
    };
    var setIsOpen = function setIsOpen2(value) {
      store.dispatch("setIsOpen", value);
    };
    var setStatus = function setStatus2(value) {
      store.dispatch("setStatus", value);
    };
    var setContext = function setContext2(value) {
      store.dispatch("setContext", value);
    };
    return {
      setActiveItemId,
      setQuery,
      setCollections,
      setIsOpen,
      setStatus,
      setContext
    };
  }

  // node_modules/@algolia/autocomplete-core/dist/esm/getDefaultProps.js
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray(o2, minLen) {
    if (!o2)
      return;
    if (typeof o2 === "string")
      return _arrayLikeToArray(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor)
      n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o2, minLen);
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
      return Array.from(iter);
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray(arr);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  function ownKeys4(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread4(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys4(Object(source), true).forEach(function(key) {
          _defineProperty4(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys4(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty4(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function getDefaultProps(props, pluginSubscribers) {
    var _props$id;
    var environment = typeof window !== "undefined" ? window : {};
    var plugins = props.plugins || [];
    return _objectSpread4(_objectSpread4({
      debug: false,
      openOnFocus: false,
      placeholder: "",
      autoFocus: false,
      defaultActiveItemId: null,
      stallThreshold: 300,
      environment,
      shouldPanelOpen: function shouldPanelOpen(_ref) {
        var state = _ref.state;
        return getItemsCount(state) > 0;
      }
    }, props), {}, {
      id: (_props$id = props.id) !== null && _props$id !== void 0 ? _props$id : generateAutocompleteId(),
      plugins,
      initialState: _objectSpread4({
        activeItemId: null,
        query: "",
        completion: null,
        collections: [],
        isOpen: false,
        status: "idle",
        context: {}
      }, props.initialState),
      onStateChange: function onStateChange(params) {
        var _props$onStateChange;
        (_props$onStateChange = props.onStateChange) === null || _props$onStateChange === void 0 ? void 0 : _props$onStateChange.call(props, params);
        plugins.forEach(function(x2) {
          var _x$onStateChange;
          return (_x$onStateChange = x2.onStateChange) === null || _x$onStateChange === void 0 ? void 0 : _x$onStateChange.call(x2, params);
        });
      },
      onSubmit: function onSubmit(params) {
        var _props$onSubmit;
        (_props$onSubmit = props.onSubmit) === null || _props$onSubmit === void 0 ? void 0 : _props$onSubmit.call(props, params);
        plugins.forEach(function(x2) {
          var _x$onSubmit;
          return (_x$onSubmit = x2.onSubmit) === null || _x$onSubmit === void 0 ? void 0 : _x$onSubmit.call(x2, params);
        });
      },
      onReset: function onReset(params) {
        var _props$onReset;
        (_props$onReset = props.onReset) === null || _props$onReset === void 0 ? void 0 : _props$onReset.call(props, params);
        plugins.forEach(function(x2) {
          var _x$onReset;
          return (_x$onReset = x2.onReset) === null || _x$onReset === void 0 ? void 0 : _x$onReset.call(x2, params);
        });
      },
      getSources: function getSources(params) {
        return Promise.all([].concat(_toConsumableArray(plugins.map(function(plugin) {
          return plugin.getSources;
        })), [props.getSources]).filter(Boolean).map(function(getSources2) {
          return getNormalizedSources(getSources2, params);
        })).then(function(nested) {
          return flatten(nested);
        }).then(function(sources) {
          return sources.map(function(source) {
            return _objectSpread4(_objectSpread4({}, source), {}, {
              onSelect: function onSelect(params2) {
                source.onSelect(params2);
                pluginSubscribers.forEach(function(x2) {
                  var _x$onSelect;
                  return (_x$onSelect = x2.onSelect) === null || _x$onSelect === void 0 ? void 0 : _x$onSelect.call(x2, params2);
                });
              },
              onActive: function onActive(params2) {
                source.onActive(params2);
                pluginSubscribers.forEach(function(x2) {
                  var _x$onActive;
                  return (_x$onActive = x2.onActive) === null || _x$onActive === void 0 ? void 0 : _x$onActive.call(x2, params2);
                });
              }
            });
          });
        });
      },
      navigator: _objectSpread4({
        navigate: function navigate(_ref2) {
          var itemUrl = _ref2.itemUrl;
          environment.location.assign(itemUrl);
        },
        navigateNewTab: function navigateNewTab(_ref3) {
          var itemUrl = _ref3.itemUrl;
          var windowReference = environment.open(itemUrl, "_blank", "noopener");
          windowReference === null || windowReference === void 0 ? void 0 : windowReference.focus();
        },
        navigateNewWindow: function navigateNewWindow(_ref4) {
          var itemUrl = _ref4.itemUrl;
          environment.open(itemUrl, "_blank", "noopener");
        }
      }, props.navigator)
    });
  }

  // node_modules/@algolia/autocomplete-core/dist/esm/resolve.js
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof2 = function _typeof4(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof2 = function _typeof4(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof2(obj);
  }
  function _toConsumableArray2(arr) {
    return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
  }
  function _nonIterableSpread2() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray2(o2, minLen) {
    if (!o2)
      return;
    if (typeof o2 === "string")
      return _arrayLikeToArray2(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor)
      n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray2(o2, minLen);
  }
  function _iterableToArray2(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
      return Array.from(iter);
  }
  function _arrayWithoutHoles2(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray2(arr);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  function ownKeys5(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread5(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys5(Object(source), true).forEach(function(key) {
          _defineProperty5(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys5(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty5(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function isDescription(item) {
    return Boolean(item.execute);
  }
  function isRequesterDescription(description) {
    return Boolean(description.execute);
  }
  function preResolve(itemsOrDescription, sourceId) {
    if (isRequesterDescription(itemsOrDescription)) {
      return _objectSpread5(_objectSpread5({}, itemsOrDescription), {}, {
        requests: itemsOrDescription.queries.map(function(query) {
          return {
            query,
            sourceId,
            transformResponse: itemsOrDescription.transformResponse
          };
        })
      });
    }
    return {
      items: itemsOrDescription,
      sourceId
    };
  }
  function resolve(items) {
    var packed = items.reduce(function(acc, current) {
      if (!isDescription(current)) {
        acc.push(current);
        return acc;
      }
      var searchClient = current.searchClient, execute = current.execute, requests = current.requests;
      var container = acc.find(function(item) {
        return isDescription(current) && isDescription(item) && item.searchClient === searchClient && item.execute === execute;
      });
      if (container) {
        var _container$items;
        (_container$items = container.items).push.apply(_container$items, _toConsumableArray2(requests));
      } else {
        var request = {
          execute,
          items: requests,
          searchClient
        };
        acc.push(request);
      }
      return acc;
    }, []);
    var values = packed.map(function(maybeDescription) {
      if (!isDescription(maybeDescription)) {
        return Promise.resolve(maybeDescription);
      }
      var _ref = maybeDescription, execute = _ref.execute, items2 = _ref.items, searchClient = _ref.searchClient;
      return execute({
        searchClient,
        requests: items2
      });
    });
    return Promise.all(values).then(function(responses) {
      return flatten(responses);
    });
  }
  function postResolve(responses, sources) {
    return sources.map(function(source) {
      var matches = responses.filter(function(response) {
        return response.sourceId === source.sourceId;
      });
      var results = matches.map(function(_ref2) {
        var items2 = _ref2.items;
        return items2;
      });
      var transform = matches[0].transformResponse;
      var items = transform ? transform(mapToAlgoliaResponse(results)) : results;
      invariant(Array.isArray(items), "The `getItems` function must return an array of items but returned type ".concat(JSON.stringify(_typeof2(items)), ":\n\n").concat(JSON.stringify(items, null, 2)));
      return {
        source,
        items
      };
    });
  }

  // node_modules/@algolia/autocomplete-core/dist/esm/onInput.js
  function ownKeys6(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread6(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys6(Object(source), true).forEach(function(key) {
          _defineProperty6(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys6(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty6(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i2;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
        key = sourceSymbolKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var lastStalledId = null;
  function onInput(_ref) {
    var event = _ref.event, _ref$nextState = _ref.nextState, nextState = _ref$nextState === void 0 ? {} : _ref$nextState, props = _ref.props, query = _ref.query, refresh = _ref.refresh, store = _ref.store, setters = _objectWithoutProperties(_ref, ["event", "nextState", "props", "query", "refresh", "store"]);
    if (lastStalledId) {
      props.environment.clearTimeout(lastStalledId);
    }
    var setCollections = setters.setCollections, setIsOpen = setters.setIsOpen, setQuery = setters.setQuery, setActiveItemId = setters.setActiveItemId, setStatus = setters.setStatus;
    setQuery(query);
    setActiveItemId(props.defaultActiveItemId);
    if (!query && props.openOnFocus === false) {
      var _nextState$isOpen;
      setStatus("idle");
      setCollections(store.getState().collections.map(function(collection) {
        return _objectSpread6(_objectSpread6({}, collection), {}, {
          items: []
        });
      }));
      setIsOpen((_nextState$isOpen = nextState.isOpen) !== null && _nextState$isOpen !== void 0 ? _nextState$isOpen : props.shouldPanelOpen({
        state: store.getState()
      }));
      return Promise.resolve();
    }
    setStatus("loading");
    lastStalledId = props.environment.setTimeout(function() {
      setStatus("stalled");
    }, props.stallThreshold);
    return props.getSources(_objectSpread6({
      query,
      refresh,
      state: store.getState()
    }, setters)).then(function(sources) {
      setStatus("loading");
      return Promise.all(sources.map(function(source) {
        return Promise.resolve(source.getItems(_objectSpread6({
          query,
          refresh,
          state: store.getState()
        }, setters))).then(function(itemsOrDescription) {
          return preResolve(itemsOrDescription, source.sourceId);
        });
      })).then(resolve).then(function(responses) {
        return postResolve(responses, sources);
      }).then(function(collections) {
        var _nextState$isOpen2;
        setStatus("idle");
        setCollections(collections);
        var isPanelOpen = props.shouldPanelOpen({
          state: store.getState()
        });
        setIsOpen((_nextState$isOpen2 = nextState.isOpen) !== null && _nextState$isOpen2 !== void 0 ? _nextState$isOpen2 : props.openOnFocus && !query && isPanelOpen || isPanelOpen);
        var highlightedItem = getActiveItem(store.getState());
        if (store.getState().activeItemId !== null && highlightedItem) {
          var item = highlightedItem.item, itemInputValue = highlightedItem.itemInputValue, itemUrl = highlightedItem.itemUrl, source = highlightedItem.source;
          source.onActive(_objectSpread6({
            event,
            item,
            itemInputValue,
            itemUrl,
            refresh,
            source,
            state: store.getState()
          }, setters));
        }
      }).finally(function() {
        if (lastStalledId) {
          props.environment.clearTimeout(lastStalledId);
        }
      });
    });
  }

  // node_modules/@algolia/autocomplete-core/dist/esm/onKeyDown.js
  function ownKeys7(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread7(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys7(Object(source), true).forEach(function(key) {
          _defineProperty7(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys7(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty7(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _objectWithoutProperties2(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose2(source, excluded);
    var key, i2;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
        key = sourceSymbolKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose2(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function onKeyDown(_ref) {
    var event = _ref.event, props = _ref.props, refresh = _ref.refresh, store = _ref.store, setters = _objectWithoutProperties2(_ref, ["event", "props", "refresh", "store"]);
    if (event.key === "ArrowUp" || event.key === "ArrowDown") {
      event.preventDefault();
      store.dispatch(event.key, null);
      var nodeItem = props.environment.document.getElementById("".concat(props.id, "-item-").concat(store.getState().activeItemId));
      if (nodeItem) {
        if (nodeItem.scrollIntoViewIfNeeded) {
          nodeItem.scrollIntoViewIfNeeded(false);
        } else {
          nodeItem.scrollIntoView(false);
        }
      }
      var highlightedItem = getActiveItem(store.getState());
      if (store.getState().activeItemId !== null && highlightedItem) {
        var item = highlightedItem.item, itemInputValue = highlightedItem.itemInputValue, itemUrl = highlightedItem.itemUrl, source = highlightedItem.source;
        source.onActive(_objectSpread7({
          event,
          item,
          itemInputValue,
          itemUrl,
          refresh,
          source,
          state: store.getState()
        }, setters));
      }
    } else if (event.key === "Escape") {
      event.preventDefault();
      store.dispatch(event.key, null);
    } else if (event.key === "Enter") {
      if (store.getState().activeItemId === null || store.getState().collections.every(function(collection) {
        return collection.items.length === 0;
      })) {
        return;
      }
      event.preventDefault();
      var _ref2 = getActiveItem(store.getState()), _item = _ref2.item, _itemInputValue = _ref2.itemInputValue, _itemUrl = _ref2.itemUrl, _source = _ref2.source;
      if (event.metaKey || event.ctrlKey) {
        if (_itemUrl !== void 0) {
          _source.onSelect(_objectSpread7({
            event,
            item: _item,
            itemInputValue: _itemInputValue,
            itemUrl: _itemUrl,
            refresh,
            source: _source,
            state: store.getState()
          }, setters));
          props.navigator.navigateNewTab({
            itemUrl: _itemUrl,
            item: _item,
            state: store.getState()
          });
        }
      } else if (event.shiftKey) {
        if (_itemUrl !== void 0) {
          _source.onSelect(_objectSpread7({
            event,
            item: _item,
            itemInputValue: _itemInputValue,
            itemUrl: _itemUrl,
            refresh,
            source: _source,
            state: store.getState()
          }, setters));
          props.navigator.navigateNewWindow({
            itemUrl: _itemUrl,
            item: _item,
            state: store.getState()
          });
        }
      } else if (event.altKey) {
      } else {
        if (_itemUrl !== void 0) {
          _source.onSelect(_objectSpread7({
            event,
            item: _item,
            itemInputValue: _itemInputValue,
            itemUrl: _itemUrl,
            refresh,
            source: _source,
            state: store.getState()
          }, setters));
          props.navigator.navigate({
            itemUrl: _itemUrl,
            item: _item,
            state: store.getState()
          });
          return;
        }
        onInput(_objectSpread7({
          event,
          nextState: {
            isOpen: false
          },
          props,
          query: _itemInputValue,
          refresh,
          store
        }, setters)).then(function() {
          _source.onSelect(_objectSpread7({
            event,
            item: _item,
            itemInputValue: _itemInputValue,
            itemUrl: _itemUrl,
            refresh,
            source: _source,
            state: store.getState()
          }, setters));
        });
      }
    }
  }

  // node_modules/@algolia/autocomplete-core/dist/esm/getPropGetters.js
  function ownKeys8(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread8(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys8(Object(source), true).forEach(function(key) {
          _defineProperty8(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys8(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty8(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _objectWithoutProperties3(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose3(source, excluded);
    var key, i2;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
        key = sourceSymbolKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose3(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function getPropGetters(_ref) {
    var props = _ref.props, refresh = _ref.refresh, store = _ref.store, setters = _objectWithoutProperties3(_ref, ["props", "refresh", "store"]);
    var getEnvironmentProps = function getEnvironmentProps2(providedProps) {
      var inputElement = providedProps.inputElement, formElement = providedProps.formElement, panelElement = providedProps.panelElement, rest = _objectWithoutProperties3(providedProps, ["inputElement", "formElement", "panelElement"]);
      return _objectSpread8({
        onTouchStart: function onTouchStart(event) {
          if (store.getState().isOpen === false || event.target === inputElement) {
            return;
          }
          var isTargetWithinAutocomplete = [formElement, panelElement].some(function(contextNode) {
            return isOrContainsNode(contextNode, event.target) || isOrContainsNode(contextNode, props.environment.document.activeElement);
          });
          if (isTargetWithinAutocomplete === false) {
            store.dispatch("blur", null);
          }
        },
        onTouchMove: function onTouchMove(event) {
          if (store.getState().isOpen === false || inputElement !== props.environment.document.activeElement || event.target === inputElement) {
            return;
          }
          inputElement.blur();
        }
      }, rest);
    };
    var getRootProps = function getRootProps2(rest) {
      return _objectSpread8({
        role: "combobox",
        "aria-expanded": store.getState().isOpen,
        "aria-haspopup": "listbox",
        "aria-owns": store.getState().isOpen ? "".concat(props.id, "-list") : void 0,
        "aria-labelledby": "".concat(props.id, "-label")
      }, rest);
    };
    var getFormProps = function getFormProps2(providedProps) {
      var inputElement = providedProps.inputElement, rest = _objectWithoutProperties3(providedProps, ["inputElement"]);
      return _objectSpread8({
        action: "",
        noValidate: true,
        role: "search",
        onSubmit: function onSubmit(event) {
          var _providedProps$inputE;
          event.preventDefault();
          props.onSubmit(_objectSpread8({
            event,
            refresh,
            state: store.getState()
          }, setters));
          store.dispatch("submit", null);
          (_providedProps$inputE = providedProps.inputElement) === null || _providedProps$inputE === void 0 ? void 0 : _providedProps$inputE.blur();
        },
        onReset: function onReset(event) {
          var _providedProps$inputE2;
          event.preventDefault();
          props.onReset(_objectSpread8({
            event,
            refresh,
            state: store.getState()
          }, setters));
          store.dispatch("reset", null);
          (_providedProps$inputE2 = providedProps.inputElement) === null || _providedProps$inputE2 === void 0 ? void 0 : _providedProps$inputE2.focus();
        }
      }, rest);
    };
    var getInputProps = function getInputProps2(providedProps) {
      function onFocus(event) {
        if (props.openOnFocus || Boolean(store.getState().query)) {
          onInput(_objectSpread8({
            event,
            props,
            query: store.getState().completion || store.getState().query,
            refresh,
            store
          }, setters));
        }
        store.dispatch("focus", null);
      }
      var isTouchDevice = "ontouchstart" in props.environment;
      var _ref2 = providedProps || {}, inputElement = _ref2.inputElement, _ref2$maxLength = _ref2.maxLength, maxLength = _ref2$maxLength === void 0 ? 512 : _ref2$maxLength, rest = _objectWithoutProperties3(_ref2, ["inputElement", "maxLength"]);
      var activeItem = getActiveItem(store.getState());
      return _objectSpread8({
        "aria-autocomplete": "both",
        "aria-activedescendant": store.getState().isOpen && store.getState().activeItemId !== null ? "".concat(props.id, "-item-").concat(store.getState().activeItemId) : void 0,
        "aria-controls": store.getState().isOpen ? "".concat(props.id, "-list") : void 0,
        "aria-labelledby": "".concat(props.id, "-label"),
        value: store.getState().completion || store.getState().query,
        id: "".concat(props.id, "-input"),
        autoComplete: "off",
        autoCorrect: "off",
        autoCapitalize: "off",
        enterKeyHint: activeItem !== null && activeItem !== void 0 && activeItem.itemUrl ? "go" : "search",
        spellCheck: "false",
        autoFocus: props.autoFocus,
        placeholder: props.placeholder,
        maxLength,
        type: "search",
        onChange: function onChange(event) {
          onInput(_objectSpread8({
            event,
            props,
            query: event.currentTarget.value.slice(0, maxLength),
            refresh,
            store
          }, setters));
        },
        onKeyDown: function onKeyDown2(event) {
          onKeyDown(_objectSpread8({
            event,
            props,
            refresh,
            store
          }, setters));
        },
        onFocus,
        onBlur: function onBlur() {
          if (!isTouchDevice) {
            store.dispatch("blur", null);
          }
        },
        onClick: function onClick(event) {
          if (providedProps.inputElement === props.environment.document.activeElement && !store.getState().isOpen) {
            onFocus(event);
          }
        }
      }, rest);
    };
    var getLabelProps = function getLabelProps2(rest) {
      return _objectSpread8({
        htmlFor: "".concat(props.id, "-input"),
        id: "".concat(props.id, "-label")
      }, rest);
    };
    var getListProps = function getListProps2(rest) {
      return _objectSpread8({
        role: "listbox",
        "aria-labelledby": "".concat(props.id, "-label"),
        id: "".concat(props.id, "-list")
      }, rest);
    };
    var getPanelProps = function getPanelProps2(rest) {
      return _objectSpread8({
        onMouseDown: function onMouseDown(event) {
          event.preventDefault();
        },
        onMouseLeave: function onMouseLeave() {
          store.dispatch("mouseleave", null);
        }
      }, rest);
    };
    var getItemProps = function getItemProps2(providedProps) {
      var item = providedProps.item, source = providedProps.source, rest = _objectWithoutProperties3(providedProps, ["item", "source"]);
      return _objectSpread8({
        id: "".concat(props.id, "-item-").concat(item.__autocomplete_id),
        role: "option",
        "aria-selected": store.getState().activeItemId === item.__autocomplete_id,
        onMouseMove: function onMouseMove(event) {
          if (item.__autocomplete_id === store.getState().activeItemId) {
            return;
          }
          store.dispatch("mousemove", item.__autocomplete_id);
          var activeItem = getActiveItem(store.getState());
          if (store.getState().activeItemId !== null && activeItem) {
            var _item = activeItem.item, itemInputValue = activeItem.itemInputValue, itemUrl = activeItem.itemUrl, _source = activeItem.source;
            _source.onActive(_objectSpread8({
              event,
              item: _item,
              itemInputValue,
              itemUrl,
              refresh,
              source: _source,
              state: store.getState()
            }, setters));
          }
        },
        onMouseDown: function onMouseDown(event) {
          event.preventDefault();
        },
        onClick: function onClick(event) {
          var itemInputValue = source.getItemInputValue({
            item,
            state: store.getState()
          });
          var itemUrl = source.getItemUrl({
            item,
            state: store.getState()
          });
          var runPreCommand = itemUrl ? Promise.resolve() : onInput(_objectSpread8({
            event,
            nextState: {
              isOpen: false
            },
            props,
            query: itemInputValue,
            refresh,
            store
          }, setters));
          runPreCommand.then(function() {
            source.onSelect(_objectSpread8({
              event,
              item,
              itemInputValue,
              itemUrl,
              refresh,
              source,
              state: store.getState()
            }, setters));
          });
        }
      }, rest);
    };
    return {
      getEnvironmentProps,
      getRootProps,
      getFormProps,
      getLabelProps,
      getInputProps,
      getPanelProps,
      getListProps,
      getItemProps
    };
  }

  // node_modules/@algolia/autocomplete-core/dist/esm/getCompletion.js
  function getCompletion(_ref) {
    var state = _ref.state;
    if (state.isOpen === false || state.activeItemId === null) {
      return null;
    }
    var _ref2 = getActiveItem(state), itemInputValue = _ref2.itemInputValue;
    return itemInputValue || null;
  }

  // node_modules/@algolia/autocomplete-core/dist/esm/stateReducer.js
  function ownKeys9(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread9(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys9(Object(source), true).forEach(function(key) {
          _defineProperty9(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys9(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty9(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var stateReducer = function stateReducer2(state, action) {
    switch (action.type) {
      case "setActiveItemId": {
        return _objectSpread9(_objectSpread9({}, state), {}, {
          activeItemId: action.payload
        });
      }
      case "setQuery": {
        return _objectSpread9(_objectSpread9({}, state), {}, {
          query: action.payload,
          completion: null
        });
      }
      case "setCollections": {
        return _objectSpread9(_objectSpread9({}, state), {}, {
          collections: action.payload
        });
      }
      case "setIsOpen": {
        return _objectSpread9(_objectSpread9({}, state), {}, {
          isOpen: action.payload
        });
      }
      case "setStatus": {
        return _objectSpread9(_objectSpread9({}, state), {}, {
          status: action.payload
        });
      }
      case "setContext": {
        return _objectSpread9(_objectSpread9({}, state), {}, {
          context: _objectSpread9(_objectSpread9({}, state.context), action.payload)
        });
      }
      case "ArrowDown": {
        var nextState = _objectSpread9(_objectSpread9({}, state), {}, {
          activeItemId: getNextActiveItemId(1, state.activeItemId, getItemsCount(state), action.props.defaultActiveItemId)
        });
        return _objectSpread9(_objectSpread9({}, nextState), {}, {
          completion: getCompletion({
            state: nextState
          })
        });
      }
      case "ArrowUp": {
        var _nextState = _objectSpread9(_objectSpread9({}, state), {}, {
          activeItemId: getNextActiveItemId(-1, state.activeItemId, getItemsCount(state), action.props.defaultActiveItemId)
        });
        return _objectSpread9(_objectSpread9({}, _nextState), {}, {
          completion: getCompletion({
            state: _nextState
          })
        });
      }
      case "Escape": {
        if (state.isOpen) {
          return _objectSpread9(_objectSpread9({}, state), {}, {
            isOpen: false,
            completion: null
          });
        }
        return _objectSpread9(_objectSpread9({}, state), {}, {
          query: "",
          status: "idle",
          collections: []
        });
      }
      case "submit": {
        return _objectSpread9(_objectSpread9({}, state), {}, {
          activeItemId: null,
          isOpen: false,
          status: "idle"
        });
      }
      case "reset": {
        return _objectSpread9(_objectSpread9({}, state), {}, {
          activeItemId: action.props.openOnFocus === true ? action.props.defaultActiveItemId : null,
          status: "idle",
          query: ""
        });
      }
      case "focus": {
        return _objectSpread9(_objectSpread9({}, state), {}, {
          activeItemId: action.props.defaultActiveItemId,
          isOpen: (action.props.openOnFocus || Boolean(state.query)) && action.props.shouldPanelOpen({
            state
          })
        });
      }
      case "blur": {
        if (action.props.debug) {
          return state;
        }
        return _objectSpread9(_objectSpread9({}, state), {}, {
          isOpen: false,
          activeItemId: null
        });
      }
      case "mousemove": {
        return _objectSpread9(_objectSpread9({}, state), {}, {
          activeItemId: action.payload
        });
      }
      case "mouseleave": {
        return _objectSpread9(_objectSpread9({}, state), {}, {
          activeItemId: action.props.defaultActiveItemId
        });
      }
      default:
        invariant(false, "The reducer action ".concat(JSON.stringify(action.type), " is not supported."));
        return state;
    }
  };

  // node_modules/@algolia/autocomplete-core/dist/esm/createAutocomplete.js
  function ownKeys10(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread10(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys10(Object(source), true).forEach(function(key) {
          _defineProperty10(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys10(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty10(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function createAutocomplete(options) {
    checkOptions(options);
    var subscribers = [];
    var props = getDefaultProps(options, subscribers);
    var store = createStore(stateReducer, props, onStoreStateChange);
    var setters = getAutocompleteSetters({
      store
    });
    var propGetters = getPropGetters(_objectSpread10({
      props,
      refresh,
      store
    }, setters));
    function onStoreStateChange(_ref) {
      var prevState = _ref.prevState, state = _ref.state;
      props.onStateChange(_objectSpread10({
        prevState,
        state,
        refresh
      }, setters));
    }
    function refresh() {
      return onInput(_objectSpread10({
        event: new Event("input"),
        nextState: {
          isOpen: store.getState().isOpen
        },
        props,
        query: store.getState().query,
        refresh,
        store
      }, setters));
    }
    props.plugins.forEach(function(plugin) {
      var _plugin$subscribe;
      return (_plugin$subscribe = plugin.subscribe) === null || _plugin$subscribe === void 0 ? void 0 : _plugin$subscribe.call(plugin, _objectSpread10(_objectSpread10({}, setters), {}, {
        refresh,
        onSelect: function onSelect(fn2) {
          subscribers.push({
            onSelect: fn2
          });
        },
        onActive: function onActive(fn2) {
          subscribers.push({
            onActive: fn2
          });
        }
      }));
    });
    return _objectSpread10(_objectSpread10({
      refresh
    }, propGetters), setters);
  }

  // node_modules/@algolia/autocomplete-js/dist/esm/utils/getHTMLElement.js
  function getHTMLElement(value) {
    if (typeof value === "string") {
      var element = document.querySelector(value);
      invariant(element !== null, "The element ".concat(JSON.stringify(value), " is not in the document."));
      return element;
    }
    return value;
  }

  // node_modules/@algolia/autocomplete-js/dist/esm/utils/mergeClassNames.js
  function mergeClassNames() {
    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
      values[_key] = arguments[_key];
    }
    return values.reduce(function(acc, current) {
      Object.keys(current).forEach(function(key) {
        var accValue = acc[key];
        var currentValue = current[key];
        if (accValue !== currentValue) {
          acc[key] = [accValue, currentValue].filter(Boolean).join(" ");
        }
      });
      return acc;
    }, {});
  }

  // node_modules/@algolia/autocomplete-js/dist/esm/utils/mergeDeep.js
  function _toConsumableArray3(arr) {
    return _arrayWithoutHoles3(arr) || _iterableToArray3(arr) || _unsupportedIterableToArray3(arr) || _nonIterableSpread3();
  }
  function _nonIterableSpread3() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray3(o2, minLen) {
    if (!o2)
      return;
    if (typeof o2 === "string")
      return _arrayLikeToArray3(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor)
      n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray3(o2, minLen);
  }
  function _iterableToArray3(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
      return Array.from(iter);
  }
  function _arrayWithoutHoles3(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray3(arr);
  }
  function _arrayLikeToArray3(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  function _typeof3(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof3 = function _typeof4(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof3 = function _typeof4(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof3(obj);
  }
  var isObject = function isObject2(value) {
    return value && _typeof3(value) === "object";
  };
  function mergeDeep() {
    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
      values[_key] = arguments[_key];
    }
    return values.reduce(function(acc, current) {
      Object.keys(current).forEach(function(key) {
        var accValue = acc[key];
        var currentValue = current[key];
        if (Array.isArray(accValue) && Array.isArray(currentValue)) {
          acc[key] = accValue.concat.apply(accValue, _toConsumableArray3(currentValue));
        } else if (isObject(accValue) && isObject(currentValue)) {
          acc[key] = mergeDeep(accValue, currentValue);
        } else {
          acc[key] = currentValue;
        }
      });
      return acc;
    }, {});
  }

  // node_modules/@algolia/autocomplete-js/dist/esm/utils/setProperties.js
  function setStyle(style, key, value) {
    if (value === null) {
      style[key] = "";
    } else if (typeof value !== "number") {
      style[key] = value;
    } else {
      style[key] = value + "px";
    }
  }
  function eventProxy(event) {
    this._listeners[event.type](event);
  }
  function setProperty(dom, name, value) {
    var useCapture;
    var nameLower;
    var oldValue = dom[name];
    if (name === "style") {
      if (typeof value == "string") {
        dom.style = value;
      } else {
        if (value === null) {
          dom.style = "";
        } else {
          for (name in value) {
            if (!oldValue || value[name] !== oldValue[name]) {
              setStyle(dom.style, name, value[name]);
            }
          }
        }
      }
    } else if (name[0] === "o" && name[1] === "n") {
      useCapture = name !== (name = name.replace(/Capture$/, ""));
      nameLower = name.toLowerCase();
      if (nameLower in dom)
        name = nameLower;
      name = name.slice(2);
      if (!dom._listeners)
        dom._listeners = {};
      dom._listeners[name] = value;
      if (value) {
        if (!oldValue)
          dom.addEventListener(name, eventProxy, useCapture);
      } else {
        dom.removeEventListener(name, eventProxy, useCapture);
      }
    } else if (name !== "list" && name !== "tagName" && name !== "form" && name !== "type" && name !== "size" && name !== "download" && name !== "href" && name in dom) {
      dom[name] = value == null ? "" : value;
    } else if (typeof value != "function" && name !== "dangerouslySetInnerHTML") {
      if (value == null || value === false && !/^ar/.test(name)) {
        dom.removeAttribute(name);
      } else {
        dom.setAttribute(name, value);
      }
    }
  }
  function getNormalizedName(name) {
    switch (name) {
      case "onChange":
        return "onInput";
      default:
        return name;
    }
  }
  function setProperties(dom, props) {
    for (var name in props) {
      setProperty(dom, getNormalizedName(name), props[name]);
    }
  }
  function setPropertiesWithoutEvents(dom, props) {
    for (var name in props) {
      if (!(name[0] === "o" && name[1] === "n")) {
        setProperty(dom, getNormalizedName(name), props[name]);
      }
    }
  }

  // node_modules/@algolia/autocomplete-js/dist/esm/createDomElement.js
  function _toConsumableArray4(arr) {
    return _arrayWithoutHoles4(arr) || _iterableToArray4(arr) || _unsupportedIterableToArray4(arr) || _nonIterableSpread4();
  }
  function _nonIterableSpread4() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray4(o2, minLen) {
    if (!o2)
      return;
    if (typeof o2 === "string")
      return _arrayLikeToArray4(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor)
      n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray4(o2, minLen);
  }
  function _iterableToArray4(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
      return Array.from(iter);
  }
  function _arrayWithoutHoles4(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray4(arr);
  }
  function _arrayLikeToArray4(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  function _objectWithoutProperties4(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose4(source, excluded);
    var key, i2;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
        key = sourceSymbolKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose4(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function createDomElement(tagName, _ref) {
    var _ref$children = _ref.children, children = _ref$children === void 0 ? [] : _ref$children, props = _objectWithoutProperties4(_ref, ["children"]);
    var element = document.createElement(tagName);
    setProperties(element, props);
    element.append.apply(element, _toConsumableArray4(children));
    return element;
  }

  // node_modules/@algolia/autocomplete-js/dist/esm/elements/ClearIcon.js
  var ClearIcon = function ClearIcon2() {
    var element = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    element.setAttribute("class", "aa-ClearIcon");
    element.setAttribute("viewBox", "0 0 24 24");
    element.setAttribute("width", "18");
    element.setAttribute("height", "18");
    element.setAttribute("fill", "currentColor");
    var path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", "M5.293 6.707l5.293 5.293-5.293 5.293c-0.391 0.391-0.391 1.024 0 1.414s1.024 0.391 1.414 0l5.293-5.293 5.293 5.293c0.391 0.391 1.024 0.391 1.414 0s0.391-1.024 0-1.414l-5.293-5.293 5.293-5.293c0.391-0.391 0.391-1.024 0-1.414s-1.024-0.391-1.414 0l-5.293 5.293-5.293-5.293c-0.391-0.391-1.024-0.391-1.414 0s-0.391 1.024 0 1.414z");
    element.appendChild(path);
    return element;
  };

  // node_modules/@algolia/autocomplete-js/dist/esm/elements/Input.js
  function ownKeys11(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread11(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys11(Object(source), true).forEach(function(key) {
          _defineProperty11(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys11(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty11(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _objectWithoutProperties5(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose5(source, excluded);
    var key, i2;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
        key = sourceSymbolKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose5(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var Input = function Input2(_ref) {
    var autocompleteScopeApi = _ref.autocompleteScopeApi, classNames = _ref.classNames, getInputProps = _ref.getInputProps, getInputPropsCore = _ref.getInputPropsCore, onDetachedEscape = _ref.onDetachedEscape, state = _ref.state, props = _objectWithoutProperties5(_ref, ["autocompleteScopeApi", "classNames", "getInputProps", "getInputPropsCore", "onDetachedEscape", "state"]);
    var element = createDomElement("input", props);
    var inputProps = getInputProps(_objectSpread11({
      state,
      props: getInputPropsCore({
        inputElement: element
      }),
      inputElement: element
    }, autocompleteScopeApi));
    setProperties(element, _objectSpread11(_objectSpread11({}, inputProps), {}, {
      onKeyDown: function onKeyDown2(event) {
        if (onDetachedEscape && event.key === "Escape") {
          onDetachedEscape();
          return;
        }
        inputProps.onKeyDown(event);
      }
    }));
    return element;
  };

  // node_modules/@algolia/autocomplete-js/dist/esm/elements/LoadingIcon.js
  var LoadingIcon = function LoadingIcon2() {
    var element = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    element.setAttribute("class", "aa-LoadingIcon");
    element.setAttribute("viewBox", "0 0 100 100");
    element.setAttribute("width", "20");
    element.setAttribute("height", "20");
    element.innerHTML = '<circle\n  cx="50"\n  cy="50"\n  fill="none"\n  r="35"\n  stroke="currentColor"\n  stroke-dasharray="164.93361431346415 56.97787143782138"\n  stroke-width="6"\n>\n  <animateTransform\n    attributeName="transform"\n    type="rotate"\n    repeatCount="indefinite"\n    dur="1s"\n    values="0 50 50;90 50 50;180 50 50;360 50 50"\n    keyTimes="0;0.40;0.65;1"\n  />\n</circle>';
    return element;
  };

  // node_modules/@algolia/autocomplete-js/dist/esm/elements/SearchIcon.js
  var SearchIcon = function SearchIcon2() {
    var element = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    element.setAttribute("class", "aa-SubmitIcon");
    element.setAttribute("viewBox", "0 0 24 24");
    element.setAttribute("width", "20");
    element.setAttribute("height", "20");
    element.setAttribute("fill", "currentColor");
    var path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", "M16.041 15.856c-0.034 0.026-0.067 0.055-0.099 0.087s-0.060 0.064-0.087 0.099c-1.258 1.213-2.969 1.958-4.855 1.958-1.933 0-3.682-0.782-4.95-2.050s-2.050-3.017-2.050-4.95 0.782-3.682 2.050-4.95 3.017-2.050 4.95-2.050 3.682 0.782 4.95 2.050 2.050 3.017 2.050 4.95c0 1.886-0.745 3.597-1.959 4.856zM21.707 20.293l-3.675-3.675c1.231-1.54 1.968-3.493 1.968-5.618 0-2.485-1.008-4.736-2.636-6.364s-3.879-2.636-6.364-2.636-4.736 1.008-6.364 2.636-2.636 3.879-2.636 6.364 1.008 4.736 2.636 6.364 3.879 2.636 6.364 2.636c2.125 0 4.078-0.737 5.618-1.968l3.675 3.675c0.391 0.391 1.024 0.391 1.414 0s0.391-1.024 0-1.414z");
    element.appendChild(path);
    return element;
  };

  // node_modules/@algolia/autocomplete-js/dist/esm/createAutocompleteDom.js
  function ownKeys12(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread12(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys12(Object(source), true).forEach(function(key) {
          _defineProperty12(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys12(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty12(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function createAutocompleteDom(_ref) {
    var autocomplete2 = _ref.autocomplete, autocompleteScopeApi = _ref.autocompleteScopeApi, classNames = _ref.classNames, isDetached = _ref.isDetached, _ref$placeholder = _ref.placeholder, placeholder = _ref$placeholder === void 0 ? "Search" : _ref$placeholder, propGetters = _ref.propGetters, state = _ref.state;
    function onDetachedOverlayClose() {
      autocomplete2.setQuery("");
      autocomplete2.setIsOpen(false);
      autocomplete2.refresh();
      document.body.classList.remove("aa-Detached");
    }
    var rootProps = propGetters.getRootProps(_objectSpread12({
      state,
      props: autocomplete2.getRootProps({})
    }, autocompleteScopeApi));
    var root = createDomElement("div", _objectSpread12({
      class: classNames.root
    }, rootProps));
    var detachedContainer = createDomElement("div", {
      class: classNames.detachedContainer,
      onMouseDown: function onMouseDown(event) {
        event.stopPropagation();
      }
    });
    var detachedOverlay = createDomElement("div", {
      class: classNames.detachedOverlay,
      children: [detachedContainer],
      onMouseDown: function onMouseDown() {
        document.body.removeChild(detachedOverlay);
        onDetachedOverlayClose();
      }
    });
    var labelProps = propGetters.getLabelProps(_objectSpread12({
      state,
      props: autocomplete2.getLabelProps({})
    }, autocompleteScopeApi));
    var submitButton = createDomElement("button", {
      class: classNames.submitButton,
      type: "submit",
      title: "Submit",
      children: [SearchIcon({})]
    });
    var label = createDomElement("label", _objectSpread12({
      class: classNames.label,
      children: [submitButton]
    }, labelProps));
    var clearButton = createDomElement("button", {
      class: classNames.clearButton,
      type: "reset",
      title: "Clear",
      children: [ClearIcon({})]
    });
    var loadingIndicator = createDomElement("div", {
      class: classNames.loadingIndicator,
      children: [LoadingIcon({})]
    });
    var input = Input({
      class: classNames.input,
      state,
      getInputProps: propGetters.getInputProps,
      getInputPropsCore: autocomplete2.getInputProps,
      autocompleteScopeApi,
      onDetachedEscape: isDetached ? function() {
        document.body.removeChild(detachedOverlay);
        onDetachedOverlayClose();
      } : void 0
    });
    var inputWrapperPrefix = createDomElement("div", {
      class: classNames.inputWrapperPrefix,
      children: [label, loadingIndicator]
    });
    var inputWrapperSuffix = createDomElement("div", {
      class: classNames.inputWrapperSuffix,
      children: [clearButton]
    });
    var inputWrapper = createDomElement("div", {
      class: classNames.inputWrapper,
      children: [input]
    });
    var formProps = propGetters.getFormProps(_objectSpread12({
      state,
      props: autocomplete2.getFormProps({
        inputElement: input
      })
    }, autocompleteScopeApi));
    var form = createDomElement("form", _objectSpread12({
      class: classNames.form,
      children: [inputWrapperPrefix, inputWrapper, inputWrapperSuffix]
    }, formProps));
    var panelProps = propGetters.getPanelProps(_objectSpread12({
      state,
      props: autocomplete2.getPanelProps({})
    }, autocompleteScopeApi));
    var panel = createDomElement("div", _objectSpread12({
      class: classNames.panel
    }, panelProps));
    if (false) {
      setProperties(panel, {
        "data-testid": "panel"
      });
    }
    function openDetachedOverlay() {
      document.body.appendChild(detachedOverlay);
      document.body.classList.add("aa-Detached");
      input.focus();
    }
    if (isDetached) {
      var detachedSearchButtonIcon = createDomElement("div", {
        class: classNames.detachedSearchButtonIcon,
        children: [SearchIcon({})]
      });
      var detachedSearchButtonPlaceholder = createDomElement("div", {
        class: classNames.detachedSearchButtonPlaceholder,
        textContent: placeholder
      });
      var detachedSearchButton = createDomElement("button", {
        class: classNames.detachedSearchButton,
        onClick: function onClick(event) {
          event.preventDefault();
          openDetachedOverlay();
        },
        children: [detachedSearchButtonIcon, detachedSearchButtonPlaceholder]
      });
      var detachedCancelButton = createDomElement("button", {
        class: classNames.detachedCancelButton,
        textContent: "Cancel",
        onClick: function onClick() {
          document.body.removeChild(detachedOverlay);
          onDetachedOverlayClose();
        }
      });
      var detachedFormContainer = createDomElement("div", {
        class: classNames.detachedFormContainer,
        children: [form, detachedCancelButton]
      });
      detachedContainer.appendChild(detachedFormContainer);
      root.appendChild(detachedSearchButton);
    } else {
      root.appendChild(form);
    }
    return {
      openDetachedOverlay,
      detachedContainer,
      detachedOverlay,
      inputWrapper,
      input,
      root,
      form,
      label,
      submitButton,
      clearButton,
      loadingIndicator,
      panel
    };
  }

  // node_modules/@algolia/autocomplete-js/dist/esm/createEffectWrapper.js
  function createEffectWrapper() {
    var effects = [];
    var cleanups = [];
    function runEffect(fn2) {
      effects.push(fn2);
      var effectCleanup = fn2();
      cleanups.push(effectCleanup);
    }
    return {
      runEffect,
      cleanupEffects: function cleanupEffects() {
        var currentCleanups = cleanups;
        cleanups = [];
        currentCleanups.forEach(function(cleanup) {
          cleanup();
        });
      },
      runEffects: function runEffects() {
        var currentEffects = effects;
        effects = [];
        currentEffects.forEach(function(effect4) {
          runEffect(effect4);
        });
      }
    };
  }

  // node_modules/@algolia/autocomplete-js/dist/esm/createReactiveWrapper.js
  function createReactiveWrapper() {
    var reactives = [];
    return {
      reactive: function reactive(value) {
        var current = value();
        var reactive2 = {
          _fn: value,
          _ref: {
            current
          },
          get value() {
            return this._ref.current;
          },
          set value(value2) {
            this._ref.current = value2;
          }
        };
        reactives.push(reactive2);
        return reactive2;
      },
      runReactives: function runReactives() {
        reactives.forEach(function(value) {
          value._ref.current = value._fn();
        });
      }
    };
  }

  // node_modules/preact/dist/preact.module.js
  var n;
  var l;
  var u;
  var i;
  var t;
  var o;
  var r = {};
  var f = [];
  var e = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
  function c(n2, l2) {
    for (var u2 in l2)
      n2[u2] = l2[u2];
    return n2;
  }
  function s(n2) {
    var l2 = n2.parentNode;
    l2 && l2.removeChild(n2);
  }
  function a(n2, l2, u2) {
    var i2, t2, o2, r2 = arguments, f2 = {};
    for (o2 in l2)
      o2 == "key" ? i2 = l2[o2] : o2 == "ref" ? t2 = l2[o2] : f2[o2] = l2[o2];
    if (arguments.length > 3)
      for (u2 = [u2], o2 = 3; o2 < arguments.length; o2++)
        u2.push(r2[o2]);
    if (u2 != null && (f2.children = u2), typeof n2 == "function" && n2.defaultProps != null)
      for (o2 in n2.defaultProps)
        f2[o2] === void 0 && (f2[o2] = n2.defaultProps[o2]);
    return v(n2, f2, i2, t2, null);
  }
  function v(l2, u2, i2, t2, o2) {
    var r2 = { type: l2, props: u2, key: i2, ref: t2, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: o2 == null ? ++n.__v : o2 };
    return n.vnode != null && n.vnode(r2), r2;
  }
  function y(n2) {
    return n2.children;
  }
  function p(n2, l2) {
    this.props = n2, this.context = l2;
  }
  function d(n2, l2) {
    if (l2 == null)
      return n2.__ ? d(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
    for (var u2; l2 < n2.__k.length; l2++)
      if ((u2 = n2.__k[l2]) != null && u2.__e != null)
        return u2.__e;
    return typeof n2.type == "function" ? d(n2) : null;
  }
  function _(n2) {
    var l2, u2;
    if ((n2 = n2.__) != null && n2.__c != null) {
      for (n2.__e = n2.__c.base = null, l2 = 0; l2 < n2.__k.length; l2++)
        if ((u2 = n2.__k[l2]) != null && u2.__e != null) {
          n2.__e = n2.__c.base = u2.__e;
          break;
        }
      return _(n2);
    }
  }
  function k(l2) {
    (!l2.__d && (l2.__d = true) && u.push(l2) && !b.__r++ || t !== n.debounceRendering) && ((t = n.debounceRendering) || i)(b);
  }
  function b() {
    for (var n2; b.__r = u.length; )
      n2 = u.sort(function(n3, l2) {
        return n3.__v.__b - l2.__v.__b;
      }), u = [], n2.some(function(n3) {
        var l2, u2, i2, t2, o2, r2;
        n3.__d && (o2 = (t2 = (l2 = n3).__v).__e, (r2 = l2.__P) && (u2 = [], (i2 = c({}, t2)).__v = t2.__v + 1, I(r2, t2, i2, l2.__n, r2.ownerSVGElement !== void 0, t2.__h != null ? [o2] : null, u2, o2 == null ? d(t2) : o2, t2.__h), T(u2, t2), t2.__e != o2 && _(t2)));
      });
  }
  function m(n2, l2, u2, i2, t2, o2, e2, c2, s2, a2) {
    var h, p2, _2, k2, b2, m2, w, A2 = i2 && i2.__k || f, P2 = A2.length;
    for (u2.__k = [], h = 0; h < l2.length; h++)
      if ((k2 = u2.__k[h] = (k2 = l2[h]) == null || typeof k2 == "boolean" ? null : typeof k2 == "string" || typeof k2 == "number" || typeof k2 == "bigint" ? v(null, k2, null, null, k2) : Array.isArray(k2) ? v(y, { children: k2 }, null, null, null) : k2.__b > 0 ? v(k2.type, k2.props, k2.key, null, k2.__v) : k2) != null) {
        if (k2.__ = u2, k2.__b = u2.__b + 1, (_2 = A2[h]) === null || _2 && k2.key == _2.key && k2.type === _2.type)
          A2[h] = void 0;
        else
          for (p2 = 0; p2 < P2; p2++) {
            if ((_2 = A2[p2]) && k2.key == _2.key && k2.type === _2.type) {
              A2[p2] = void 0;
              break;
            }
            _2 = null;
          }
        I(n2, k2, _2 = _2 || r, t2, o2, e2, c2, s2, a2), b2 = k2.__e, (p2 = k2.ref) && _2.ref != p2 && (w || (w = []), _2.ref && w.push(_2.ref, null, k2), w.push(p2, k2.__c || b2, k2)), b2 != null ? (m2 == null && (m2 = b2), typeof k2.type == "function" && k2.__k != null && k2.__k === _2.__k ? k2.__d = s2 = g(k2, s2, n2) : s2 = x(n2, k2, _2, A2, b2, s2), a2 || u2.type !== "option" ? typeof u2.type == "function" && (u2.__d = s2) : n2.value = "") : s2 && _2.__e == s2 && s2.parentNode != n2 && (s2 = d(_2));
      }
    for (u2.__e = m2, h = P2; h--; )
      A2[h] != null && (typeof u2.type == "function" && A2[h].__e != null && A2[h].__e == u2.__d && (u2.__d = d(i2, h + 1)), L(A2[h], A2[h]));
    if (w)
      for (h = 0; h < w.length; h++)
        z(w[h], w[++h], w[++h]);
  }
  function g(n2, l2, u2) {
    var i2, t2;
    for (i2 = 0; i2 < n2.__k.length; i2++)
      (t2 = n2.__k[i2]) && (t2.__ = n2, l2 = typeof t2.type == "function" ? g(t2, l2, u2) : x(u2, t2, t2, n2.__k, t2.__e, l2));
    return l2;
  }
  function x(n2, l2, u2, i2, t2, o2) {
    var r2, f2, e2;
    if (l2.__d !== void 0)
      r2 = l2.__d, l2.__d = void 0;
    else if (u2 == null || t2 != o2 || t2.parentNode == null)
      n:
        if (o2 == null || o2.parentNode !== n2)
          n2.appendChild(t2), r2 = null;
        else {
          for (f2 = o2, e2 = 0; (f2 = f2.nextSibling) && e2 < i2.length; e2 += 2)
            if (f2 == t2)
              break n;
          n2.insertBefore(t2, o2), r2 = o2;
        }
    return r2 !== void 0 ? r2 : t2.nextSibling;
  }
  function A(n2, l2, u2, i2, t2) {
    var o2;
    for (o2 in u2)
      o2 === "children" || o2 === "key" || o2 in l2 || C(n2, o2, null, u2[o2], i2);
    for (o2 in l2)
      t2 && typeof l2[o2] != "function" || o2 === "children" || o2 === "key" || o2 === "value" || o2 === "checked" || u2[o2] === l2[o2] || C(n2, o2, l2[o2], u2[o2], i2);
  }
  function P(n2, l2, u2) {
    l2[0] === "-" ? n2.setProperty(l2, u2) : n2[l2] = u2 == null ? "" : typeof u2 != "number" || e.test(l2) ? u2 : u2 + "px";
  }
  function C(n2, l2, u2, i2, t2) {
    var o2;
    n:
      if (l2 === "style")
        if (typeof u2 == "string")
          n2.style.cssText = u2;
        else {
          if (typeof i2 == "string" && (n2.style.cssText = i2 = ""), i2)
            for (l2 in i2)
              u2 && l2 in u2 || P(n2.style, l2, "");
          if (u2)
            for (l2 in u2)
              i2 && u2[l2] === i2[l2] || P(n2.style, l2, u2[l2]);
        }
      else if (l2[0] === "o" && l2[1] === "n")
        o2 = l2 !== (l2 = l2.replace(/Capture$/, "")), l2 = l2.toLowerCase() in n2 ? l2.toLowerCase().slice(2) : l2.slice(2), n2.l || (n2.l = {}), n2.l[l2 + o2] = u2, u2 ? i2 || n2.addEventListener(l2, o2 ? H : $, o2) : n2.removeEventListener(l2, o2 ? H : $, o2);
      else if (l2 !== "dangerouslySetInnerHTML") {
        if (t2)
          l2 = l2.replace(/xlink[H:h]/, "h").replace(/sName$/, "s");
        else if (l2 !== "href" && l2 !== "list" && l2 !== "form" && l2 !== "tabIndex" && l2 !== "download" && l2 in n2)
          try {
            n2[l2] = u2 == null ? "" : u2;
            break n;
          } catch (n3) {
          }
        typeof u2 == "function" || (u2 != null && (u2 !== false || l2[0] === "a" && l2[1] === "r") ? n2.setAttribute(l2, u2) : n2.removeAttribute(l2));
      }
  }
  function $(l2) {
    this.l[l2.type + false](n.event ? n.event(l2) : l2);
  }
  function H(l2) {
    this.l[l2.type + true](n.event ? n.event(l2) : l2);
  }
  function I(l2, u2, i2, t2, o2, r2, f2, e2, s2) {
    var a2, v2, h, d2, _2, k2, b2, g2, w, x2, A2, P2 = u2.type;
    if (u2.constructor !== void 0)
      return null;
    i2.__h != null && (s2 = i2.__h, e2 = u2.__e = i2.__e, u2.__h = null, r2 = [e2]), (a2 = n.__b) && a2(u2);
    try {
      n:
        if (typeof P2 == "function") {
          if (g2 = u2.props, w = (a2 = P2.contextType) && t2[a2.__c], x2 = a2 ? w ? w.props.value : a2.__ : t2, i2.__c ? b2 = (v2 = u2.__c = i2.__c).__ = v2.__E : ("prototype" in P2 && P2.prototype.render ? u2.__c = v2 = new P2(g2, x2) : (u2.__c = v2 = new p(g2, x2), v2.constructor = P2, v2.render = M), w && w.sub(v2), v2.props = g2, v2.state || (v2.state = {}), v2.context = x2, v2.__n = t2, h = v2.__d = true, v2.__h = []), v2.__s == null && (v2.__s = v2.state), P2.getDerivedStateFromProps != null && (v2.__s == v2.state && (v2.__s = c({}, v2.__s)), c(v2.__s, P2.getDerivedStateFromProps(g2, v2.__s))), d2 = v2.props, _2 = v2.state, h)
            P2.getDerivedStateFromProps == null && v2.componentWillMount != null && v2.componentWillMount(), v2.componentDidMount != null && v2.__h.push(v2.componentDidMount);
          else {
            if (P2.getDerivedStateFromProps == null && g2 !== d2 && v2.componentWillReceiveProps != null && v2.componentWillReceiveProps(g2, x2), !v2.__e && v2.shouldComponentUpdate != null && v2.shouldComponentUpdate(g2, v2.__s, x2) === false || u2.__v === i2.__v) {
              v2.props = g2, v2.state = v2.__s, u2.__v !== i2.__v && (v2.__d = false), v2.__v = u2, u2.__e = i2.__e, u2.__k = i2.__k, u2.__k.forEach(function(n2) {
                n2 && (n2.__ = u2);
              }), v2.__h.length && f2.push(v2);
              break n;
            }
            v2.componentWillUpdate != null && v2.componentWillUpdate(g2, v2.__s, x2), v2.componentDidUpdate != null && v2.__h.push(function() {
              v2.componentDidUpdate(d2, _2, k2);
            });
          }
          v2.context = x2, v2.props = g2, v2.state = v2.__s, (a2 = n.__r) && a2(u2), v2.__d = false, v2.__v = u2, v2.__P = l2, a2 = v2.render(v2.props, v2.state, v2.context), v2.state = v2.__s, v2.getChildContext != null && (t2 = c(c({}, t2), v2.getChildContext())), h || v2.getSnapshotBeforeUpdate == null || (k2 = v2.getSnapshotBeforeUpdate(d2, _2)), A2 = a2 != null && a2.type === y && a2.key == null ? a2.props.children : a2, m(l2, Array.isArray(A2) ? A2 : [A2], u2, i2, t2, o2, r2, f2, e2, s2), v2.base = u2.__e, u2.__h = null, v2.__h.length && f2.push(v2), b2 && (v2.__E = v2.__ = null), v2.__e = false;
        } else
          r2 == null && u2.__v === i2.__v ? (u2.__k = i2.__k, u2.__e = i2.__e) : u2.__e = j(i2.__e, u2, i2, t2, o2, r2, f2, s2);
      (a2 = n.diffed) && a2(u2);
    } catch (l3) {
      u2.__v = null, (s2 || r2 != null) && (u2.__e = e2, u2.__h = !!s2, r2[r2.indexOf(e2)] = null), n.__e(l3, u2, i2);
    }
  }
  function T(l2, u2) {
    n.__c && n.__c(u2, l2), l2.some(function(u3) {
      try {
        l2 = u3.__h, u3.__h = [], l2.some(function(n2) {
          n2.call(u3);
        });
      } catch (l3) {
        n.__e(l3, u3.__v);
      }
    });
  }
  function j(n2, l2, u2, i2, t2, o2, e2, c2) {
    var a2, v2, h, y2, p2 = u2.props, d2 = l2.props, _2 = l2.type, k2 = 0;
    if (_2 === "svg" && (t2 = true), o2 != null) {
      for (; k2 < o2.length; k2++)
        if ((a2 = o2[k2]) && (a2 === n2 || (_2 ? a2.localName == _2 : a2.nodeType == 3))) {
          n2 = a2, o2[k2] = null;
          break;
        }
    }
    if (n2 == null) {
      if (_2 === null)
        return document.createTextNode(d2);
      n2 = t2 ? document.createElementNS("http://www.w3.org/2000/svg", _2) : document.createElement(_2, d2.is && d2), o2 = null, c2 = false;
    }
    if (_2 === null)
      p2 === d2 || c2 && n2.data === d2 || (n2.data = d2);
    else {
      if (o2 = o2 && f.slice.call(n2.childNodes), v2 = (p2 = u2.props || r).dangerouslySetInnerHTML, h = d2.dangerouslySetInnerHTML, !c2) {
        if (o2 != null)
          for (p2 = {}, y2 = 0; y2 < n2.attributes.length; y2++)
            p2[n2.attributes[y2].name] = n2.attributes[y2].value;
        (h || v2) && (h && (v2 && h.__html == v2.__html || h.__html === n2.innerHTML) || (n2.innerHTML = h && h.__html || ""));
      }
      if (A(n2, d2, p2, t2, c2), h)
        l2.__k = [];
      else if (k2 = l2.props.children, m(n2, Array.isArray(k2) ? k2 : [k2], l2, u2, i2, t2 && _2 !== "foreignObject", o2, e2, n2.firstChild, c2), o2 != null)
        for (k2 = o2.length; k2--; )
          o2[k2] != null && s(o2[k2]);
      c2 || ("value" in d2 && (k2 = d2.value) !== void 0 && (k2 !== n2.value || _2 === "progress" && !k2) && C(n2, "value", k2, p2.value, false), "checked" in d2 && (k2 = d2.checked) !== void 0 && k2 !== n2.checked && C(n2, "checked", k2, p2.checked, false));
    }
    return n2;
  }
  function z(l2, u2, i2) {
    try {
      typeof l2 == "function" ? l2(u2) : l2.current = u2;
    } catch (l3) {
      n.__e(l3, i2);
    }
  }
  function L(l2, u2, i2) {
    var t2, o2, r2;
    if (n.unmount && n.unmount(l2), (t2 = l2.ref) && (t2.current && t2.current !== l2.__e || z(t2, null, u2)), i2 || typeof l2.type == "function" || (i2 = (o2 = l2.__e) != null), l2.__e = l2.__d = void 0, (t2 = l2.__c) != null) {
      if (t2.componentWillUnmount)
        try {
          t2.componentWillUnmount();
        } catch (l3) {
          n.__e(l3, u2);
        }
      t2.base = t2.__P = null;
    }
    if (t2 = l2.__k)
      for (r2 = 0; r2 < t2.length; r2++)
        t2[r2] && L(t2[r2], u2, i2);
    o2 != null && s(o2);
  }
  function M(n2, l2, u2) {
    return this.constructor(n2, u2);
  }
  function N(l2, u2, i2) {
    var t2, o2, e2;
    n.__ && n.__(l2, u2), o2 = (t2 = typeof i2 == "function") ? null : i2 && i2.__k || u2.__k, e2 = [], I(u2, l2 = (!t2 && i2 || u2).__k = a(y, null, [l2]), o2 || r, r, u2.ownerSVGElement !== void 0, !t2 && i2 ? [i2] : o2 ? null : u2.firstChild ? f.slice.call(u2.childNodes) : null, e2, !t2 && i2 ? i2 : o2 ? o2.__e : u2.firstChild, t2), T(e2, l2);
  }
  n = { __e: function(n2, l2) {
    for (var u2, i2, t2; l2 = l2.__; )
      if ((u2 = l2.__c) && !u2.__)
        try {
          if ((i2 = u2.constructor) && i2.getDerivedStateFromError != null && (u2.setState(i2.getDerivedStateFromError(n2)), t2 = u2.__d), u2.componentDidCatch != null && (u2.componentDidCatch(n2), t2 = u2.__d), t2)
            return u2.__E = u2;
        } catch (l3) {
          n2 = l3;
        }
    throw n2;
  }, __v: 0 }, l = function(n2) {
    return n2 != null && n2.constructor === void 0;
  }, p.prototype.setState = function(n2, l2) {
    var u2;
    u2 = this.__s != null && this.__s !== this.state ? this.__s : this.__s = c({}, this.state), typeof n2 == "function" && (n2 = n2(c({}, u2), this.props)), n2 && c(u2, n2), n2 != null && this.__v && (l2 && this.__h.push(l2), k(this));
  }, p.prototype.forceUpdate = function(n2) {
    this.__v && (this.__e = true, n2 && this.__h.push(n2), k(this));
  }, p.prototype.render = y, u = [], i = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, b.__r = 0, o = 0;

  // node_modules/@algolia/autocomplete-preset-algolia/dist/esm/constants/index.js
  var HIGHLIGHT_PRE_TAG = "__aa-highlight__";
  var HIGHLIGHT_POST_TAG = "__/aa-highlight__";

  // node_modules/@algolia/autocomplete-preset-algolia/dist/esm/highlight/parseAttribute.js
  function createAttributeSet() {
    var initialValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var value = initialValue;
    return {
      get: function get() {
        return value;
      },
      add: function add3(part) {
        var lastPart = value[value.length - 1];
        if ((lastPart === null || lastPart === void 0 ? void 0 : lastPart.isHighlighted) === part.isHighlighted) {
          value[value.length - 1] = {
            value: lastPart.value + part.value,
            isHighlighted: lastPart.isHighlighted
          };
        } else {
          value.push(part);
        }
      }
    };
  }
  function parseAttribute(_ref) {
    var highlightedValue = _ref.highlightedValue;
    var preTagParts = highlightedValue.split(HIGHLIGHT_PRE_TAG);
    var firstValue = preTagParts.shift();
    var parts = createAttributeSet(firstValue ? [{
      value: firstValue,
      isHighlighted: false
    }] : []);
    preTagParts.forEach(function(part) {
      var postTagParts = part.split(HIGHLIGHT_POST_TAG);
      parts.add({
        value: postTagParts[0],
        isHighlighted: true
      });
      if (postTagParts[1] !== "") {
        parts.add({
          value: postTagParts[1],
          isHighlighted: false
        });
      }
    });
    return parts.get();
  }

  // node_modules/@algolia/autocomplete-preset-algolia/dist/esm/highlight/parseAlgoliaHitHighlight.js
  function _toConsumableArray5(arr) {
    return _arrayWithoutHoles5(arr) || _iterableToArray5(arr) || _unsupportedIterableToArray5(arr) || _nonIterableSpread5();
  }
  function _nonIterableSpread5() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray5(o2, minLen) {
    if (!o2)
      return;
    if (typeof o2 === "string")
      return _arrayLikeToArray5(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor)
      n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray5(o2, minLen);
  }
  function _iterableToArray5(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
      return Array.from(iter);
  }
  function _arrayWithoutHoles5(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray5(arr);
  }
  function _arrayLikeToArray5(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  function parseAlgoliaHitHighlight(_ref) {
    var hit = _ref.hit, attribute = _ref.attribute;
    var path = Array.isArray(attribute) ? attribute : [attribute];
    var highlightedValue = getAttributeValueByPath(hit, ["_highlightResult"].concat(_toConsumableArray5(path), ["value"]));
    if (typeof highlightedValue !== "string") {
      true ? warn(false, 'The attribute "'.concat(path.join("."), '" described by the path ').concat(JSON.stringify(path), " does not exist on the hit. Did you set it in `attributesToHighlight`?") + "\nSee https://www.algolia.com/doc/api-reference/api-parameters/attributesToHighlight/") : void 0;
      highlightedValue = getAttributeValueByPath(hit, path) || "";
    }
    return parseAttribute({
      highlightedValue
    });
  }

  // node_modules/@algolia/autocomplete-preset-algolia/dist/esm/highlight/isPartHighlighted.js
  var htmlEscapes = {
    "&amp;": "&",
    "&lt;": "<",
    "&gt;": ">",
    "&quot;": '"',
    "&#39;": "'"
  };
  var hasAlphanumeric = new RegExp(/\w/i);
  var regexEscapedHtml = /&(amp|quot|lt|gt|#39);/g;
  var regexHasEscapedHtml = RegExp(regexEscapedHtml.source);
  function unescape2(value) {
    return value && regexHasEscapedHtml.test(value) ? value.replace(regexEscapedHtml, function(character) {
      return htmlEscapes[character];
    }) : value;
  }
  function isPartHighlighted(parts, i2) {
    var _parts, _parts2;
    var current = parts[i2];
    var isNextHighlighted = ((_parts = parts[i2 + 1]) === null || _parts === void 0 ? void 0 : _parts.isHighlighted) || true;
    var isPreviousHighlighted = ((_parts2 = parts[i2 - 1]) === null || _parts2 === void 0 ? void 0 : _parts2.isHighlighted) || true;
    if (!hasAlphanumeric.test(unescape2(current.value)) && isPreviousHighlighted === isNextHighlighted) {
      return isPreviousHighlighted;
    }
    return current.isHighlighted;
  }

  // node_modules/@algolia/autocomplete-preset-algolia/dist/esm/highlight/reverseHighlightedParts.js
  function ownKeys13(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread13(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys13(Object(source), true).forEach(function(key) {
          _defineProperty13(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys13(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty13(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function reverseHighlightedParts(parts) {
    if (!parts.some(function(part) {
      return part.isHighlighted;
    })) {
      return parts.map(function(part) {
        return _objectSpread13(_objectSpread13({}, part), {}, {
          isHighlighted: false
        });
      });
    }
    return parts.map(function(part, i2) {
      return _objectSpread13(_objectSpread13({}, part), {}, {
        isHighlighted: !isPartHighlighted(parts, i2)
      });
    });
  }

  // node_modules/@algolia/autocomplete-preset-algolia/dist/esm/highlight/parseAlgoliaHitReverseHighlight.js
  function parseAlgoliaHitReverseHighlight(props) {
    return reverseHighlightedParts(parseAlgoliaHitHighlight(props));
  }

  // node_modules/@algolia/autocomplete-preset-algolia/dist/esm/highlight/parseAlgoliaHitSnippet.js
  function _toConsumableArray6(arr) {
    return _arrayWithoutHoles6(arr) || _iterableToArray6(arr) || _unsupportedIterableToArray6(arr) || _nonIterableSpread6();
  }
  function _nonIterableSpread6() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray6(o2, minLen) {
    if (!o2)
      return;
    if (typeof o2 === "string")
      return _arrayLikeToArray6(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor)
      n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray6(o2, minLen);
  }
  function _iterableToArray6(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
      return Array.from(iter);
  }
  function _arrayWithoutHoles6(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray6(arr);
  }
  function _arrayLikeToArray6(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  function parseAlgoliaHitSnippet(_ref) {
    var hit = _ref.hit, attribute = _ref.attribute;
    var path = Array.isArray(attribute) ? attribute : [attribute];
    var highlightedValue = getAttributeValueByPath(hit, ["_snippetResult"].concat(_toConsumableArray6(path), ["value"]));
    if (typeof highlightedValue !== "string") {
      true ? warn(false, 'The attribute "'.concat(path.join("."), '" described by the path ').concat(JSON.stringify(path), " does not exist on the hit. Did you set it in `attributesToSnippet`?") + "\nSee https://www.algolia.com/doc/api-reference/api-parameters/attributesToSnippet/") : void 0;
      highlightedValue = getAttributeValueByPath(hit, path) || "";
    }
    return parseAttribute({
      highlightedValue
    });
  }

  // node_modules/@algolia/autocomplete-preset-algolia/dist/esm/highlight/parseAlgoliaHitReverseSnippet.js
  function parseAlgoliaHitReverseSnippet(props) {
    return reverseHighlightedParts(parseAlgoliaHitSnippet(props));
  }

  // node_modules/@algolia/autocomplete-js/dist/esm/components/Highlight.js
  function _toConsumableArray7(arr) {
    return _arrayWithoutHoles7(arr) || _iterableToArray7(arr) || _unsupportedIterableToArray7(arr) || _nonIterableSpread7();
  }
  function _nonIterableSpread7() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray7(o2, minLen) {
    if (!o2)
      return;
    if (typeof o2 === "string")
      return _arrayLikeToArray7(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor)
      n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray7(o2, minLen);
  }
  function _iterableToArray7(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
      return Array.from(iter);
  }
  function _arrayWithoutHoles7(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray7(arr);
  }
  function _arrayLikeToArray7(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  function createHighlightComponent(_ref) {
    var createElement2 = _ref.createElement, Fragment = _ref.Fragment;
    return function Highlight(_ref2) {
      var hit = _ref2.hit, attribute = _ref2.attribute, _ref2$tagName = _ref2.tagName, tagName = _ref2$tagName === void 0 ? "mark" : _ref2$tagName;
      return createElement2.apply(void 0, [Fragment, {}].concat(_toConsumableArray7(parseAlgoliaHitHighlight({
        hit,
        attribute
      }).map(function(x2, index) {
        return x2.isHighlighted ? createElement2(tagName, {
          key: index
        }, x2.value) : x2.value;
      }))));
    };
  }

  // node_modules/@algolia/autocomplete-js/dist/esm/components/ReverseHighlight.js
  function _toConsumableArray8(arr) {
    return _arrayWithoutHoles8(arr) || _iterableToArray8(arr) || _unsupportedIterableToArray8(arr) || _nonIterableSpread8();
  }
  function _nonIterableSpread8() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray8(o2, minLen) {
    if (!o2)
      return;
    if (typeof o2 === "string")
      return _arrayLikeToArray8(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor)
      n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray8(o2, minLen);
  }
  function _iterableToArray8(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
      return Array.from(iter);
  }
  function _arrayWithoutHoles8(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray8(arr);
  }
  function _arrayLikeToArray8(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  function createReverseHighlightComponent(_ref) {
    var createElement2 = _ref.createElement, Fragment = _ref.Fragment;
    return function ReverseHighlight(_ref2) {
      var hit = _ref2.hit, attribute = _ref2.attribute, _ref2$tagName = _ref2.tagName, tagName = _ref2$tagName === void 0 ? "mark" : _ref2$tagName;
      return createElement2.apply(void 0, [Fragment, {}].concat(_toConsumableArray8(parseAlgoliaHitReverseHighlight({
        hit,
        attribute
      }).map(function(x2, index) {
        return x2.isHighlighted ? createElement2(tagName, {
          key: index
        }, x2.value) : x2.value;
      }))));
    };
  }

  // node_modules/@algolia/autocomplete-js/dist/esm/components/ReverseSnippet.js
  function _toConsumableArray9(arr) {
    return _arrayWithoutHoles9(arr) || _iterableToArray9(arr) || _unsupportedIterableToArray9(arr) || _nonIterableSpread9();
  }
  function _nonIterableSpread9() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray9(o2, minLen) {
    if (!o2)
      return;
    if (typeof o2 === "string")
      return _arrayLikeToArray9(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor)
      n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray9(o2, minLen);
  }
  function _iterableToArray9(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
      return Array.from(iter);
  }
  function _arrayWithoutHoles9(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray9(arr);
  }
  function _arrayLikeToArray9(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  function createReverseSnippetComponent(_ref) {
    var createElement2 = _ref.createElement, Fragment = _ref.Fragment;
    return function ReverseSnippet(_ref2) {
      var hit = _ref2.hit, attribute = _ref2.attribute, _ref2$tagName = _ref2.tagName, tagName = _ref2$tagName === void 0 ? "mark" : _ref2$tagName;
      return createElement2.apply(void 0, [Fragment, {}].concat(_toConsumableArray9(parseAlgoliaHitReverseSnippet({
        hit,
        attribute
      }).map(function(x2, index) {
        return x2.isHighlighted ? createElement2(tagName, {
          key: index
        }, x2.value) : x2.value;
      }))));
    };
  }

  // node_modules/@algolia/autocomplete-js/dist/esm/components/Snippet.js
  function _toConsumableArray10(arr) {
    return _arrayWithoutHoles10(arr) || _iterableToArray10(arr) || _unsupportedIterableToArray10(arr) || _nonIterableSpread10();
  }
  function _nonIterableSpread10() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray10(o2, minLen) {
    if (!o2)
      return;
    if (typeof o2 === "string")
      return _arrayLikeToArray10(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor)
      n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray10(o2, minLen);
  }
  function _iterableToArray10(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
      return Array.from(iter);
  }
  function _arrayWithoutHoles10(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray10(arr);
  }
  function _arrayLikeToArray10(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  function createSnippetComponent(_ref) {
    var createElement2 = _ref.createElement, Fragment = _ref.Fragment;
    return function Snippet(_ref2) {
      var hit = _ref2.hit, attribute = _ref2.attribute, _ref2$tagName = _ref2.tagName, tagName = _ref2$tagName === void 0 ? "mark" : _ref2$tagName;
      return createElement2.apply(void 0, [Fragment, {}].concat(_toConsumableArray10(parseAlgoliaHitSnippet({
        hit,
        attribute
      }).map(function(x2, index) {
        return x2.isHighlighted ? createElement2(tagName, {
          key: index
        }, x2.value) : x2.value;
      }))));
    };
  }

  // node_modules/@algolia/autocomplete-js/dist/esm/getDefaultOptions.js
  function ownKeys14(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread14(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys14(Object(source), true).forEach(function(key) {
          _defineProperty14(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys14(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty14(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _objectWithoutProperties6(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose6(source, excluded);
    var key, i2;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
        key = sourceSymbolKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose6(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var defaultClassNames = {
    clearButton: "aa-ClearButton",
    detachedCancelButton: "aa-DetachedCancelButton",
    detachedContainer: "aa-DetachedContainer",
    detachedFormContainer: "aa-DetachedFormContainer",
    detachedOverlay: "aa-DetachedOverlay",
    detachedSearchButton: "aa-DetachedSearchButton",
    detachedSearchButtonIcon: "aa-DetachedSearchButtonIcon",
    detachedSearchButtonPlaceholder: "aa-DetachedSearchButtonPlaceholder",
    form: "aa-Form",
    input: "aa-Input",
    inputWrapper: "aa-InputWrapper",
    inputWrapperPrefix: "aa-InputWrapperPrefix",
    inputWrapperSuffix: "aa-InputWrapperSuffix",
    item: "aa-Item",
    label: "aa-Label",
    list: "aa-List",
    loadingIndicator: "aa-LoadingIndicator",
    panel: "aa-Panel",
    panelLayout: "aa-PanelLayout",
    root: "aa-Autocomplete",
    source: "aa-Source",
    sourceFooter: "aa-SourceFooter",
    sourceHeader: "aa-SourceHeader",
    sourceNoResults: "aa-SourceNoResults",
    submitButton: "aa-SubmitButton"
  };
  var defaultRender = function defaultRender2(_ref, root) {
    var children = _ref.children;
    N(children, root);
  };
  var defaultRenderer = {
    createElement: a,
    Fragment: y
  };
  function getDefaultOptions(options) {
    var _core$id;
    var classNames = options.classNames, container = options.container, getEnvironmentProps = options.getEnvironmentProps, getFormProps = options.getFormProps, getInputProps = options.getInputProps, getItemProps = options.getItemProps, getLabelProps = options.getLabelProps, getListProps = options.getListProps, getPanelProps = options.getPanelProps, getRootProps = options.getRootProps, panelContainer = options.panelContainer, panelPlacement = options.panelPlacement, render2 = options.render, renderNoResults = options.renderNoResults, renderer = options.renderer, detachedMediaQuery = options.detachedMediaQuery, components = options.components, core = _objectWithoutProperties6(options, ["classNames", "container", "getEnvironmentProps", "getFormProps", "getInputProps", "getItemProps", "getLabelProps", "getListProps", "getPanelProps", "getRootProps", "panelContainer", "panelPlacement", "render", "renderNoResults", "renderer", "detachedMediaQuery", "components"]);
    var containerElement = getHTMLElement(container);
    invariant(containerElement.tagName !== "INPUT", "The `container` option does not support `input` elements. You need to change the container to a `div`.");
    var environment = typeof window !== "undefined" ? window : {};
    var defaultedRenderer = renderer !== null && renderer !== void 0 ? renderer : defaultRenderer;
    var defaultComponents = {
      Highlight: createHighlightComponent(defaultedRenderer),
      ReverseHighlight: createReverseHighlightComponent(defaultedRenderer),
      ReverseSnippet: createReverseSnippetComponent(defaultedRenderer),
      Snippet: createSnippetComponent(defaultedRenderer)
    };
    return {
      renderer: {
        classNames: mergeClassNames(defaultClassNames, classNames !== null && classNames !== void 0 ? classNames : {}),
        container: containerElement,
        getEnvironmentProps: getEnvironmentProps !== null && getEnvironmentProps !== void 0 ? getEnvironmentProps : function(_ref2) {
          var props = _ref2.props;
          return props;
        },
        getFormProps: getFormProps !== null && getFormProps !== void 0 ? getFormProps : function(_ref3) {
          var props = _ref3.props;
          return props;
        },
        getInputProps: getInputProps !== null && getInputProps !== void 0 ? getInputProps : function(_ref4) {
          var props = _ref4.props;
          return props;
        },
        getItemProps: getItemProps !== null && getItemProps !== void 0 ? getItemProps : function(_ref5) {
          var props = _ref5.props;
          return props;
        },
        getLabelProps: getLabelProps !== null && getLabelProps !== void 0 ? getLabelProps : function(_ref6) {
          var props = _ref6.props;
          return props;
        },
        getListProps: getListProps !== null && getListProps !== void 0 ? getListProps : function(_ref7) {
          var props = _ref7.props;
          return props;
        },
        getPanelProps: getPanelProps !== null && getPanelProps !== void 0 ? getPanelProps : function(_ref8) {
          var props = _ref8.props;
          return props;
        },
        getRootProps: getRootProps !== null && getRootProps !== void 0 ? getRootProps : function(_ref9) {
          var props = _ref9.props;
          return props;
        },
        panelContainer: panelContainer ? getHTMLElement(panelContainer) : document.body,
        panelPlacement: panelPlacement !== null && panelPlacement !== void 0 ? panelPlacement : "input-wrapper-width",
        render: render2 !== null && render2 !== void 0 ? render2 : defaultRender,
        renderNoResults,
        renderer: defaultedRenderer,
        detachedMediaQuery: detachedMediaQuery !== null && detachedMediaQuery !== void 0 ? detachedMediaQuery : getComputedStyle(environment.document.documentElement).getPropertyValue("--aa-detached-media-query"),
        components: _objectSpread14(_objectSpread14({}, defaultComponents), components)
      },
      core: _objectSpread14(_objectSpread14({}, core), {}, {
        id: (_core$id = core.id) !== null && _core$id !== void 0 ? _core$id : generateAutocompleteId(),
        environment
      })
    };
  }

  // node_modules/@algolia/autocomplete-js/dist/esm/getPanelPlacementStyle.js
  function getPanelPlacementStyle(_ref) {
    var panelPlacement = _ref.panelPlacement, container = _ref.container, form = _ref.form, environment = _ref.environment;
    var containerRect = container.getBoundingClientRect();
    var top2 = containerRect.top + containerRect.height;
    switch (panelPlacement) {
      case "start": {
        return {
          top: top2,
          left: containerRect.left
        };
      }
      case "end": {
        return {
          top: top2,
          right: environment.document.documentElement.clientWidth - (containerRect.left + containerRect.width)
        };
      }
      case "full-width": {
        return {
          top: top2,
          left: 0,
          right: 0,
          width: "unset",
          maxWidth: "unset"
        };
      }
      case "input-wrapper-width": {
        var formRect = form.getBoundingClientRect();
        return {
          top: top2,
          left: formRect.left,
          right: environment.document.documentElement.clientWidth - (formRect.left + formRect.width),
          width: "unset",
          maxWidth: "unset"
        };
      }
      default: {
        throw new Error("[Autocomplete] The `panelPlacement` value ".concat(JSON.stringify(panelPlacement), " is not valid."));
      }
    }
  }

  // node_modules/@algolia/autocomplete-js/dist/esm/render.js
  function _extends() {
    _extends = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function ownKeys15(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread15(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys15(Object(source), true).forEach(function(key) {
          _defineProperty15(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys15(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty15(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function renderSearchBox(_ref) {
    var autocomplete2 = _ref.autocomplete, autocompleteScopeApi = _ref.autocompleteScopeApi, dom = _ref.dom, propGetters = _ref.propGetters, state = _ref.state;
    setPropertiesWithoutEvents(dom.root, propGetters.getRootProps(_objectSpread15({
      state,
      props: autocomplete2.getRootProps({})
    }, autocompleteScopeApi)));
    setPropertiesWithoutEvents(dom.input, propGetters.getInputProps(_objectSpread15({
      state,
      props: autocomplete2.getInputProps({
        inputElement: dom.input
      }),
      inputElement: dom.input
    }, autocompleteScopeApi)));
    setProperties(dom.label, {
      hidden: state.status === "stalled"
    });
    setProperties(dom.loadingIndicator, {
      hidden: state.status !== "stalled"
    });
    setProperties(dom.clearButton, {
      hidden: !state.query
    });
  }
  function renderPanel(render2, _ref2) {
    var autocomplete2 = _ref2.autocomplete, autocompleteScopeApi = _ref2.autocompleteScopeApi, classNames = _ref2.classNames, createElement2 = _ref2.createElement, dom = _ref2.dom, Fragment = _ref2.Fragment, panelContainer = _ref2.panelContainer, propGetters = _ref2.propGetters, state = _ref2.state, components = _ref2.components;
    if (!state.isOpen) {
      if (panelContainer.contains(dom.panel)) {
        panelContainer.removeChild(dom.panel);
      }
      return;
    }
    if (!panelContainer.contains(dom.panel) && state.status !== "loading") {
      panelContainer.appendChild(dom.panel);
    }
    dom.panel.classList.toggle("aa-Panel--stalled", state.status === "stalled");
    var sections = state.collections.map(function(_ref3, sourceIndex) {
      var source = _ref3.source, items = _ref3.items;
      return createElement2("section", {
        key: sourceIndex,
        className: classNames.source,
        "data-autocomplete-source-id": source.sourceId
      }, source.templates.header && createElement2("div", {
        className: classNames.sourceHeader
      }, source.templates.header({
        components,
        createElement: createElement2,
        Fragment,
        items,
        source,
        state
      })), items.length === 0 && source.templates.noResults && state.query ? createElement2("div", {
        className: classNames.sourceNoResults
      }, source.templates.noResults({
        components,
        createElement: createElement2,
        Fragment,
        source,
        state
      })) : createElement2("ul", _extends({
        className: classNames.list
      }, propGetters.getListProps(_objectSpread15({
        state,
        props: autocomplete2.getListProps({})
      }, autocompleteScopeApi))), items.map(function(item) {
        var itemProps = autocomplete2.getItemProps({
          item,
          source
        });
        return createElement2("li", _extends({
          key: itemProps.id,
          className: classNames.item
        }, propGetters.getItemProps(_objectSpread15({
          state,
          props: itemProps
        }, autocompleteScopeApi))), source.templates.item({
          components,
          createElement: createElement2,
          Fragment,
          item,
          state
        }));
      })), source.templates.footer && createElement2("div", {
        className: classNames.sourceFooter
      }, source.templates.footer({
        components,
        createElement: createElement2,
        Fragment,
        items,
        source,
        state
      })));
    });
    var children = createElement2(Fragment, null, createElement2("div", {
      className: "aa-PanelLayout aa-Panel--scrollable"
    }, sections), createElement2("div", {
      className: "aa-GradientBottom"
    }));
    var elements = sections.reduce(function(acc, current) {
      acc[current.props["data-autocomplete-source-id"]] = current;
      return acc;
    }, {});
    render2({
      children,
      state,
      sections,
      elements,
      createElement: createElement2,
      Fragment,
      components
    }, dom.panel);
  }

  // node_modules/@algolia/autocomplete-js/dist/esm/autocomplete.js
  function ownKeys16(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread16(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys16(Object(source), true).forEach(function(key) {
          _defineProperty16(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys16(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty16(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function autocomplete(options) {
    var _createEffectWrapper = createEffectWrapper(), runEffect = _createEffectWrapper.runEffect, cleanupEffects = _createEffectWrapper.cleanupEffects, runEffects = _createEffectWrapper.runEffects;
    var _createReactiveWrappe = createReactiveWrapper(), reactive = _createReactiveWrappe.reactive, runReactives = _createReactiveWrappe.runReactives;
    var hasNoResultsSourceTemplateRef = createRef(false);
    var optionsRef = createRef(options);
    var onStateChangeRef = createRef(void 0);
    var props = reactive(function() {
      return getDefaultOptions(optionsRef.current);
    });
    var isDetached = reactive(function() {
      return props.value.core.environment.matchMedia(props.value.renderer.detachedMediaQuery).matches;
    });
    var autocomplete2 = reactive(function() {
      return createAutocomplete(_objectSpread16(_objectSpread16({}, props.value.core), {}, {
        onStateChange: function onStateChange(options2) {
          var _onStateChangeRef$cur, _props$value$core$onS, _props$value$core;
          hasNoResultsSourceTemplateRef.current = options2.state.collections.some(function(collection) {
            return collection.source.templates.noResults;
          });
          (_onStateChangeRef$cur = onStateChangeRef.current) === null || _onStateChangeRef$cur === void 0 ? void 0 : _onStateChangeRef$cur.call(onStateChangeRef, options2);
          (_props$value$core$onS = (_props$value$core = props.value.core).onStateChange) === null || _props$value$core$onS === void 0 ? void 0 : _props$value$core$onS.call(_props$value$core, options2);
        },
        shouldPanelOpen: optionsRef.current.shouldPanelOpen || function(_ref) {
          var state = _ref.state;
          var hasItems = getItemsCount(state) > 0;
          if (!props.value.core.openOnFocus && !state.query) {
            return hasItems;
          }
          var hasNoResultsTemplate = Boolean(hasNoResultsSourceTemplateRef.current || props.value.renderer.renderNoResults);
          return !hasItems && hasNoResultsTemplate || hasItems;
        }
      }));
    });
    var lastStateRef = createRef(_objectSpread16({
      collections: [],
      completion: null,
      context: {},
      isOpen: false,
      query: "",
      activeItemId: null,
      status: "idle"
    }, props.value.core.initialState));
    var propGetters = {
      getEnvironmentProps: props.value.renderer.getEnvironmentProps,
      getFormProps: props.value.renderer.getFormProps,
      getInputProps: props.value.renderer.getInputProps,
      getItemProps: props.value.renderer.getItemProps,
      getLabelProps: props.value.renderer.getLabelProps,
      getListProps: props.value.renderer.getListProps,
      getPanelProps: props.value.renderer.getPanelProps,
      getRootProps: props.value.renderer.getRootProps
    };
    var autocompleteScopeApi = {
      setActiveItemId: autocomplete2.value.setActiveItemId,
      setQuery: autocomplete2.value.setQuery,
      setCollections: autocomplete2.value.setCollections,
      setIsOpen: autocomplete2.value.setIsOpen,
      setStatus: autocomplete2.value.setStatus,
      setContext: autocomplete2.value.setContext,
      refresh: autocomplete2.value.refresh
    };
    var dom = reactive(function() {
      return createAutocompleteDom({
        autocomplete: autocomplete2.value,
        autocompleteScopeApi,
        classNames: props.value.renderer.classNames,
        isDetached: isDetached.value,
        placeholder: props.value.core.placeholder,
        propGetters,
        state: lastStateRef.current
      });
    });
    function setPanelPosition() {
      setProperties(dom.value.panel, {
        style: isDetached.value ? {} : getPanelPlacementStyle({
          panelPlacement: props.value.renderer.panelPlacement,
          container: dom.value.root,
          form: dom.value.form,
          environment: props.value.core.environment
        })
      });
    }
    function scheduleRender(state) {
      lastStateRef.current = state;
      var renderProps2 = {
        autocomplete: autocomplete2.value,
        autocompleteScopeApi,
        classNames: props.value.renderer.classNames,
        components: props.value.renderer.components,
        container: props.value.renderer.container,
        createElement: props.value.renderer.renderer.createElement,
        dom: dom.value,
        Fragment: props.value.renderer.renderer.Fragment,
        panelContainer: isDetached.value ? dom.value.detachedContainer : props.value.renderer.panelContainer,
        propGetters,
        state: lastStateRef.current
      };
      var render2 = !getItemsCount(state) && !hasNoResultsSourceTemplateRef.current && props.value.renderer.renderNoResults || props.value.renderer.render;
      renderSearchBox(renderProps2);
      renderPanel(render2, renderProps2);
    }
    runEffect(function() {
      var environmentProps = autocomplete2.value.getEnvironmentProps({
        formElement: dom.value.form,
        panelElement: dom.value.panel,
        inputElement: dom.value.input
      });
      setProperties(props.value.core.environment, environmentProps);
      return function() {
        setProperties(props.value.core.environment, Object.keys(environmentProps).reduce(function(acc, key) {
          return _objectSpread16(_objectSpread16({}, acc), {}, _defineProperty16({}, key, void 0));
        }, {}));
      };
    });
    runEffect(function() {
      var panelContainerElement = isDetached.value ? props.value.core.environment.document.body : props.value.renderer.panelContainer;
      var panelElement = isDetached.value ? dom.value.detachedOverlay : dom.value.panel;
      if (isDetached.value && lastStateRef.current.isOpen) {
        dom.value.openDetachedOverlay();
      }
      scheduleRender(lastStateRef.current);
      return function() {
        if (panelContainerElement.contains(panelElement)) {
          panelContainerElement.removeChild(panelElement);
        }
      };
    });
    runEffect(function() {
      var containerElement = props.value.renderer.container;
      containerElement.appendChild(dom.value.root);
      return function() {
        containerElement.removeChild(dom.value.root);
      };
    });
    runEffect(function() {
      var debouncedRender = debounce4(function(_ref2) {
        var state = _ref2.state;
        scheduleRender(state);
      }, 0);
      onStateChangeRef.current = function(_ref3) {
        var state = _ref3.state, prevState = _ref3.prevState;
        if (state.isOpen && !prevState.isOpen) {
          setPanelPosition();
        }
        if (state.query !== prevState.query) {
          var scrollablePanels = document.querySelectorAll(".aa-Panel--scrollable");
          scrollablePanels.forEach(function(scrollablePanel) {
            if (scrollablePanel.scrollTop !== 0) {
              scrollablePanel.scrollTop = 0;
            }
          });
        }
        debouncedRender({
          state
        });
      };
      return function() {
        onStateChangeRef.current = void 0;
      };
    });
    runEffect(function() {
      var onResize = debounce4(function() {
        var previousIsDetached = isDetached.value;
        isDetached.value = props.value.core.environment.matchMedia(props.value.renderer.detachedMediaQuery).matches;
        if (previousIsDetached !== isDetached.value) {
          update({});
        } else {
          requestAnimationFrame(setPanelPosition);
        }
      }, 20);
      props.value.core.environment.addEventListener("resize", onResize);
      return function() {
        props.value.core.environment.removeEventListener("resize", onResize);
      };
    });
    runEffect(function() {
      if (!isDetached.value) {
        return function() {
        };
      }
      function toggleModalClassname(isActive) {
        dom.value.detachedContainer.classList.toggle("aa-DetachedContainer--modal", isActive);
      }
      function onChange(event) {
        toggleModalClassname(event.matches);
      }
      var isModalDetachedMql = props.value.core.environment.matchMedia(getComputedStyle(props.value.core.environment.document.documentElement).getPropertyValue("--aa-detached-modal-media-query"));
      toggleModalClassname(isModalDetachedMql.matches);
      isModalDetachedMql.addEventListener("change", onChange);
      return function() {
        isModalDetachedMql.removeEventListener("change", onChange);
      };
    });
    runEffect(function() {
      requestAnimationFrame(setPanelPosition);
      return function() {
      };
    });
    function destroy() {
      cleanupEffects();
    }
    function update() {
      var updatedOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      cleanupEffects();
      optionsRef.current = mergeDeep(props.value.renderer, props.value.core, {
        initialState: lastStateRef.current
      }, updatedOptions);
      runReactives();
      runEffects();
      autocomplete2.value.refresh().then(function() {
        scheduleRender(lastStateRef.current);
      });
    }
    return _objectSpread16(_objectSpread16({}, autocompleteScopeApi), {}, {
      update,
      destroy
    });
  }

  // app/javascript/js/controllers/search_controller.js
  var import_urijs2 = __toESM(require_URI());

  // app/javascript/js/helpers/debounce_promise.js
  var debounce_promise_default = (fn2, time) => {
    let timerId;
    return (...args) => {
      if (timerId) {
        clearTimeout(timerId);
      }
      return new Promise((resolve2) => {
        timerId = setTimeout(() => resolve2(fn2(...args)), time);
      });
    };
  };

  // app/javascript/js/controllers/search_controller.js
  var search_controller_default = class extends Controller {
    constructor() {
      super(...arguments);
      __publicField(this, "debouncedFetch", debounce_promise_default(fetch, this.searchDebounce));
    }
    get dataset() {
      return this.autocompleteTarget.dataset;
    }
    get searchDebounce() {
      return window.Avo.configuration.search_debounce;
    }
    get translationKeys() {
      let keys;
      try {
        keys = JSON.parse(this.dataset.translationKeys);
      } catch (error2) {
        keys = {};
      }
      return keys;
    }
    get isBelongsToSearch() {
      return this.dataset.viaAssociation === "belongs_to";
    }
    get isGlobalSearch() {
      return this.dataset.searchResource === "global";
    }
    searchUrl(query) {
      const url = (0, import_urijs2.default)();
      let params = { q: query };
      let segments = [
        window.Avo.configuration.root_path,
        "avo_api",
        this.dataset.searchResource,
        "search"
      ];
      if (this.isGlobalSearch) {
        segments = [window.Avo.configuration.root_path, "avo_api", "search"];
      }
      if (this.isBelongsToSearch) {
        params = __spreadProps(__spreadValues({}, params), { via_association: this.dataset.viaAssociation });
      }
      return url.segment(segments).search(params).toString();
    }
    handleOnSelect({ item }) {
      if (this.isBelongsToSearch) {
        this.hiddenIdTarget.setAttribute("value", item._id);
        this.buttonTarget.setAttribute("value", item._label);
        document.querySelector(".aa-DetachedOverlay").remove();
        if (this.hasClearButtonTarget) {
          this.clearButtonTarget.classList.remove("hidden");
        }
      } else {
        turbo_es2017_esm_exports.visit(item._url, { action: "advance" });
      }
    }
    addSource(resourceName, data) {
      const that = this;
      return {
        sourceId: resourceName,
        getItems: () => data.results,
        onSelect: that.handleOnSelect.bind(that),
        templates: {
          header() {
            return `${data.header.toUpperCase()} ${data.help}`;
          },
          item({ item, createElement: createElement2 }) {
            let element = "";
            if (item._avatar) {
              let classes;
              switch (item._avatar_type) {
                default:
                case "circle":
                  classes = "rounded-full";
                  break;
                case "rounded":
                  classes = "rounded";
                  break;
              }
              element += `<img src="${item._avatar}" alt="${item._label}" class="flex-shrink-0 w-8 h-8 my-[2px] inline mr-2 ${classes}" />`;
            }
            element += `<div>${item._label}`;
            if (item._description) {
              element += `<div class="aa-ItemDescription">${item._description}</div>`;
            }
            element += "</div>";
            return createElement2("div", {
              class: "flex",
              dangerouslySetInnerHTML: {
                __html: element
              }
            });
          },
          noResults() {
            return that.translationKeys.no_item_found.replace("%{item}", resourceName);
          }
        }
      };
    }
    showSearchPanel() {
      this.autocompleteTarget.querySelector("button").click();
    }
    clearValue() {
      this.clearValueTargets.map((e2) => e2.setAttribute("value", ""));
      this.clearButtonTarget.classList.add("hidden");
    }
    connect() {
      const that = this;
      this.buttonTarget.onclick = () => this.showSearchPanel();
      this.clearValueTargets.forEach((target) => {
        if (target.getAttribute("value") && this.hasClearButtonTarget) {
          this.clearButtonTarget.classList.remove("hidden");
        }
      });
      if (this.isGlobalSearch) {
        Mousetrap.bind(["command+k", "ctrl+k"], () => this.showSearchPanel());
      }
      autocomplete({
        container: this.autocompleteTarget,
        placeholder: this.translationKeys.placeholder,
        translations: {
          detachedCancelButtonText: this.translationKeys.cancel_button
        },
        openOnFocus: true,
        detachedMediaQuery: "",
        getSources: ({ query }) => {
          document.body.classList.add("search-loading");
          const endpoint = that.searchUrl(query);
          return that.debouncedFetch(endpoint).then((response) => {
            document.body.classList.remove("search-loading");
            return response.json();
          }).then((data) => Object.keys(data).map((resourceName) => that.addSource(resourceName, data[resourceName])));
        }
      });
      if (this.buttonTarget.dataset.shouldBeDisabled !== "true") {
        this.buttonTarget.removeAttribute("disabled");
      }
    }
  };
  __publicField(search_controller_default, "targets", [
    "autocomplete",
    "button",
    "hiddenId",
    "visibleLabel",
    "clearValue",
    "clearButton"
  ]);

  // app/javascript/js/controllers/select_filter_controller.js
  var select_filter_controller_default = class extends filter_controller_default {
    getFilterValue() {
      return this.selectorTarget.value;
    }
    getFilterClass() {
      const { filterClass } = this.selectorTarget.dataset;
      return filterClass;
    }
  };
  __publicField(select_filter_controller_default, "targets", ["selector"]);

  // app/javascript/js/controllers/fields/simple_mde_controller.js
  var import_simplemde = __toESM(require_simplemde());
  var simple_mde_controller_default = class extends Controller {
    get view() {
      return this.elementTarget.dataset.view;
    }
    get componentOptions() {
      try {
        return JSON.parse(this.elementTarget.dataset.componentOptions);
      } catch (error2) {
        return {};
      }
    }
    connect() {
      const options = {
        element: this.elementTarget,
        spellChecker: this.componentOptions.spell_checker
      };
      if (this.view === "show") {
        options.toolbar = false;
        options.status = false;
      }
      const simpleMde = new import_simplemde.default(options);
      if (this.view === "show") {
        simpleMde.codemirror.options.readOnly = true;
      }
    }
  };
  __publicField(simple_mde_controller_default, "targets", ["element"]);

  // app/javascript/js/controllers/text_filter_controller.js
  var text_filter_controller_default = class extends filter_controller_default {
    getFilterValue() {
      return this.textTarget.value;
    }
    tryToSubmit(e2) {
      if (e2.keyCode === 13) {
        return this.changeFilter();
      }
      return void 0;
    }
    getFilterClass() {
      const { filterClass } = this.textTarget.dataset;
      return filterClass;
    }
  };
  __publicField(text_filter_controller_default, "targets", ["text"]);

  // app/javascript/js/controllers/tippy_controller.js
  var tippy_controller_default = class extends Controller {
    connect() {
      tippy_esm_default(this.sourceTarget, {
        content: this.contentTarget.innerHTML,
        allowHTML: true,
        theme: "light"
      });
    }
  };
  __publicField(tippy_controller_default, "targets", ["source", "content"]);

  // node_modules/hotkeys-js/dist/hotkeys.esm.js
  var isff = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : false;
  function addEvent(object, event, method) {
    if (object.addEventListener) {
      object.addEventListener(event, method, false);
    } else if (object.attachEvent) {
      object.attachEvent("on".concat(event), function() {
        method(window.event);
      });
    }
  }
  function getMods(modifier, key) {
    var mods = key.slice(0, key.length - 1);
    for (var i2 = 0; i2 < mods.length; i2++) {
      mods[i2] = modifier[mods[i2].toLowerCase()];
    }
    return mods;
  }
  function getKeys(key) {
    if (typeof key !== "string")
      key = "";
    key = key.replace(/\s/g, "");
    var keys = key.split(",");
    var index = keys.lastIndexOf("");
    for (; index >= 0; ) {
      keys[index - 1] += ",";
      keys.splice(index, 1);
      index = keys.lastIndexOf("");
    }
    return keys;
  }
  function compareArray(a1, a2) {
    var arr1 = a1.length >= a2.length ? a1 : a2;
    var arr2 = a1.length >= a2.length ? a2 : a1;
    var isIndex = true;
    for (var i2 = 0; i2 < arr1.length; i2++) {
      if (arr2.indexOf(arr1[i2]) === -1)
        isIndex = false;
    }
    return isIndex;
  }
  var _keyMap = {
    backspace: 8,
    tab: 9,
    clear: 12,
    enter: 13,
    return: 13,
    esc: 27,
    escape: 27,
    space: 32,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    del: 46,
    delete: 46,
    ins: 45,
    insert: 45,
    home: 36,
    end: 35,
    pageup: 33,
    pagedown: 34,
    capslock: 20,
    num_0: 96,
    num_1: 97,
    num_2: 98,
    num_3: 99,
    num_4: 100,
    num_5: 101,
    num_6: 102,
    num_7: 103,
    num_8: 104,
    num_9: 105,
    num_multiply: 106,
    num_add: 107,
    num_enter: 108,
    num_subtract: 109,
    num_decimal: 110,
    num_divide: 111,
    "\u21EA": 20,
    ",": 188,
    ".": 190,
    "/": 191,
    "`": 192,
    "-": isff ? 173 : 189,
    "=": isff ? 61 : 187,
    ";": isff ? 59 : 186,
    "'": 222,
    "[": 219,
    "]": 221,
    "\\": 220
  };
  var _modifier = {
    "\u21E7": 16,
    shift: 16,
    "\u2325": 18,
    alt: 18,
    option: 18,
    "\u2303": 17,
    ctrl: 17,
    control: 17,
    "\u2318": 91,
    cmd: 91,
    command: 91
  };
  var modifierMap = {
    16: "shiftKey",
    18: "altKey",
    17: "ctrlKey",
    91: "metaKey",
    shiftKey: 16,
    ctrlKey: 17,
    altKey: 18,
    metaKey: 91
  };
  var _mods = {
    16: false,
    18: false,
    17: false,
    91: false
  };
  var _handlers = {};
  for (k2 = 1; k2 < 20; k2++) {
    _keyMap["f".concat(k2)] = 111 + k2;
  }
  var k2;
  var _downKeys = [];
  var _scope = "all";
  var elementHasBindEvent = [];
  var code = function code2(x2) {
    return _keyMap[x2.toLowerCase()] || _modifier[x2.toLowerCase()] || x2.toUpperCase().charCodeAt(0);
  };
  function setScope(scope) {
    _scope = scope || "all";
  }
  function getScope() {
    return _scope || "all";
  }
  function getPressedKeyCodes() {
    return _downKeys.slice(0);
  }
  function filter(event) {
    var target = event.target || event.srcElement;
    var tagName = target.tagName;
    var flag = true;
    if (target.isContentEditable || (tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT") && !target.readOnly) {
      flag = false;
    }
    return flag;
  }
  function isPressed(keyCode) {
    if (typeof keyCode === "string") {
      keyCode = code(keyCode);
    }
    return _downKeys.indexOf(keyCode) !== -1;
  }
  function deleteScope(scope, newScope) {
    var handlers;
    var i2;
    if (!scope)
      scope = getScope();
    for (var key in _handlers) {
      if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
        handlers = _handlers[key];
        for (i2 = 0; i2 < handlers.length; ) {
          if (handlers[i2].scope === scope)
            handlers.splice(i2, 1);
          else
            i2++;
        }
      }
    }
    if (getScope() === scope)
      setScope(newScope || "all");
  }
  function clearModifier(event) {
    var key = event.keyCode || event.which || event.charCode;
    var i2 = _downKeys.indexOf(key);
    if (i2 >= 0) {
      _downKeys.splice(i2, 1);
    }
    if (event.key && event.key.toLowerCase() === "meta") {
      _downKeys.splice(0, _downKeys.length);
    }
    if (key === 93 || key === 224)
      key = 91;
    if (key in _mods) {
      _mods[key] = false;
      for (var k2 in _modifier) {
        if (_modifier[k2] === key)
          hotkeys[k2] = false;
      }
    }
  }
  function unbind(keysInfo) {
    if (!keysInfo) {
      Object.keys(_handlers).forEach(function(key) {
        return delete _handlers[key];
      });
    } else if (Array.isArray(keysInfo)) {
      keysInfo.forEach(function(info) {
        if (info.key)
          eachUnbind(info);
      });
    } else if (typeof keysInfo === "object") {
      if (keysInfo.key)
        eachUnbind(keysInfo);
    } else if (typeof keysInfo === "string") {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var scope = args[0], method = args[1];
      if (typeof scope === "function") {
        method = scope;
        scope = "";
      }
      eachUnbind({
        key: keysInfo,
        scope,
        method,
        splitKey: "+"
      });
    }
  }
  var eachUnbind = function eachUnbind2(_ref) {
    var key = _ref.key, scope = _ref.scope, method = _ref.method, _ref$splitKey = _ref.splitKey, splitKey = _ref$splitKey === void 0 ? "+" : _ref$splitKey;
    var multipleKeys = getKeys(key);
    multipleKeys.forEach(function(originKey) {
      var unbindKeys = originKey.split(splitKey);
      var len = unbindKeys.length;
      var lastKey = unbindKeys[len - 1];
      var keyCode = lastKey === "*" ? "*" : code(lastKey);
      if (!_handlers[keyCode])
        return;
      if (!scope)
        scope = getScope();
      var mods = len > 1 ? getMods(_modifier, unbindKeys) : [];
      _handlers[keyCode] = _handlers[keyCode].map(function(record) {
        var isMatchingMethod = method ? record.method === method : true;
        if (isMatchingMethod && record.scope === scope && compareArray(record.mods, mods)) {
          return {};
        }
        return record;
      });
    });
  };
  function eventHandler(event, handler, scope) {
    var modifiersMatch;
    if (handler.scope === scope || handler.scope === "all") {
      modifiersMatch = handler.mods.length > 0;
      for (var y2 in _mods) {
        if (Object.prototype.hasOwnProperty.call(_mods, y2)) {
          if (!_mods[y2] && handler.mods.indexOf(+y2) > -1 || _mods[y2] && handler.mods.indexOf(+y2) === -1) {
            modifiersMatch = false;
          }
        }
      }
      if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === "*") {
        if (handler.method(event, handler) === false) {
          if (event.preventDefault)
            event.preventDefault();
          else
            event.returnValue = false;
          if (event.stopPropagation)
            event.stopPropagation();
          if (event.cancelBubble)
            event.cancelBubble = true;
        }
      }
    }
  }
  function dispatch2(event) {
    var asterisk = _handlers["*"];
    var key = event.keyCode || event.which || event.charCode;
    if (!hotkeys.filter.call(this, event))
      return;
    if (key === 93 || key === 224)
      key = 91;
    if (_downKeys.indexOf(key) === -1 && key !== 229)
      _downKeys.push(key);
    ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach(function(keyName) {
      var keyNum = modifierMap[keyName];
      if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {
        _downKeys.push(keyNum);
      } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {
        _downKeys.splice(_downKeys.indexOf(keyNum), 1);
      } else if (keyName === "metaKey" && event[keyName] && _downKeys.length === 3) {
        if (!(event.ctrlKey || event.shiftKey || event.altKey)) {
          _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));
        }
      }
    });
    if (key in _mods) {
      _mods[key] = true;
      for (var k2 in _modifier) {
        if (_modifier[k2] === key)
          hotkeys[k2] = true;
      }
      if (!asterisk)
        return;
    }
    for (var e2 in _mods) {
      if (Object.prototype.hasOwnProperty.call(_mods, e2)) {
        _mods[e2] = event[modifierMap[e2]];
      }
    }
    if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState("AltGraph")) {
      if (_downKeys.indexOf(17) === -1) {
        _downKeys.push(17);
      }
      if (_downKeys.indexOf(18) === -1) {
        _downKeys.push(18);
      }
      _mods[17] = true;
      _mods[18] = true;
    }
    var scope = getScope();
    if (asterisk) {
      for (var i2 = 0; i2 < asterisk.length; i2++) {
        if (asterisk[i2].scope === scope && (event.type === "keydown" && asterisk[i2].keydown || event.type === "keyup" && asterisk[i2].keyup)) {
          eventHandler(event, asterisk[i2], scope);
        }
      }
    }
    if (!(key in _handlers))
      return;
    for (var _i = 0; _i < _handlers[key].length; _i++) {
      if (event.type === "keydown" && _handlers[key][_i].keydown || event.type === "keyup" && _handlers[key][_i].keyup) {
        if (_handlers[key][_i].key) {
          var record = _handlers[key][_i];
          var splitKey = record.splitKey;
          var keyShortcut = record.key.split(splitKey);
          var _downKeysCurrent = [];
          for (var a2 = 0; a2 < keyShortcut.length; a2++) {
            _downKeysCurrent.push(code(keyShortcut[a2]));
          }
          if (_downKeysCurrent.sort().join("") === _downKeys.sort().join("")) {
            eventHandler(event, record, scope);
          }
        }
      }
    }
  }
  function isElementBind(element) {
    return elementHasBindEvent.indexOf(element) > -1;
  }
  function hotkeys(key, option, method) {
    _downKeys = [];
    var keys = getKeys(key);
    var mods = [];
    var scope = "all";
    var element = document;
    var i2 = 0;
    var keyup = false;
    var keydown = true;
    var splitKey = "+";
    if (method === void 0 && typeof option === "function") {
      method = option;
    }
    if (Object.prototype.toString.call(option) === "[object Object]") {
      if (option.scope)
        scope = option.scope;
      if (option.element)
        element = option.element;
      if (option.keyup)
        keyup = option.keyup;
      if (option.keydown !== void 0)
        keydown = option.keydown;
      if (typeof option.splitKey === "string")
        splitKey = option.splitKey;
    }
    if (typeof option === "string")
      scope = option;
    for (; i2 < keys.length; i2++) {
      key = keys[i2].split(splitKey);
      mods = [];
      if (key.length > 1)
        mods = getMods(_modifier, key);
      key = key[key.length - 1];
      key = key === "*" ? "*" : code(key);
      if (!(key in _handlers))
        _handlers[key] = [];
      _handlers[key].push({
        keyup,
        keydown,
        scope,
        mods,
        shortcut: keys[i2],
        method,
        key: keys[i2],
        splitKey
      });
    }
    if (typeof element !== "undefined" && !isElementBind(element) && window) {
      elementHasBindEvent.push(element);
      addEvent(element, "keydown", function(e2) {
        dispatch2(e2);
      });
      addEvent(window, "focus", function() {
        _downKeys = [];
      });
      addEvent(element, "keyup", function(e2) {
        dispatch2(e2);
        clearModifier(e2);
      });
    }
  }
  var _api = {
    setScope,
    getScope,
    deleteScope,
    getPressedKeyCodes,
    isPressed,
    filter,
    unbind
  };
  for (a2 in _api) {
    if (Object.prototype.hasOwnProperty.call(_api, a2)) {
      hotkeys[a2] = _api[a2];
    }
  }
  var a2;
  if (typeof window !== "undefined") {
    _hotkeys = window.hotkeys;
    hotkeys.noConflict = function(deep) {
      if (deep && window.hotkeys === hotkeys) {
        window.hotkeys = _hotkeys;
      }
      return hotkeys;
    };
    window.hotkeys = hotkeys;
  }
  var _hotkeys;

  // node_modules/stimulus-use/dist/index.js
  var composeEventName = (name, controller, eventPrefix) => {
    let composedName = name;
    if (eventPrefix === true) {
      composedName = `${controller.identifier}:${name}`;
    } else if (typeof eventPrefix === "string") {
      composedName = `${eventPrefix}:${name}`;
    }
    return composedName;
  };
  var extendedEvent = (type, event, detail) => {
    const { bubbles, cancelable, composed } = event || { bubbles: true, cancelable: true, composed: true };
    if (event) {
      Object.assign(detail, { originalEvent: event });
    }
    const customEvent = new CustomEvent(type, {
      bubbles,
      cancelable,
      composed,
      detail
    });
    return customEvent;
  };
  function isElementInViewport(el) {
    const rect = el.getBoundingClientRect();
    const windowHeight = window.innerHeight || document.documentElement.clientHeight;
    const windowWidth = window.innerWidth || document.documentElement.clientWidth;
    const vertInView = rect.top <= windowHeight && rect.top + rect.height >= 0;
    const horInView = rect.left <= windowWidth && rect.left + rect.width >= 0;
    return vertInView && horInView;
  }
  var defaultOptions$5 = {
    events: ["click", "touchend"],
    onlyVisible: true,
    dispatchEvent: true,
    eventPrefix: true
  };
  var useClickOutside = (controller, options = {}) => {
    const { onlyVisible, dispatchEvent: dispatchEvent2, events, eventPrefix } = Object.assign({}, defaultOptions$5, options);
    const onEvent = (event) => {
      const targetElement = (options === null || options === void 0 ? void 0 : options.element) || controller.element;
      if (targetElement.contains(event.target) || !isElementInViewport(targetElement) && onlyVisible) {
        return;
      }
      if (controller.clickOutside) {
        controller.clickOutside(event);
      }
      if (dispatchEvent2) {
        const eventName = composeEventName("click:outside", controller, eventPrefix);
        const clickOutsideEvent = extendedEvent(eventName, event, { controller });
        targetElement.dispatchEvent(clickOutsideEvent);
      }
    };
    const observe = () => {
      events === null || events === void 0 ? void 0 : events.forEach((event) => {
        window.addEventListener(event, onEvent, false);
      });
    };
    const unobserve = () => {
      events === null || events === void 0 ? void 0 : events.forEach((event) => {
        window.removeEventListener(event, onEvent, false);
      });
    };
    const controllerDisconnect = controller.disconnect.bind(controller);
    Object.assign(controller, {
      disconnect() {
        unobserve();
        controllerDisconnect();
      }
    });
    observe();
    return [observe, unobserve];
  };
  var DebounceController = class extends Controller {
  };
  DebounceController.debounces = [];
  var ThrottleController = class extends Controller {
  };
  ThrottleController.throttles = [];

  // app/javascript/js/controllers/toggle_panel_controller.js
  var toggle_panel_controller_default = class extends Controller {
    connect() {
      useClickOutside(this);
    }
    clickOutside() {
      this.panelTarget.classList.add("hidden");
    }
    togglePanel() {
      this.panelTarget.classList.toggle("hidden");
    }
  };
  __publicField(toggle_panel_controller_default, "targets", ["panel"]);

  // app/javascript/js/controllers/fields/trix_field_controller.js
  var import_trix = __toESM(require_trix());
  var trix_field_controller_default = class extends Controller {
    get resourceId() {
      return this.controllerTarget.dataset.resourceId;
    }
    get resourceName() {
      return this.controllerTarget.dataset.resourceName;
    }
    get attachmentKey() {
      return this.controllerTarget.dataset.attachmentKey;
    }
    get attachmentsDisabled() {
      return castBoolean(this.controllerTarget.dataset.attachmentsDisabled);
    }
    get hideAttachmentFilename() {
      return castBoolean(this.controllerTarget.dataset.hideAttachmentFilename);
    }
    get hideAttachmentFilesize() {
      return castBoolean(this.controllerTarget.dataset.hideAttachmentFilesize);
    }
    get hideAttachmentUrl() {
      return castBoolean(this.controllerTarget.dataset.hideAttachmentUrl);
    }
    get uploadUrl() {
      return `${window.location.origin}${window.Avo.configuration.root_path}/avo_api/resources/${this.resourceName}/${this.resourceId}/attachments`;
    }
    connect() {
      if (this.attachmentsDisabled) {
        this.controllerTarget.querySelector(".trix-button-group--file-tools").remove();
      }
      window.addEventListener("trix-file-accept", (event) => {
        if (event.target === this.editorTarget) {
          if (this.attachmentsDisabled) {
            event.preventDefault();
            window.toastr.warning("This field has attachments disabled.");
            return;
          }
          if (this.resourceId === "") {
            event.preventDefault();
            window.toastr.warning("You can't upload files into the Trix editor until you save the resource.");
            return;
          }
          if (this.attachmentKey === "") {
            event.preventDefault();
            window.toastr.warning("You haven't set an <a href='https://google.com' class='!text-blue-700 underline'>attachment_key</a> to this Trix field.");
          }
        }
      });
      window.addEventListener("trix-attachment-add", (event) => {
        if (event.target === this.editorTarget) {
          if (event.attachment.file) {
            this.uploadFileAttachment(event.attachment);
          }
        }
      });
    }
    uploadFileAttachment(attachment) {
      this.uploadFile(attachment.file, (progress) => attachment.setUploadProgress(progress), (attributes) => attachment.setAttributes(attributes));
    }
    uploadFile(file, progressCallback, successCallback) {
      const formData = this.createFormData(file);
      const xhr = new XMLHttpRequest();
      xhr.open("POST", this.uploadUrl, true);
      xhr.setRequestHeader("X-CSRF-Token", document.querySelector('meta[name="csrf-token"]').content);
      xhr.upload.addEventListener("progress", (event) => {
        const progress = event.loaded / event.total * 100;
        progressCallback(progress);
      });
      xhr.addEventListener("load", () => {
        if (xhr.status === 200) {
          let response;
          try {
            response = JSON.parse(xhr.response);
          } catch (error2) {
            response = {};
          }
          const attributes = {
            url: response.url,
            href: response.href
          };
          if (this.hideAttachmentFilename)
            attributes.filename = null;
          if (this.hideAttachmentFilesize)
            attributes.filesize = null;
          if (this.hideAttachmentUrl)
            attributes.href = null;
          successCallback(attributes);
        }
      });
      xhr.send(formData);
    }
    createFormData(file) {
      const data = new FormData();
      data.append("Content-Type", file.type);
      data.append("file", file);
      data.append("filename", file.name);
      data.append("attachment_key", this.attachmentKey);
      return data;
    }
  };
  __publicField(trix_field_controller_default, "targets", ["editor", "controller"]);

  // app/javascript/js/controllers.js
  application.register("action", action_controller_default);
  application.register("actions-picker", actions_picker_controller_default);
  application.register("alerts", alerts_controller_default);
  application.register("attachments", attachments_controller_default);
  application.register("boolean-filter", boolean_filter_controller_default);
  application.register("filter", filter_controller_default);
  application.register("hidden-input", hidden_input_controller_default);
  application.register("item-select-all", item_select_all_controller_default);
  application.register("item-selector", item_selector_controller_default);
  application.register("loading-button", loading_button_controller_default);
  application.register("mobile", mobile_controller_default);
  application.register("modal", modal_controller_default);
  application.register("multiple-select-filter", multiple_select_filter_controller_default);
  application.register("per-page", per_page_controller_default);
  application.register("search", search_controller_default);
  application.register("select-filter", select_filter_controller_default);
  application.register("text-filter", text_filter_controller_default);
  application.register("tippy", tippy_controller_default);
  application.register("toggle-panel", toggle_panel_controller_default);
  application.register("belongs-to-field", belongs_to_field_controller_default);
  application.register("code-field", code_field_controller_default);
  application.register("date-field", date_field_controller_default);
  application.register("key-value", key_value_controller_default);
  application.register("simple-mde", simple_mde_controller_default);
  application.register("trix-field", trix_field_controller_default);

  // app/javascript/js/toastr.js
  var import_toastr = __toESM(require_toastr_min());
  import_toastr.default.options.showDuration = 400;
  import_toastr.default.options.hideDuration = 400;
  import_toastr.default.options.closeButton = true;
  import_toastr.default.options.positionClass = "toast-bottom-right";
  import_toastr.default.options.closeHtml = '<button class="mt-2 mr-1"><svg class="w-4 h-4 text-gray-700" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg></button>';
  window.toastr = import_toastr.default;

  // app/javascript/avo.js
  import_ujs.default.start();
  window.Turbolinks = turbo_es2017_esm_exports;
  Mousetrap2.bind("r r r", () => turbo_es2017_esm_exports.visit(window.location.href, { action: "replace" }));
  function isMac() {
    const isMac2 = window.navigator.userAgent.indexOf("Mac OS X");
    if (isMac2) {
      document.body.classList.add("os-mac");
      document.body.classList.remove("os-pc");
    } else {
      document.body.classList.add("os-pc");
      document.body.classList.remove("os-mac");
    }
  }
  function initTippy() {
    tippy_esm_default('[data-tippy="tooltip"]', {
      theme: "light",
      content(reference2) {
        const title = reference2.getAttribute("title");
        reference2.removeAttribute("title");
        return title;
      }
    });
  }
  window.initTippy = initTippy;
  ActiveStorage.start();
  document.addEventListener("turbo:load", () => {
    document.body.classList.remove("turbo-loading");
    initTippy();
    isMac();
  });
  document.addEventListener("turbo:before-fetch-response", (e2) => {
    if (e2.detail.fetchResponse.response.status === 500) {
      const id = e2.srcElement.getAttribute("id");
      e2.srcElement.src = `${window.Avo.configuration.root_path}/failed_to_load?turbo_frame=${id}`;
    }
  });
  document.addEventListener("turbo:visit", () => document.body.classList.add("turbo-loading"));
  document.addEventListener("turbo:submit-start", () => document.body.classList.add("turbo-loading"));
  document.addEventListener("turbo:submit-end", () => document.body.classList.remove("turbo-loading"));
  document.addEventListener("turbo:before-cache", () => {
    document.querySelectorAll("[data-turbo-remove-before-cache]").forEach((element) => element.remove());
  });
})();
/*!
 * URI.js - Mutating URLs
 *
 * Version: 1.19.7
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
/*!
 * URI.js - Mutating URLs
 * IPv6 Support
 *
 * Version: 1.19.7
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
/*!
 * URI.js - Mutating URLs
 * Second Level Domain (SLD) Support
 *
 * Version: 1.19.7
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
/*!
 * hotkeys-js v3.8.7
 * A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies.
 * 
 * Copyright (c) 2021 kenny wong <wowohoo@qq.com>
 * http://jaywcjlove.github.io/hotkeys
 * 
 * Licensed under the MIT license.
 */
/*!
 * jQuery JavaScript Library v3.5.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2020-05-04T22:49Z
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/*! https://mths.be/punycode v1.4.0 by @mathias */
//# sourceMappingURL=avo.js.map
