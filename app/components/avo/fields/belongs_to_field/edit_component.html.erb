<%
  if @field.types.present? # It's a polymorphic association

  # Set the model keys so we can pass them over
  model_keys = @field.types.map do |type|
    resource = Avo::App.get_resource_by_model_name(type.to_s)
    [type.to_s, resource.model_key]
  end.to_h
%>
<div data-controller="belongs-to-field"
    data-searchable="<%= @field.searchable %>"
    data-association="<%= @field.id %>"
    data-association-class="<%= @field&.target_resource&.model_class || nil %>"
  >
  <%= edit_field_wrapper field: @field, index: @index, form: @form, resource: @resource, displayed_in_modal: @displayed_in_modal do %>
    <%= @form.select "#{@field.foreign_key}_type", @field.types.map { |type| [type.to_s.underscore.humanize, type.to_s] },
      {
        value: @field.value,
        include_blank: @field.placeholder,
      },
      {
        class: helpers.input_classes('w-full', has_error: @field.model_errors.include?(@field.id)),
        disabled: disabled,
        'data-belongs-to-field-target': "select",
        'data-action': 'change->belongs-to-field#changeType'
      }
    %>
    <%
        # If the select field is disabled, no value will be sent. It's how HTML works.
        # Thus the extra hidden field to actually send the related id to the server.
        if disabled %>
      <%= @form.hidden_field "#{@field.foreign_key}_type" %>
    <% end %>
  <% end %>
  <% @field.types.each do |type| %>
    <div class="hidden"
        data-belongs-to-field-target="type"
        data-type="<%= type %>"
      >
      <%= edit_field_wrapper field: @field, index: @index, form: @form, resource: @resource, displayed_in_modal: @displayed_in_modal, label: type.to_s.underscore.humanize do %>
        <% if @field.searchable %>
          <%= render Avo::Fields::BelongsToField::AutocompleteComponent.new form: @form, field: @field, type: type, model_key: model_keys[type.to_s], foreign_key: "#{@field.foreign_key}_id" %>
        <% else %>
          <%= @form.select "#{@field.foreign_key}_id", options_for_select(@field.values_for_type(type), @field.value&.class == type ? @field.field_value : nil),
            {
              include_blank: @field.placeholder,
            },
            {
              class: helpers.input_classes('w-full', has_error: @field.model_errors.include?(@field.id)),
              disabled: disabled
            }
          %>
        <% end %>
      <% end %>
    </div>
  <% end %>
</div>
<% else %>
  <%= edit_field_wrapper field: @field, index: @index, form: @form, resource: @resource, displayed_in_modal: @displayed_in_modal do %>
    <% if @field.searchable %>
      <%= render Avo::Fields::BelongsToField::AutocompleteComponent.new form: @form, field: @field, model_key: @field.target_resource&.model_key, foreign_key: @field.foreign_key %>
    <% else %>
      <%= @form.select @field.foreign_key, @field.options.map { |o| [o[:label], o[:value]] },
        {
          include_blank: @field.placeholder,
        },
        {
          class: helpers.input_classes('w-full', has_error: @field.model_errors.include?(@field.id)),
          disabled: disabled
        }
      %>
      <%
        # If the select field is disabled, no value will be sent. It's how HTML works.
        # Thus the extra hidden field to actually send the related id to the server.
        if disabled %>
        <%= @form.hidden_field @field.foreign_key %>
      <% end %>
    <% end %>
  <% end %>
<% end %>
